<haxe>
	<abstract path="Any" params="" file="D:\HaxeToolkit\haxe\std/Any.hx">
		<from><icast field="__cast"><c path="__cast.T"/></icast></from>
		<this><d/></this>
		<to><icast field="__promote"><c path="__promote.T"/></icast></to>
		<haxe_doc>`Any` is a type that is compatible with any other in both ways.

	This means that a value of any type can be assigned to `Any`, and
	vice-versa, a value of `Any` type can be assigned to any other type.

	It's a more type-safe alternative to `Dynamic`, because it doesn't
	support field access or operators and it's bound to monomorphs. So,
	to work with the actual value, it needs to be explicitly promoted
	to another type.</haxe_doc>
		<impl><class path="_Any.Any_Impl_" params="" file="D:\HaxeToolkit\haxe\std/Any.hx" private="1" module="Any"><meta>
	<m n=":keep"/>
	<m n=":final"/>
</meta></class></impl>
	</abstract>
	<class path="neko.Lib" params="" file="D:\HaxeToolkit\haxe\std/neko/Lib.hx">
		<load public="1" set="method" line="34" static="1">
			<f a="lib:prim:nargs">
				<c path="String"/>
				<c path="String"/>
				<x path="Int"/>
				<d/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Load and return a Neko primitive from a NDLL library.</haxe_doc>
		</load>
		<loadLazy public="1" set="method" line="38" static="1">
			<f a="lib:prim:nargs">
				<c path="String"/>
				<c path="String"/>
				<x path="Int"/>
				<d/>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</loadLazy>
		<rethrow public="1" set="method" line="64" static="1">
			<f a="e">
				<d/>
				<d/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Rethrow an exception. This is useful when manually filtering an exception in order
		to keep the previous exception stack.</haxe_doc>
		</rethrow>
		<haxeToNeko public="1" set="method" line="132" static="1">
			<f a="v">
				<d/>
				<d/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Converts a Haxe value to its Neko equivalent. Used to unwrap String and Arrays Objects into raw Neko values.</haxe_doc>
		</haxeToNeko>
		<haxe_doc>Platform-specific Neko Library. Provides some platform-specific functions 
	for the Neko target, such as conversion from Haxe types to native types 
	and vice-versa.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="Array" params="T" file="D:\HaxeToolkit\haxe\std/neko/_std/Array.hx">
		<new1 params="T" set="method" line="32" static="1"><f a="a:l">
	<c path="neko.NativeArray"><c path="new1.T"/></c>
	<x path="Int"/>
	<c path="Array"><c path="new1.T"/></c>
</f></new1>
		<__a><c path="neko.NativeArray"><c path="Array.T"/></c></__a>
		<length public="1" set="null">
			<x path="Int"/>
			<haxe_doc>The length of `this` Array.</haxe_doc>
		</length>
		<concat public="1" set="method" line="39">
			<f a="a">
				<c path="Array"><c path="Array.T"/></c>
				<c path="Array"><c path="Array.T"/></c>
			</f>
			<haxe_doc>Returns a new Array by appending the elements of `a` to the elements of
		`this` Array.

		This operation does not modify `this` Array.

		If `a` is the empty Array `[]`, a copy of `this` Array is returned.

		The length of the returned Array is equal to the sum of `this.length`
		and `a.length`.

		If `a` is `null`, the result is unspecified.</haxe_doc>
		</concat>
		<copy public="1" set="method" line="50">
			<f a=""><c path="Array"><c path="Array.T"/></c></f>
			<haxe_doc>Returns a shallow copy of `this` Array.

		The elements are not copied and retain their identity, so
		`a[i] == a.copy()[i]` is true for any valid `i`. However,
		`a == a.copy()` is always false.</haxe_doc>
		</copy>
		<iterator public="1" set="method" line="54">
			<f a=""><t path="Iterator"><c path="Array.T"/></t></f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Returns an iterator of the Array values.</haxe_doc>
		</iterator>
		<insert public="1" set="method" line="69">
			<f a="pos:x">
				<x path="Int"/>
				<c path="Array.T"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Inserts the element `x` at the position `pos`.

		This operation modifies `this` Array in place.

		The offset is calculated like so:

		- If `pos` exceeds `this.length`, the offset is `this.length`.
		- If `pos` is negative, the offset is calculated from the end of `this`
		  Array, i.e. `this.length + pos`. If this yields a negative value, the
		  offset is 0.
		- Otherwise, the offset is `pos`.

		If the resulting offset does not exceed `this.length`, all elements from
		and including that offset to the end of `this` Array are moved one index
		ahead.</haxe_doc>
		</insert>
		<join public="1" set="method" line="82">
			<f a="sep">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns a string representation of `this` Array, with `sep` separating
		each element.

		The result of this operation is equal to `Std.string(this[0]) + sep +
		Std.string(this[1]) + sep + ... + sep + Std.string(this[this.length-1])`

		If `this` is the empty Array `[]`, the result is the empty String `""`.
		If `this` has exactly one element, the result is equal to a call to
		`Std.string(this[0])`.

		If `sep` is null, the result is unspecified.</haxe_doc>
		</join>
		<toString public="1" set="method" line="94">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns a string representation of `this` Array.

		The result will include the individual elements' String representations
		separated by comma. The enclosing [ ] may be missing on some platforms,
		use `Std.string()` to get a String representation that is consistent
		across platforms.</haxe_doc>
		</toString>
		<pop public="1" set="method" line="107">
			<f a=""><t path="Null"><c path="Array.T"/></t></f>
			<haxe_doc>Removes the last element of `this` Array and returns it.

		This operation modifies `this` Array in place.

		If `this` has at least one element, `this.length` will decrease by 1.

		If `this` is the empty Array `[]`, null is returned and the length
		remains 0.</haxe_doc>
		</pop>
		<push public="1" set="method" line="116">
			<f a="x">
				<c path="Array.T"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Adds the element `x` at the end of `this` Array and returns the new
		length of `this` Array.

		This operation modifies `this` Array in place.

		`this.length` increases by 1.</haxe_doc>
		</push>
		<unshift public="1" set="method" line="123">
			<f a="x">
				<c path="Array.T"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Adds the element `x` at the start of `this` Array.

		This operation modifies `this` Array in place.

		`this.length` and the index of each Array element increases by 1.</haxe_doc>
		</unshift>
		<remove public="1" set="method" line="131">
			<f a="x">
				<c path="Array.T"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Removes the first occurence of `x` in `this` Array.

		This operation modifies `this` Array in place.

		If `x` is found by checking standard equality, it is removed from `this`
		Array and all following elements are reindexed acoordingly. The function
		then returns true.

		If `x` is not found, `this` Array is not changed and the function
		returns false.</haxe_doc>
		</remove>
		<indexOf public="1" set="method" line="148">
			<f a="x:?fromIndex">
				<c path="Array.T"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns position of the first occurense of `x` in `this` Array, searching front to back.

		If `x` is found by checking standard equality, the function returns its index.

		If `x` is not found, the function returns -1.

		If `fromIndex` is specified, it will be used as the starting index to search from,
		otherwise search starts with zero index. If it is negative, it will be taken as the
		offset from the end of `this` Array to compute the starting index. If given or computed
		starting index is less than 0, the whole array will be searched, if it is greater than
		or equal to the length of `this` Array, the function returns -1.</haxe_doc>
		</indexOf>
		<lastIndexOf public="1" set="method" line="165">
			<f a="x:?fromIndex">
				<c path="Array.T"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns position of the last occurense of `x` in `this` Array, searching back to front.

		If `x` is found by checking standard equality, the function returns its index.

		If `x` is not found, the function returns -1.

		If `fromIndex` is specified, it will be used as the starting index to search from,
		otherwise search starts with the last element index. If it is negative, it will be
		taken as the offset from the end of `this` Array to compute the starting index. If
		given or computed starting index is greater than or equal to the length of `this` Array,
		the whole array will be searched, if it is less than 0, the function returns -1.</haxe_doc>
		</lastIndexOf>
		<reverse public="1" set="method" line="182">
			<f a=""><x path="Void"/></f>
			<haxe_doc><![CDATA[Reverse the order of elements of `this` Array.

		This operation modifies `this` Array in place.

		If `this.length < 2`, `this` remains unchanged.]]></haxe_doc>
		</reverse>
		<shift public="1" set="method" line="196">
			<f a=""><t path="Null"><c path="Array.T"/></t></f>
			<haxe_doc>Removes the first element of `this` Array and returns it.

		This operation modifies `this` Array in place.

		If `this` has at least one element, `this`.length and the index of each
		remaining element is decreased by 1.

		If `this` is the empty Array `[]`, `null` is returned and the length
		remains 0.</haxe_doc>
		</shift>
		<slice public="1" set="method" line="209">
			<f a="pos:?end">
				<x path="Int"/>
				<x path="Int"/>
				<c path="Array"><c path="Array.T"/></c>
			</f>
			<haxe_doc>Creates a shallow copy of the range of `this` Array, starting at and
		including `pos`, up to but not including `end`.

		This operation does not modify `this` Array.

		The elements are not copied and retain their identity.

		If `end` is omitted or exceeds `this.length`, it defaults to the end of
		`this` Array.

		If `pos` or `end` are negative, their offsets are calculated from the
		end of `this` Array by `this.length + pos` and `this.length + end`
		respectively. If this yields a negative value, 0 is used instead.

		If `pos` exceeds `this.length` or if `end` is less than or equals
		`pos`, the result is `[]`.</haxe_doc>
		</slice>
		<sort public="1" set="method" line="226">
			<f a="f">
				<f a=":">
					<c path="Array.T"/>
					<c path="Array.T"/>
					<x path="Int"/>
				</f>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[Sorts `this` Array according to the comparison function `f`, where
		`f(x,y)` returns 0 if x == y, a positive Int if x > y and a
		negative Int if x < y.

		This operation modifies `this` Array in place.

		The sort operation is not guaranteed to be stable, which means that the
		order of equal elements may not be retained. For a stable Array sorting
		algorithm, `haxe.ds.ArraySort.sort()` can be used instead.

		If `f` is null, the result is unspecified.]]></haxe_doc>
		</sort>
		<splice public="1" set="method" line="249">
			<f a="pos:len">
				<x path="Int"/>
				<x path="Int"/>
				<c path="Array"><c path="Array.T"/></c>
			</f>
			<haxe_doc><![CDATA[Removes `len` elements from `this` Array, starting at and including
		`pos`, an returns them.

		This operation modifies `this` Array in place.

		If `len` is < 0 or `pos` exceeds `this`.length, the result is the empty
		Array [].

		If `pos` is negative, its value is calculated from the end	of `this`
		Array by `this.length + pos`. If this yields a negative value, 0 is
		used instead.

		If the sum of the resulting values for `len` and `pos` exceed
		`this.length`, this operation will affect the elements from `pos` to the
		end of `this` Array.

		The length of the returned Array is equal to the new length of `this`
		Array subtracted from the original length of `this` Array. In other
		words, each element of the original `this` Array either remains in
		`this` Array or becomes an element of the returned Array.]]></haxe_doc>
		</splice>
		<map public="1" params="S" set="method" line="272">
			<f a="f">
				<f a="">
					<c path="Array.T"/>
					<c path="map.S"/>
				</f>
				<c path="Array"><c path="map.S"/></c>
			</f>
			<haxe_doc>Creates a new Array by applying function `f` to all elements of `this`.

		The order of elements is preserved.

		If `f` is null, the result is unspecified.</haxe_doc>
		</map>
		<filter public="1" set="method" line="279">
			<f a="f">
				<f a="">
					<c path="Array.T"/>
					<x path="Bool"/>
				</f>
				<c path="Array"><c path="Array.T"/></c>
			</f>
			<haxe_doc>Returns an Array containing those elements of `this` for which `f`
		returned true.

		The individual elements are not duplicated and retain their identity.

		If `f` is null, the result is unspecified.</haxe_doc>
		</filter>
		<__get set="method" line="290"><f a="pos">
	<x path="Int"/>
	<c path="Array.T"/>
</f></__get>
		<__set set="method" line="294"><f a="pos:v">
	<x path="Int"/>
	<c path="Array.T"/>
	<c path="Array.T"/>
</f></__set>
		<__grow set="method" line="315"><f a="l">
	<x path="Int"/>
	<x path="Void"/>
</f></__grow>
		<__neko set="method" line="330"><f a=""><c path="neko.NativeArray"><c path="Array.T"/></c></f></__neko>
		<new public="1" set="method" line="27">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new Array.</haxe_doc>
		</new>
		<haxe_doc>An Array is a storage for values. You can access it using indexes or
	with its API.

	@see https://haxe.org/manual/std-Array.html
	@see https://haxe.org/manual/lf-array-comprehension.html</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":coreApi"/>
			<m n=":final"/>
		</meta>
	</class>
	<abstract path="Class" params="T" file="D:\HaxeToolkit\haxe\std/Class.hx">
		<this><x path="Class"><c path="Class.T"/></x></this>
		<haxe_doc>An abstract type that represents a Class.

	See `Type` for the Haxe Reflection API.

	@see https://haxe.org/manual/types-class-instance.html</haxe_doc>
		<meta>
			<m n=":valueUsed"/>
			<m n=":coreType"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<class path="Date" params="" file="D:\HaxeToolkit\haxe\std/neko/_std/Date.hx">
		<now public="1" set="method" line="69" static="1">
			<f a=""><c path="Date"/></f>
			<haxe_doc>Returns a Date representing the current local time.</haxe_doc>
		</now>
		<fromTime public="1" set="method" line="73" static="1">
			<f a="t">
				<x path="Float"/>
				<c path="Date"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Returns a Date from timestamp `t`.</haxe_doc>
		</fromTime>
		<fromString public="1" set="method" line="81" static="1">
			<f a="s">
				<c path="String"/>
				<c path="Date"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Returns a Date from a formated string `s`, with the following accepted
		formats:

		- `"YYYY-MM-DD hh:mm:ss"`
		- `"YYYY-MM-DD"`
		- `"hh:mm:ss"`

		The first two formats are expressed in local time, the third in UTC
		Epoch.</haxe_doc>
		</fromString>
		<new1 set="method" line="85" static="1"><f a="t">
	<d/>
	<c path="Date"/>
</f></new1>
		<date_new expr="Lib.load(&quot;std&quot;, &quot;date_new&quot;, 1)" line="91" static="1">
			<f a="">
				<unknown/>
				<unknown/>
			</f>
			<meta><m n=":value"><e>Lib.load("std", "date_new", 1)</e></m></meta>
		</date_new>
		<date_now expr="Lib.load(&quot;std&quot;, &quot;date_now&quot;, 0)" line="92" static="1">
			<f a=""><unknown/></f>
			<meta><m n=":value"><e>Lib.load("std", "date_now", 0)</e></m></meta>
		</date_now>
		<date_format expr="Lib.load(&quot;std&quot;, &quot;date_format&quot;, 2)" line="93" static="1">
			<f a=":">
				<d/>
				<unknown/>
				<c path="String"/>
			</f>
			<meta><m n=":value"><e>Lib.load("std", "date_format", 2)</e></m></meta>
		</date_format>
		<date_set_hour expr="Lib.load(&quot;std&quot;, &quot;date_set_hour&quot;, 4)" line="94" static="1">
			<f a=":::">
				<d/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<unknown/>
			</f>
			<meta><m n=":value"><e>Lib.load("std", "date_set_hour", 4)</e></m></meta>
		</date_set_hour>
		<date_set_day expr="Lib.load(&quot;std&quot;, &quot;date_set_day&quot;, 4)" line="95" static="1">
			<f a=":::">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<unknown/>
			</f>
			<meta><m n=":value"><e>Lib.load("std", "date_set_day", 4)</e></m></meta>
		</date_set_day>
		<date_get_day expr="Lib.load(&quot;std&quot;, &quot;date_get_day&quot;, 1)" line="96" static="1">
			<f a="">
				<d/>
				<a>
					<y><x path="Int"/></y>
					<m><x path="Int"/></m>
					<d><x path="Int"/></d>
				</a>
			</f>
			<meta><m n=":value"><e>Lib.load("std", "date_get_day", 1)</e></m></meta>
		</date_get_day>
		<date_get_hour expr="Lib.load(&quot;std&quot;, &quot;date_get_hour&quot;, 1)" line="97" static="1">
			<f a="">
				<d/>
				<a>
					<s><x path="Int"/></s>
					<m><x path="Int"/></m>
					<h><x path="Int"/></h>
				</a>
			</f>
			<meta><m n=":value"><e>Lib.load("std", "date_get_hour", 1)</e></m></meta>
		</date_get_hour>
		<int32_to_float expr="Lib.load(&quot;std&quot;, &quot;int32_to_float&quot;, 1)" line="98" static="1">
			<f a="">
				<d/>
				<x path="Int"/>
			</f>
			<meta><m n=":value"><e>Lib.load("std", "int32_to_float", 1)</e></m></meta>
		</int32_to_float>
		<int32_add expr="Lib.load(&quot;std&quot;, &quot;int32_add&quot;, 2)" line="99" static="1">
			<f a=":">
				<unknown/>
				<unknown/>
				<unknown/>
			</f>
			<meta><m n=":value"><e>Lib.load("std", "int32_add", 2)</e></m></meta>
		</int32_add>
		<int32_shl expr="Lib.load(&quot;std&quot;, &quot;int32_shl&quot;, 2)" line="100" static="1">
			<f a=":">
				<unknown/>
				<x path="Int"/>
				<unknown/>
			</f>
			<meta><m n=":value"><e>Lib.load("std", "int32_shl", 2)</e></m></meta>
		</int32_shl>
		<__string set="method" line="101" static="1">
			<f a=""><c path="String"/></f>
			<meta>
				<m n=":has_untyped"/>
				<m n=":keep"/>
			</meta>
		</__string>
		<__t><d/></__t>
		<getTime public="1" set="method" line="33">
			<f a=""><x path="Float"/></f>
			<haxe_doc>Returns the timestamp (in milliseconds) of the date. It might
		only have a per-second precision depending on the platforms.</haxe_doc>
		</getTime>
		<toString public="1" set="method" line="65">
			<f a=""><c path="String"/></f>
			<meta><m n=":keep"/></meta>
			<haxe_doc>Returns a string representation of `this` Date, by using the
		standard format [YYYY-MM-DD HH:MM:SS]. See `DateTools.format` for
		other formating rules.</haxe_doc>
		</toString>
		<new public="1" set="method" line="28">
			<f a="year:month:day:hour:min:sec">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Creates a new date object from the given arguments.

		The behaviour of a Date instance is only consistent across platforms if
		the the arguments describe a valid date.

		- month: 0 to 11
		- day: 1 to 31
		- hour: 0 to 23
		- min: 0 to 59
		- sec: 0 to 59</haxe_doc>
		</new>
		<haxe_doc>The Date class provides a basic structure for date and time related
	information. Date instances can be created by

	- `new Date()` for a specific date,
	- `Date.now()` to obtain information about the current time,
	- `Date.fromTime()` with a given timestamp or
	- `Date.fromString()` by parsing from a String.

	There are some extra functions available in the `DateTools` class.

	In the context of Haxe dates, a timestamp is defined as the number of
	milliseconds elapsed since 1st January 1970.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":coreApi"/>
			<m n=":final"/>
		</meta>
	</class>
	<class path="EReg" params="" file="D:\HaxeToolkit\haxe\std/neko/_std/EReg.hx">
		<regexp_new_options expr="neko.Lib.load(&quot;regexp&quot;, &quot;regexp_new_options&quot;, 2)" line="200" static="1">
			<f a=":">
				<unknown/>
				<unknown/>
				<unknown/>
			</f>
			<meta><m n=":value"><e>neko.Lib.load("regexp", "regexp_new_options", 2)</e></m></meta>
		</regexp_new_options>
		<regexp_match expr="neko.Lib.load(&quot;regexp&quot;, &quot;regexp_match&quot;, 4)" line="201" static="1">
			<f a=":::">
				<d/>
				<unknown/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":value"><e>neko.Lib.load("regexp", "regexp_match", 4)</e></m></meta>
		</regexp_match>
		<regexp_matched expr="neko.Lib.load(&quot;regexp&quot;, &quot;regexp_matched&quot;, 2)" line="202" static="1">
			<f a=":">
				<d/>
				<x path="Int"/>
				<c path="String"/>
			</f>
			<meta><m n=":value"><e>neko.Lib.load("regexp", "regexp_matched", 2)</e></m></meta>
		</regexp_matched>
		<regexp_matched_pos expr="neko.Lib.load(&quot;regexp&quot;, &quot;regexp_matched_pos&quot;, 2)" line="203" static="1">
			<f a=":">
				<d/>
				<x path="Int"/>
				<a>
					<pos><x path="Int"/></pos>
					<len><x path="Int"/></len>
				</a>
			</f>
			<meta><m n=":value"><e>neko.Lib.load("regexp", "regexp_matched_pos", 2)</e></m></meta>
		</regexp_matched_pos>
		<r><d/></r>
		<last><c path="String"/></last>
		<global><x path="Bool"/></global>
		<match public="1" set="method" line="36">
			<f a="s">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Tells if `this` regular expression matches String `s`.

		This method modifies the internal state.

		If `s` is `null`, the result is unspecified.</haxe_doc>
		</match>
		<matched public="1" set="method" line="45">
			<f a="n">
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the matched sub-group `n` of `this` EReg.

		This method should only be called after `this.match` or
		`this.matchSub`, and then operates on the String of that operation.

		The index `n` corresponds to the n-th set of parentheses in the pattern
		of `this` EReg. If no such sub-group exists, an exception is thrown.

		If `n` equals 0, the whole matched substring is returned.</haxe_doc>
		</matched>
		<split public="1" set="method" line="74">
			<f a="s">
				<c path="String"/>
				<c path="Array"><c path="String"/></c>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Splits String `s` at all substrings `this` EReg matches.

		If a match is found at the start of `s`, the result contains a leading
		empty String "" entry.

		If a match is found at the end of `s`, the result contains a trailing
		empty String "" entry.

		If two matching substrings appear next to each other, the result
		contains the empty String `""` between them.

		By default, this method splits `s` into two parts at the first matched
		substring. If the global g modifier is in place, `s` is split at each
		matched substring.

		If `s` is null, the result is unspecified.</haxe_doc>
		</split>
		<replace public="1" set="method" line="98">
			<f a="s:by">
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Replaces the first substring of `s` which `this` EReg matches with `by`.

		If `this` EReg does not match any substring, the result is `s`.

		By default, this method replaces only the first matched substring. If
		the global g modifier is in place, all matched substrings are replaced.

		If `by` contains `$1` to `$9`, the digit corresponds to number of a
		matched sub-group and its value is used instead. If no such sub-group
		exists, the replacement is unspecified. The string `$$` becomes `$`.

		If `s` or `by` are null, the result is unspecified.</haxe_doc>
		</replace>
		<new public="1" set="method" line="28">
			<f a="r:opt">
				<c path="String"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Creates a new regular expression with pattern `r` and modifiers `opt`.

		This is equivalent to the shorthand syntax `~/r/opt`

		If `r` or `opt` are null, the result is unspecified.</haxe_doc>
		</new>
		<haxe_doc><![CDATA[The EReg class represents regular expressions.

	While basic usage and patterns consistently work across platforms, some more
	complex operations may yield different results. This is a necessary trade-
	off to retain a certain level of performance.

	EReg instances can be created by calling the constructor, or with the
	special syntax `~/pattern/modifier`

	EReg instances maintain an internal state, which is affected by several of
	its methods.

	A detailed explanation of the supported operations is available at
	<https://haxe.org/manual/std-regex.html>]]></haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":coreApi"/>
			<m n=":final"/>
		</meta>
	</class>
	<abstract path="Enum" params="T" file="D:\HaxeToolkit\haxe\std/Enum.hx">
		<this><x path="Enum"><c path="Enum.T"/></x></this>
		<haxe_doc>An abstract type that represents an Enum type.

	The corresponding enum instance type is `EnumValue`.

	See `Type` for the Haxe Reflection API.

	@see https://haxe.org/manual/types-enum-instance.html</haxe_doc>
		<meta>
			<m n=":valueUsed"/>
			<m n=":coreType"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<abstract path="EnumValue" params="" file="D:\HaxeToolkit\haxe\std/EnumValue.hx">
		<this><x path="EnumValue"/></this>
		<haxe_doc>An abstract type that represents any enum value.
	See `Type` for the Haxe Reflection API.

	@see https://haxe.org/manual/types-enum-instance.html</haxe_doc>
		<meta><m n=":coreType"/></meta>
	</abstract>
	<class path="Lambda" params="" file="D:\HaxeToolkit\haxe\std/Lambda.hx">
		<array public="1" params="A" set="method" line="44" static="1">
			<f a="it">
				<t path="Iterable"><c path="array.A"/></t>
				<c path="Array"><c path="array.A"/></c>
			</f>
			<haxe_doc>Creates an Array from Iterable `it`.

		If `it` is an Array, this function returns a copy of it.</haxe_doc>
		</array>
		<haxe_doc>The `Lambda` class is a collection of methods to support functional
	programming. It is ideally used with `using Lambda` and then acts as an
	extension to Iterable types.

	On static platforms, working with the Iterable structure might be slower
	than performing the operations directly on known types, such as Array and
	List.

	If the first argument to any of the methods is null, the result is
	unspecified.

	@see https://haxe.org/manual/std-Lambda.html</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="List" params="T" file="D:\HaxeToolkit\haxe\std/List.hx">
		<h><c path="_List.ListNode"><c path="List.T"/></c></h>
		<q><c path="_List.ListNode"><c path="List.T"/></c></q>
		<length public="1" set="null">
			<x path="Int"/>
			<haxe_doc>The length of `this` List.</haxe_doc>
		</length>
		<add public="1" set="method" line="52">
			<f a="item">
				<c path="List.T"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Adds element `item` at the end of `this` List.

		`this.length` increases by 1.</haxe_doc>
		</add>
		<push public="1" set="method" line="67">
			<f a="item">
				<c path="List.T"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Adds element `item` at the beginning of `this` List.

		`this.length` increases by 1.</haxe_doc>
		</push>
		<pop public="1" set="method" line="99">
			<f a=""><t path="Null"><c path="List.T"/></t></f>
			<haxe_doc>Returns the first element of `this` List, or null if no elements exist.

		The element is removed from `this` List.</haxe_doc>
		</pop>
		<iterator public="1" get="inline" set="null" line="160">
			<f a=""><c path="_List.ListIterator"><c path="List.T"/></c></f>
			<haxe_doc>Returns an iterator on the elements of the list.</haxe_doc>
		</iterator>
		<new public="1" set="method" line="43">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new empty list.</haxe_doc>
		</new>
		<haxe_doc>A linked-list of elements. The list is composed of element container objects
	that are chained together. It is optimized so that adding or removing an
	element does not imply copying the whole list content every time.

	@see https://haxe.org/manual/std-List.html</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="neko.NativeArray" params="T" file="D:\HaxeToolkit\haxe\std/neko/NativeArray.hx"><meta><m n=":keep"/></meta></class>
	<class path="_List.ListNode" params="T" file="D:\HaxeToolkit\haxe\std/List.hx" private="1" module="List" extern="1">
		<extends path="neko.NativeArray"><d/></extends>
		<create public="1" params="T" get="inline" set="null" line="247" static="1">
			<f a="item:next">
				<c path="create.T"/>
				<c path="_List.ListNode"><c path="create.T"/></c>
				<c path="_List.ListNode"><c path="create.T"/></c>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</create>
		<item public="1" get="accessor" set="accessor"><c path="_List.ListNode.T"/></item>
		<next public="1" get="accessor" set="accessor"><c path="_List.ListNode"><c path="_List.ListNode.T"/></c></next>
		<get_item get="inline" set="null" line="243"><f a=""><c path="_List.ListNode.T"/></f></get_item>
		<set_item get="inline" set="null" line="244"><f a="v">
	<c path="_List.ListNode.T"/>
	<c path="_List.ListNode.T"/>
</f></set_item>
		<get_next get="inline" set="null" line="245"><f a=""><c path="_List.ListNode"><c path="_List.ListNode.T"/></c></f></get_next>
		<set_next get="inline" set="null" line="246"><f a="v">
	<c path="_List.ListNode"><c path="_List.ListNode.T"/></c>
	<c path="_List.ListNode"><c path="_List.ListNode.T"/></c>
</f></set_next>
	</class>
	<class path="_List.ListIterator" params="T" file="D:\HaxeToolkit\haxe\std/List.hx" private="1" module="List">
		<head><c path="_List.ListNode"><c path="_List.ListIterator.T"/></c></head>
		<hasNext public="1" get="inline" set="null" line="272"><f a=""><x path="Bool"/></f></hasNext>
		<next public="1" get="inline" set="null" line="276"><f a=""><c path="_List.ListIterator.T"/></f></next>
		<new public="1" get="inline" set="null" line="268"><f a="head">
	<c path="_List.ListNode"><c path="_List.ListIterator.T"/></c>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<abstract path="Map" params="K:V" file="D:\HaxeToolkit\haxe\std/Map.hx">
		<from>
			<icast field="fromStringMap"><c path="haxe.ds.StringMap"><c path="fromStringMap.V"/></c></icast>
			<icast field="fromIntMap"><c path="haxe.ds.IntMap"><c path="fromIntMap.V"/></c></icast>
			<icast field="fromObjectMap"><c path="haxe.ds.ObjectMap">
	<c path="fromObjectMap.K"/>
	<c path="fromObjectMap.V"/>
</c></icast>
		</from>
		<this><t path="IMap">
	<c path="Map.K"/>
	<c path="Map.V"/>
</t></this>
		<to>
			<icast field="toStringMap"><c path="haxe.ds.StringMap"><c path="toStringMap.V"/></c></icast>
			<icast field="toIntMap"><c path="haxe.ds.IntMap"><c path="toIntMap.V"/></c></icast>
			<icast field="toEnumValueMapMap"><c path="haxe.ds.EnumValueMap">
	<c path="toEnumValueMapMap.K"/>
	<c path="toEnumValueMapMap.V"/>
</c></icast>
			<icast field="toObjectMap"><c path="haxe.ds.ObjectMap">
	<c path="toObjectMap.K"/>
	<c path="toObjectMap.V"/>
</c></icast>
		</to>
		<haxe_doc><![CDATA[Map allows key to value mapping for arbitrary value types, and many key
	types.

	This is a multi-type abstract, it is instantiated as one of its
	specialization types depending on its type parameters.

	A Map can be instantiated without explicit type parameters. Type inference
	will then determine the type parameters from the usage.

	Maps can also be created with `key1 => value1, key2 => value2` syntax.

	Map is an abstract type, it is not available at runtime.

	@see https://haxe.org/manual/std-Map.html]]></haxe_doc>
		<meta><m n=":multiType"><e>@:followWithAbstracts K</e></m></meta>
		<impl><class path="_Map.Map_Impl_" params="" file="D:\HaxeToolkit\haxe\std/Map.hx" private="1" module="Map"><meta>
	<m n=":keep"/>
	<m n=":final"/>
</meta></class></impl>
	</abstract>
	<typedef path="IMap" params="K:V" file="D:\HaxeToolkit\haxe\std/Map.hx" module="Map">
		<c path="haxe.IMap">
			<c path="IMap.K"/>
			<c path="IMap.V"/>
		</c>
		<meta>
			<m n=":dox"><e>hide</e></m>
			<m n=":deprecated"/>
		</meta>
	</typedef>
	<class path="_Math.MathImpl" params="" file="D:\HaxeToolkit\haxe\std/neko/_std/Math.hx" private="1" module="Math">
		<__rnd static="1"><unknown/></__rnd>
		<_rand_float expr="Lib.load(&quot;std&quot;, &quot;random_float&quot;, 1)" line="28" static="1">
			<f a="">
				<unknown/>
				<x path="Float"/>
			</f>
			<meta><m n=":value"><e>Lib.load("std", "random_float", 1)</e></m></meta>
		</_rand_float>
		<_rand_int expr="Lib.load(&quot;std&quot;, &quot;random_int&quot;, 2)" line="29" static="1">
			<unknown/>
			<meta><m n=":value"><e>Lib.load("std", "random_int", 2)</e></m></meta>
		</_rand_int>
		<min public="1" set="method" line="31" static="1">
			<f a="a:b">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</min>
		<max public="1" set="method" line="32" static="1">
			<f a="a:b">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</max>
		<random public="1" set="method" line="33" static="1"><f a=""><x path="Float"/></f></random>
		<isNaN public="1" set="method" line="34" static="1">
			<f a="f">
				<x path="Float"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</isNaN>
		<isFinite public="1" set="method" line="35" static="1">
			<f a="f">
				<x path="Float"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</isFinite>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":native"><e>"Math"</e></m>
			<m n=":keep"/>
		</meta>
	</class>
	<class path="Math" params="" file="D:\HaxeToolkit\haxe\std/neko/_std/Math.hx" extern="1">
		<PI public="1" set="null" static="1">
			<x path="Float"/>
			<haxe_doc>Represents the ratio of the circumference of a circle to its diameter,
		specified by the constant, Ï€. `PI` is approximately 3.141592653589793.</haxe_doc>
		</PI>
		<NaN public="1" set="null" static="1">
			<x path="Float"/>
			<haxe_doc><![CDATA[A special `Float` constant which denotes an invalid number.

		NaN stands for "Not a Number". It occurs when a mathematically incorrect
		operation is executed, such as taking the square root of a negative
		number: Math.sqrt(-1).

		All further operations with `NaN` as an operand will result in `NaN`.

		If this constant is converted to an `Int`, e.g. through `Std.int()`, the
		result is unspecified.

		In order to test if a value is `NaN`, you should use `Math.isNaN()` function.

		@php In PHP versions prior to 5.3.1 VC 9 there may be unexpected
		results when performing arithmetic operations with `NaN` on Windows,
		see <https://bugs.php.net/bug.php?id=42143>]]></haxe_doc>
		</NaN>
		<POSITIVE_INFINITY public="1" set="null" static="1">
			<x path="Float"/>
			<haxe_doc>A special `Float` constant which denotes positive infinity.

		For example, this is the result of 1.0 / 0.0.

		Operations with `POSITIVE_INFINITY` as an operand may result in
		`NEGATIVE_INFINITY`, `POSITIVE_INFINITY` or `NaN`.

		If this constant is converted to an `Int`, e.g. through `Std.int()`, the
		result is unspecified.</haxe_doc>
		</POSITIVE_INFINITY>
		<NEGATIVE_INFINITY public="1" set="null" static="1">
			<x path="Float"/>
			<haxe_doc>A special `Float` constant which denotes negative infinity.

		For example, this is the result of -1.0 / 0.0.

		Operations with `NEGATIVE_INFINITY` as an operand may result in
		`NEGATIVE_INFINITY`, `POSITIVE_INFINITY` or `NaN`.

		If this constant is converted to an `Int`, e.g. through `Std.int()`, the
		result is unspecified.</haxe_doc>
		</NEGATIVE_INFINITY>
		<min public="1" set="method" static="1">
			<f a="a:b">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the smaller of values `a` and `b`.

		If `a` or `b` are `NaN`, the result is `NaN`.
		If `a` or `b` are `NEGATIVE_INFINITY`, the result is `NEGATIVE_INFINITY`.
		If `a` and `b` are `POSITIVE_INFINITY`, the result is `POSITIVE_INFINITY`.</haxe_doc>
		</min>
		<max public="1" set="method" static="1">
			<f a="a:b">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the greater of values `a` and `b`.

		If `a` or `b` are `NaN`, the result is `NaN`.
		If `a` or `b` are `POSITIVE_INFINITY`, the result is `POSITIVE_INFINITY`.
		If `a` and `b` are `NEGATIVE_INFINITY`, the result is `NEGATIVE_INFINITY`.</haxe_doc>
		</max>
		<abs public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the absolute value of `v`.

		If `v` is positive or 0, the result is unchanged. Otherwise the result
		is -`v`.

		If `v` is `NEGATIVE_INFINITY` or `POSITIVE_INFINITY`, the result is
		`POSITIVE_INFINITY`.

		If `v` is `NaN`, the result is `NaN`.</haxe_doc>
		</abs>
		<sin public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the trigonometric sine of the specified angle `v`, in radians.

		If `v` is `NaN` or infinite, the result is `NaN`.</haxe_doc>
		</sin>
		<cos public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the trigonometric cosine of the specified angle `v`, in radians.

		If `v` is `NaN` or infinite, the result is `NaN`.</haxe_doc>
		</cos>
		<atan2 public="1" set="method" static="1">
			<f a="y:x">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the trigonometric arc tangent whose tangent is the quotient of
		two specified numbers, in radians.

		If parameter `x` or `y`  is `NaN`, `NEGATIVE_INFINITY` or `POSITIVE_INFINITY`,
		the result is `NaN`.</haxe_doc>
		</atan2>
		<tan public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the trigonometric tangent of the specified angle `v`, in radians.

		If `v` is `NaN` or infinite, the result is `NaN`.</haxe_doc>
		</tan>
		<exp public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns Euler's number, raised to the power of `v`.

		exp(1.0) is approximately 2.718281828459.

		If `v` is `POSITIVE_INFINITY`, the result is `POSITIVE_INFINITY`.
		If `v` is `NEGATIVE_INFINITY`, the result is `0.0`.
		If `v` is `NaN`, the result is `NaN`.</haxe_doc>
		</exp>
		<log public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the natural logarithm of `v`.

		This is the mathematical inverse operation of exp,
		i.e. `log(exp(v)) == v` always holds.

		If `v` is negative (including `NEGATIVE_INFINITY`) or `NaN`, the result
		is `NaN`.
		If `v` is `POSITIVE_INFINITY`, the result is `POSITIVE_INFINITY`.
		If `v` is `0.0`, the result is `NEGATIVE_INFINITY`.</haxe_doc>
		</log>
		<sqrt public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the square root of `v`.

		If `v` is negative (including `NEGATIVE_INFINITY`) or `NaN`, the result
		is `NaN`.
		If `v` is `POSITIVE_INFINITY`, the result is `POSITIVE_INFINITY`.
		If `v` is `0.0`, the result is `0.0`.</haxe_doc>
		</sqrt>
		<round public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Rounds `v` to the nearest integer value.

		Ties are rounded up, so that `0.5` becomes `1` and `-0.5` becomes `0`.

		If `v` is outside of the signed `Int32` range, or is `NaN`, `NEGATIVE_INFINITY`
		or `POSITIVE_INFINITY`, the result is unspecified.</haxe_doc>
		</round>
		<floor public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the largest integer value that is not greater than `v`.

		If `v` is outside of the signed `Int32` range, or is `NaN`, `NEGATIVE_INFINITY`
		or `POSITIVE_INFINITY`, the result is unspecified.</haxe_doc>
		</floor>
		<ceil public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the smallest integer value that is not less than `v`.

		If `v` is outside of the signed `Int32` range, or is `NaN`, `NEGATIVE_INFINITY`
		or `POSITIVE_INFINITY`, the result is unspecified.</haxe_doc>
		</ceil>
		<atan public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the trigonometric arc tangent of the specified angle `v`,
		in radians.

		If `v` is `NaN` or infinite, the result is `NaN`.</haxe_doc>
		</atan>
		<asin public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the trigonometric arc of the specified angle `v`, in radians.

		If `v` is `NaN` or infinite, the result is `NaN`.</haxe_doc>
		</asin>
		<acos public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the trigonometric arc cosine of the specified angle `v`,
		in radians.

		If `v` is `NaN` or infinite, the result is `NaN`.</haxe_doc>
		</acos>
		<pow public="1" set="method" static="1">
			<f a="v:exp">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns a specified base `v` raised to the specified power `exp`.</haxe_doc>
		</pow>
		<fround public="1" set="method" static="1"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></fround>
		<ffloor public="1" set="method" static="1"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></ffloor>
		<fceil public="1" set="method" static="1"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></fceil>
		<random public="1" set="method" static="1">
			<f a=""><x path="Float"/></f>
			<haxe_doc>Returns a pseudo-random number which is greater than or equal to 0.0,
		and less than 1.0.</haxe_doc>
		</random>
		<isNaN public="1" set="method" static="1">
			<f a="f">
				<x path="Float"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tells if `f` is not a valid number.

		If `f` is `NaN`, the result is `true`, otherwise the result is `false`.
		In particular, both `POSITIVE_INFINITY` and `NEGATIVE_INFINITY` are
		not considered `NaN`.</haxe_doc>
		</isNaN>
		<isFinite public="1" set="method" static="1">
			<f a="f">
				<x path="Float"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tells if `f` is a finite number.

		If `f` is `POSITIVE_INFINITY`, `NEGATIVE_INFINITY` or `NaN`, the result
		is `false`, otherwise the result is `true`.</haxe_doc>
		</isFinite>
		<haxe_doc>This class defines mathematical functions and constants.

	@see https://haxe.org/manual/std-math.html</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":coreApi"/>
			<m n=":final"/>
		</meta>
	</class>
	<class path="Reflect" params="" file="D:\HaxeToolkit\haxe\std/neko/_std/Reflect.hx">
		<hasField public="1" set="method" line="24" static="1">
			<f a="o:field">
				<d/>
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Tells if structure `o` has a field named `field`.

		This is only guaranteed to work for anonymous structures. Refer to
		`Type.getInstanceFields` for a function supporting class instances.

		If `o` or `field` are null, the result is unspecified.</haxe_doc>
		</hasField>
		<field public="1" get="inline" set="null" line="28" static="1">
			<f a="o:field">
				<d/>
				<c path="String"/>
				<d/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Returns the value of the field named `field` on object `o`.

		If `o` is not an object or has no field named `field`, the result is
		null.

		If the field is defined as a property, its accessors are ignored. Refer
		to `Reflect.getProperty` for a function supporting property accessors.

		If `field` is null, the result is unspecified.

		(As3) If used on a property field, the getter will be invoked. It is
		not possible to obtain the value directly.</haxe_doc>
		</field>
		<setField public="1" get="inline" set="null" line="32" static="1">
			<f a="o:field:value">
				<d/>
				<c path="String"/>
				<d/>
				<x path="Void"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Sets the field named `field` of object `o` to value `value`.

		If `o` has no field named `field`, this function is only guaranteed to
		work for anonymous structures.

		If `o` or `field` are null, the result is unspecified.

		(As3) If used on a property field, the setter will be invoked. It is
		not possible to set the value directly.</haxe_doc>
		</setField>
		<getProperty public="1" get="inline" set="null" line="37" static="1">
			<f a="o:field">
				<d/>
				<c path="String"/>
				<d/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Returns the value of the field named `field` on object `o`, taking
		property getter functions into account.

		If the field is not a property, this function behaves like
		`Reflect.field`, but might be slower.

		If `o` or `field` are null, the result is unspecified.</haxe_doc>
		</getProperty>
		<setProperty public="1" get="inline" set="null" line="42" static="1">
			<f a="o:field:value">
				<d/>
				<c path="String"/>
				<d/>
				<x path="Void"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Sets the field named `field` of object `o` to value `value`, taking
		property setter functions into account.

		If the field is not a property, this function behaves like
		`Reflect.setField`, but might be slower.

		If `field` is null, the result is unspecified.</haxe_doc>
		</setProperty>
		<callMethod public="1" set="method" line="49" static="1">
			<f a="o:func:args">
				<d/>
				<x path="haxe.Function"/>
				<c path="Array"><d/></c>
				<d/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Call a method with the given object and arguments.</haxe_doc>
		</callMethod>
		<fields public="1" set="method" line="61" static="1">
			<f a="o">
				<d/>
				<c path="Array"><c path="String"/></c>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Returns the fields of structure `o`.

		This method is only guaranteed to work on anonymous structures. Refer to
		`Type.getInstanceFields` for a function supporting class instances.

		If `o` is null, the result is unspecified.</haxe_doc>
		</fields>
		<isFunction public="1" set="method" line="81" static="1">
			<f a="f">
				<d/>
				<x path="Bool"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Returns true if `f` is a function, false otherwise.

		If `f` is null, the result is false.</haxe_doc>
		</isFunction>
		<compare public="1" params="T" get="inline" set="null" line="85" static="1">
			<f a="a:b">
				<c path="compare.T"/>
				<c path="compare.T"/>
				<x path="Int"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Compares `a` and `b`.

		If `a` is less than `b`, the result is negative. If `b` is less than
		`a`, the result is positive. If `a` and `b` are equal, the result is 0.

		This function is only defined if `a` and `b` are of the same type.

		If that type is a function, the result is unspecified and
		`Reflect.compareMethods` should be used instead.

		For all other types, the result is 0 if `a` and `b` are equal. If they
		are not equal, the result depends on the type and is negative if:

		- Numeric types: a is less than b
		- String: a is lexicographically less than b
		- Other: unspecified

		If `a` and `b` are null, the result is 0. If only one of them is null,
		the result is unspecified.</haxe_doc>
		</compare>
		<compareMethods public="1" get="inline" set="null" line="89" static="1">
			<f a="f1:f2">
				<d/>
				<d/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Compares the functions `f1` and `f2`.

		If `f1` or `f2` are not functions, the result is unspecified.

		Otherwise the result is true if `f1` and the `f2` are physically equal,
		false otherwise.</haxe_doc>
		</compareMethods>
		<isObject public="1" set="method" line="93" static="1">
			<f a="v">
				<d/>
				<x path="Bool"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc><![CDATA[Tells if `v` is an object.

		The result is true if `v` is one of the following:

		- class instance
		- structure
		- `Class<T>`
		- `Enum<T>`

		Otherwise, including if `v` is null, the result is false.]]></haxe_doc>
		</isObject>
		<isEnumValue public="1" set="method" line="97" static="1">
			<f a="v">
				<d/>
				<x path="Bool"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Tells if `v` is an enum value.

		The result is true if `v` is of type EnumValue, i.e. an enum
		constructor.

		Otherwise, including if `v` is null, the result is false.</haxe_doc>
		</isEnumValue>
		<deleteField public="1" get="inline" set="null" line="101" static="1">
			<f a="o:field">
				<d/>
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Removes the field named `field` from structure `o`.

		This method is only guaranteed to work on anonymous structures.

		If `o` or `field` are null, the result is unspecified.</haxe_doc>
		</deleteField>
		<copy public="1" params="T" get="inline" set="null" line="105" static="1">
			<f a="o">
				<c path="copy.T"/>
				<c path="copy.T"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Copies the fields of structure `o`.

		This is only guaranteed to work on anonymous structures.

		If `o` is null, the result is unspecified.</haxe_doc>
		</copy>
		<makeVarArgs public="1" set="method" line="110" static="1">
			<f a="f">
				<f a="">
					<c path="Array"><d/></c>
					<d/>
				</f>
				<d/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Transform a function taking an array of arguments into a function that can
		be called with any number of arguments.</haxe_doc>
			<overloads><makeVarArgs public="1" set="method"><f a="f">
	<f a="">
		<c path="Array"><d/></c>
		<x path="Void"/>
	</f>
	<d/>
</f></makeVarArgs></overloads>
		</makeVarArgs>
		<same_closure expr="try neko.Lib.load(&quot;std&quot;, &quot;same_closure&quot;, 2) catch(e:Dynamic) function(f1, f2) return f1 == f2" line="114" static="1">
			<f a=":">
				<d/>
				<d/>
				<x path="Bool"/>
			</f>
			<meta><m n=":value"><e>try neko.Lib.load("std", "same_closure", 2) catch(e:Dynamic) function(f1, f2) return f1 == f2</e></m></meta>
		</same_closure>
		<haxe_doc>The Reflect API is a way to manipulate values dynamically through an
	abstract interface in an untyped manner. Use with care.

	@see https://haxe.org/manual/std-reflection.html</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<abstract path="Int" params="" file="D:\HaxeToolkit\haxe\std/StdTypes.hx" module="StdTypes">
		<this><x path="Int"/></this>
		<to><icast><x path="Float"/></icast></to>
		<haxe_doc><![CDATA[The standard `Int` type. Its precision depends on the platform.

	On static targets, `null` cannot be assigned to `Int`. If this is necessary,
	`Null<Int>` can be used instead.

	`Std.int` converts a `Float` to an `Int`, rounded towards 0.
	`Std.parseInt` converts a `String` to an `Int`.

	@see https://haxe.org/manual/types-basic-types.html
	@see https://haxe.org/manual/std-math-integer-math.html
	@see https://haxe.org/manual/types-nullability.html]]></haxe_doc>
		<meta>
			<m n=":valueUsed"/>
			<m n=":coreType"/>
			<m n=":notNull"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<abstract path="Float" params="" file="D:\HaxeToolkit\haxe\std/StdTypes.hx" module="StdTypes">
		<this><x path="Float"/></this>
		<haxe_doc><![CDATA[The standard `Float` type, this is a double-precision IEEE 64bit float.

	On static targets, `null` cannot be assigned to Float. If this is necessary,
	`Null<Float>` can be used instead.

	`Std.int` converts a `Float` to an `Int`, rounded towards 0.
	`Std.parseFloat` converts a `String` to a `Float`.

	@see https://haxe.org/manual/types-basic-types.html
	@see https://haxe.org/manual/types-nullability.html]]></haxe_doc>
		<meta>
			<m n=":valueUsed"/>
			<m n=":coreType"/>
			<m n=":notNull"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<abstract path="Bool" params="" file="D:\HaxeToolkit\haxe\std/StdTypes.hx" module="StdTypes">
		<this><x path="Bool"/></this>
		<haxe_doc><![CDATA[The standard Boolean type, which can either be `true` or `false`.

	On static targets, `null` cannot be assigned to `Bool`. If this is necessary,
	`Null<Bool>` can be used instead.

	@see https://haxe.org/manual/types-bool.html
	@see https://haxe.org/manual/types-nullability.html]]></haxe_doc>
		<meta>
			<m n=":valueUsed"/>
			<m n=":coreType"/>
			<m n=":notNull"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<abstract path="Dynamic" params="T" file="D:\HaxeToolkit\haxe\std/StdTypes.hx" module="StdTypes">
		<this><x path="Dynamic"><c path="Dynamic.T"/></x></this>
		<haxe_doc>`Dynamic` is a special type which is compatible with all other types.

	Use of `Dynamic` should be minimized as it prevents several compiler
	checks and optimizations. See `Any` type for a safer alternative for
	representing values of any type.

	@see https://haxe.org/manual/types-dynamic.html</haxe_doc>
		<meta>
			<m n=":valueUsed"/>
			<m n=":coreType"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<class path="neko.Boot" params="" file="D:\HaxeToolkit\haxe\std/neko/Boot.hx">
		<__tmp_str set="method" line="28" static="1">
			<f a=""><c path="String"/></f>
			<meta><m n=":has_untyped"/></meta>
		</__tmp_str>
		<__enum_str set="method" line="32" static="1">
			<f a="e">
				<d/>
				<c path="String"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</__enum_str>
		<__interfLoop set="method" line="54" static="1"><f a="cc:cl">
	<d/>
	<d/>
	<x path="Bool"/>
</f></__interfLoop>
		<__instanceof set="method" line="70" static="1">
			<f a="o:cl">
				<a>
					<__name__ set="null"><unknown/></__name__>
					<__enum__ set="null"><t path="Abstract&lt;Dynamic&gt;"/></__enum__>
					<__ename__ set="null"><unknown/></__ename__>
					<__class__ set="null"><unknown/></__class__>
				</a>
				<t path="Abstract&lt;Dynamic&gt;"/>
				<x path="Bool"/>
			</f>
			<meta>
				<m n=":has_untyped"/>
				<m n=":ifFeature"><e>"typed_catch"</e></m>
			</meta>
		</__instanceof>
		<__serialize set="method" line="88" static="1">
			<f a="o">
				<a>
					<__enum__ set="null"><a><__ename__ set="null"><a><length set="null"><x path="Int"/></length></a></__ename__></a></__enum__>
					<__class__ set="null"><a><__name__ set="null"><a><length set="null"><x path="Int"/></length></a></__name__></a></__class__>
				</a>
				<c path="Array"><unknown/></c>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</__serialize>
		<__tagserialize set="method" line="108" static="1">
			<f a="o">
				<a>
					<tag set="null"><unknown/></tag>
					<__enum__ set="null"><a><__ename__ set="null"><a><length set="null"><x path="Int"/></length></a></__ename__></a></__enum__>
				</a>
				<c path="Array"><unknown/></c>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</__tagserialize>
		<__unserialize set="method" line="117" static="1">
			<f a="v">
				<c path="Array"><unknown/></c>
				<unknown/>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</__unserialize>
		<__init set="method" line="140" static="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":has_untyped"/></meta>
		</__init>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":dox"><e>hide</e></m>
			<m n=":keep"/>
		</meta>
	</class>
	<class path="Std" params="" file="D:\HaxeToolkit\haxe\std/neko/_std/Std.hx">
		<is public="1" set="method" line="25" static="1">
			<f a="v:t">
				<d/>
				<d/>
				<x path="Bool"/>
			</f>
			<meta>
				<m n=":has_untyped"/>
				<m n=":ifFeature"><e>"typed_cast"</e></m>
			</meta>
			<haxe_doc>Tells if a value `v` is of the type `t`. Returns `false` if `v` or `t` are null.</haxe_doc>
		</is>
		<instance public="1" params="T:S" set="method" line="29" static="1">
			<f a="value:c">
				<c path="instance.T"/>
				<x path="Class"><c path="instance.S"/></x>
				<c path="instance.S"/>
			</f>
			<haxe_doc>Checks if object `value` is an instance of class `c`.

		Compiles only if the class specified by `c` can be assigned to the type
		of `value`.

		This method checks if a downcast is possible. That is, if the runtime
		type of `value` is assignable to the class specified by `c`, `value` is
		returned. Otherwise null is returned.

		This method is not guaranteed to work with interfaces or core types such
		as `String`, `Array` and `Date`.

		If `value` is null, the result is null. If `c` is null, the result is
		unspecified.</haxe_doc>
		</instance>
		<string public="1" set="method" line="33" static="1">
			<f a="s">
				<d/>
				<c path="String"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Converts any value to a String.

		If `s` is of `String`, `Int`, `Float` or `Bool`, its value is returned.

		If `s` is an instance of a class and that class or one of its parent classes has
		a `toString` method, that method is called. If no such method is present, the result
		is unspecified.

		If `s` is an enum constructor without argument, the constructor's name is returned. If
		arguments exists, the constructor's name followed by the String representations of
		the arguments is returned.

		If `s` is a structure, the field names along with their values are returned. The field order
		and the operator separating field names and values are unspecified.

		If s is null, "null" is returned.</haxe_doc>
		</string>
		<int public="1" set="method" line="37" static="1">
			<f a="x">
				<x path="Float"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Converts a `Float` to an `Int`, rounded towards 0.

		If `x` is outside of the signed Int32 range, or is `NaN`, `NEGATIVE_INFINITY` or `POSITIVE_INFINITY`, the result is unspecified.</haxe_doc>
		</int>
		<parseInt public="1" set="method" line="42" static="1">
			<f a="x">
				<c path="String"/>
				<t path="Null"><x path="Int"/></t>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Converts a `String` to an `Int`.

		Leading whitespaces are ignored.

		If `x` starts with 0x or 0X, hexadecimal notation is recognized where the following digits may
		contain 0-9 and A-F.

		Otherwise `x` is read as decimal number with 0-9 being allowed characters. `x` may also start with
		a - to denote a negative value.

		In decimal mode, parsing continues until an invalid character is detected, in which case the
		result up to that point is returned. For hexadecimal notation, the effect of invalid characters
		is unspecified.

		Leading 0s that are not part of the 0x/0X hexadecimal notation are ignored, which means octal
		notation is not supported.

		If the input cannot be recognized, the result is `null`.</haxe_doc>
		</parseInt>
		<parseFloat public="1" set="method" line="53" static="1">
			<f a="x">
				<c path="String"/>
				<x path="Float"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Converts a `String` to a `Float`.

		The parsing rules for `parseInt` apply here as well, with the exception of invalid input
		resulting in a `NaN` value instead of null.

		Additionally, decimal notation may contain a single `.` to denote the start of the fractions.</haxe_doc>
		</parseFloat>
		<random public="1" set="method" line="60" static="1">
			<f a="x">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc><![CDATA[Return a random integer between 0 included and `x` excluded.

		If `x <= 1`, the result is always 0.]]></haxe_doc>
		</random>
		<haxe_doc>The Std class provides standard methods for manipulating basic types.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<abstract path="Void" params="" file="D:\HaxeToolkit\haxe\std/StdTypes.hx" module="StdTypes">
		<this><x path="Void"/></this>
		<haxe_doc>The standard `Void` type. Only `null` values can be of the type `Void`.

	@see https://haxe.org/manual/types-void.html</haxe_doc>
		<meta><m n=":coreType"/></meta>
	</abstract>
	<typedef path="Null" params="T" file="D:\HaxeToolkit\haxe\std/StdTypes.hx" module="StdTypes">
		<c path="Null.T"/>
		<haxe_doc>`Null` can be useful in two cases. In order to document some methods
	that accept or can return a `null` value, or for the Flash compiler and AS3
	generator to distinguish between base values that can be `null` and others that
	can't.

	@see https://haxe.org/manual/types-nullability.html</haxe_doc>
	</typedef>
	<typedef path="Iterator" params="T" file="D:\HaxeToolkit\haxe\std/StdTypes.hx" module="StdTypes">
		<a>
			<next set="method">
				<f a=""><c path="Iterator.T"/></f>
				<haxe_doc>Returns the current item of the `Iterator` and advances to the next one.

		This method is not required to check `hasNext()` first. A call to this
		method while `hasNext()` is `false` yields unspecified behavior.

		On the other hand, iterators should not require a call to `hasNext()`
		before the first call to `next()` if an element is available.</haxe_doc>
			</next>
			<hasNext set="method">
				<f a=""><x path="Bool"/></f>
				<haxe_doc>Returns `false` if the iteration is complete, `true` otherwise.

		Usually iteration is considered to be complete if all elements of the
		underlying data structure were handled through calls to `next()`. However,
		in custom iterators any logic may be used to determine the completion
		state.</haxe_doc>
			</hasNext>
		</a>
		<haxe_doc>An `Iterator` is a structure that permits iteration over elements of type `T`.

	Any class with matching `hasNext()` and `next()` fields is considered an `Iterator`
	and can then be used e.g. in `for`-loops. This makes it easy to implement
	custom iterators.

	@see https://haxe.org/manual/lf-iterators.html</haxe_doc>
	</typedef>
	<typedef path="Iterable" params="T" file="D:\HaxeToolkit\haxe\std/StdTypes.hx" module="StdTypes">
		<a><iterator set="method"><f a=""><t path="Iterator"><c path="Iterable.T"/></t></f></iterator></a>
		<haxe_doc>An `Iterable` is a data structure which has an `iterator()` method.
	See `Lambda` for generic functions on iterable structures.

	@see https://haxe.org/manual/lf-iterators.html</haxe_doc>
	</typedef>
	<class path="ArrayAccess" params="T" file="D:\HaxeToolkit\haxe\std/StdTypes.hx" module="StdTypes" extern="1" interface="1"><haxe_doc>`ArrayAccess` is used to indicate a class that can be accessed using brackets.
	The type parameter represents the type of the elements stored.

	This interface should be used for externs only. Haxe does not support custom
	array access on classes. However, array access can be implemented for
	abstract types.

	@see https://haxe.org/manual/types-abstract-array-access.html</haxe_doc></class>
	<class path="String" params="" file="D:\HaxeToolkit\haxe\std/neko/_std/String.hx">
		<__is_String static="1"><x path="Bool"/></__is_String>
		<__split expr="neko.Lib.load(&quot;std&quot;, &quot;string_split&quot;, 2)" line="25" static="1">
			<d/>
			<meta><m n=":value"><e>neko.Lib.load("std", "string_split", 2)</e></m></meta>
		</__split>
		<fromCharCode public="1" set="method" line="199" static="1">
			<f a="code">
				<x path="Int"/>
				<c path="String"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Returns the String corresponding to the character code `code`.

		If `code` is negative or has another invalid value, the result is
		unspecified.</haxe_doc>
		</fromCharCode>
		<length public="1" set="null">
			<x path="Int"/>
			<haxe_doc>The number of characters in `this` String.</haxe_doc>
		</length>
		<charAt public="1" set="method" line="42">
			<f a="index">
				<x path="Int"/>
				<c path="String"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Returns the character at position `index` of `this` String.

		If `index` is negative or exceeds `this.length`, the empty String `""`
		is returned.</haxe_doc>
		</charAt>
		<charCodeAt public="1" set="method" line="54">
			<f a="index">
				<x path="Int"/>
				<t path="Null"><x path="Int"/></t>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Returns the character code at position `index` of `this` String.

		If `index` is negative or exceeds `this.length`, `null` is returned.

		To obtain the character code of a single character, `"x".code` can be
		used instead to inline the character code at compile time. Note that
		this only works on String literals of length 1.</haxe_doc>
		</charCodeAt>
		<indexOf public="1" set="method" line="60">
			<f a="str:?startIndex">
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Returns the position of the leftmost occurence of `str` within `this`
		String.

		If `startIndex` is given, the search is performed within the substring
		of `this` String starting from `startIndex`. Otherwise the search is
		performed within `this` String. In either case, the returned position
		is relative to the beginning of `this` String.

		If `str` cannot be found, -1 is returned.</haxe_doc>
		</indexOf>
		<lastIndexOf public="1" set="method" line="69">
			<f a="str:?startIndex">
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Returns the position of the rightmost occurence of `str` within `this`
		String.

		If `startIndex` is given, the search is performed within the substring
		of `this` String from 0 to `startIndex`. Otherwise the search is
		performed within `this` String. In either case, the returned position
		is relative to the beginning of `this` String.

		If `str` cannot be found, -1 is returned.</haxe_doc>
		</lastIndexOf>
		<split public="1" set="method" line="83">
			<f a="delimiter">
				<c path="String"/>
				<c path="Array"><c path="String"/></c>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Splits `this` String at each occurence of `delimiter`.

		If `this` String is the empty String `""`, the result is not consistent
		across targets and may either be `[]` (on Js, Cpp) or `[""]`.

		If `delimiter` is the empty String `""`, `this` String is split into an
		Array of `this.length` elements, where the elements correspond to the
		characters of `this` String.

		If `delimiter` is not found within `this` String, the result is an Array
		with one element, which equals `this` String.

		If `delimiter` is null, the result is unspecified.

		Otherwise, `this` String is split into parts at each occurence of
		`delimiter`. If `this` String starts (or ends) with `delimiter`, the
		result `Array` contains a leading (or trailing) empty String `""` element.
		Two subsequent delimiters also result in an empty String `""` element.</haxe_doc>
		</split>
		<substr public="1" set="method" line="99">
			<f a="pos:?len">
				<x path="Int"/>
				<x path="Int"/>
				<c path="String"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Returns `len` characters of `this` String, starting at position `pos`.

		If `len` is omitted, all characters from position `pos` to the end of
		`this` String are included.

		If `pos` is negative, its value is calculated from the end of `this`
		String by `this.length + pos`. If this yields a negative value, 0 is
		used instead.

		If the calculated position + `len` exceeds `this.length`, the characters
		from that position to the end of `this` String are returned.

		If `len` is negative, the result is unspecified.</haxe_doc>
		</substr>
		<substring public="1" set="method" line="125">
			<f a="startIndex:?endIndex">
				<x path="Int"/>
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the part of `this` String from `startIndex` to but not including `endIndex`.

		If `startIndex` or `endIndex` are negative, 0 is used instead.

		If `startIndex` exceeds `endIndex`, they are swapped.

		If the (possibly swapped) `endIndex` is omitted or exceeds
		`this.length`, `this.length` is used instead.

		If the (possibly swapped) `startIndex` exceeds `this.length`, the empty
		String `""` is returned.</haxe_doc>
		</substring>
		<toLowerCase public="1" set="method" line="149">
			<f a=""><c path="String"/></f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Returns a String where all characters of `this` String are lower case.

		Affects the characters `A-Z`. Other characters remain unchanged.</haxe_doc>
		</toLowerCase>
		<toUpperCase public="1" set="method" line="165">
			<f a=""><c path="String"/></f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Returns a String where all characters of `this` String are upper case.

		Affects the characters `a-z`. Other characters remain unchanged.</haxe_doc>
		</toUpperCase>
		<toString public="1" set="method" line="181">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns the String itself.</haxe_doc>
		</toString>
		<__compare set="method" line="187">
			<f a="o">
				<c path="String"/>
				<x path="Int"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</__compare>
		<__add set="method" line="191">
			<f a="s">
				<d/>
				<c path="String"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</__add>
		<__radd set="method" line="195">
			<f a="s">
				<d/>
				<c path="String"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</__radd>
		<new public="1" set="method" line="33">
			<f a="string">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Creates a copy from a given String.</haxe_doc>
		</new>
		<haxe_doc>The basic String class.

	A Haxe String is immutable, it is not possible to modify individual
	characters. No method of this class changes the state of `this` String.

	Strings can be constructed using the String literal syntax `"string value"`.

	String can be concatenated by using the `+` operator. If an operand is not a
	String, it is passed through `Std.string()` first.
	
	@see https://haxe.org/manual/std-String.html</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":coreApi"/>
			<m n=":final"/>
		</meta>
	</class>
	<class path="StringBuf" params="" file="D:\HaxeToolkit\haxe\std/neko/_std/StringBuf.hx">
		<__make expr="neko.Lib.load(&quot;std&quot;, &quot;buffer_new&quot;, 0)" line="52" static="1">
			<d/>
			<meta><m n=":value"><e>neko.Lib.load("std", "buffer_new", 0)</e></m></meta>
		</__make>
		<__add expr="neko.Lib.load(&quot;std&quot;, &quot;buffer_add&quot;, 2)" line="53" static="1">
			<d/>
			<meta><m n=":value"><e>neko.Lib.load("std", "buffer_add", 2)</e></m></meta>
		</__add>
		<__add_char expr="neko.Lib.load(&quot;std&quot;, &quot;buffer_add_char&quot;, 2)" line="54" static="1">
			<d/>
			<meta><m n=":value"><e>neko.Lib.load("std", "buffer_add_char", 2)</e></m></meta>
		</__add_char>
		<__add_sub expr="neko.Lib.load(&quot;std&quot;, &quot;buffer_add_sub&quot;, 4)" line="55" static="1">
			<d/>
			<meta><m n=":value"><e>neko.Lib.load("std", "buffer_add_sub", 4)</e></m></meta>
		</__add_sub>
		<__to_string expr="neko.Lib.load(&quot;std&quot;, &quot;buffer_string&quot;, 1)" line="56" static="1">
			<d/>
			<meta><m n=":value"><e>neko.Lib.load("std", "buffer_string", 1)</e></m></meta>
		</__to_string>
		<__get_length expr="try neko.Lib.load(&quot;std&quot;, &quot;buffer_get_length&quot;, 1) catch(e:Dynamic) null" line="57" static="1">
			<d/>
			<meta><m n=":value"><e>try neko.Lib.load("std", "buffer_get_length", 1) catch(e:Dynamic) null</e></m></meta>
		</__get_length>
		<b><d/></b>
		<length public="1" get="accessor" set="null">
			<x path="Int"/>
			<haxe_doc>The length of `this` StringBuf in characters.</haxe_doc>
		</length>
		<get_length set="method" line="32">
			<f a=""><x path="Int"/></f>
			<meta><m n=":has_untyped"/></meta>
		</get_length>
		<new public="1" set="method" line="28">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new StringBuf instance.

		This may involve initialization of the internal buffer.</haxe_doc>
		</new>
		<haxe_doc>A String buffer is an efficient way to build a big string by appending small
	elements together.

	Its cross-platform implementation uses String concatenation internally, but
	StringBuf may be optimized for different targets.

	Unlike String, an instance of StringBuf is not immutable in the sense that
	it can be passed as argument to functions which modify it by appending more
	values. However, the internal buffer cannot be modified.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<class path="StringTools" params="" file="D:\HaxeToolkit\haxe\std/StringTools.hx">
		<urlEncode public="1" get="inline" set="null" line="37" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Encode an URL by using the standard format.</haxe_doc>
		</urlEncode>
		<urlDecode public="1" get="inline" set="null" line="107" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Decode an URL using the standard format.</haxe_doc>
		</urlDecode>
		<htmlEscape public="1" set="method" line="153" static="1">
			<f a="s:?quotes">
				<c path="String"/>
				<x path="Bool"/>
				<c path="String"/>
			</f>
			<haxe_doc><![CDATA[Escapes HTML special characters of the string `s`.

		The following replacements are made:

		- `&` becomes `&amp`;
		- `<` becomes `&lt`;
		- `>` becomes `&gt`;

		If `quotes` is true, the following characters are also replaced:

		- `"` becomes `&quot`;
		- `'` becomes `&#039`;]]></haxe_doc>
		</htmlEscape>
		<htmlUnescape public="1" set="method" line="172" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc><![CDATA[Unescapes HTML special characters of the string `s`.

		This is the inverse operation to htmlEscape, i.e. the following always
		holds: `htmlUnescape(htmlEscape(s)) == s`

		The replacements follow:

		- `&amp;` becomes `&`
		- `&lt;` becomes `<`
		- `&gt;` becomes `>`
		- `&quot;` becomes `"`
		- `&#039;` becomes `'`]]></haxe_doc>
		</htmlUnescape>
		<startsWith public="1" set="method" line="183" static="1">
			<f a="s:start">
				<c path="String"/>
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tells if the string `s` starts with the string `start`.

		If `start` is `null`, the result is unspecified.

		If `start` is the empty String `""`, the result is true.</haxe_doc>
		</startsWith>
		<endsWith public="1" set="method" line="211" static="1">
			<f a="s:end">
				<c path="String"/>
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tells if the string `s` ends with the string `end`.

		If `end` is `null`, the result is unspecified.

		If `end` is the empty String `""`, the result is true.</haxe_doc>
		</endsWith>
		<isSpace public="1" set="method" line="245" static="1">
			<f a="s:pos">
				<c path="String"/>
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tells if the character in the string `s` at position `pos` is a space.

		A character is considered to be a space character if its character code
		is 9,10,11,12,13 or 32.

		If `s` is the empty String `""`, or if pos is not a valid position within
		`s`, the result is false.</haxe_doc>
		</isSpace>
		<ltrim public="1" set="method" line="262" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Removes leading space characters of `s`.

		This function internally calls `isSpace()` to decide which characters to
		remove.

		If `s` is the empty String `""` or consists only of space characters, the
		result is the empty String `""`.</haxe_doc>
		</ltrim>
		<rtrim public="1" set="method" line="287" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Removes trailing space characters of `s`.

		This function internally calls `isSpace()` to decide which characters to
		remove.

		If `s` is the empty String `""` or consists only of space characters, the
		result is the empty String `""`.</haxe_doc>
		</rtrim>
		<trim public="1" set="method" line="309" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Removes leading and trailing space characters of `s`.

		This is a convenience function for `ltrim(rtrim(s))`.</haxe_doc>
		</trim>
		<lpad public="1" set="method" line="331" static="1">
			<f a="s:c:l">
				<c path="String"/>
				<c path="String"/>
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Concatenates `c` to `s` until `s.length` is at least `l`.

		If `c` is the empty String `""` or if `l` does not exceed `s.length`,
		`s` is returned unchanged.

		If `c.length` is 1, the resulting String length is exactly `l`.

		Otherwise the length may exceed `l`.

		If `c` is null, the result is unspecified.</haxe_doc>
		</lpad>
		<rpad public="1" set="method" line="353" static="1">
			<f a="s:c:l">
				<c path="String"/>
				<c path="String"/>
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Appends `c` to `s` until `s.length` is at least `l`.

		If `c` is the empty String `""` or if `l` does not exceed `s.length`,
		`s` is returned unchanged.

		If `c.length` is 1, the resulting String length is exactly `l`.

		Otherwise the length may exceed `l`.

		If `c` is null, the result is unspecified.</haxe_doc>
		</rpad>
		<replace public="1" set="method" line="374" static="1">
			<f a="s:sub:by">
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Replace all occurences of the String `sub` in the String `s` by the
		String `by`.

		If `sub` is the empty String `""`, `by` is inserted after each character
		of `s`. If `by` is also the empty String `""`, `s` remains unchanged.

		This is a convenience function for `s.split(sub).join(by)`.

		If `sub` or `by` are null, the result is unspecified.</haxe_doc>
		</replace>
		<hex public="1" set="method" line="396" static="1">
			<f a="n:?digits">
				<x path="Int"/>
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Encodes `n` into a hexadecimal representation.

		If `digits` is specified, the resulting String is padded with "0" until
		its `length` equals `digits`.</haxe_doc>
		</hex>
		<fastCodeAt public="1" get="inline" set="null" line="438" static="1">
			<f a="s:index">
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Returns the character code at position `index` of String `s`, or an
		end-of-file indicator at if `position` equals `s.length`.

		This method is faster than `String.charCodeAt()` on some platforms, but
		the result is unspecified if `index` is negative or greater than
		`s.length`.

		End of file status can be checked by calling `StringTools.isEof()` with
		the returned value as argument.

		This operation is not guaranteed to work if `s` contains the `\0`
		character.</haxe_doc>
		</fastCodeAt>
		<isEof public="1" get="inline" set="null" line="465" static="1">
			<f a="c">
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":noUsing"/></meta>
		</isEof>
		<quoteUnixArg public="1" set="method" line="488" static="1">
			<f a="argument">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns a String that can be used as a single command line argument
		on Unix.
		The input will be quoted, or escaped if necessary.</haxe_doc>
		</quoteUnixArg>
		<winMetaCharacters public="1" expr="[&quot; &quot;.code, &quot;(&quot;.code, &quot;)&quot;.code, &quot;%&quot;.code, &quot;!&quot;.code, &quot;^&quot;.code, &quot;\&quot;&quot;.code, &quot;&lt;&quot;.code, &quot;&gt;&quot;.code, &quot;&amp;&quot;.code, &quot;|&quot;.code, &quot;\n&quot;.code, &quot;\r&quot;.code, &quot;,&quot;.code, &quot;;&quot;.code]" line="506" static="1">
			<c path="Array"><x path="Int"/></c>
			<meta><m n=":value"><e><![CDATA[[" ".code, "(".code, ")".code, "%".code, "!".code, "^".code, "\"".code, "<".code, ">".code, "&".code, "|".code, "\n".code, "\r".code, ",".code, ";".code]]]></e></m></meta>
			<haxe_doc>Character codes of the characters that will be escaped by `quoteWinArg(_, true)`.</haxe_doc>
		</winMetaCharacters>
		<quoteWinArg public="1" set="method" line="521" static="1">
			<f a="argument:escapeMetaCharacters">
				<c path="String"/>
				<x path="Bool"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns a String that can be used as a single command line argument
		on Windows.
		The input will be quoted, or escaped if necessary, such that the output
		will be parsed as a single argument using the rule specified in
		http://msdn.microsoft.com/en-us/library/ms880421

		Examples:
		```
		quoteWinArg("abc") == "abc";
		quoteWinArg("ab c") == '"ab c"';
		```</haxe_doc>
		</quoteWinArg>
		<_urlEncode expr="neko.Lib.load(&quot;std&quot;, &quot;url_encode&quot;, 1)" line="588" static="1">
			<f a="">
				<unknown/>
				<c path="String"/>
			</f>
			<meta><m n=":value"><e>neko.Lib.load("std", "url_encode", 1)</e></m></meta>
		</_urlEncode>
		<_urlDecode expr="neko.Lib.load(&quot;std&quot;, &quot;url_decode&quot;, 1)" line="589" static="1">
			<f a="">
				<unknown/>
				<c path="String"/>
			</f>
			<meta><m n=":value"><e>neko.Lib.load("std", "url_decode", 1)</e></m></meta>
		</_urlDecode>
		<haxe_doc>This class provides advanced methods on Strings. It is ideally used with
	`using StringTools` and then acts as an [extension](https://haxe.org/manual/lf-static-extension.html)
	to the `String` class.

	If the first argument to any of the methods is null, the result is
	unspecified.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="neko.vm.Module" params="" file="D:\HaxeToolkit\haxe\std/neko/vm/Module.hx">
		<local public="1" set="method" line="135" static="1">
			<f a=""><c path="neko.vm.Module"/></f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Returns the local Module, which is the one in which this
		method is included.</haxe_doc>
		</local>
		<_module_name expr="neko.Lib.load(&quot;std&quot;, &quot;module_name&quot;, 1)" line="212" static="1">
			<f a="">
				<e path="neko.vm.ModuleHandle"/>
				<c path="String"/>
			</f>
			<meta><m n=":value"><e>neko.Lib.load("std", "module_name", 1)</e></m></meta>
		</_module_name>
		<m public="1">
			<e path="neko.vm.ModuleHandle"/>
			<haxe_doc>The abstract handle.</haxe_doc>
		</m>
		<name public="1" get="accessor" set="null"><c path="String"/></name>
		<get_name set="method" line="55"><f a=""><c path="String"/></f></get_name>
		<new public="1" set="method" line="42"><f a="m">
	<e path="neko.vm.ModuleHandle"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>A Neko Module represent a execution unit for the Neko Virtual Machine. 
	Each compiled `.n` bytecode file is a module once loaded by the NekoVM.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="sys.FileSystem" params="" file="D:\HaxeToolkit\haxe\std/neko/_std/sys/FileSystem.hx">
		<exists public="1" set="method" line="33" static="1">
			<f a="path">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Tells if the file or directory specified by `path` exists.

		If `path` is null, the result is unspecified.</haxe_doc>
		</exists>
		<fullPath public="1" set="method" line="49" static="1">
			<f a="relPath">
				<c path="String"/>
				<c path="String"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Returns the full path of the file or directory specified by `relPath`,
		which is relative to the current working directory. Symlinks will be
		followed and the path will be normalized.

		If `relPath` is null, the result is unspecified.</haxe_doc>
		</fullPath>
		<createDirectory public="1" set="method" line="71" static="1">
			<f a="path">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Creates a directory specified by `path`.

		This method is recursive: The parent directories don't have to exist.

		If the directory cannot be created, an exception is thrown.

		If `path` is null, the result is unspecified.</haxe_doc>
		</createDirectory>
		<deleteFile public="1" set="method" line="85" static="1">
			<f a="path">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Deletes the file specified by `path`.

		If `path` does not denote a valid file, or if that file cannot be
		deleted, an exception is thrown.

		If `path` is null, the result is unspecified.</haxe_doc>
		</deleteFile>
		<sys_exists expr="neko.Lib.load(&quot;std&quot;, &quot;sys_exists&quot;, 1)" line="111" static="1">
			<f a="">
				<unknown/>
				<x path="Bool"/>
			</f>
			<meta><m n=":value"><e>neko.Lib.load("std", "sys_exists", 1)</e></m></meta>
		</sys_exists>
		<file_delete expr="neko.Lib.load(&quot;std&quot;, &quot;file_delete&quot;, 1)" line="112" static="1">
			<f a="">
				<unknown/>
				<unknown/>
			</f>
			<meta><m n=":value"><e>neko.Lib.load("std", "file_delete", 1)</e></m></meta>
		</file_delete>
		<sys_create_dir expr="neko.Lib.load(&quot;std&quot;, &quot;sys_create_dir&quot;, 2)" line="116" static="1">
			<f a=":">
				<unknown/>
				<x path="Int"/>
				<unknown/>
			</f>
			<meta><m n=":value"><e>neko.Lib.load("std", "sys_create_dir", 2)</e></m></meta>
		</sys_create_dir>
		<file_full_path expr="neko.Lib.load(&quot;std&quot;, &quot;file_full_path&quot;, 1)" line="119" static="1">
			<f a="">
				<unknown/>
				<c path="String"/>
			</f>
			<meta><m n=":value"><e>neko.Lib.load("std", "file_full_path", 1)</e></m></meta>
		</file_full_path>
		<haxe_doc>This class allows you to get information about the files and directories.

	See `sys.io.File` for the complementary file API.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<class path="Sys" params="" file="D:\HaxeToolkit\haxe\std/neko/_std/Sys.hx">
		<print public="1" set="method" line="24" static="1">
			<f a="v">
				<d/>
				<x path="Void"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Print any value on the standard output.</haxe_doc>
		</print>
		<println public="1" set="method" line="28" static="1">
			<f a="v">
				<d/>
				<x path="Void"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Print any value on the standard output, followed by a newline.</haxe_doc>
		</println>
		<getChar public="1" set="method" line="32" static="1">
			<f a="echo">
				<x path="Bool"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Read a single input character from the standard input (without blocking) and returns it. Setting `echo` to true will also display it on the output.</haxe_doc>
		</getChar>
		<stdin public="1" set="method" line="36" static="1">
			<f a=""><c path="haxe.io.Input"/></f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Returns the process standard input, from which you can read what user enters. Usually it will block until the user send a full input line. See `getChar` for an alternative.</haxe_doc>
		</stdin>
		<stdout public="1" set="method" line="40" static="1">
			<f a=""><c path="haxe.io.Output"/></f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Returns the process standard output on which you can write.</haxe_doc>
		</stdout>
		<stderr public="1" set="method" line="44" static="1">
			<f a=""><c path="haxe.io.Output"/></f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Returns the process standard error on which you can write.</haxe_doc>
		</stderr>
		<args public="1" set="method" line="48" static="1">
			<f a=""><c path="Array"><c path="String"/></c></f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Returns all the arguments that were passed by the commandline.</haxe_doc>
		</args>
		<getEnv public="1" set="method" line="63" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Returns the value of the given environment variable.</haxe_doc>
		</getEnv>
		<putEnv public="1" set="method" line="70" static="1">
			<f a="s:v">
				<c path="String"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Set the value of the given environment variable.</haxe_doc>
		</putEnv>
		<sleep public="1" set="method" line="74" static="1">
			<f a="seconds">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Suspend the current execution for the given time (in seconds).</haxe_doc>
		</sleep>
		<setTimeLocale public="1" set="method" line="78" static="1">
			<f a="loc">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Change the current time locale, which will affect `DateTools.format` date formating.
		Returns true if the locale was successfully changed</haxe_doc>
		</setTimeLocale>
		<getCwd public="1" set="method" line="82" static="1">
			<f a=""><c path="String"/></f>
			<haxe_doc>Get the current working directory (usually the one in which the program was started)</haxe_doc>
		</getCwd>
		<setCwd public="1" set="method" line="86" static="1">
			<f a="s">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Change the current working directory.</haxe_doc>
		</setCwd>
		<systemName public="1" set="method" line="90" static="1">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns the name of the system you are running on. For instance :
			"Windows", "Linux", "BSD" and "Mac" depending on your desktop OS.</haxe_doc>
		</systemName>
		<command public="1" set="method" line="94" static="1">
			<f a="cmd:?args">
				<c path="String"/>
				<c path="Array"><c path="String"/></c>
				<x path="Int"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Run the given command. The command output will be printed on the same output as the current process.
		The current process will block until the command terminates and it will return the command result (0 if there was no error).

		Command arguments can be passed in two ways: 1. using `args`, 2. appending to `cmd` and leaving `args` as `null`.

		 1. When using `args` to pass command arguments, each argument will be automatically quoted, and shell meta-characters will be escaped if needed.
		`cmd` should be an executable name that can be located in the `PATH` environment variable, or a path to an executable.

		 2. When `args` is not given or is `null`, command arguments can be appended to `cmd`. No automatic quoting/escaping will be performed. `cmd` should be formatted exactly as it would be when typed at the command line.
		It can run executables, as well as shell commands that are not executables (e.g. on Windows: `dir`, `cd`, `echo` etc).

		Read the `sys.io.Process` api for a more complete way to start background processes.</haxe_doc>
		</command>
		<exit public="1" set="method" line="112" static="1">
			<f a="code">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Exit the current process with the given error code.</haxe_doc>
		</exit>
		<time public="1" set="method" line="116" static="1">
			<f a=""><x path="Float"/></f>
			<haxe_doc>Gives the most precise timestamp value (in seconds).</haxe_doc>
		</time>
		<cpuTime public="1" set="method" line="120" static="1">
			<f a=""><x path="Float"/></f>
			<haxe_doc>Gives the most precise timestamp value (in seconds) but only account for the actual time spent running on the CPU for the current thread/process.</haxe_doc>
		</cpuTime>
		<executablePath public="1" set="method" line="124" static="1">
			<f a=""><c path="String"/></f>
			<meta><m n=":deprecated"><e>"Use programPath instead"</e></m></meta>
			<haxe_doc>Returns the path to the current executable that we are running.</haxe_doc>
		</executablePath>
		<programPath public="1" set="method" line="128" static="1">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns the absolute path to the current program file that we are running.
		Concretely, for an executable binary, it returns the path to the binary.
		For a script (e.g. a PHP file), it returns the path to the script.</haxe_doc>
		</programPath>
		<environment public="1" set="method" line="138" static="1">
			<f a=""><x path="Map">
	<c path="String"/>
	<c path="String"/>
</x></f>
			<haxe_doc>Returns the whole environement variables.</haxe_doc>
		</environment>
		<get_env expr="neko.Lib.load(&quot;std&quot;, &quot;get_env&quot;, 1)" line="148" static="1">
			<f a="">
				<unknown/>
				<c path="String"/>
			</f>
			<meta><m n=":value"><e>neko.Lib.load("std", "get_env", 1)</e></m></meta>
		</get_env>
		<put_env expr="neko.Lib.load(&quot;std&quot;, &quot;put_env&quot;, 2)" line="149" static="1">
			<f a=":">
				<unknown/>
				<t path="Null"><unknown/></t>
				<unknown/>
			</f>
			<meta><m n=":value"><e>neko.Lib.load("std", "put_env", 2)</e></m></meta>
		</put_env>
		<_sleep expr="neko.Lib.load(&quot;std&quot;, &quot;sys_sleep&quot;, 1)" line="150" static="1">
			<f a="">
				<x path="Float"/>
				<unknown/>
			</f>
			<meta><m n=":value"><e>neko.Lib.load("std", "sys_sleep", 1)</e></m></meta>
		</_sleep>
		<set_time_locale expr="neko.Lib.load(&quot;std&quot;, &quot;set_time_locale&quot;, 1)" line="151" static="1">
			<f a="">
				<unknown/>
				<x path="Bool"/>
			</f>
			<meta><m n=":value"><e>neko.Lib.load("std", "set_time_locale", 1)</e></m></meta>
		</set_time_locale>
		<get_cwd expr="neko.Lib.load(&quot;std&quot;, &quot;get_cwd&quot;, 0)" line="152" static="1">
			<f a=""><c path="String"/></f>
			<meta><m n=":value"><e>neko.Lib.load("std", "get_cwd", 0)</e></m></meta>
		</get_cwd>
		<set_cwd expr="neko.Lib.load(&quot;std&quot;, &quot;set_cwd&quot;, 1)" line="153" static="1">
			<f a="">
				<unknown/>
				<unknown/>
			</f>
			<meta><m n=":value"><e>neko.Lib.load("std", "set_cwd", 1)</e></m></meta>
		</set_cwd>
		<sys_string expr="neko.Lib.load(&quot;std&quot;, &quot;sys_string&quot;, 0)" line="154" static="1">
			<f a=""><c path="String"/></f>
			<meta><m n=":value"><e>neko.Lib.load("std", "sys_string", 0)</e></m></meta>
		</sys_string>
		<sys_command expr="neko.Lib.load(&quot;std&quot;, &quot;sys_command&quot;, 1)" line="155" static="1">
			<f a="">
				<unknown/>
				<x path="Int"/>
			</f>
			<meta><m n=":value"><e>neko.Lib.load("std", "sys_command", 1)</e></m></meta>
		</sys_command>
		<sys_exit expr="neko.Lib.load(&quot;std&quot;, &quot;sys_exit&quot;, 1)" line="156" static="1">
			<f a="">
				<x path="Int"/>
				<unknown/>
			</f>
			<meta><m n=":value"><e>neko.Lib.load("std", "sys_exit", 1)</e></m></meta>
		</sys_exit>
		<sys_time expr="neko.Lib.load(&quot;std&quot;, &quot;sys_time&quot;, 0)" line="157" static="1">
			<f a=""><x path="Float"/></f>
			<meta><m n=":value"><e>neko.Lib.load("std", "sys_time", 0)</e></m></meta>
		</sys_time>
		<sys_cpu_time expr="neko.Lib.load(&quot;std&quot;, &quot;sys_cpu_time&quot;, 0)" line="158" static="1">
			<f a=""><x path="Float"/></f>
			<meta><m n=":value"><e>neko.Lib.load("std", "sys_cpu_time", 0)</e></m></meta>
		</sys_cpu_time>
		<sys_exe_path expr="neko.Lib.load(&quot;std&quot;, &quot;sys_exe_path&quot;, 0)" line="159" static="1">
			<f a=""><c path="String"/></f>
			<meta><m n=":value"><e>neko.Lib.load("std", "sys_exe_path", 0)</e></m></meta>
		</sys_exe_path>
		<sys_program_path expr="{
	var m = neko.vm.Module.local().name;
	try {
		sys.FileSystem.fullPath(m);
	} catch(e:Dynamic) {
		if (!StringTools.endsWith(m, &quot;.n&quot;)) {
			try {
				sys.FileSystem.fullPath(m + &quot;.n&quot;);
			} catch(e:Dynamic) {
				m;
			};
		} else {
			m;
		};
	};
}" line="164" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>{
	var m = neko.vm.Module.local().name;
	try {
		sys.FileSystem.fullPath(m);
	} catch(e:Dynamic) {
		if (!StringTools.endsWith(m, ".n")) {
			try {
				sys.FileSystem.fullPath(m + ".n");
			} catch(e:Dynamic) {
				m;
			};
		} else {
			m;
		};
	};
}</e></m></meta>
		</sys_program_path>
		<sys_env expr="neko.Lib.load(&quot;std&quot;, &quot;sys_env&quot;, 0)" line="182" static="1">
			<f a=""><c path="Array"><d/></c></f>
			<meta><m n=":value"><e>neko.Lib.load("std", "sys_env", 0)</e></m></meta>
		</sys_env>
		<file_stdin expr="neko.Lib.load(&quot;std&quot;, &quot;file_stdin&quot;, 0)" line="184" static="1">
			<f a=""><e path="sys.io.FileHandle"/></f>
			<meta><m n=":value"><e>neko.Lib.load("std", "file_stdin", 0)</e></m></meta>
		</file_stdin>
		<file_stdout expr="neko.Lib.load(&quot;std&quot;, &quot;file_stdout&quot;, 0)" line="185" static="1">
			<f a=""><e path="sys.io.FileHandle"/></f>
			<meta><m n=":value"><e>neko.Lib.load("std", "file_stdout", 0)</e></m></meta>
		</file_stdout>
		<file_stderr expr="neko.Lib.load(&quot;std&quot;, &quot;file_stderr&quot;, 0)" line="186" static="1">
			<f a=""><e path="sys.io.FileHandle"/></f>
			<meta><m n=":value"><e>neko.Lib.load("std", "file_stderr", 0)</e></m></meta>
		</file_stderr>
		<getch expr="neko.Lib.load(&quot;std&quot;, &quot;sys_getch&quot;, 1)" line="187" static="1">
			<f a="">
				<x path="Bool"/>
				<x path="Int"/>
			</f>
			<meta><m n=":value"><e>neko.Lib.load("std", "sys_getch", 1)</e></m></meta>
		</getch>
		<haxe_doc>This class gives you access to many base functionalities of system platforms. Looks in `sys` sub packages for more system APIs.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<enum path="ValueType" params="" file="D:\HaxeToolkit\haxe\std/neko/_std/Type.hx" module="Type">
		<TNull/>
		<TInt/>
		<TFloat/>
		<TBool/>
		<TObject/>
		<TFunction/>
		<TClass a="c"><x path="Class"><d/></x></TClass>
		<TEnum a="e"><x path="Enum"><d/></x></TEnum>
		<TUnknown/>
		<meta><m n=":directlyUsed"/></meta>
	</enum>
	<class path="Type" params="" file="D:\HaxeToolkit\haxe\std/neko/_std/Type.hx">
		<getClass public="1" params="T" set="method" line="37" static="1">
			<f a="o">
				<c path="getClass.T"/>
				<x path="Class"><c path="getClass.T"/></x>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Returns the class of `o`, if `o` is a class instance.

		If `o` is null or of a different type, null is returned.

		In general, type parameter information cannot be obtained at runtime.</haxe_doc>
		</getClass>
		<getEnum public="1" set="method" line="46" static="1">
			<f a="o">
				<x path="EnumValue"/>
				<x path="Enum"><d/></x>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc><![CDATA[Returns the enum of enum instance `o`.

		An enum instance is the result of using an enum constructor. Given an
		`enum Color { Red; }`, `getEnum(Red)` returns `Enum<Color>`.

		If `o` is null, null is returned.

		In general, type parameter information cannot be obtained at runtime.]]></haxe_doc>
		</getEnum>
		<getSuperClass public="1" set="method" line="53" static="1">
			<f a="c">
				<x path="Class"><d/></x>
				<x path="Class"><d/></x>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Returns the super-class of class `c`.

		If `c` has no super class, null is returned.

		If `c` is null, the result is unspecified.

		In general, type parameter information cannot be obtained at runtime.</haxe_doc>
		</getSuperClass>
		<getClassName public="1" set="method" line="58" static="1">
			<f a="c">
				<x path="Class"><d/></x>
				<c path="String"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Returns the name of class `c`, including its path.

		If `c` is inside a package, the package structure is returned dot-
		separated, with another dot separating the class name:
		`pack1.pack2.(...).packN.ClassName`
		If `c` is a sub-type of a Haxe module, that module is not part of the
		package structure.

		If `c` has no package, the class name is returned.

		If `c` is null, the result is unspecified.

		The class name does not include any type parameters.</haxe_doc>
		</getClassName>
		<getEnumName public="1" set="method" line="65" static="1">
			<f a="e">
				<x path="Enum"><d/></x>
				<c path="String"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Returns the name of enum `e`, including its path.

		If `e` is inside a package, the package structure is returned dot-
		separated, with another dot separating the enum name:
		`pack1.pack2.(...).packN.EnumName`
		If `e` is a sub-type of a Haxe module, that module is not part of the
		package structure.

		If `e` has no package, the enum name is returned.

		If `e` is null, the result is unspecified.

		The enum name does not include any type parameters.</haxe_doc>
		</getEnumName>
		<resolveClass public="1" set="method" line="70" static="1">
			<f a="name">
				<c path="String"/>
				<x path="Class"><d/></x>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Resolves a class by name.

		If `name` is the path of an existing class, that class is returned.

		Otherwise null is returned.

		If `name` is null or the path to a different type, the result is
		unspecified.

		The class name must not include any type parameters.</haxe_doc>
		</resolveClass>
		<resolveEnum public="1" set="method" line="85" static="1">
			<f a="name">
				<c path="String"/>
				<x path="Enum"><d/></x>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Resolves an enum by name.

		If `name` is the path of an existing enum, that enum is returned.

		Otherwise null is returned.

		If `name` is null the result is unspecified.

		If `name` is the path to a different type, null is returned.

		The enum name must not include any type parameters.</haxe_doc>
		</resolveEnum>
		<createInstance public="1" params="T" set="method" line="99" static="1">
			<f a="cl:args">
				<x path="Class"><c path="createInstance.T"/></x>
				<c path="Array"><d/></c>
				<c path="createInstance.T"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Creates an instance of class `cl`, using `args` as arguments to the
		class constructor.

		This function guarantees that the class constructor is called.

		Default values of constructors arguments are not guaranteed to be
		taken into account.

		If `cl` or `args` are null, or if the number of elements in `args` does
		not match the expected number of constructor arguments, or if any
		argument has an invalid type,  or if `cl` has no own constructor, the
		result is unspecified.

		In particular, default values of constructor arguments are not
		guaranteed to be taken into account.</haxe_doc>
		</createInstance>
		<createEmptyInstance public="1" params="T" set="method" line="112" static="1">
			<f a="cl">
				<x path="Class"><c path="createEmptyInstance.T"/></x>
				<c path="createEmptyInstance.T"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Creates an instance of class `cl`.

		This function guarantees that the class constructor is not called.

		If `cl` is null, the result is unspecified.</haxe_doc>
		</createEmptyInstance>
		<createEnum public="1" params="T" set="method" line="118" static="1">
			<f a="e:constr:?params">
				<x path="Enum"><c path="createEnum.T"/></x>
				<c path="String"/>
				<c path="Array"><d/></c>
				<c path="createEnum.T"/>
			</f>
			<haxe_doc>Creates an instance of enum `e` by calling its constructor `constr` with
		arguments `params`.

		If `e` or `constr` is null, or if enum `e` has no constructor named
		`constr`, or if the number of elements in `params` does not match the
		expected number of constructor arguments, or if any argument has an
		invalid type, the result is unspecified.</haxe_doc>
		</createEnum>
		<createEnumIndex public="1" params="T" set="method" line="130" static="1">
			<f a="e:index:?params">
				<x path="Enum"><c path="createEnumIndex.T"/></x>
				<x path="Int"/>
				<c path="Array"><d/></c>
				<c path="createEnumIndex.T"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Creates an instance of enum `e` by calling its constructor number
		`index` with arguments `params`.

		The constructor indices are preserved from Haxe syntax, so the first
		declared is index 0, the next index 1 etc.

		If `e` or `constr` is null, or if enum `e` has no constructor named
		`constr`, or if the number of elements in `params` does not match the
		expected number of constructor arguments, or if any argument has an
		invalid type, the result is unspecified.</haxe_doc>
		</createEnumIndex>
		<getInstanceFields public="1" set="method" line="136" static="1">
			<f a="c">
				<x path="Class"><d/></x>
				<c path="Array"><c path="String"/></c>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Returns a list of the instance fields of class `c`.

		This only includes fields which are known at compile-time. In
		particular, using getInstanceFields(getClass(obj)) will not include
		any fields which were added to obj at runtime.

		The order of the fields in the returned Array is unspecified.

		If `c` is null, the result is unspecified.

		(As3) This method only returns instance fields that are public.</haxe_doc>
		</getInstanceFields>
		<getClassFields public="1" set="method" line="153" static="1">
			<f a="c">
				<x path="Class"><d/></x>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>Returns a list of static fields of class `c`.

		This does not include static fields of parent classes.

		The order of the fields in the returned Array is unspecified.

		If `c` is null, the result is unspecified.

		(As3) This method only returns class fields that are public.</haxe_doc>
		</getClassFields>
		<getEnumConstructs public="1" set="method" line="169" static="1">
			<f a="e">
				<x path="Enum"><d/></x>
				<c path="Array"><c path="String"/></c>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Returns a list of the names of all constructors of enum `e`.

		The order of the constructor names in the returned Array is preserved
		from the original syntax.

		If `c` is null, the result is unspecified.</haxe_doc>
		</getEnumConstructs>
		<typeof public="1" set="method" line="174" static="1">
			<f a="v">
				<d/>
				<e path="ValueType"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Returns the runtime type of value `v`.

		The result corresponds to the type `v` has at runtime, which may vary
		per platform. Assumptions regarding this should be minimized to avoid
		surprises.</haxe_doc>
		</typeof>
		<enumEq public="1" params="T" set="method" line="196" static="1">
			<f a="a:b">
				<c path="enumEq.T"/>
				<c path="enumEq.T"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Recursively compares two enum instances `a` and `b` by value.

		Unlike `a == b`, this function performs a deep equality check on the
		arguments of the constructors, if exists.

		If `a` or `b` are null, the result is unspecified.</haxe_doc>
		</enumEq>
		<enumConstructor public="1" set="method" line="211" static="1">
			<f a="e">
				<x path="EnumValue"/>
				<c path="String"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Returns the constructor name of enum instance `e`.

		The result String does not contain any constructor arguments.

		If `e` is null, the result is unspecified.</haxe_doc>
		</enumConstructor>
		<enumParameters public="1" set="method" line="215" static="1">
			<f a="e">
				<x path="EnumValue"/>
				<c path="Array"><d/></c>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Returns a list of the constructor arguments of enum instance `e`.

		If `e` has no arguments, the result is [].

		Otherwise the result are the values that were used as arguments to `e`,
		in the order of their declaration.

		If `e` is null, the result is unspecified.</haxe_doc>
		</enumParameters>
		<enumIndex public="1" get="inline" set="null" line="219" static="1">
			<f a="e">
				<x path="EnumValue"/>
				<x path="Int"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Returns the index of enum instance `e`.

		This corresponds to the original syntactic position of `e`. The index of
		the first declared constructor is 0, the next one is 1 etc.

		If `e` is null, the result is unspecified.</haxe_doc>
		</enumIndex>
		<allEnums public="1" params="T" set="method" line="223" static="1">
			<f a="e">
				<x path="Enum"><c path="allEnums.T"/></x>
				<c path="Array"><c path="allEnums.T"/></c>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Returns a list of all constructors of enum `e` that require no
		arguments.

		This may return the empty Array `[]` if all constructors of `e` require
		arguments.

		Otherwise an instance of `e` constructed through each of its non-
		argument constructors is returned, in the order of the constructor
		declaration.

		If `e` is null, the result is unspecified.</haxe_doc>
		</allEnums>
		<haxe_doc>The Haxe Reflection API allows retrieval of type information at runtime.

	This class complements the more lightweight Reflect class, with a focus on
	class and enum instances.

	@see https://haxe.org/manual/types.html
	@see https://haxe.org/manual/std-reflection.html</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<abstract path="UInt" params="" file="D:\HaxeToolkit\haxe\std/UInt.hx">
		<from><icast><x path="Int"/></icast></from>
		<this><x path="Int"/></this>
		<to>
			<icast><x path="Int"/></icast>
			<icast field="toFloat"><x path="Float"/></icast>
		</to>
		<haxe_doc>The unsigned `Int` type is only defined for Flash and C#.
	Simulate it for other platforms.

	@see https://haxe.org/manual/types-basic-types.html</haxe_doc>
		<impl><class path="_UInt.UInt_Impl_" params="" file="D:\HaxeToolkit\haxe\std/UInt.hx" private="1" module="UInt"><meta>
	<m n=":keep"/>
	<m n=":final"/>
</meta></class></impl>
	</abstract>
	<abstract path="XmlType" params="" file="D:\HaxeToolkit\haxe\std/Xml.hx" module="Xml">
		<this><x path="Int"/></this>
		<haxe_doc>Xml node types.

	@see https://haxe.org/manual/std-Xml.html</haxe_doc>
		<meta><m n=":enum"/></meta>
		<impl><class path="_Xml.XmlType_Impl_" params="" file="D:\HaxeToolkit\haxe\std/Xml.hx" private="1" module="Xml"><meta>
	<m n=":keep"/>
	<m n=":final"/>
	<m n=":enum"/>
</meta></class></impl>
	</abstract>
	<class path="Xml" params="" file="D:\HaxeToolkit\haxe\std/Xml.hx">
		<Element public="1" set="null" expr="XmlType.Element" line="68" static="1">
			<x path="XmlType"/>
			<meta><m n=":value"><e>XmlType.Element</e></m></meta>
			<haxe_doc>XML element type.</haxe_doc>
		</Element>
		<PCData public="1" set="null" expr="XmlType.PCData" line="72" static="1">
			<x path="XmlType"/>
			<meta><m n=":value"><e>XmlType.PCData</e></m></meta>
			<haxe_doc>XML parsed character data type.</haxe_doc>
		</PCData>
		<CData public="1" set="null" expr="XmlType.CData" line="76" static="1">
			<x path="XmlType"/>
			<meta><m n=":value"><e>XmlType.CData</e></m></meta>
			<haxe_doc>XML character data type.</haxe_doc>
		</CData>
		<Comment public="1" set="null" expr="XmlType.Comment" line="80" static="1">
			<x path="XmlType"/>
			<meta><m n=":value"><e>XmlType.Comment</e></m></meta>
			<haxe_doc>XML comment type.</haxe_doc>
		</Comment>
		<DocType public="1" set="null" expr="XmlType.DocType" line="84" static="1">
			<x path="XmlType"/>
			<meta><m n=":value"><e>XmlType.DocType</e></m></meta>
			<haxe_doc>XML doctype element type.</haxe_doc>
		</DocType>
		<ProcessingInstruction public="1" set="null" expr="XmlType.ProcessingInstruction" line="88" static="1">
			<x path="XmlType"/>
			<meta><m n=":value"><e>XmlType.ProcessingInstruction</e></m></meta>
			<haxe_doc>XML processing instruction type.</haxe_doc>
		</ProcessingInstruction>
		<Document public="1" set="null" expr="XmlType.Document" line="92" static="1">
			<x path="XmlType"/>
			<meta><m n=":value"><e>XmlType.Document</e></m></meta>
			<haxe_doc>XML document type.</haxe_doc>
		</Document>
		<parse public="1" set="method" line="97" static="1">
			<f a="str">
				<c path="String"/>
				<c path="Xml"/>
			</f>
			<haxe_doc>Parses the String into an Xml document.</haxe_doc>
		</parse>
		<createElement public="1" set="method" line="158" static="1">
			<f a="name">
				<c path="String"/>
				<c path="Xml"/>
			</f>
			<haxe_doc>Creates a node of the given type.</haxe_doc>
		</createElement>
		<createPCData public="1" set="method" line="167" static="1">
			<f a="data">
				<c path="String"/>
				<c path="Xml"/>
			</f>
			<haxe_doc>Creates a node of the given type.</haxe_doc>
		</createPCData>
		<createCData public="1" set="method" line="176" static="1">
			<f a="data">
				<c path="String"/>
				<c path="Xml"/>
			</f>
			<haxe_doc>Creates a node of the given type.</haxe_doc>
		</createCData>
		<createComment public="1" set="method" line="185" static="1">
			<f a="data">
				<c path="String"/>
				<c path="Xml"/>
			</f>
			<haxe_doc>Creates a node of the given type.</haxe_doc>
		</createComment>
		<createDocType public="1" set="method" line="194" static="1">
			<f a="data">
				<c path="String"/>
				<c path="Xml"/>
			</f>
			<haxe_doc>Creates a node of the given type.</haxe_doc>
		</createDocType>
		<createProcessingInstruction public="1" set="method" line="203" static="1">
			<f a="data">
				<c path="String"/>
				<c path="Xml"/>
			</f>
			<haxe_doc>Creates a node of the given type.</haxe_doc>
		</createProcessingInstruction>
		<createDocument public="1" set="method" line="212" static="1">
			<f a=""><c path="Xml"/></f>
			<haxe_doc>Creates a node of the given type.</haxe_doc>
		</createDocument>
		<nodeType public="1" set="null">
			<x path="XmlType"/>
			<haxe_doc>Returns the type of the Xml Node. This should be used before
		accessing other functions since some might raise an exception
		if the node type is not correct.</haxe_doc>
		</nodeType>
		<nodeName public="1" get="null" set="null">
			<c path="String"/>
			<meta><m n=":isVar"/></meta>
			<haxe_doc>Returns the node name of an Element.</haxe_doc>
		</nodeName>
		<nodeValue public="1" get="null" set="null">
			<c path="String"/>
			<meta><m n=":isVar"/></meta>
			<haxe_doc>Returns the node value. Only works if the Xml node is not an Element or a Document.</haxe_doc>
		</nodeValue>
		<parent public="1" set="null">
			<c path="Xml"/>
			<haxe_doc>Returns the parent object in the Xml hierarchy.
		The parent can be `null`, an Element or a Document.</haxe_doc>
		</parent>
		<children><c path="Array"><c path="Xml"/></c></children>
		<attributeMap><x path="Map">
	<c path="String"/>
	<c path="String"/>
</x></attributeMap>
		<get public="1" set="method" line="220">
			<f a="att">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Get the given attribute of an Element node. Returns `null` if not found.
		Attributes are case-sensitive.</haxe_doc>
		</get>
		<set public="1" set="method" line="231">
			<f a="att:value">
				<c path="String"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Set the given attribute value for an Element node.
		Attributes are case-sensitive.</haxe_doc>
		</set>
		<exists public="1" set="method" line="253">
			<f a="att">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tells if the Element node has a given attribute.
		Attributes are case-sensitive.</haxe_doc>
		</exists>
		<elements public="1" set="method" line="283">
			<f a=""><t path="Iterator"><c path="Xml"/></t></f>
			<haxe_doc>Returns an iterator of all child nodes which are Elements.
		Only works if the current node is an Element or a Document.</haxe_doc>
		</elements>
		<elementsNamed public="1" set="method" line="293">
			<f a="name">
				<c path="String"/>
				<t path="Iterator"><c path="Xml"/></t>
			</f>
			<haxe_doc>Returns an iterator of all child nodes which are Elements with the given nodeName.
		Only works if the current node is an Element or a Document.</haxe_doc>
		</elementsNamed>
		<firstElement public="1" set="method" line="310">
			<f a=""><c path="Xml"/></f>
			<haxe_doc>Returns the first child node which is an Element.</haxe_doc>
		</firstElement>
		<addChild public="1" set="method" line="326">
			<f a="x">
				<c path="Xml"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Adds a child node to the Document or Element.
		A child node can only be inside one given parent node, which is indicated by the `parent` property.
		If the child is already inside this Document or Element, it will be moved to the last position among the Document or Element's children.
		If the child node was previously inside a different node, it will be moved to this Document or Element.</haxe_doc>
		</addChild>
		<removeChild public="1" set="method" line="339">
			<f a="x">
				<c path="Xml"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Removes a child from the Document or Element.
		Returns true if the child was successfuly removed.</haxe_doc>
		</removeChild>
		<new set="method" line="370"><f a="nodeType">
	<x path="XmlType"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>Crossplatform Xml API.

	@see https://haxe.org/manual/std-Xml.html</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<typedef path="cpp.CallableData" params="T" file="D:\HaxeToolkit\haxe\std/cpp/Callable.hx" module="cpp.Callable">
		<c path="cpp.CallableData.T"/>
		<meta>
			<m n=":noPackageRestrict"/>
			<m n=":callable"/>
		</meta>
	</typedef>
	<abstract path="cpp.Callable" params="T" file="D:\HaxeToolkit\haxe\std/cpp/Callable.hx">
		<this><t path="cpp.CallableData"><c path="cpp.Callable.T"/></t></this>
		<meta>
			<m n=":noPackageRestrict"/>
			<m n=":callable"/>
		</meta>
		<impl><class path="cpp._Callable.Callable_Impl_" params="" file="D:\HaxeToolkit\haxe\std/cpp/Callable.hx" private="1" module="cpp.Callable">
	<call public="1" get="accessor" set="null" static="1">
		<c path="cpp.Callable.T"/>
		<meta><m n=":impl"/></meta>
	</call>
	<meta>
		<m n=":keep"/>
		<m n=":final"/>
	</meta>
</class></impl>
	</abstract>
	<typedef path="flash.Lib" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/Lib.hx"><c path="openfl.Lib"/></typedef>
	<typedef path="flash.display.Bitmap" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/display/Bitmap.hx"><c path="openfl.display.Bitmap"/></typedef>
	<typedef path="flash.display.BitmapData" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/display/BitmapData.hx"><c path="openfl.display.BitmapData"/></typedef>
	<typedef path="flash.display.TextureUvs" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/display/BitmapData.hx" module="flash.display.BitmapData"><c path="openfl.display.TextureUvs"/></typedef>
	<typedef path="flash.display.BitmapDataChannel" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/display/BitmapDataChannel.hx"><x path="openfl.display.BitmapDataChannel"/></typedef>
	<typedef path="flash.display.BlendMode" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/display/BlendMode.hx"><x path="openfl.display.BlendMode"/></typedef>
	<typedef path="flash.display.CapsStyle" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/display/CapsStyle.hx"><x path="openfl.display.CapsStyle"/></typedef>
	<typedef path="flash.display.DisplayObject" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/display/DisplayObject.hx"><c path="openfl.display.DisplayObject"/></typedef>
	<typedef path="flash.display.DisplayObjectContainer" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/display/DisplayObjectContainer.hx"><c path="openfl.display.DisplayObjectContainer"/></typedef>
	<typedef path="flash.display.GradientType" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/display/GradientType.hx"><x path="openfl.display.GradientType"/></typedef>
	<typedef path="flash.display.Graphics" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/display/Graphics.hx"><c path="openfl.display.Graphics"/></typedef>
	<typedef path="flash.display.InterpolationMethod" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/display/InterpolationMethod.hx"><x path="openfl.display.InterpolationMethod"/></typedef>
	<typedef path="flash.display.JointStyle" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/display/JointStyle.hx"><x path="openfl.display.JointStyle"/></typedef>
	<typedef path="flash.display.LineScaleMode" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/display/LineScaleMode.hx"><x path="openfl.display.LineScaleMode"/></typedef>
	<typedef path="flash.display.Shape" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/display/Shape.hx"><c path="openfl.display.Shape"/></typedef>
	<typedef path="flash.display.SpreadMethod" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/display/SpreadMethod.hx"><x path="openfl.display.SpreadMethod"/></typedef>
	<typedef path="flash.display.Sprite" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/display/Sprite.hx"><c path="openfl.display.Sprite"/></typedef>
	<typedef path="flash.display.Stage" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/display/Stage.hx"><c path="openfl.display.Stage"/></typedef>
	<typedef path="flash.display.StageAlign" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/display/StageAlign.hx"><x path="openfl.display.StageAlign"/></typedef>
	<typedef path="flash.display.StageDisplayState" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/display/StageDisplayState.hx"><x path="openfl.display.StageDisplayState"/></typedef>
	<typedef path="flash.display.StageScaleMode" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/display/StageScaleMode.hx"><x path="openfl.display.StageScaleMode"/></typedef>
	<typedef path="flash.errors.Error" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/errors/Error.hx"><c path="openfl.errors.Error"/></typedef>
	<typedef path="flash.events.Event" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/events/Event.hx"><c path="openfl.events.Event"/></typedef>
	<typedef path="flash.events.GameInputEvent" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/events/GameInputEvent.hx"><c path="openfl.events.GameInputEvent"/></typedef>
	<typedef path="flash.events.KeyboardEvent" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/events/KeyboardEvent.hx"><c path="openfl.events.KeyboardEvent"/></typedef>
	<typedef path="flash.events.MouseEvent" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/events/MouseEvent.hx"><c path="openfl.events.MouseEvent"/></typedef>
	<typedef path="flash.events.TouchEvent" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/events/TouchEvent.hx"><c path="openfl.events.TouchEvent"/></typedef>
	<typedef path="flash.geom.ColorTransform" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/geom/ColorTransform.hx"><c path="openfl.geom.ColorTransform"/></typedef>
	<typedef path="flash.geom.Matrix" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/geom/Matrix.hx"><c path="openfl.geom.Matrix"/></typedef>
	<typedef path="flash.geom.Point" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/geom/Point.hx"><c path="openfl.geom.Point"/></typedef>
	<typedef path="flash.geom.Rectangle" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/geom/Rectangle.hx"><c path="openfl.geom.Rectangle"/></typedef>
	<typedef path="flash.media.Sound" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/media/Sound.hx"><c path="openfl.media.Sound"/></typedef>
	<typedef path="flash.media.SoundChannel" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/media/SoundChannel.hx"><c path="openfl.media.SoundChannel"/></typedef>
	<typedef path="flash.media.SoundTransform" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/media/SoundTransform.hx"><c path="openfl.media.SoundTransform"/></typedef>
	<typedef path="flash.net.SharedObject" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/net/SharedObject.hx"><c path="openfl.net.SharedObject"/></typedef>
	<typedef path="flash.net.SharedObjectFlushStatus" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/net/SharedObjectFlushStatus.hx"><x path="openfl.net.SharedObjectFlushStatus"/></typedef>
	<typedef path="flash.net.URLRequest" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/net/URLRequest.hx"><c path="openfl.net.URLRequest"/></typedef>
	<typedef path="flash.system.System" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/system/System.hx"><c path="openfl.system.System"/></typedef>
	<typedef path="flash.text.TextField" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/text/TextField.hx"><c path="openfl.text.TextField"/></typedef>
	<typedef path="flash.text.TextFieldAutoSize" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/text/TextFieldAutoSize.hx"><x path="openfl.text.TextFieldAutoSize"/></typedef>
	<typedef path="flash.text.TextFormat" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/text/TextFormat.hx"><c path="openfl.text.TextFormat"/></typedef>
	<typedef path="flash.text.TextFormatAlign" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/text/TextFormatAlign.hx"><x path="openfl.text.TextFormatAlign"/></typedef>
	<typedef path="flash.ui.GameInput" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/ui/GameInput.hx"><c path="openfl.ui.GameInput"/></typedef>
	<typedef path="flash.ui.GameInputControl" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/ui/GameInputControl.hx"><c path="openfl.ui.GameInputControl"/></typedef>
	<typedef path="flash.ui.GameInputDevice" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/ui/GameInputDevice.hx"><c path="openfl.ui.GameInputDevice"/></typedef>
	<typedef path="flash.ui.Keyboard" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/ui/Keyboard.hx"><c path="openfl.ui.Keyboard"/></typedef>
	<typedef path="flash.ui.Mouse" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/ui/Mouse.hx"><c path="openfl.ui.Mouse"/></typedef>
	<typedef path="flash.ui.Multitouch" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/ui/Multitouch.hx"><c path="openfl.ui.Multitouch"/></typedef>
	<typedef path="flash.ui.MultitouchInputMode" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/ui/MultitouchInputMode.hx"><x path="openfl.ui.MultitouchInputMode"/></typedef>
	<class path="flixel.util.IFlxDestroyable" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/util/FlxDestroyUtil.hx" module="flixel.util.FlxDestroyUtil" interface="1"><destroy public="1" set="method"><f a=""><x path="Void"/></f></destroy></class>
	<class path="flixel.FlxBasic" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/FlxBasic.hx">
		<implements path="flixel.util.IFlxDestroyable"/>
		<activeCount expr="0" line="17" static="1">
			<x path="Int"/>
			<meta>
				<m n=":value"><e>0</e></m>
				<m n=":allow"><e>flixel.FlxGame</e></m>
			</meta>
			<haxe_doc>* Static counters for performance tracking.</haxe_doc>
		</activeCount>
		<visibleCount expr="0" line="19" static="1">
			<x path="Int"/>
			<meta>
				<m n=":value"><e>0</e></m>
				<m n=":allow"><e>flixel.FlxGame</e></m>
			</meta>
		</visibleCount>
		<ID public="1" expr="-1">
			<x path="Int"/>
			<meta><m n=":value"><e>-1</e></m></meta>
			<haxe_doc>* IDs seem like they could be pretty useful, huh?
	 * They're not actually used for anything yet though.</haxe_doc>
		</ID>
		<active public="1" set="accessor" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
			<haxe_doc>* Controls whether `update()` is automatically called by `FlxState`/`FlxGroup`.</haxe_doc>
		</active>
		<visible public="1" set="accessor" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
			<haxe_doc>* Controls whether `draw()` is automatically called by `FlxState`/`FlxGroup`.</haxe_doc>
		</visible>
		<alive public="1" set="accessor" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
			<haxe_doc>* Useful state for many game objects - "dead" (`!alive`) vs `alive`. `kill()` and
	 * `revive()` both flip this switch (along with `exists`, but you can override that).</haxe_doc>
		</alive>
		<exists public="1" set="accessor" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
			<haxe_doc>* Controls whether `update()` and `draw()` are automatically called by `FlxState`/`FlxGroup`.</haxe_doc>
		</exists>
		<camera public="1" get="accessor" set="accessor">
			<c path="flixel.FlxCamera"/>
			<haxe_doc>* Gets ot sets the first camera of this object.</haxe_doc>
		</camera>
		<cameras public="1" get="accessor" set="accessor">
			<c path="Array"><c path="flixel.FlxCamera"/></c>
			<haxe_doc>* This determines on which `FlxCamera`s this object will be drawn. If it is `null` / has not been
	 * set, it uses `FlxCamera.defaultCameras`, which is a reference to `FlxG.cameras.list` (all cameras) by default.</haxe_doc>
		</cameras>
		<flixelType set="null" expr="NONE">
			<x path="flixel.FlxType"/>
			<meta>
				<m n=":value"><e>NONE</e></m>
				<m n=":noCompletion"/>
			</meta>
			<haxe_doc>* Enum that informs the collision system which type of object this is (to avoid expensive type casting).</haxe_doc>
		</flixelType>
		<_cameras>
			<c path="Array"><c path="flixel.FlxCamera"/></c>
			<meta><m n=":noCompletion"/></meta>
		</_cameras>
		<destroy public="1" set="method" line="76">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* **WARNING:** A destroyed `FlxBasic` can't be used anymore.
	 * It may even cause crashes if it is still part of a group or state.
	 * You may want to use `kill()` instead if you want to disable the object temporarily only and `revive()` it later.
	 * 
	 * This function is usually not called manually (Flixel calls it automatically during state switches for all `add()`ed objects).
	 * 
	 * Override this function to `null` out variables manually or call `destroy()` on class members if necessary.
	 * Don't forget to call `super.destroy()`!</haxe_doc>
		</destroy>
		<kill public="1" set="method" line="88">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Handy function for "killing" game objects. Use `reset()` to revive them.
	 * Default behavior is to flag them as nonexistent AND dead.
	 * However, if you want the "corpse" to remain in the game, like to animate an effect or whatever,
	 * you should `override` this, setting only `alive` to `false`, and leaving `exists` `true`.</haxe_doc>
		</kill>
		<revive public="1" set="method" line="98">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Handy function for bringing game objects "back to life". Just sets `alive` and `exists` back to `true`.
	 * In practice, this function is most often called by `FlxObject#reset()`.</haxe_doc>
		</revive>
		<update public="1" set="method" line="108">
			<f a="elapsed">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Override this function to update your class's position and appearance.
	 * This is where most of your game rules and behavioral code will go.</haxe_doc>
		</update>
		<draw public="1" set="method" line="119">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Override this function to control how the object is drawn.
	 * Doing so is rarely necessary, but can be very useful.</haxe_doc>
		</draw>
		<toString public="1" set="method" line="126"><f a=""><c path="String"/></f></toString>
		<set_visible set="method" line="136">
			<f a="Value">
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_visible>
		<set_active set="method" line="142">
			<f a="Value">
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_active>
		<set_exists set="method" line="148">
			<f a="Value">
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_exists>
		<set_alive set="method" line="154">
			<f a="Value">
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_alive>
		<get_camera set="method" line="160">
			<f a=""><c path="flixel.FlxCamera"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_camera>
		<set_camera set="method" line="166">
			<f a="Value">
				<c path="flixel.FlxCamera"/>
				<c path="flixel.FlxCamera"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_camera>
		<get_cameras set="method" line="176">
			<f a=""><c path="Array"><c path="flixel.FlxCamera"/></c></f>
			<meta><m n=":noCompletion"/></meta>
		</get_cameras>
		<set_cameras set="method" line="182">
			<f a="Value">
				<c path="Array"><c path="flixel.FlxCamera"/></c>
				<c path="Array"><c path="flixel.FlxCamera"/></c>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_cameras>
		<new public="1" set="method" line="64"><f a=""><x path="Void"/></f></new>
		<haxe_doc>* This is a useful "generic" Flixel object. Both `FlxObject` and
 * `FlxGroup` extend this class. Has no size, position or graphical data.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<abstract path="flixel.FlxType" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/FlxBasic.hx" module="flixel.FlxBasic">
		<this><x path="Int"/></this>
		<haxe_doc>* Types of flixel objects - mainly for collisions.</haxe_doc>
		<meta><m n=":enum"/></meta>
		<impl><class path="flixel._FlxBasic.FlxType_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/FlxBasic.hx" private="1" module="flixel.FlxBasic" extern="1">
	<NONE public="1" get="inline" set="null" expr="cast 0" line="194" static="1">
		<x path="flixel.FlxType"/>
		<meta>
			<m n=":value"><e>cast 0</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NONE>
	<OBJECT public="1" get="inline" set="null" expr="cast 1" line="195" static="1">
		<x path="flixel.FlxType"/>
		<meta>
			<m n=":value"><e>cast 1</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</OBJECT>
	<GROUP public="1" get="inline" set="null" expr="cast 2" line="196" static="1">
		<x path="flixel.FlxType"/>
		<meta>
			<m n=":value"><e>cast 2</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</GROUP>
	<TILEMAP public="1" get="inline" set="null" expr="cast 3" line="197" static="1">
		<x path="flixel.FlxType"/>
		<meta>
			<m n=":value"><e>cast 3</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</TILEMAP>
	<SPRITEGROUP public="1" get="inline" set="null" expr="cast 4" line="198" static="1">
		<x path="flixel.FlxType"/>
		<meta>
			<m n=":value"><e>cast 4</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</SPRITEGROUP>
	<meta>
		<m n=":final"/>
		<m n=":enum"/>
	</meta>
</class></impl>
	</abstract>
	<class path="flixel._FlxBasic.FlxType_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/FlxBasic.hx" private="1" module="flixel.FlxBasic" extern="1">
		<NONE public="1" get="inline" set="null" expr="cast 0" line="194" static="1">
			<x path="flixel.FlxType"/>
			<meta>
				<m n=":value"><e>cast 0</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NONE>
		<OBJECT public="1" get="inline" set="null" expr="cast 1" line="195" static="1">
			<x path="flixel.FlxType"/>
			<meta>
				<m n=":value"><e>cast 1</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</OBJECT>
		<GROUP public="1" get="inline" set="null" expr="cast 2" line="196" static="1">
			<x path="flixel.FlxType"/>
			<meta>
				<m n=":value"><e>cast 2</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</GROUP>
		<TILEMAP public="1" get="inline" set="null" expr="cast 3" line="197" static="1">
			<x path="flixel.FlxType"/>
			<meta>
				<m n=":value"><e>cast 3</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</TILEMAP>
		<SPRITEGROUP public="1" get="inline" set="null" expr="cast 4" line="198" static="1">
			<x path="flixel.FlxType"/>
			<meta>
				<m n=":value"><e>cast 4</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</SPRITEGROUP>
		<meta>
			<m n=":final"/>
			<m n=":enum"/>
		</meta>
	</class>
	<class path="flixel.IFlxBasic" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/FlxBasic.hx" module="flixel.FlxBasic" interface="1">
		<set_active public="1" set="method">
			<f a="value">
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":compilerGenerated"/></meta>
		</set_active>
		<set_visible public="1" set="method">
			<f a="value">
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":compilerGenerated"/></meta>
		</set_visible>
		<set_alive public="1" set="method">
			<f a="value">
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":compilerGenerated"/></meta>
		</set_alive>
		<set_exists public="1" set="method">
			<f a="value">
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":compilerGenerated"/></meta>
		</set_exists>
		<ID public="1"><x path="Int"/></ID>
		<active public="1" set="accessor"><x path="Bool"/></active>
		<visible public="1" set="accessor"><x path="Bool"/></visible>
		<alive public="1" set="accessor"><x path="Bool"/></alive>
		<exists public="1" set="accessor"><x path="Bool"/></exists>
		<draw public="1" set="method"><f a=""><x path="Void"/></f></draw>
		<update public="1" set="method"><f a="elapsed">
	<x path="Float"/>
	<x path="Void"/>
</f></update>
		<destroy public="1" set="method"><f a=""><x path="Void"/></f></destroy>
		<kill public="1" set="method"><f a=""><x path="Void"/></f></kill>
		<revive public="1" set="method"><f a=""><x path="Void"/></f></revive>
		<toString public="1" set="method"><f a=""><c path="String"/></f></toString>
	</class>
	<class path="openfl.VectorData" params="T" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/Vector.hx" module="openfl.Vector">
		<data public="1"><x path="haxe.ds.Vector"><c path="openfl.VectorData.T"/></x></data>
		<fixed public="1"><x path="Bool"/></fixed>
		<length public="1"><x path="Int"/></length>
		<new public="1" set="method" line="724"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":dox"><e>hide</e></m>
		</meta>
	</class>
	<class path="flixel.util.IFlxPooled" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/util/FlxPool.hx" module="flixel.util.FlxPool" interface="1">
		<extends path="flixel.util.IFlxDestroyable"/>
		<put public="1" set="method"><f a=""><x path="Void"/></f></put>
		<_inPool><x path="Bool"/></_inPool>
	</class>
	<class path="flixel.util.IFlxPool" params="T" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/util/FlxPool.hx" module="flixel.util.FlxPool" interface="1">
		<preAllocate public="1" set="method"><f a="numObjects">
	<x path="Int"/>
	<x path="Void"/>
</f></preAllocate>
		<clear public="1" set="method"><f a=""><c path="Array"><c path="flixel.util.IFlxPool.T"/></c></f></clear>
	</class>
	<class path="flixel.math.FlxPoint" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/math/FlxPoint.hx">
		<implements path="flixel.util.IFlxPooled"/>
		<pool public="1" get="accessor" set="null" static="1"><c path="flixel.util.IFlxPool"><c path="flixel.math.FlxPoint"/></c></pool>
		<_pool expr="new FlxPool&lt;FlxPoint&gt;(FlxPoint)" line="16" static="1">
			<c path="flixel.util.FlxPool_flixel_math_FlxPoint"/>
			<meta><m n=":value"><e><![CDATA[new FlxPool<FlxPoint>(FlxPoint)]]></e></m></meta>
		</_pool>
		<get public="1" get="inline" set="null" line="26" static="1">
			<f a="?X:?Y" v="0:0">
				<x path="Float"/>
				<x path="Float"/>
				<c path="flixel.math.FlxPoint"/>
			</f>
			<meta><m n=":value"><e>{ Y : 0, X : 0 }</e></m></meta>
			<haxe_doc>* Recycle or create a new FlxPoint. 
	 * Be sure to put() them back into the pool after you're done with them!
	 * 
	 * @param	X		The X-coordinate of the point in space.
	 * @param	Y		The Y-coordinate of the point in space.
	 * @return	This point.</haxe_doc>
		</get>
		<weak public="1" get="inline" set="null" line="41" static="1">
			<f a="?X:?Y" v="0:0">
				<x path="Float"/>
				<x path="Float"/>
				<c path="flixel.math.FlxPoint"/>
			</f>
			<meta><m n=":value"><e>{ Y : 0, X : 0 }</e></m></meta>
			<haxe_doc>* Recycle or create a new FlxPoint which will automatically be released 
	 * to the pool when passed into a flixel function.
	 * 
	 * @param	X		The X-coordinate of the point in space.
	 * @param	Y		The Y-coordinate of the point in space.
	 * @return	This point.</haxe_doc>
		</weak>
		<get_pool set="method" line="457" static="1"><f a=""><c path="flixel.util.IFlxPool"><c path="flixel.math.FlxPoint"/></c></f></get_pool>
		<x public="1" set="accessor" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</x>
		<y public="1" set="accessor" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</y>
		<_weak expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</_weak>
		<_inPool expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</_inPool>
		<put public="1" set="method" line="63">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Add this FlxPoint to the recycling pool.</haxe_doc>
		</put>
		<putWeak public="1" get="inline" set="null" line="76">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Add this FlxPoint to the recycling pool if it's a weak reference (allocated via weak()).</haxe_doc>
		</putWeak>
		<set public="1" set="method" line="91">
			<f a="?X:?Y" v="0:0">
				<x path="Float"/>
				<x path="Float"/>
				<c path="flixel.math.FlxPoint"/>
			</f>
			<meta><m n=":value"><e>{ Y : 0, X : 0 }</e></m></meta>
			<haxe_doc>* Set the coordinates of this point.
	 * 
	 * @param	X	The X-coordinate of the point in space.
	 * @param	Y	The Y-coordinate of the point in space.
	 * @return	This point.</haxe_doc>
		</set>
		<add public="1" get="inline" set="null" line="105">
			<f a="?X:?Y" v="0:0">
				<x path="Float"/>
				<x path="Float"/>
				<c path="flixel.math.FlxPoint"/>
			</f>
			<meta><m n=":value"><e>{ Y : 0, X : 0 }</e></m></meta>
			<haxe_doc>* Adds to the coordinates of this point.
	 * 
	 * @param	X	Amount to add to x
	 * @param	Y	Amount to add to y
	 * @return	This point.</haxe_doc>
		</add>
		<addPoint public="1" set="method" line="118">
			<f a="point">
				<c path="flixel.math.FlxPoint"/>
				<c path="flixel.math.FlxPoint"/>
			</f>
			<haxe_doc>* Adds the coordinates of another point to the coordinates of this point.
	 * 
	 * @param	point	The point to add to this point
	 * @return	This point.</haxe_doc>
		</addPoint>
		<subtract public="1" get="inline" set="null" line="133">
			<f a="?X:?Y" v="0:0">
				<x path="Float"/>
				<x path="Float"/>
				<c path="flixel.math.FlxPoint"/>
			</f>
			<meta><m n=":value"><e>{ Y : 0, X : 0 }</e></m></meta>
			<haxe_doc>* Subtracts from the coordinates of this point.
	 * 
	 * @param	X	Amount to subtract from x
	 * @param	Y	Amount to subtract from y
	 * @return	This point.</haxe_doc>
		</subtract>
		<subtractPoint public="1" set="method" line="146">
			<f a="point">
				<c path="flixel.math.FlxPoint"/>
				<c path="flixel.math.FlxPoint"/>
			</f>
			<haxe_doc>* Subtracts the coordinates of another point from the coordinates of this point.
	 * 
	 * @param	point	The point to subtract from this point
	 * @return	This point.</haxe_doc>
		</subtractPoint>
		<scale public="1" set="method" line="161">
			<f a="k">
				<x path="Float"/>
				<c path="flixel.math.FlxPoint"/>
			</f>
			<haxe_doc>* Scale this point.
	 * 
	 * @param	k - scale coefficient
	 * @return	scaled point
	 * @since   4.1.0</haxe_doc>
		</scale>
		<copyFrom public="1" get="inline" set="null" line="174">
			<f a="point">
				<c path="flixel.math.FlxPoint"/>
				<c path="flixel.math.FlxPoint"/>
			</f>
			<haxe_doc>* Helper function, just copies the values from the specified point.
	 * 
	 * @param	point	Any FlxPoint.
	 * @return	A reference to itself.</haxe_doc>
		</copyFrom>
		<copyTo public="1" set="method" line="188">
			<f a="?point">
				<c path="flixel.math.FlxPoint"/>
				<c path="flixel.math.FlxPoint"/>
			</f>
			<haxe_doc>* Helper function, just copies the values from this point to the specified point.
	 * 
	 * @param	Point	Any FlxPoint.
	 * @return	A reference to the altered point parameter.</haxe_doc>
		</copyTo>
		<copyFromFlash public="1" get="inline" set="null" line="205">
			<f a="FlashPoint">
				<t path="flash.geom.Point"/>
				<c path="flixel.math.FlxPoint"/>
			</f>
			<haxe_doc>* Helper function, just copies the values from the specified Flash point.
	 * 
	 * @param	Point	Any Point.
	 * @return	A reference to itself.</haxe_doc>
		</copyFromFlash>
		<copyToFlash public="1" get="inline" set="null" line="218">
			<f a="FlashPoint">
				<t path="flash.geom.Point"/>
				<t path="flash.geom.Point"/>
			</f>
			<haxe_doc>* Helper function, just copies the values from this point to the specified Flash point.
	 * 
	 * @param	Point	Any Point.
	 * @return	A reference to the altered point parameter.</haxe_doc>
		</copyToFlash>
		<addToFlash public="1" get="inline" set="null" line="236">
			<f a="FlashPoint">
				<t path="flash.geom.Point"/>
				<t path="flash.geom.Point"/>
			</f>
			<haxe_doc>* Helper function, just increases the values of the specified Flash point by the values of this point.
	 * 
	 * @param	Point	Any Point.
	 * @return	A reference to the altered point parameter.</haxe_doc>
		</addToFlash>
		<subtractFromFlash public="1" get="inline" set="null" line="250">
			<f a="FlashPoint">
				<t path="flash.geom.Point"/>
				<t path="flash.geom.Point"/>
			</f>
			<haxe_doc>* Helper function, just decreases the values of the specified Flash point by the values of this point.
	 * 
	 * @param	Point	Any Point.
	 * @return	A reference to the altered point parameter.</haxe_doc>
		</subtractFromFlash>
		<inCoords public="1" get="inline" set="null" line="267">
			<f a="RectX:RectY:RectWidth:RectHeight">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Returns true if this point is within the given rectangular block
	 * 
	 * @param	RectX		The X value of the region to test within
	 * @param	RectY		The Y value of the region to test within
	 * @param	RectWidth	The width of the region to test within
	 * @param	RectHeight	The height of the region to test within
	 * @return	True if the point is within the region, otherwise false</haxe_doc>
		</inCoords>
		<inRect public="1" get="inline" set="null" line="278">
			<f a="Rect">
				<c path="flixel.math.FlxRect"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Returns true if this point is within the given rectangular block
	 * 
	 * @param	Rect	The FlxRect to test within
	 * @return	True if pointX/pointY is within the FlxRect, otherwise false</haxe_doc>
		</inRect>
		<distanceTo public="1" set="method" line="289">
			<f a="point">
				<c path="flixel.math.FlxPoint"/>
				<x path="Float"/>
			</f>
			<haxe_doc>* Calculate the distance to another point.
	 * 
	 * @param 	AnotherPoint	A FlxPoint object to calculate the distance to.
	 * @return	The distance between the two points as a Float.</haxe_doc>
		</distanceTo>
		<floor public="1" get="inline" set="null" line="300">
			<f a=""><c path="flixel.math.FlxPoint"/></f>
			<haxe_doc>* Rounds x and y using Math.floor()</haxe_doc>
		</floor>
		<ceil public="1" get="inline" set="null" line="310">
			<f a=""><c path="flixel.math.FlxPoint"/></f>
			<haxe_doc>* Rounds x and y using Math.ceil()</haxe_doc>
		</ceil>
		<round public="1" get="inline" set="null" line="320">
			<f a=""><c path="flixel.math.FlxPoint"/></f>
			<haxe_doc>* Rounds x and y using Math.round()</haxe_doc>
		</round>
		<rotate public="1" set="method" line="334">
			<f a="Pivot:Angle">
				<c path="flixel.math.FlxPoint"/>
				<x path="Float"/>
				<c path="flixel.math.FlxPoint"/>
			</f>
			<haxe_doc>* Rotates this point clockwise in 2D space around another point by the given angle.
	 * 
	 * @param   Pivot   The pivot you want to rotate this point around
	 * @param   Angle   Rotate the point by this many degrees clockwise.
	 * @return  A FlxPoint containing the coordinates of the rotated point.</haxe_doc>
		</rotate>
		<angleBetween public="1" set="method" line="355">
			<f a="point">
				<c path="flixel.math.FlxPoint"/>
				<x path="Float"/>
			</f>
			<haxe_doc>* Calculates the angle between this and another point. 0 degrees points straight up.
	 * 
	 * @param   point   The other point.
	 * @return  The angle in degrees, between -180 and 180.</haxe_doc>
		</angleBetween>
		<toVector public="1" get="inline" set="null" line="395">
			<f a=""><c path="flixel.math.FlxVector"/></f>
			<haxe_doc>* Function to get a `FlxVector` from this `FlxPoint`
	 * @since 4.3.0</haxe_doc>
		</toVector>
		<equals public="1" get="inline" set="null" line="406">
			<f a="point">
				<c path="flixel.math.FlxPoint"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Function to compare this FlxPoint to another.
	 * 
	 * @param	point  The other FlxPoint to compare to this one.
	 * @return	True if the FlxPoints have the same x and y value, false otherwise.</haxe_doc>
		</equals>
		<destroy public="1" set="method" line="416">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Necessary for IFlxDestroyable.</haxe_doc>
		</destroy>
		<transform public="1" get="inline" set="null" line="423">
			<f a="matrix">
				<c path="openfl.geom.Matrix"/>
				<c path="flixel.math.FlxPoint"/>
			</f>
			<haxe_doc>* Applies transformation matrix to this point
	 * @param	matrix	transformation matrix
	 * @return	transformed point</haxe_doc>
		</transform>
		<toString public="1" get="inline" set="null" line="434">
			<f a=""><c path="String"/></f>
			<haxe_doc>* Convert object to readable string name. Useful for debugging, save games, etc.</haxe_doc>
		</toString>
		<set_x set="method" line="444">
			<f a="Value">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>* Necessary for FlxCallbackPoint.</haxe_doc>
		</set_x>
		<set_y set="method" line="452">
			<f a="Value">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>* Necessary for FlxCallbackPoint.</haxe_doc>
		</set_y>
		<new public="1" set="method" line="55">
			<f a="?X:?Y" v="0:0">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":value"><e>{ Y : 0, X : 0 }</e></m>
				<m n=":keep"/>
			</meta>
		</new>
		<haxe_doc>* Stores a 2D floating point coordinate.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="flixel.math.FlxRect" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/math/FlxRect.hx">
		<implements path="flixel.util.IFlxPooled"/>
		<pool public="1" get="accessor" set="null" static="1"><c path="flixel.util.IFlxPool"><c path="flixel.math.FlxRect"/></c></pool>
		<_pool expr="new FlxPool&lt;FlxRect&gt;(FlxRect)" line="15" static="1">
			<c path="flixel.util.FlxPool_flixel_math_FlxRect"/>
			<meta><m n=":value"><e><![CDATA[new FlxPool<FlxRect>(FlxRect)]]></e></m></meta>
		</_pool>
		<get public="1" get="inline" set="null" line="21" static="1">
			<f a="?X:?Y:?Width:?Height" v="0:0:0:0">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<c path="flixel.math.FlxRect"/>
			</f>
			<meta><m n=":value"><e>{ Height : 0, Width : 0, Y : 0, X : 0 }</e></m></meta>
			<haxe_doc>* Recycle or create new FlxRect.
	 * Be sure to put() them back into the pool after you're done with them!</haxe_doc>
		</get>
		<weak public="1" get="inline" set="null" line="32" static="1">
			<f a="?X:?Y:?Width:?Height" v="0:0:0:0">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<c path="flixel.math.FlxRect"/>
			</f>
			<meta><m n=":value"><e>{ Height : 0, Width : 0, Y : 0, X : 0 }</e></m></meta>
			<haxe_doc>* Recycle or create a new FlxRect which will automatically be released 
	 * to the pool when passed into a flixel function.</haxe_doc>
		</weak>
		<get_pool set="method" line="456" static="1"><f a=""><c path="flixel.util.IFlxPool"><c path="flixel.math.FlxRect"/></c></f></get_pool>
		<x public="1"><x path="Float"/></x>
		<y public="1"><x path="Float"/></y>
		<width public="1"><x path="Float"/></width>
		<height public="1"><x path="Float"/></height>
		<left public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<haxe_doc>* The x coordinate of the left side of the rectangle.</haxe_doc>
		</left>
		<right public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<haxe_doc>* The x coordinate of the right side of the rectangle.</haxe_doc>
		</right>
		<top public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<haxe_doc>* The x coordinate of the top of the rectangle.</haxe_doc>
		</top>
		<bottom public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<haxe_doc>* The y coordinate of the bottom of the rectangle.</haxe_doc>
		</bottom>
		<isEmpty public="1" get="accessor" set="null">
			<x path="Bool"/>
			<haxe_doc>* Whether width or height of this rectangle is equal to zero or not.</haxe_doc>
		</isEmpty>
		<_weak expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</_weak>
		<_inPool expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</_inPool>
		<put public="1" get="inline" set="null" line="81">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Add this FlxRect to the recycling pool.</haxe_doc>
		</put>
		<putWeak public="1" get="inline" set="null" line="94">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Add this FlxPoint to the recycling pool if it's a weak reference (allocated via weak()).</haxe_doc>
		</putWeak>
		<setSize public="1" get="inline" set="null" line="108">
			<f a="Width:Height">
				<x path="Float"/>
				<x path="Float"/>
				<c path="flixel.math.FlxRect"/>
			</f>
			<haxe_doc>* Shortcut for setting both width and Height.
	 * 
	 * @param	Width	The new sprite width.
	 * @param	Height	The new sprite height.</haxe_doc>
		</setSize>
		<setPosition public="1" get="inline" set="null" line="118">
			<f a="x:y">
				<x path="Float"/>
				<x path="Float"/>
				<c path="flixel.math.FlxRect"/>
			</f>
			<haxe_doc>* Shortcut for setting both x and y.</haxe_doc>
		</setPosition>
		<set public="1" get="inline" set="null" line="134">
			<f a="?X:?Y:?Width:?Height" v="0:0:0:0">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<c path="flixel.math.FlxRect"/>
			</f>
			<meta><m n=":value"><e>{ Height : 0, Width : 0, Y : 0, X : 0 }</e></m></meta>
			<haxe_doc>* Fill this rectangle with the data provided.
	 * 
	 * @param	X		The X-coordinate of the point in space.
	 * @param	Y		The Y-coordinate of the point in space.
	 * @param	Width	Desired width of the rectangle.
	 * @param	Height	Desired height of the rectangle.
	 * @return	A reference to itself.</haxe_doc>
		</set>
		<copyFrom public="1" get="inline" set="null" line="149">
			<f a="Rect">
				<c path="flixel.math.FlxRect"/>
				<c path="flixel.math.FlxRect"/>
			</f>
			<haxe_doc>* Helper function, just copies the values from the specified rectangle.
	 * 
	 * @param	Rect	Any FlxRect.
	 * @return	A reference to itself.</haxe_doc>
		</copyFrom>
		<copyTo public="1" get="inline" set="null" line="166">
			<f a="Rect">
				<c path="flixel.math.FlxRect"/>
				<c path="flixel.math.FlxRect"/>
			</f>
			<haxe_doc>* Helper function, just copies the values from this rectangle to the specified rectangle.
	 * 
	 * @param	Point	Any FlxRect.
	 * @return	A reference to the altered rectangle parameter.</haxe_doc>
		</copyTo>
		<copyFromFlash public="1" get="inline" set="null" line="183">
			<f a="FlashRect">
				<t path="flash.geom.Rectangle"/>
				<c path="flixel.math.FlxRect"/>
			</f>
			<haxe_doc>* Helper function, just copies the values from the specified Flash rectangle.
	 * 
	 * @param	FlashRect	Any Rectangle.
	 * @return	A reference to itself.</haxe_doc>
		</copyFromFlash>
		<copyToFlash public="1" get="inline" set="null" line="198">
			<f a="?FlashRect">
				<t path="flash.geom.Rectangle"/>
				<t path="flash.geom.Rectangle"/>
			</f>
			<haxe_doc>* Helper function, just copies the values from this rectangle to the specified Flash rectangle.
	 * 
	 * @param	Point	Any Rectangle.
	 * @return	A reference to the altered rectangle parameter.</haxe_doc>
		</copyToFlash>
		<overlaps public="1" get="inline" set="null" line="218">
			<f a="Rect">
				<c path="flixel.math.FlxRect"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Checks to see if some FlxRect object overlaps this FlxRect object.
	 * 
	 * @param	Rect	The rectangle being tested.
	 * @return	Whether or not the two rectangles overlap.</haxe_doc>
		</overlaps>
		<containsPoint public="1" get="inline" set="null" line="235">
			<f a="Point">
				<c path="flixel.math.FlxPoint"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Returns true if this FlxRect contains the FlxPoint
	 * 
	 * @param	Point	The FlxPoint to check
	 * @return	True if the FlxPoint is within this FlxRect, otherwise false</haxe_doc>
		</containsPoint>
		<union public="1" get="inline" set="null" line="249">
			<f a="Rect">
				<c path="flixel.math.FlxRect"/>
				<c path="flixel.math.FlxRect"/>
			</f>
			<haxe_doc>* Add another rectangle to this one by filling in the 
	 * horizontal and vertical space between the two rectangles.
	 * 
	 * @param	Rect	The second FlxRect to add to this one
	 * @return	The changed FlxRect</haxe_doc>
		</union>
		<floor public="1" get="inline" set="null" line="263">
			<f a=""><c path="flixel.math.FlxRect"/></f>
			<haxe_doc>* Rounds x, y, width and height using Math.floor()</haxe_doc>
		</floor>
		<ceil public="1" get="inline" set="null" line="275">
			<f a=""><c path="flixel.math.FlxRect"/></f>
			<haxe_doc>* Rounds x, y, width and height using Math.ceil()</haxe_doc>
		</ceil>
		<round public="1" get="inline" set="null" line="287">
			<f a=""><c path="flixel.math.FlxRect"/></f>
			<haxe_doc>* Rounds x, y, width and height using Math.round()</haxe_doc>
		</round>
		<fromTwoPoints public="1" get="inline" set="null" line="303">
			<f a="Point1:Point2">
				<c path="flixel.math.FlxPoint"/>
				<c path="flixel.math.FlxPoint"/>
				<c path="flixel.math.FlxRect"/>
			</f>
			<haxe_doc>* Calculation of bounding box for two points
	 * 
	 * @param	point1	first point to calculate bounding box
	 * @param	point2	second point to calculate bounding box
	 * @return	this rectangle filled with the position and size of bounding box for two specified points</haxe_doc>
		</fromTwoPoints>
		<unionWithPoint public="1" get="inline" set="null" line="323">
			<f a="Point">
				<c path="flixel.math.FlxPoint"/>
				<c path="flixel.math.FlxRect"/>
			</f>
			<haxe_doc>* Add another point to this rectangle one by filling in the 
	 * horizontal and vertical space between the point and this rectangle.
	 * 
	 * @param	Point	point to add to this one
	 * @return	The changed FlxRect</haxe_doc>
		</unionWithPoint>
		<offset public="1" get="inline" set="null" line="334"><f a="dx:dy">
	<x path="Float"/>
	<x path="Float"/>
	<c path="flixel.math.FlxRect"/>
</f></offset>
		<destroy public="1" set="method" line="344">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Necessary for IFlxDestroyable.</haxe_doc>
		</destroy>
		<equals public="1" get="inline" set="null" line="352">
			<f a="rect">
				<c path="flixel.math.FlxRect"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Checks if this rectangle's properties are equal to properties of provided rect.
	 * 
	 * @param	rect	Rectangle to check equality to.
	 * @return	Whether both rectangles are equal.</haxe_doc>
		</equals>
		<intersection public="1" set="method" line="370">
			<f a="rect:?result">
				<c path="flixel.math.FlxRect"/>
				<c path="flixel.math.FlxRect"/>
				<c path="flixel.math.FlxRect"/>
			</f>
			<haxe_doc>* Returns the area of intersection with specified rectangle. 
	 * If the rectangles do not intersect, this method returns an empty rectangle.
	 * 
	 * @param	rect	Rectangle to check intersection against.
	 * @return	The area of intersection of two rectangles.</haxe_doc>
		</intersection>
		<toString public="1" get="inline" set="null" line="398">
			<f a=""><c path="String"/></f>
			<haxe_doc>* Convert object to readable string name. Useful for debugging, save games, etc.</haxe_doc>
		</toString>
		<get_left get="inline" set="null" line="407"><f a=""><x path="Float"/></f></get_left>
		<set_left get="inline" set="null" line="412"><f a="Value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_left>
		<get_right get="inline" set="null" line="418"><f a=""><x path="Float"/></f></get_right>
		<set_right get="inline" set="null" line="423"><f a="Value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_right>
		<get_top get="inline" set="null" line="429"><f a=""><x path="Float"/></f></get_top>
		<set_top get="inline" set="null" line="434"><f a="Value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_top>
		<get_bottom get="inline" set="null" line="440"><f a=""><x path="Float"/></f></get_bottom>
		<set_bottom get="inline" set="null" line="445"><f a="Value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_bottom>
		<get_isEmpty get="inline" set="null" line="451"><f a=""><x path="Bool"/></f></get_isEmpty>
		<new public="1" set="method" line="73">
			<f a="?X:?Y:?Width:?Height" v="0:0:0:0">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":value"><e>{ Height : 0, Width : 0, Y : 0, X : 0 }</e></m>
				<m n=":keep"/>
			</meta>
		</new>
		<haxe_doc>* Stores a rectangle.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="openfl.events.IEventDispatcher" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/events/IEventDispatcher.hx" interface="1">
		<addEventListener public="1" set="method">
			<f a="type:listener:?useCapture:?priority:?useWeakReference" v="::false:0:false">
				<c path="String"/>
				<f a="">
					<d/>
					<x path="Void"/>
				</f>
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ useWeakReference : false, priority : 0, useCapture : false }</e></m></meta>
		</addEventListener>
		<dispatchEvent public="1" set="method"><f a="event">
	<c path="openfl.events.Event"/>
	<x path="Bool"/>
</f></dispatchEvent>
		<hasEventListener public="1" set="method"><f a="type">
	<c path="String"/>
	<x path="Bool"/>
</f></hasEventListener>
		<removeEventListener public="1" set="method">
			<f a="type:listener:?useCapture" v="::false">
				<c path="String"/>
				<f a="">
					<d/>
					<x path="Void"/>
				</f>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ useCapture : false }</e></m></meta>
		</removeEventListener>
		<willTrigger public="1" set="method"><f a="type">
	<c path="String"/>
	<x path="Bool"/>
</f></willTrigger>
	</class>
	<class path="openfl.events.EventDispatcher" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/events/EventDispatcher.hx">
		<implements path="openfl.events.IEventDispatcher"/>
		<__sortByPriority set="method" line="289" static="1"><f a="l1:l2">
	<c path="openfl.events._EventDispatcher.Listener"/>
	<c path="openfl.events._EventDispatcher.Listener"/>
	<x path="Int"/>
</f></__sortByPriority>
		<__dispatching><x path="Map">
	<c path="String"/>
	<x path="Bool"/>
</x></__dispatching>
		<__targetDispatcher><c path="openfl.events.IEventDispatcher"/></__targetDispatcher>
		<__eventMap><x path="Map">
	<c path="String"/>
	<c path="Array"><c path="openfl.events._EventDispatcher.Listener"/></c>
</x></__eventMap>
		<__newEventMap><x path="Map">
	<c path="String"/>
	<c path="Array"><c path="openfl.events._EventDispatcher.Listener"/></c>
</x></__newEventMap>
		<addEventListener public="1" set="method" line="30">
			<f a="type:listener:?useCapture:?priority:?useWeakReference" v="::false:0:false">
				<c path="String"/>
				<f a="">
					<d/>
					<x path="Void"/>
				</f>
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ useWeakReference : false, priority : 0, useCapture : false }</e></m></meta>
		</addEventListener>
		<dispatchEvent public="1" set="method" line="83"><f a="event">
	<c path="openfl.events.Event"/>
	<x path="Bool"/>
</f></dispatchEvent>
		<hasEventListener public="1" set="method" line="100"><f a="type">
	<c path="String"/>
	<x path="Bool"/>
</f></hasEventListener>
		<removeEventListener public="1" set="method" line="117">
			<f a="type:listener:?useCapture" v="::false">
				<c path="String"/>
				<f a="">
					<d/>
					<x path="Void"/>
				</f>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ useCapture : false }</e></m></meta>
		</removeEventListener>
		<toString public="1" set="method" line="172">
			<f a=""><c path="String"/></f>
			<meta><m n=":has_untyped"/></meta>
		</toString>
		<willTrigger public="1" set="method" line="182"><f a="type">
	<c path="String"/>
	<x path="Bool"/>
</f></willTrigger>
		<__dispatchEvent set="method" line="189"><f a="event">
	<c path="openfl.events.Event"/>
	<x path="Bool"/>
</f></__dispatchEvent>
		<new public="1" set="method" line="19">
			<f a="?target" v="null">
				<c path="openfl.events.IEventDispatcher"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ target : null }</e></m></meta>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":access"><e>openfl.events.Event</e></m>
		</meta>
	</class>
	<class path="openfl.display.IBitmapDrawable" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/display/IBitmapDrawable.hx" interface="1">
		<__worldTransform public="1"><c path="openfl.geom.Matrix"/></__worldTransform>
		<__worldColorTransform public="1"><c path="openfl.geom.ColorTransform"/></__worldColorTransform>
		<__blendMode><x path="openfl.display.BlendMode"/></__blendMode>
		<__cacheAsBitmap><x path="Bool"/></__cacheAsBitmap>
		<__renderCairo public="1" set="method"><f a="renderSession">
	<c path="openfl._internal.renderer.RenderSession"/>
	<x path="Void"/>
</f></__renderCairo>
		<__renderCairoMask public="1" set="method"><f a="renderSession">
	<c path="openfl._internal.renderer.RenderSession"/>
	<x path="Void"/>
</f></__renderCairoMask>
		<__renderCanvas public="1" set="method"><f a="renderSession">
	<c path="openfl._internal.renderer.RenderSession"/>
	<x path="Void"/>
</f></__renderCanvas>
		<__renderCanvasMask public="1" set="method"><f a="renderSession">
	<c path="openfl._internal.renderer.RenderSession"/>
	<x path="Void"/>
</f></__renderCanvasMask>
		<__renderGL public="1" set="method"><f a="renderSession">
	<c path="openfl._internal.renderer.RenderSession"/>
	<x path="Void"/>
</f></__renderGL>
		<__updateChildren public="1" set="method"><f a="transformOnly">
	<x path="Bool"/>
	<x path="Void"/>
</f></__updateChildren>
		<__updateTransforms public="1" set="method">
			<f a="?overrideTransform" v="null">
				<c path="openfl.geom.Matrix"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ overrideTransform : null }</e></m></meta>
		</__updateTransforms>
		<__updateMask public="1" set="method"><f a="maskGraphics">
	<c path="openfl.display.Graphics"/>
	<x path="Void"/>
</f></__updateMask>
	</class>
	<class path="openfl.display.DisplayObject" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/display/DisplayObject.hx">
		<extends path="openfl.events.EventDispatcher"/>
		<implements path="openfl.display.IBitmapDrawable"/>
		<__instanceCount expr="0" line="46" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</__instanceCount>
		<__worldRenderDirty expr="0" line="47" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</__worldRenderDirty>
		<__worldTransformDirty expr="0" line="48" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</__worldTransformDirty>
		<__cacheAsBitmapMode expr="false" line="50" static="1">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</__cacheAsBitmapMode>
		<alpha public="1" get="accessor" set="accessor"><x path="Float"/></alpha>
		<blendMode public="1" set="accessor"><x path="openfl.display.BlendMode"/></blendMode>
		<cacheAsBitmap public="1" get="accessor" set="accessor"><x path="Bool"/></cacheAsBitmap>
		<cacheAsBitmapMatrix public="1" get="accessor" set="accessor"><c path="openfl.geom.Matrix"/></cacheAsBitmapMatrix>
		<cacheAsBitmapSmooth public="1" get="accessor" set="accessor"><x path="Bool"/></cacheAsBitmapSmooth>
		<cacheAsBitmapBounds public="1"><c path="openfl.geom.Rectangle"/></cacheAsBitmapBounds>
		<filters public="1" get="accessor" set="accessor"><c path="Array"><c path="openfl.filters.BitmapFilter"/></c></filters>
		<height public="1" get="accessor" set="accessor"><x path="Float"/></height>
		<loaderInfo public="1" set="null"><c path="openfl.display.LoaderInfo"/></loaderInfo>
		<mask public="1" get="accessor" set="accessor"><c path="openfl.display.DisplayObject"/></mask>
		<mouseX public="1" get="accessor" set="null"><x path="Float"/></mouseX>
		<mouseY public="1" get="accessor" set="null"><x path="Float"/></mouseY>
		<name public="1" get="accessor" set="accessor"><c path="String"/></name>
		<opaqueBackground public="1"><t path="Null"><x path="Int"/></t></opaqueBackground>
		<parent public="1" set="null"><c path="openfl.display.DisplayObjectContainer"/></parent>
		<root public="1" get="accessor" set="null"><c path="openfl.display.DisplayObject"/></root>
		<rotation public="1" get="accessor" set="accessor"><x path="Float"/></rotation>
		<scale9Grid public="1"><c path="openfl.geom.Rectangle"/></scale9Grid>
		<scaleX public="1" get="accessor" set="accessor"><x path="Float"/></scaleX>
		<scaleY public="1" get="accessor" set="accessor"><x path="Float"/></scaleY>
		<scrollRect public="1" get="accessor" set="accessor"><c path="openfl.geom.Rectangle"/></scrollRect>
		<shader public="1" set="accessor"><c path="openfl.display.Shader"/></shader>
		<stage public="1" set="null"><c path="openfl.display.Stage"/></stage>
		<transform public="1" get="accessor" set="accessor"><c path="openfl.geom.Transform"/></transform>
		<visible public="1" get="accessor" set="accessor"><x path="Bool"/></visible>
		<width public="1" get="accessor" set="accessor"><x path="Float"/></width>
		<x public="1" get="accessor" set="accessor"><x path="Float"/></x>
		<y public="1" get="accessor" set="accessor"><x path="Float"/></y>
		<__renderTransform public="1"><c path="openfl.geom.Matrix"/></__renderTransform>
		<__worldColorTransform public="1"><c path="openfl.geom.ColorTransform"/></__worldColorTransform>
		<__worldOffset public="1"><c path="openfl.geom.Point"/></__worldOffset>
		<__worldTransform public="1"><c path="openfl.geom.Matrix"/></__worldTransform>
		<__alpha><x path="Float"/></__alpha>
		<__blendMode><x path="openfl.display.BlendMode"/></__blendMode>
		<__cairo><c path="lime.graphics.cairo.Cairo"/></__cairo>
		<__children><c path="Array"><c path="openfl.display.DisplayObject"/></c></__children>
		<__filters><c path="Array"><c path="openfl.filters.BitmapFilter"/></c></__filters>
		<__graphics><c path="openfl.display.Graphics"/></__graphics>
		<__interactive><x path="Bool"/></__interactive>
		<__isMask><x path="Bool"/></__isMask>
		<__mask><c path="openfl.display.DisplayObject"/></__mask>
		<__maskGraphics><c path="openfl.display.Graphics"/></__maskGraphics>
		<__maskCached expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</__maskCached>
		<__name><c path="String"/></__name>
		<__objectTransform><c path="openfl.geom.Transform"/></__objectTransform>
		<__offset><c path="openfl.geom.Point"/></__offset>
		<__renderable><x path="Bool"/></__renderable>
		<__renderDirty><x path="Bool"/></__renderDirty>
		<__rotation><x path="Float"/></__rotation>
		<__rotationCosine><x path="Float"/></__rotationCosine>
		<__rotationSine><x path="Float"/></__rotationSine>
		<__scrollRect><c path="openfl.geom.Rectangle"/></__scrollRect>
		<__shader><c path="openfl.display.Shader"/></__shader>
		<__transform><c path="openfl.geom.Matrix"/></__transform>
		<__transformDirty><x path="Bool"/></__transformDirty>
		<__visible><x path="Bool"/></__visible>
		<__worldAlpha><x path="Float"/></__worldAlpha>
		<__worldAlphaChanged><x path="Bool"/></__worldAlphaChanged>
		<__worldClip><c path="openfl.geom.Rectangle"/></__worldClip>
		<__worldClipChanged><x path="Bool"/></__worldClipChanged>
		<__worldTransformCache><c path="openfl.geom.Matrix"/></__worldTransformCache>
		<__worldTransformChanged><x path="Bool"/></__worldTransformChanged>
		<__worldVisible><x path="Bool"/></__worldVisible>
		<__worldVisibleChanged><x path="Bool"/></__worldVisibleChanged>
		<__worldZ><x path="Int"/></__worldZ>
		<__cacheAsBitmap expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</__cacheAsBitmap>
		<__cacheAsBitmapMatrix><c path="openfl.geom.Matrix"/></__cacheAsBitmapMatrix>
		<__cacheAsBitmapSmooth expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</__cacheAsBitmapSmooth>
		<__forceCacheAsBitmap><x path="Bool"/></__forceCacheAsBitmap>
		<__updateCachedBitmap><x path="Bool"/></__updateCachedBitmap>
		<__cachedBitmap><c path="openfl.display.BitmapData"/></__cachedBitmap>
		<__cachedBitmapBounds><c path="openfl.geom.Rectangle"/></__cachedBitmapBounds>
		<__cachedFilterBounds><c path="openfl.geom.Rectangle"/></__cachedFilterBounds>
		<__cacheGLMatrix><c path="openfl.geom.Matrix"/></__cacheGLMatrix>
		<__updateFilters><x path="Bool"/></__updateFilters>
		<getBounds public="1" set="method" line="167"><f a="targetCoordinateSpace">
	<c path="openfl.display.DisplayObject"/>
	<c path="openfl.geom.Rectangle"/>
</f></getBounds>
		<getRect public="1" set="method" line="191"><f a="targetCoordinateSpace">
	<c path="openfl.display.DisplayObject"/>
	<c path="openfl.geom.Rectangle"/>
</f></getRect>
		<globalToLocal public="1" set="method" line="199"><f a="pos">
	<c path="openfl.geom.Point"/>
	<c path="openfl.geom.Point"/>
</f></globalToLocal>
		<hitTestObject public="1" set="method" line="208"><f a="obj">
	<c path="openfl.display.DisplayObject"/>
	<x path="Bool"/>
</f></hitTestObject>
		<hitTestPoint public="1" set="method" line="224">
			<f a="x:y:?shapeFlag" v="::false">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":value"><e>{ shapeFlag : false }</e></m></meta>
		</hitTestPoint>
		<localToGlobal public="1" set="method" line="240"><f a="point">
	<c path="openfl.geom.Point"/>
	<c path="openfl.geom.Point"/>
</f></localToGlobal>
		<__broadcast set="method" line="247"><f a="event:notifyChilden">
	<c path="openfl.events.Event"/>
	<x path="Bool"/>
	<x path="Bool"/>
</f></__broadcast>
		<__dispatchEvent set="method" line="268" override="1"><f a="event">
	<c path="openfl.events.Event"/>
	<x path="Bool"/>
</f></__dispatchEvent>
		<__enterFrame set="method" line="297"><f a="deltaTime">
	<x path="Int"/>
	<x path="Void"/>
</f></__enterFrame>
		<__getBounds set="method" line="304"><f a="rect:matrix">
	<c path="openfl.geom.Rectangle"/>
	<c path="openfl.geom.Matrix"/>
	<x path="Void"/>
</f></__getBounds>
		<__getCursor set="method" line="315"><f a=""><e path="lime.ui.MouseCursor"/></f></__getCursor>
		<__getInteractive set="method" line="322"><f a="stack">
	<c path="Array"><c path="openfl.display.DisplayObject"/></c>
	<x path="Bool"/>
</f></__getInteractive>
		<__getLocalBounds get="inline" set="null" line="329"><f a="rect">
	<c path="openfl.geom.Rectangle"/>
	<x path="Void"/>
</f></__getLocalBounds>
		<__getRenderBounds set="method" line="336"><f a="rect:matrix">
	<c path="openfl.geom.Rectangle"/>
	<c path="openfl.geom.Matrix"/>
	<x path="Void"/>
</f></__getRenderBounds>
		<__getWorldTransform set="method" line="354"><f a=""><c path="openfl.geom.Matrix"/></f></__getWorldTransform>
		<__hitTest set="method" line="401"><f a="x:y:shapeFlag:stack:interactiveOnly:hitObject">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Bool"/>
	<c path="Array"><c path="openfl.display.DisplayObject"/></c>
	<x path="Bool"/>
	<c path="openfl.display.DisplayObject"/>
	<x path="Bool"/>
</f></__hitTest>
		<__hitTestMask set="method" line="427"><f a="x:y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Bool"/>
</f></__hitTestMask>
		<__renderCairo public="1" set="method" line="444"><f a="renderSession">
	<c path="openfl._internal.renderer.RenderSession"/>
	<x path="Void"/>
</f></__renderCairo>
		<__renderCairoMask public="1" set="method" line="455"><f a="renderSession">
	<c path="openfl._internal.renderer.RenderSession"/>
	<x path="Void"/>
</f></__renderCairoMask>
		<__renderCanvas public="1" set="method" line="466"><f a="renderSession">
	<c path="openfl._internal.renderer.RenderSession"/>
	<x path="Void"/>
</f></__renderCanvas>
		<__renderCanvasMask public="1" set="method" line="477"><f a="renderSession">
	<c path="openfl._internal.renderer.RenderSession"/>
	<x path="Void"/>
</f></__renderCanvasMask>
		<__renderDOM public="1" set="method" line="488"><f a="renderSession">
	<c path="openfl._internal.renderer.RenderSession"/>
	<x path="Void"/>
</f></__renderDOM>
		<__renderGL public="1" set="method" line="499"><f a="renderSession">
	<c path="openfl._internal.renderer.RenderSession"/>
	<x path="Void"/>
</f></__renderGL>
		<__drawGraphicsGL public="1" get="inline" set="null" line="514"><f a="renderSession">
	<c path="openfl._internal.renderer.RenderSession"/>
	<x path="Void"/>
</f></__drawGraphicsGL>
		<__preRenderGL public="1" get="inline" set="null" line="538"><f a="renderSession">
	<c path="openfl._internal.renderer.RenderSession"/>
	<x path="Void"/>
</f></__preRenderGL>
		<__postRenderGL public="1" get="inline" set="null" line="555"><f a="renderSession">
	<c path="openfl._internal.renderer.RenderSession"/>
	<x path="Void"/>
</f></__postRenderGL>
		<__cacheGL public="1" get="inline" set="null" line="572"><f a="renderSession">
	<c path="openfl._internal.renderer.RenderSession"/>
	<x path="Void"/>
</f></__cacheGL>
		<__setStageReference set="method" line="647"><f a="stage">
	<c path="openfl.display.Stage"/>
	<x path="Void"/>
</f></__setStageReference>
		<__setRenderDirty get="inline" set="null" line="676"><f a=""><x path="Void"/></f></__setRenderDirty>
		<__setTransformDirty get="inline" set="null" line="690"><f a=""><x path="Void"/></f></__setTransformDirty>
		<__update public="1" set="method" line="702">
			<f a="transformOnly:updateChildren:?maskGraphics" v="::null">
				<x path="Bool"/>
				<x path="Bool"/>
				<c path="openfl.display.Graphics"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ maskGraphics : null }</e></m></meta>
		</__update>
		<__updateChildren public="1" set="method" line="891"><f a="transformOnly">
	<x path="Bool"/>
	<x path="Void"/>
</f></__updateChildren>
		<__updateMask public="1" set="method" line="907"><f a="maskGraphics">
	<c path="openfl.display.Graphics"/>
	<x path="Void"/>
</f></__updateMask>
		<__updateTransforms public="1" set="method" line="929">
			<f a="?overrideTransform" v="null">
				<c path="openfl.geom.Matrix"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ overrideTransform : null }</e></m></meta>
		</__updateTransforms>
		<get_alpha set="method" line="984"><f a=""><x path="Float"/></f></get_alpha>
		<set_alpha set="method" line="991"><f a="value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_alpha>
		<set_blendMode set="method" line="1000"><f a="value">
	<x path="openfl.display.BlendMode"/>
	<x path="openfl.display.BlendMode"/>
</f></set_blendMode>
		<set_shader set="method" line="1007"><f a="value">
	<c path="openfl.display.Shader"/>
	<c path="openfl.display.Shader"/>
</f></set_shader>
		<get_cacheAsBitmap set="method" line="1015"><f a=""><x path="Bool"/></f></get_cacheAsBitmap>
		<set_cacheAsBitmap set="method" line="1022"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_cacheAsBitmap>
		<get_cacheAsBitmapMatrix set="method" line="1030"><f a=""><c path="openfl.geom.Matrix"/></f></get_cacheAsBitmapMatrix>
		<set_cacheAsBitmapMatrix set="method" line="1037"><f a="value">
	<c path="openfl.geom.Matrix"/>
	<c path="openfl.geom.Matrix"/>
</f></set_cacheAsBitmapMatrix>
		<get_cacheAsBitmapSmooth set="method" line="1045"><f a=""><x path="Bool"/></f></get_cacheAsBitmapSmooth>
		<set_cacheAsBitmapSmooth set="method" line="1052"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_cacheAsBitmapSmooth>
		<get_filters set="method" line="1059"><f a=""><c path="Array"><c path="openfl.filters.BitmapFilter"/></c></f></get_filters>
		<set_filters set="method" line="1074"><f a="value">
	<c path="Array"><c path="openfl.filters.BitmapFilter"/></c>
	<c path="Array"><c path="openfl.filters.BitmapFilter"/></c>
</f></set_filters>
		<get_height set="method" line="1099"><f a=""><x path="Float"/></f></get_height>
		<set_height set="method" line="1109"><f a="value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_height>
		<get_mask set="method" line="1133"><f a=""><c path="openfl.display.DisplayObject"/></f></get_mask>
		<set_mask set="method" line="1140"><f a="value">
	<c path="openfl.display.DisplayObject"/>
	<c path="openfl.display.DisplayObject"/>
</f></set_mask>
		<get_mouseX set="method" line="1159"><f a=""><x path="Float"/></f></get_mouseX>
		<get_mouseY set="method" line="1169"><f a=""><x path="Float"/></f></get_mouseY>
		<get_name set="method" line="1179"><f a=""><c path="String"/></f></get_name>
		<set_name set="method" line="1186"><f a="value">
	<c path="String"/>
	<c path="String"/>
</f></set_name>
		<get_root set="method" line="1193"><f a=""><c path="openfl.display.DisplayObject"/></f></get_root>
		<get_rotation set="method" line="1206"><f a=""><x path="Float"/></f></get_rotation>
		<set_rotation set="method" line="1213"><f a="value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_rotation>
		<get_scaleX set="method" line="1239"><f a=""><x path="Float"/></f></get_scaleX>
		<set_scaleX set="method" line="1254"><f a="value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_scaleX>
		<get_scaleY set="method" line="1282"><f a=""><x path="Float"/></f></get_scaleY>
		<set_scaleY set="method" line="1297"><f a="value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_scaleY>
		<get_scrollRect set="method" line="1325"><f a=""><c path="openfl.geom.Rectangle"/></f></get_scrollRect>
		<set_scrollRect set="method" line="1334"><f a="value">
	<c path="openfl.geom.Rectangle"/>
	<c path="openfl.geom.Rectangle"/>
</f></set_scrollRect>
		<get_transform set="method" line="1348"><f a=""><c path="openfl.geom.Transform"/></f></get_transform>
		<set_transform set="method" line="1361"><f a="value">
	<c path="openfl.geom.Transform"/>
	<c path="openfl.geom.Transform"/>
</f></set_transform>
		<get_visible set="method" line="1384"><f a=""><x path="Bool"/></f></get_visible>
		<set_visible set="method" line="1391"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_visible>
		<get_width set="method" line="1399"><f a=""><x path="Float"/></f></get_width>
		<set_width set="method" line="1409"><f a="value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_width>
		<get_x set="method" line="1433"><f a=""><x path="Float"/></f></get_x>
		<set_x set="method" line="1440"><f a="value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_x>
		<get_y set="method" line="1448"><f a=""><x path="Float"/></f></get_y>
		<set_y set="method" line="1455"><f a="value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_y>
		<new set="method" line="137"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":access"><e>openfl.events.Event</e></m>
			<m n=":access"><e>openfl.display.Graphics</e></m>
			<m n=":access"><e>openfl.display.Stage</e></m>
			<m n=":access"><e>openfl.geom.ColorTransform</e></m>
			<m n=":access"><e>openfl.geom.Matrix</e></m>
			<m n=":access"><e>openfl.geom.Rectangle</e></m>
		</meta>
		<haxe_dynamic><c path="openfl.display.DisplayObject"/></haxe_dynamic>
	</class>
	<class path="openfl.display.InteractiveObject" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/display/InteractiveObject.hx">
		<extends path="openfl.display.DisplayObject"/>
		<doubleClickEnabled public="1"><x path="Bool"/></doubleClickEnabled>
		<focusRect public="1"><d/></focusRect>
		<mouseEnabled public="1"><x path="Bool"/></mouseEnabled>
		<needsSoftKeyboard public="1"><x path="Bool"/></needsSoftKeyboard>
		<softKeyboardInputAreaOfInterest public="1"><c path="openfl.geom.Rectangle"/></softKeyboardInputAreaOfInterest>
		<tabEnabled public="1" get="accessor" set="accessor"><x path="Bool"/></tabEnabled>
		<tabIndex public="1"><x path="Int"/></tabIndex>
		<__tabEnabled><x path="Bool"/></__tabEnabled>
		<requestSoftKeyboard public="1" set="method" line="35"><f a=""><x path="Bool"/></f></requestSoftKeyboard>
		<__getInteractive set="method" line="44" override="1"><f a="stack">
	<c path="Array"><c path="openfl.display.DisplayObject"/></c>
	<x path="Bool"/>
</f></__getInteractive>
		<__hitTest set="method" line="63" override="1"><f a="x:y:shapeFlag:stack:interactiveOnly:hitObject">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Bool"/>
	<c path="Array"><c path="openfl.display.DisplayObject"/></c>
	<x path="Bool"/>
	<c path="openfl.display.DisplayObject"/>
	<x path="Bool"/>
</f></__hitTest>
		<get_tabEnabled set="method" line="78"><f a=""><x path="Bool"/></f></get_tabEnabled>
		<set_tabEnabled set="method" line="85"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_tabEnabled>
		<new public="1" set="method" line="22"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="openfl.display.DisplayObjectContainer" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/display/DisplayObjectContainer.hx">
		<extends path="openfl.display.InteractiveObject"/>
		<mouseChildren public="1"><x path="Bool"/></mouseChildren>
		<numChildren public="1" get="accessor" set="null"><x path="Int"/></numChildren>
		<tabChildren public="1"><x path="Bool"/></tabChildren>
		<__removedChildren><c path="Array"><c path="openfl.display.DisplayObject"/></c></__removedChildren>
		<addChild public="1" set="method" line="42"><f a="child">
	<c path="openfl.display.DisplayObject"/>
	<c path="openfl.display.DisplayObject"/>
</f></addChild>
		<addChildAt public="1" set="method" line="78"><f a="child:index">
	<c path="openfl.display.DisplayObject"/>
	<x path="Int"/>
	<c path="openfl.display.DisplayObject"/>
</f></addChildAt>
		<areInaccessibleObjectsUnderPoint public="1" set="method" line="125"><f a="point">
	<c path="openfl.geom.Point"/>
	<x path="Bool"/>
</f></areInaccessibleObjectsUnderPoint>
		<contains public="1" set="method" line="132"><f a="child">
	<c path="openfl.display.DisplayObject"/>
	<x path="Bool"/>
</f></contains>
		<getChildAt public="1" set="method" line="145"><f a="index">
	<x path="Int"/>
	<c path="openfl.display.DisplayObject"/>
</f></getChildAt>
		<getChildByName public="1" set="method" line="158"><f a="name">
	<c path="String"/>
	<c path="openfl.display.DisplayObject"/>
</f></getChildByName>
		<getChildIndex public="1" set="method" line="171"><f a="child">
	<c path="openfl.display.DisplayObject"/>
	<x path="Int"/>
</f></getChildIndex>
		<getObjectsUnderPoint public="1" set="method" line="184"><f a="point">
	<c path="openfl.geom.Point"/>
	<c path="Array"><c path="openfl.display.DisplayObject"/></c>
</f></getObjectsUnderPoint>
		<removeChild public="1" set="method" line="194"><f a="child">
	<c path="openfl.display.DisplayObject"/>
	<c path="openfl.display.DisplayObject"/>
</f></removeChild>
		<removeChildAt public="1" set="method" line="220"><f a="index">
	<x path="Int"/>
	<c path="openfl.display.DisplayObject"/>
</f></removeChildAt>
		<removeChildren public="1" set="method" line="233">
			<f a="?beginIndex:?endIndex" v="0:0x7FFFFFFF">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ endIndex : 0x7FFFFFFF, beginIndex : 0 }</e></m></meta>
		</removeChildren>
		<resolve set="method" line="268"><f a="fieldName">
	<c path="String"/>
	<c path="openfl.display.DisplayObject"/>
</f></resolve>
		<setChildIndex public="1" set="method" line="287"><f a="child:index">
	<c path="openfl.display.DisplayObject"/>
	<x path="Int"/>
	<x path="Void"/>
</f></setChildIndex>
		<swapChildren public="1" set="method" line="299"><f a="child1:child2">
	<c path="openfl.display.DisplayObject"/>
	<c path="openfl.display.DisplayObject"/>
	<x path="Void"/>
</f></swapChildren>
		<swapChildrenAt public="1" set="method" line="337"><f a="index1:index2">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></swapChildrenAt>
		<__broadcast set="method" line="347" override="1"><f a="event:notifyChilden">
	<c path="openfl.events.Event"/>
	<x path="Bool"/>
	<x path="Bool"/>
</f></__broadcast>
		<__enterFrame set="method" line="378" override="1"><f a="deltaTime">
	<x path="Int"/>
	<x path="Void"/>
</f></__enterFrame>
		<__getBounds set="method" line="389" override="1"><f a="rect:matrix">
	<c path="openfl.geom.Rectangle"/>
	<c path="openfl.geom.Matrix"/>
	<x path="Void"/>
</f></__getBounds>
		<__getRenderBounds set="method" line="419" override="1"><f a="rect:matrix">
	<c path="openfl.geom.Rectangle"/>
	<c path="openfl.geom.Matrix"/>
	<x path="Void"/>
</f></__getRenderBounds>
		<__hitTest set="method" line="458" override="1"><f a="x:y:shapeFlag:stack:interactiveOnly:hitObject">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Bool"/>
	<c path="Array"><c path="openfl.display.DisplayObject"/></c>
	<x path="Bool"/>
	<c path="openfl.display.DisplayObject"/>
	<x path="Bool"/>
</f></__hitTest>
		<__hitTestMask set="method" line="538" override="1"><f a="x:y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Bool"/>
</f></__hitTestMask>
		<__renderCairo public="1" set="method" line="557" override="1"><f a="renderSession">
	<c path="openfl._internal.renderer.RenderSession"/>
	<x path="Void"/>
</f></__renderCairo>
		<__renderCairoMask public="1" set="method" line="602" override="1"><f a="renderSession">
	<c path="openfl._internal.renderer.RenderSession"/>
	<x path="Void"/>
</f></__renderCairoMask>
		<__renderCanvas public="1" set="method" line="624" override="1"><f a="renderSession">
	<c path="openfl._internal.renderer.RenderSession"/>
	<x path="Void"/>
</f></__renderCanvas>
		<__renderCanvasMask public="1" set="method" line="673" override="1"><f a="renderSession">
	<c path="openfl._internal.renderer.RenderSession"/>
	<x path="Void"/>
</f></__renderCanvasMask>
		<__renderDOM public="1" set="method" line="695" override="1"><f a="renderSession">
	<c path="openfl._internal.renderer.RenderSession"/>
	<x path="Void"/>
</f></__renderDOM>
		<__renderGL public="1" set="method" line="744" override="1"><f a="renderSession">
	<c path="openfl._internal.renderer.RenderSession"/>
	<x path="Void"/>
</f></__renderGL>
		<__setStageReference set="method" line="773" override="1"><f a="stage">
	<c path="openfl.display.Stage"/>
	<x path="Void"/>
</f></__setStageReference>
		<__update public="1" set="method" line="806" override="1">
			<f a="transformOnly:updateChildren:?maskGraphics" v="::null">
				<x path="Bool"/>
				<x path="Bool"/>
				<c path="openfl.display.Graphics"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ maskGraphics : null }</e></m></meta>
		</__update>
		<__updateChildren public="1" set="method" line="832" override="1"><f a="transformOnly">
	<x path="Bool"/>
	<x path="Void"/>
</f></__updateChildren>
		<get_numChildren set="method" line="852"><f a=""><x path="Int"/></f></get_numChildren>
		<new set="method" line="30"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":access"><e>openfl.events.Event</e></m>
			<m n=":access"><e>openfl.display.Graphics</e></m>
			<m n=":access"><e>openfl.geom.Rectangle</e></m>
		</meta>
	</class>
	<class path="openfl.display.Sprite" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/display/Sprite.hx">
		<extends path="openfl.display.DisplayObjectContainer"/>
		<buttonMode public="1"><x path="Bool"/></buttonMode>
		<graphics public="1" get="accessor" set="null"><c path="openfl.display.Graphics"/></graphics>
		<hitArea public="1"><c path="openfl.display.Sprite"/></hitArea>
		<useHandCursor public="1"><x path="Bool"/></useHandCursor>
		<startDrag public="1" set="method" line="38">
			<f a="?lockCenter:?bounds" v="false:null">
				<x path="Bool"/>
				<c path="openfl.geom.Rectangle"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ bounds : null, lockCenter : false }</e></m></meta>
		</startDrag>
		<stopDrag public="1" set="method" line="49"><f a=""><x path="Void"/></f></stopDrag>
		<__getCursor set="method" line="60" override="1"><f a=""><e path="lime.ui.MouseCursor"/></f></__getCursor>
		<__hitTest set="method" line="67" override="1"><f a="x:y:shapeFlag:stack:interactiveOnly:hitObject">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Bool"/>
	<c path="Array"><c path="openfl.display.DisplayObject"/></c>
	<x path="Bool"/>
	<c path="openfl.display.DisplayObject"/>
	<x path="Bool"/>
</f></__hitTest>
		<__hitTestMask set="method" line="112" override="1"><f a="x:y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Bool"/>
</f></__hitTestMask>
		<get_graphics set="method" line="136"><f a=""><c path="openfl.display.Graphics"/></f></get_graphics>
		<get_tabEnabled set="method" line="150" override="1"><f a=""><x path="Bool"/></f></get_tabEnabled>
		<new public="1" set="method" line="27"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":access"><e>openfl.display.Graphics</e></m>
			<m n=":access"><e>openfl.display.Stage</e></m>
		</meta>
	</class>
	<class path="openfl.display.LoaderInfo" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/display/LoaderInfo.hx">
		<extends path="openfl.events.EventDispatcher"/>
		<__rootURL expr="&quot;&quot;" line="17" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>""</e></m></meta>
		</__rootURL>
		<create public="1" set="method" line="53" static="1"><f a="loader">
	<c path="openfl.display.Loader"/>
	<c path="openfl.display.LoaderInfo"/>
</f></create>
		<applicationDomain public="1" set="null"><c path="openfl.system.ApplicationDomain"/></applicationDomain>
		<bytes public="1" set="null"><x path="openfl.utils.ByteArray"/></bytes>
		<bytesLoaded public="1" set="null"><x path="Int"/></bytesLoaded>
		<bytesTotal public="1" set="null"><x path="Int"/></bytesTotal>
		<childAllowsParent public="1" set="null"><x path="Bool"/></childAllowsParent>
		<content public="1" set="null"><c path="openfl.display.DisplayObject"/></content>
		<contentType public="1" set="null"><c path="String"/></contentType>
		<frameRate public="1" set="null"><x path="Float"/></frameRate>
		<height public="1" set="null"><x path="Int"/></height>
		<loader public="1" set="null"><c path="openfl.display.Loader"/></loader>
		<loaderURL public="1" set="null"><c path="String"/></loaderURL>
		<parameters public="1" set="null"><d><c path="String"/></d></parameters>
		<parentAllowsChild public="1" set="null"><x path="Bool"/></parentAllowsChild>
		<sameDomain public="1" set="null"><x path="Bool"/></sameDomain>
		<sharedEvents public="1" set="null"><c path="openfl.events.EventDispatcher"/></sharedEvents>
		<uncaughtErrorEvents public="1" set="null"><c path="openfl.events.UncaughtErrorEvents"/></uncaughtErrorEvents>
		<url public="1" set="null"><c path="String"/></url>
		<width public="1" set="null"><x path="Int"/></width>
		<new set="method" line="40"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="openfl.system.ApplicationDomain" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/system/ApplicationDomain.hx">
		<currentDomain public="1" set="null" expr="new ApplicationDomain(null)" line="10" static="1">
			<c path="openfl.system.ApplicationDomain"/>
			<meta><m n=":value"><e>new ApplicationDomain(null)</e></m></meta>
		</currentDomain>
		<parentDomain public="1" set="null"><c path="openfl.system.ApplicationDomain"/></parentDomain>
		<getDefinition public="1" set="method" line="30"><f a="name">
	<c path="String"/>
	<x path="Class"><d/></x>
</f></getDefinition>
		<hasDefinition public="1" set="method" line="37"><f a="name">
	<c path="String"/>
	<x path="Bool"/>
</f></hasDefinition>
		<new public="1" set="method" line="15">
			<f a="?parentDomain" v="null">
				<c path="openfl.system.ApplicationDomain"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ parentDomain : null }</e></m></meta>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":final"/>
		</meta>
	</class>
	<class path="openfl.events.UncaughtErrorEvents" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/events/UncaughtErrorEvents.hx">
		<extends path="openfl.events.EventDispatcher"/>
		<new public="1" set="method" line="7"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="openfl.geom.Matrix" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/geom/Matrix.hx">
		<__identity expr="new Matrix()" line="12" static="1">
			<c path="openfl.geom.Matrix"/>
			<meta><m n=":value"><e>new Matrix()</e></m></meta>
		</__identity>
		<__temp expr="new Matrix()" line="13" static="1">
			<c path="openfl.geom.Matrix"/>
			<meta><m n=":value"><e>new Matrix()</e></m></meta>
		</__temp>
		<a public="1"><x path="Float"/></a>
		<b public="1"><x path="Float"/></b>
		<c public="1"><x path="Float"/></c>
		<d public="1"><x path="Float"/></d>
		<tx public="1"><x path="Float"/></tx>
		<ty public="1"><x path="Float"/></ty>
		<__array><x path="lime.utils.Float32Array"/></__array>
		<clone public="1" set="method" line="37"><f a=""><c path="openfl.geom.Matrix"/></f></clone>
		<concat public="1" set="method" line="44"><f a="m">
	<c path="openfl.geom.Matrix"/>
	<x path="Void"/>
</f></concat>
		<copyColumnFrom public="1" set="method" line="63"><f a="column:vector3D">
	<x path="Int"/>
	<c path="openfl.geom.Vector3D"/>
	<x path="Void"/>
</f></copyColumnFrom>
		<copyColumnTo public="1" set="method" line="89"><f a="column:vector3D">
	<x path="Int"/>
	<c path="openfl.geom.Vector3D"/>
	<x path="Void"/>
</f></copyColumnTo>
		<copyFrom public="1" set="method" line="118"><f a="sourceMatrix">
	<c path="openfl.geom.Matrix"/>
	<x path="Void"/>
</f></copyFrom>
		<copyRowFrom public="1" set="method" line="130"><f a="row:vector3D">
	<x path="Int"/>
	<c path="openfl.geom.Vector3D"/>
	<x path="Void"/>
</f></copyRowFrom>
		<copyRowTo public="1" set="method" line="156"><f a="row:vector3D">
	<x path="Int"/>
	<c path="openfl.geom.Vector3D"/>
	<x path="Void"/>
</f></copyRowTo>
		<createBox public="1" set="method" line="183">
			<f a="scaleX:scaleY:?rotation:?tx:?ty" v="::0:0:0">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ ty : 0, tx : 0, rotation : 0 }</e></m></meta>
		</createBox>
		<createGradientBox public="1" set="method" line="215">
			<f a="width:height:?rotation:?tx:?ty" v="::0:0:0">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ ty : 0, tx : 0, rotation : 0 }</e></m></meta>
		</createGradientBox>
		<deltaTransformPoint public="1" set="method" line="244"><f a="point">
	<c path="openfl.geom.Point"/>
	<c path="openfl.geom.Point"/>
</f></deltaTransformPoint>
		<equals public="1" set="method" line="251"><f a="matrix">
	<a>
		<ty set="null"><x path="Float"/></ty>
		<tx set="null"><x path="Float"/></tx>
		<d set="null"><x path="Float"/></d>
		<c set="null"><x path="Float"/></c>
		<b set="null"><x path="Float"/></b>
		<a set="null"><x path="Float"/></a>
	</a>
	<x path="Bool"/>
</f></equals>
		<identity public="1" set="method" line="258"><f a=""><x path="Void"/></f></identity>
		<invert public="1" set="method" line="270"><f a=""><c path="openfl.geom.Matrix"/></f></invert>
		<rotate public="1" set="method" line="302"><f a="theta">
	<x path="Float"/>
	<x path="Void"/>
</f></rotate>
		<scale public="1" set="method" line="338"><f a="sx:sy">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></scale>
		<setRotation set="method" line="361">
			<f a="theta:?scale" v=":1">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ scale : 1 }</e></m></meta>
		</setRotation>
		<setTo public="1" set="method" line="373"><f a="a:b:c:d:tx:ty">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></setTo>
		<to3DString public="1" get="inline" set="null" line="385">
			<f a="?roundPixels" v="false">
				<x path="Bool"/>
				<c path="String"/>
			</f>
			<meta><m n=":value"><e>{ roundPixels : false }</e></m></meta>
		</to3DString>
		<toMozString public="1" get="inline" set="null" line="400"><f a=""><c path="String"/></f></toMozString>
		<toString public="1" set="method" line="407"><f a=""><c path="String"/></f></toString>
		<transformPoint public="1" set="method" line="414"><f a="pos">
	<c path="openfl.geom.Point"/>
	<c path="openfl.geom.Point"/>
</f></transformPoint>
		<translate public="1" set="method" line="421"><f a="dx:dy">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></translate>
		<toArray set="method" line="429">
			<f a="?transpose" v="false">
				<x path="Bool"/>
				<x path="lime.utils.Float32Array"/>
			</f>
			<meta><m n=":value"><e>{ transpose : false }</e></m></meta>
		</toArray>
		<__cleanValues get="inline" set="null" line="468"><f a=""><x path="Void"/></f></__cleanValues>
		<__toMatrix3 set="method" line="480"><f a=""><c path="lime.math.Matrix3"/></f></__toMatrix3>
		<__transformInversePoint public="1" get="inline" set="null" line="487"><f a="point">
	<c path="openfl.geom.Point"/>
	<x path="Void"/>
</f></__transformInversePoint>
		<__transformInverseX public="1" get="inline" set="null" line="507"><f a="px:py">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></__transformInverseX>
		<__transformInverseY public="1" get="inline" set="null" line="524"><f a="px:py">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></__transformInverseY>
		<__transformPoint public="1" get="inline" set="null" line="541"><f a="point">
	<c path="openfl.geom.Point"/>
	<x path="Void"/>
</f></__transformPoint>
		<__transformX public="1" get="inline" set="null" line="552"><f a="px:py">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></__transformX>
		<__transformY public="1" get="inline" set="null" line="559"><f a="px:py">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></__transformY>
		<__translateTransformed public="1" get="inline" set="null" line="566"><f a="px:py">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></__translateTransformed>
		<new public="1" set="method" line="25">
			<f a="?a:?b:?c:?d:?tx:?ty" v="1:0:0:1:0:0">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ ty : 0, tx : 0, d : 1, c : 0, b : 0, a : 1 }</e></m></meta>
		</new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="openfl.geom.Point" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/geom/Point.hx">
		<distance public="1" set="method" line="45" static="1"><f a="pt1:pt2">
	<c path="openfl.geom.Point"/>
	<c path="openfl.geom.Point"/>
	<x path="Float"/>
</f></distance>
		<interpolate public="1" set="method" line="61" static="1"><f a="pt1:pt2:f">
	<c path="openfl.geom.Point"/>
	<c path="openfl.geom.Point"/>
	<x path="Float"/>
	<c path="openfl.geom.Point"/>
</f></interpolate>
		<polar public="1" set="method" line="93" static="1"><f a="len:angle">
	<x path="Float"/>
	<x path="Float"/>
	<c path="openfl.geom.Point"/>
</f></polar>
		<length public="1" get="accessor" set="null"><x path="Float"/></length>
		<x public="1"><x path="Float"/></x>
		<y public="1"><x path="Float"/></y>
		<add public="1" set="method" line="23"><f a="v">
	<c path="openfl.geom.Point"/>
	<c path="openfl.geom.Point"/>
</f></add>
		<clone public="1" set="method" line="30"><f a=""><c path="openfl.geom.Point"/></f></clone>
		<copyFrom public="1" set="method" line="37"><f a="sourcePoint">
	<c path="openfl.geom.Point"/>
	<x path="Void"/>
</f></copyFrom>
		<equals public="1" set="method" line="54"><f a="toCompare">
	<c path="openfl.geom.Point"/>
	<x path="Bool"/>
</f></equals>
		<normalize public="1" set="method" line="68"><f a="thickness">
	<x path="Float"/>
	<x path="Void"/>
</f></normalize>
		<offset public="1" set="method" line="85"><f a="dx:dy">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></offset>
		<setTo public="1" set="method" line="100"><f a="xa:ya">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></setTo>
		<subtract public="1" set="method" line="107"><f a="v">
	<c path="openfl.geom.Point"/>
	<c path="openfl.geom.Point"/>
</f></subtract>
		<toString public="1" set="method" line="114"><f a=""><c path="String"/></f></toString>
		<__toLimeVector2 set="method" line="121"><f a=""><c path="lime.math.Vector2"/></f></__toLimeVector2>
		<get_length set="method" line="135"><f a=""><x path="Float"/></f></get_length>
		<new public="1" set="method" line="15">
			<f a="?x:?y" v="0:0">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ y : 0, x : 0 }</e></m></meta>
		</new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="openfl.geom.ColorTransform" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/geom/ColorTransform.hx">
		<alphaMultiplier public="1"><x path="Float"/></alphaMultiplier>
		<alphaOffset public="1"><x path="Float"/></alphaOffset>
		<blueMultiplier public="1"><x path="Float"/></blueMultiplier>
		<blueOffset public="1"><x path="Float"/></blueOffset>
		<color public="1" get="accessor" set="accessor"><x path="Int"/></color>
		<greenMultiplier public="1"><x path="Float"/></greenMultiplier>
		<greenOffset public="1"><x path="Float"/></greenOffset>
		<redMultiplier public="1"><x path="Float"/></redMultiplier>
		<redOffset public="1"><x path="Float"/></redOffset>
		<concat public="1" set="method" line="36"><f a="second">
	<c path="openfl.geom.ColorTransform"/>
	<x path="Void"/>
</f></concat>
		<toString public="1" set="method" line="51"><f a=""><c path="String"/></f></toString>
		<__clone set="method" line="58"><f a=""><c path="openfl.geom.ColorTransform"/></f></__clone>
		<__combine set="method" line="65"><f a="ct">
	<c path="openfl.geom.ColorTransform"/>
	<x path="Void"/>
</f></__combine>
		<__equals set="method" line="80">
			<f a="ct:?skipAlphaMultiplier" v=":false">
				<c path="openfl.geom.ColorTransform"/>
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":value"><e>{ skipAlphaMultiplier : false }</e></m></meta>
		</__equals>
		<__isDefault set="method" line="87"><f a=""><x path="Bool"/></f></__isDefault>
		<get_color set="method" line="101"><f a=""><x path="Int"/></f></get_color>
		<set_color set="method" line="108"><f a="value">
	<x path="Int"/>
	<x path="Int"/>
</f></set_color>
		<__toLimeColorMatrix set="method" line="123"><f a=""><x path="lime.math.ColorMatrix"/></f></__toLimeColorMatrix>
		<new public="1" set="method" line="22">
			<f a="?redMultiplier:?greenMultiplier:?blueMultiplier:?alphaMultiplier:?redOffset:?greenOffset:?blueOffset:?alphaOffset" v="1:1:1:1:0:0:0:0">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ alphaOffset : 0, blueOffset : 0, greenOffset : 0, redOffset : 0, alphaMultiplier : 1, blueMultiplier : 1, greenMultiplier : 1, redMultiplier : 1 }</e></m></meta>
		</new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="flixel.FlxCamera" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/FlxCamera.hx">
		<extends path="flixel.FlxBasic"/>
		<defaultZoom public="1" static="1">
			<x path="Float"/>
			<haxe_doc>* While you can alter the zoom of each camera after the fact,
	 * this variable determines what value the camera will start at when created.</haxe_doc>
		</defaultZoom>
		<defaultCameras public="1" static="1">
			<c path="Array"><c path="flixel.FlxCamera"/></c>
			<haxe_doc>* Which cameras a `FlxBasic` uses to be drawn on when nothing else has been specified.
	 * By default, this is just a reference to `FlxG.cameras.list` / all cameras, but it can be very useful to change.</haxe_doc>
		</defaultCameras>
		<_storageTilesHead static="1">
			<c path="flixel.graphics.tile.FlxDrawTilesItem"/>
			<haxe_doc>* Draw tiles stack items that can be reused</haxe_doc>
		</_storageTilesHead>
		<_storageTrianglesHead static="1">
			<c path="flixel.graphics.tile.FlxDrawTrianglesItem"/>
			<haxe_doc>* Draw triangles stack items that can be reused</haxe_doc>
		</_storageTrianglesHead>
		<drawVertices expr="new Vector&lt;Float&gt;()" line="440" static="1">
			<x path="openfl.Vector"><x path="Float"/></x>
			<meta><m n=":value"><e><![CDATA[new Vector<Float>()]]></e></m></meta>
			<haxe_doc>* Internal variable, used for visibility checks to minimize `drawTriangles()` calls.</haxe_doc>
		</drawVertices>
		<trianglesSprite expr="new Sprite()" line="444" static="1">
			<t path="flash.display.Sprite"/>
			<meta><m n=":value"><e>new Sprite()</e></m></meta>
			<haxe_doc>* Internal variable, used in blit render mode to render triangles (`drawTriangles()`) on camera's buffer.</haxe_doc>
		</trianglesSprite>
		<renderPoint expr="FlxPoint.get()" line="449" static="1">
			<c path="flixel.math.FlxPoint"/>
			<meta><m n=":value"><e>FlxPoint.get()</e></m></meta>
			<haxe_doc>* Internal variables, used in blit render mode to draw trianglesSprite on camera's buffer.
	 * Added for less garbage creation.</haxe_doc>
		</renderPoint>
		<renderRect expr="FlxRect.get()" line="450" static="1">
			<c path="flixel.math.FlxRect"/>
			<meta><m n=":value"><e>FlxRect.get()</e></m></meta>
		</renderRect>
		<x public="1" set="accessor" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* The X position of this camera's display. `zoom` does NOT affect this number.
	 * Measured in pixels from the left side of the window.
	 * You might be interested in using camera's `scroll.x` instead.</haxe_doc>
		</x>
		<y public="1" set="accessor" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* The Y position of this camera's display. `zoom` does NOT affect this number.
	 * Measured in pixels from the top of the window.
	 * You might be interested in using camera's `scroll.y` instead.</haxe_doc>
		</y>
		<scaleX public="1" set="null" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* The scaling on horizontal axis for this camera.
	 * Setting `scaleX` changes `scaleX` and x coordinate of camera's internal display objects.</haxe_doc>
		</scaleX>
		<scaleY public="1" set="null" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* The scaling on vertical axis for this camera.
	 * Setting `scaleY` changes `scaleY` and y coordinate of camera's internal display objects.</haxe_doc>
		</scaleY>
		<totalScaleX public="1" set="null">
			<x path="Float"/>
			<haxe_doc>* Product of camera's `scaleX` and game's scale mode `scale.x` multiplication.</haxe_doc>
		</totalScaleX>
		<totalScaleY public="1" set="null">
			<x path="Float"/>
			<haxe_doc>* Product of camera's scaleY and game's scale mode scale.y multiplication.</haxe_doc>
		</totalScaleY>
		<style public="1">
			<e path="flixel.FlxCameraFollowStyle"/>
			<haxe_doc>* Tells the camera to use this following style.</haxe_doc>
		</style>
		<target public="1">
			<c path="flixel.FlxObject"/>
			<haxe_doc>* Tells the camera to follow this FlxObject object around.</haxe_doc>
		</target>
		<targetOffset public="1" set="null" expr="FlxPoint.get()">
			<c path="flixel.math.FlxPoint"/>
			<meta><m n=":value"><e>FlxPoint.get()</e></m></meta>
			<haxe_doc>* Offset the camera target.</haxe_doc>
		</targetOffset>
		<followLerp public="1" set="accessor" expr="60 / FlxG.updateFramerate">
			<x path="Float"/>
			<meta><m n=":value"><e>60 / FlxG.updateFramerate</e></m></meta>
			<haxe_doc>* Used to smoothly track the camera as it follows:
	 * The percent of the distance to the follow `target` the camera moves per 1/60 sec.
	 * Values are bounded between `0.0` and `FlxG.updateFrameRate / 60` for consistency across framerates.
	 * The maximum value means no camera easing. A value of `0` means the camera does not move.</haxe_doc>
		</followLerp>
		<deadzone public="1">
			<c path="flixel.math.FlxRect"/>
			<haxe_doc>* You can assign a "dead zone" to the camera in order to better control its movement.
	 * The camera will always keep the focus object inside the dead zone, unless it is bumping up against
	 * the camera bounds. The `deadzone`'s coordinates are measured from the camera's upper left corner in game pixels.
	 * For rapid prototyping, you can use the preset deadzones (e.g. `PLATFORMER`) with `follow()`.</haxe_doc>
		</deadzone>
		<minScrollX public="1">
			<t path="Null"><x path="Float"/></t>
			<haxe_doc>* Lower bound of the camera's `scroll` on the x axis.</haxe_doc>
		</minScrollX>
		<maxScrollX public="1">
			<t path="Null"><x path="Float"/></t>
			<haxe_doc>* Upper bound of the camera's `scroll` on the x axis.</haxe_doc>
		</maxScrollX>
		<minScrollY public="1">
			<t path="Null"><x path="Float"/></t>
			<haxe_doc>* Lower bound of the camera's `scroll` on the y axis.</haxe_doc>
		</minScrollY>
		<maxScrollY public="1">
			<t path="Null"><x path="Float"/></t>
			<haxe_doc>* Upper bound of the camera's `scroll` on the y axis.</haxe_doc>
		</maxScrollY>
		<scroll public="1" expr="FlxPoint.get()">
			<c path="flixel.math.FlxPoint"/>
			<meta><m n=":value"><e>FlxPoint.get()</e></m></meta>
			<haxe_doc>* Stores the basic parallax scrolling values.
	 * This is basically the camera's top-left corner position in world coordinates.
	 * There is also `focusOn(point:FlxPoint)` which you can use to
	 * make the camera look at specified point in world coordinates.</haxe_doc>
		</scroll>
		<buffer public="1">
			<t path="flash.display.BitmapData"/>
			<haxe_doc>* The actual `BitmapData` of the camera display itself.
	 * Used in blit render mode, where you can manipulate its pixels for achieving some visual effects.</haxe_doc>
		</buffer>
		<bgColor public="1">
			<x path="flixel.util.FlxColor"/>
			<haxe_doc>* The natural background color of the camera, in `AARRGGBB` format. Defaults to `FlxG.cameras.bgColor`.
	 * On Flash, transparent backgrounds can be used in conjunction with `useBgAlphaBlending`.</haxe_doc>
		</bgColor>
		<screen public="1">
			<c path="flixel.FlxSprite"/>
			<haxe_doc>* Sometimes it's easier to just work with a `FlxSprite` than it is to work directly with the `BitmapData` buffer.
	 * This sprite reference will allow you to do exactly that.
	 * Basically this sprite's `pixels` property is camera's `BitmapData` buffer.
	 * NOTE: This variable is used only in blit render mode.
	 * 
	 * The FlxBloom demo shows how you can use this variable in blit render mode.
	 * @see http://haxeflixel.com/demos/FlxBloom/</haxe_doc>
		</screen>
		<useBgAlphaBlending public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
			<haxe_doc>* Whether to use alpha blending for camera's background fill or not.
	 * If `true` then previously drawn graphics won't be erased,
	 * and if camera's `bgColor` is transparent/semitransparent then you
	 * will be able to see graphics of the previous frame.
	 * Useful for blit render mode (and works only in this mode). Default value is `false`.
	 * 
	 * Usage example can be seen in FlxBloom demo.
	 * @see http://haxeflixel.com/demos/FlxBloom/</haxe_doc>
		</useBgAlphaBlending>
		<flashSprite public="1" expr="new Sprite()">
			<t path="flash.display.Sprite"/>
			<meta><m n=":value"><e>new Sprite()</e></m></meta>
			<haxe_doc>* Used to render buffer to screen space.
	 * NOTE: We don't recommend modifying this directly unless you are fairly experienced.
	 * Uses include 3D projection, advanced display list modification, and more.
	 * This is container for everything else that is used by camera and rendered to the camera.
	 * 
	 * Its position is modified by `updateFlashSpritePosition()` which is called every frame.</haxe_doc>
		</flashSprite>
		<pixelPerfectRender public="1">
			<x path="Bool"/>
			<haxe_doc>* Whether the positions of the objects rendered on this camera are rounded.
	 * If set on individual objects, they ignore the global camera setting.
	 * Defaults to `false` with `FlxG.renderTile` and to `true` with `FlxG.renderBlit`.
	 * WARNING: setting this to `false` on blitting targets is very expensive.</haxe_doc>
		</pixelPerfectRender>
		<width public="1" set="accessor" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* How wide the camera display is, in game pixels.</haxe_doc>
		</width>
		<height public="1" set="accessor" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* How tall the camera display is, in game pixels.</haxe_doc>
		</height>
		<zoom public="1" set="accessor">
			<x path="Float"/>
			<haxe_doc>* The zoom level of this camera. `1` = 1:1, `2` = 2x zoom, etc.
	 * Indicates how far the camera is zoomed in.</haxe_doc>
		</zoom>
		<viewOffsetX set="null" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* Difference between native size of camera and zoomed size, divided in half
	 * Needed to do occlusion of objects when zoom != initialZoom</haxe_doc>
		</viewOffsetX>
		<viewOffsetY set="null" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</viewOffsetY>
		<viewOffsetWidth set="null" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* The size of the camera plus view offset.
	 * These variables are used for object visibility checks.</haxe_doc>
		</viewOffsetWidth>
		<viewOffsetHeight set="null" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</viewOffsetHeight>
		<viewWidth set="null" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* Dimensions of area visible at current camera zoom.</haxe_doc>
		</viewWidth>
		<viewHeight set="null" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</viewHeight>
		<_blitMatrix expr="new FlxMatrix()">
			<c path="flixel.math.FlxMatrix"/>
			<meta><m n=":value"><e>new FlxMatrix()</e></m></meta>
			<haxe_doc>* Helper matrix object. Used in blit render mode when camera's zoom is less than initialZoom
	 * (it is applied to all objects rendered on the camera at such circumstances).</haxe_doc>
		</_blitMatrix>
		<_useBlitMatrix expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
			<haxe_doc>* Logical flag for tracking whether to apply _blitMatrix transformation to objects or not.</haxe_doc>
		</_useBlitMatrix>
		<alpha public="1" set="accessor" expr="1">
			<x path="Float"/>
			<meta><m n=":value"><e>1</e></m></meta>
			<haxe_doc>* The alpha value of this camera display (a number between `0.0` and `1.0`).</haxe_doc>
		</alpha>
		<angle public="1" set="accessor" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* The angle of the camera display (in degrees).</haxe_doc>
		</angle>
		<color public="1" set="accessor" expr="FlxColor.WHITE">
			<x path="flixel.util.FlxColor"/>
			<meta><m n=":value"><e>FlxColor.WHITE</e></m></meta>
			<haxe_doc>* The color tint of the camera display.</haxe_doc>
		</color>
		<antialiasing public="1" set="accessor" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
			<haxe_doc>* Whether the camera display is smooth and filtered, or chunky and pixelated.
	 * Default behavior is chunky-style.</haxe_doc>
		</antialiasing>
		<followLead public="1" set="null" expr="FlxPoint.get()">
			<c path="flixel.math.FlxPoint"/>
			<meta><m n=":value"><e>FlxPoint.get()</e></m></meta>
			<haxe_doc>* Used to force the camera to look ahead of the target.</haxe_doc>
		</followLead>
		<filtersEnabled public="1" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
			<haxe_doc>* Enables or disables the filters set via `setFilters()`.</haxe_doc>
		</filtersEnabled>
		<_flashRect>
			<t path="flash.geom.Rectangle"/>
			<haxe_doc>* Internal, used in blit render mode in camera's `fill()` method for less garbage creation.
	 * It represents the size of buffer `BitmapData`
	 * (the area of camera's buffer which should be filled with `bgColor`).
	 * Do not modify it unless you know what are you doing.</haxe_doc>
		</_flashRect>
		<_flashPoint expr="new Point()">
			<t path="flash.geom.Point"/>
			<meta><m n=":value"><e>new Point()</e></m></meta>
			<haxe_doc>* Internal, used in blit render mode in camera's `fill()` method for less garbage creation:
	 * Its coordinates are always `(0,0)`, where camera's buffer filling should start.
	 * Do not modify it unless you know what are you doing.</haxe_doc>
		</_flashPoint>
		<_flashOffset expr="FlxPoint.get()">
			<c path="flixel.math.FlxPoint"/>
			<meta><m n=":value"><e>FlxPoint.get()</e></m></meta>
			<haxe_doc>* Internal, used for positioning camera's `flashSprite` on screen.
	 * Basically it represents position of camera's center point in game sprite.
	 * It's recalculated every time you resize game or camera.
	 * Its value depends on camera's size (`width` and `height`), game's `scale` and camera's initial zoom factor.
	 * Do not modify it unless you know what are you doing.</haxe_doc>
		</_flashOffset>
		<_fxFlashColor expr="FlxColor.TRANSPARENT">
			<x path="flixel.util.FlxColor"/>
			<meta><m n=":value"><e>FlxColor.TRANSPARENT</e></m></meta>
			<haxe_doc>* Internal, represents the color of `flash()` special effect.</haxe_doc>
		</_fxFlashColor>
		<_fxFlashDuration expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* Internal, stores `flash()` special effect duration.</haxe_doc>
		</_fxFlashDuration>
		<_fxFlashComplete expr="null">
			<f a=""><x path="Void"/></f>
			<meta><m n=":value"><e>null</e></m></meta>
			<haxe_doc>* Internal, camera's `flash()` complete callback.</haxe_doc>
		</_fxFlashComplete>
		<_fxFlashAlpha expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* Internal, used to control the `flash()` special effect.</haxe_doc>
		</_fxFlashAlpha>
		<_fxFadeColor expr="FlxColor.TRANSPARENT">
			<x path="flixel.util.FlxColor"/>
			<meta><m n=":value"><e>FlxColor.TRANSPARENT</e></m></meta>
			<haxe_doc>* Internal, color of fading special effect.</haxe_doc>
		</_fxFadeColor>
		<_lastTargetPosition>
			<c path="flixel.math.FlxPoint"/>
			<haxe_doc>* Used to calculate the following target current velocity.</haxe_doc>
		</_lastTargetPosition>
		<_scrollTarget expr="FlxPoint.get()">
			<c path="flixel.math.FlxPoint"/>
			<meta><m n=":value"><e>FlxPoint.get()</e></m></meta>
			<haxe_doc>* Helper to calculate follow target current scroll.</haxe_doc>
		</_scrollTarget>
		<_fxFadeDuration expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* Internal, `fade()` special effect duration.</haxe_doc>
		</_fxFadeDuration>
		<_fxFadeIn expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
			<haxe_doc>* Internal, "direction" of the `fade()` effect.
	 * `true` means that camera fades from a color, `false` - camera fades to it.</haxe_doc>
		</_fxFadeIn>
		<_fxFadeComplete expr="null">
			<f a=""><x path="Void"/></f>
			<meta><m n=":value"><e>null</e></m></meta>
			<haxe_doc>* Internal, used to control the `fade()` special effect complete callback.</haxe_doc>
		</_fxFadeComplete>
		<_fxFadeCompleted expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
			<haxe_doc>* Internal, tracks whether fade effect is running or not.</haxe_doc>
		</_fxFadeCompleted>
		<_fxFadeAlpha expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* Internal, alpha component of fade color.
	 * Changes from 0 to 1 or from 1 to 0 as the effect continues.</haxe_doc>
		</_fxFadeAlpha>
		<_fxShakeIntensity expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* Internal, percentage of screen size representing the maximum distance that the screen can move while shaking.</haxe_doc>
		</_fxShakeIntensity>
		<_fxShakeDuration expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* Internal, duration of the `shake()` effect.</haxe_doc>
		</_fxShakeDuration>
		<_fxShakeComplete>
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Internal, `shake()` effect complete callback.</haxe_doc>
		</_fxShakeComplete>
		<_fxShakeAxes expr="XY">
			<e path="flixel.util.FlxAxes"/>
			<meta><m n=":value"><e>XY</e></m></meta>
			<haxe_doc>* Internal, defines on what axes to `shake()`. Default value is `XY` / both.</haxe_doc>
		</_fxShakeAxes>
		<_point expr="FlxPoint.get()">
			<c path="flixel.math.FlxPoint"/>
			<meta><m n=":value"><e>FlxPoint.get()</e></m></meta>
			<haxe_doc>* Internal, used for repetitive calculations and added to help avoid costly allocations.</haxe_doc>
		</_point>
		<_filters>
			<c path="Array"><c path="openfl.filters.BitmapFilter"/></c>
			<haxe_doc>* Internal, the filters array to be applied to the camera.</haxe_doc>
		</_filters>
		<initialZoom public="1" set="null" expr="1">
			<x path="Float"/>
			<meta><m n=":value"><e>1</e></m></meta>
			<haxe_doc>* Camera's initial zoom value. Used for camera's scale handling.</haxe_doc>
		</initialZoom>
		<_fill>
			<t path="flash.display.BitmapData"/>
			<haxe_doc>* Internal helper variable for doing better wipes/fills between renders.
	 * Used it blit render mode only (in `fill()` method).</haxe_doc>
		</_fill>
		<_flashBitmap>
			<t path="flash.display.Bitmap"/>
			<haxe_doc>* Internal, used to render buffer to screen space. Used it blit render mode only.
	 * This Bitmap used for rendering camera's buffer (`_flashBitmap.bitmapData = buffer;`)
	 * Its position is modified by `updateInternalSpritePositions()`, which is called on camera's resize and scale events.
	 * It is a child of the `_scrollRect` `Sprite`.</haxe_doc>
		</_flashBitmap>
		<_scrollRect expr="new Sprite()">
			<t path="flash.display.Sprite"/>
			<meta><m n=":value"><e>new Sprite()</e></m></meta>
			<haxe_doc>* Internal sprite, used for correct trimming of camera viewport.
	 * It is a child of `flashSprite`.
	 * Its position is modified by `updateScrollRect()` method, which is called on camera's resize and scale events.</haxe_doc>
		</_scrollRect>
		<_bounds expr="FlxRect.get()">
			<c path="flixel.math.FlxRect"/>
			<meta><m n=":value"><e>FlxRect.get()</e></m></meta>
			<haxe_doc>* Helper rect for `drawTriangles()` visibility checks</haxe_doc>
		</_bounds>
		<canvas public="1">
			<t path="flash.display.Sprite"/>
			<haxe_doc>* Sprite used for actual rendering in tile render mode (instead of `_flashBitmap` for blitting).
	 * Its graphics is used as a drawing surface for `drawTriangles()` and `drawTiles()` methods.
	 * It is a child of `_scrollRect` `Sprite` (which trims graphics that should be invisible).
	 * Its position is modified by `updateInternalSpritePositions()`, which is called on camera's resize and scale events.</haxe_doc>
		</canvas>
		<debugLayer public="1">
			<t path="flash.display.Sprite"/>
			<haxe_doc>* Sprite for visual effects (flash and fade) and drawDebug information 
	 * (bounding boxes are drawn on it) for tile render mode.
	 * It is a child of `_scrollRect` `Sprite` (which trims graphics that should be invisible).
	 * Its position is modified by `updateInternalSpritePositions()`, which is called on camera's resize and scale events.</haxe_doc>
		</debugLayer>
		<_helperMatrix expr="new FlxMatrix()">
			<c path="flixel.math.FlxMatrix"/>
			<meta><m n=":value"><e>new FlxMatrix()</e></m></meta>
		</_helperMatrix>
		<_helperPoint expr="new Point()">
			<t path="flash.geom.Point"/>
			<meta><m n=":value"><e>new Point()</e></m></meta>
		</_helperPoint>
		<_currentDrawItem>
			<c path="flixel.graphics.tile.FlxDrawBaseItem"><d/></c>
			<haxe_doc>* Currently used draw stack item</haxe_doc>
		</_currentDrawItem>
		<_headOfDrawStack>
			<c path="flixel.graphics.tile.FlxDrawBaseItem"><d/></c>
			<haxe_doc>* Pointer to head of stack with draw items</haxe_doc>
		</_headOfDrawStack>
		<_headTiles>
			<c path="flixel.graphics.tile.FlxDrawTilesItem"/>
			<haxe_doc>* Last draw tiles item</haxe_doc>
		</_headTiles>
		<_headTriangles>
			<c path="flixel.graphics.tile.FlxDrawTrianglesItem"/>
			<haxe_doc>* Last draw triangles item</haxe_doc>
		</_headTriangles>
		<startQuadBatch public="1" set="method" line="453">
			<f a="graphic:colored:?hasColorOffsets:?blend:?smooth:?shader" v="::false::false:">
				<c path="flixel.graphics.FlxGraphic"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="openfl.display.BlendMode"/>
				<x path="Bool"/>
				<t path="flixel.system.FlxShader"/>
				<c path="flixel.graphics.tile.FlxDrawTilesItem"/>
			</f>
			<meta>
				<m n=":value"><e>{ smooth : false, hasColorOffsets : false }</e></m>
				<m n=":noCompletion"/>
			</meta>
		</startQuadBatch>
		<startTrianglesBatch public="1" set="method" line="512">
			<f a="graphic:?smoothing:?isColored:?blend" v=":false:false:">
				<c path="flixel.graphics.FlxGraphic"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="openfl.display.BlendMode"/>
				<c path="flixel.graphics.tile.FlxDrawTrianglesItem"/>
			</f>
			<meta>
				<m n=":value"><e>{ isColored : false, smoothing : false }</e></m>
				<m n=":noCompletion"/>
			</meta>
		</startTrianglesBatch>
		<getNewDrawTrianglesItem public="1" set="method" line="530">
			<f a="graphic:?smoothing:?isColored:?blend" v=":false:false:">
				<c path="flixel.graphics.FlxGraphic"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="openfl.display.BlendMode"/>
				<c path="flixel.graphics.tile.FlxDrawTrianglesItem"/>
			</f>
			<meta>
				<m n=":value"><e>{ isColored : false, smoothing : false }</e></m>
				<m n=":noCompletion"/>
			</meta>
		</getNewDrawTrianglesItem>
		<clearDrawStack set="method" line="572">
			<f a=""><x path="Void"/></f>
			<meta><m n=":allow"><e>flixel.system.frontEnds.CameraFrontEnd</e></m></meta>
		</clearDrawStack>
		<render set="method" line="605">
			<f a=""><x path="Void"/></f>
			<meta><m n=":allow"><e>flixel.system.frontEnds.CameraFrontEnd</e></m></meta>
		</render>
		<drawPixels public="1" set="method" line="615">
			<f a="?frame:?pixels:matrix:?transform:?blend:?smoothing:?shader" v=":::::false:">
				<c path="flixel.graphics.frames.FlxFrame"/>
				<t path="flash.display.BitmapData"/>
				<c path="flixel.math.FlxMatrix"/>
				<t path="flash.geom.ColorTransform"/>
				<x path="openfl.display.BlendMode"/>
				<x path="Bool"/>
				<t path="flixel.system.FlxShader"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ smoothing : false }</e></m></meta>
		</drawPixels>
		<copyPixels public="1" set="method" line="647">
			<f a="?frame:?pixels:?sourceRect:destPoint:?transform:?blend:?smoothing:?shader" v="::::::false:">
				<c path="flixel.graphics.frames.FlxFrame"/>
				<t path="flash.display.BitmapData"/>
				<t path="flash.geom.Rectangle"/>
				<t path="flash.geom.Point"/>
				<t path="flash.geom.ColorTransform"/>
				<x path="openfl.display.BlendMode"/>
				<x path="Bool"/>
				<t path="flixel.system.FlxShader"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ smoothing : false }</e></m></meta>
		</copyPixels>
		<drawTriangles public="1" set="method" line="691">
			<f a="graphic:vertices:indices:uvtData:?colors:?position:?blend:?repeat:?smoothing" v=":::::::false:false">
				<c path="flixel.graphics.FlxGraphic"/>
				<t path="flixel.graphics.tile.DrawData"><x path="Float"/></t>
				<t path="flixel.graphics.tile.DrawData"><x path="Int"/></t>
				<t path="flixel.graphics.tile.DrawData"><x path="Float"/></t>
				<t path="flixel.graphics.tile.DrawData"><x path="Int"/></t>
				<c path="flixel.math.FlxPoint"/>
				<x path="openfl.display.BlendMode"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ smoothing : false, repeat : false }</e></m></meta>
		</drawTriangles>
		<transformRect set="method" line="782">
			<f a="rect">
				<c path="flixel.math.FlxRect"/>
				<c path="flixel.math.FlxRect"/>
			</f>
			<haxe_doc>* Helper method preparing debug rectangle for rendering in blit render mode
	 * @param	rect	rectangle to prepare for rendering
	 * @return	transformed rectangle with respect to camera's zoom factor</haxe_doc>
		</transformRect>
		<transformPoint set="method" line="805">
			<f a="point">
				<c path="flixel.math.FlxPoint"/>
				<c path="flixel.math.FlxPoint"/>
			</f>
			<haxe_doc>* Helper method preparing debug point for rendering in blit render mode (for debug path rendering, for example)
	 * @param	point		point to prepare for rendering
	 * @return	transformed point with respect to camera's zoom factor</haxe_doc>
		</transformPoint>
		<transformVector get="inline" set="null" line="823">
			<f a="vector">
				<c path="flixel.math.FlxPoint"/>
				<c path="flixel.math.FlxPoint"/>
			</f>
			<haxe_doc>* Helper method preparing debug vectors (relative positions) for rendering in blit render mode
	 * @param	vector	relative position to prepare for rendering
	 * @return	transformed vector with respect to camera's zoom factor</haxe_doc>
		</transformVector>
		<transformObject set="method" line="838">
			<f a="object">
				<t path="flash.display.DisplayObject"/>
				<t path="flash.display.DisplayObject"/>
			</f>
			<haxe_doc>* Helper method for applying transformations (scaling and offsets) 
	 * to specified display objects which has been added to the camera display list.
	 * For example, debug sprite for nape debug rendering.
	 * @param	object	display object to apply transformations to.
	 * @return	transformed object.</haxe_doc>
		</transformObject>
		<destroy public="1" set="method" line="916" override="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Clean up memory.</haxe_doc>
		</destroy>
		<update public="1" set="method" line="975" override="1">
			<f a="elapsed">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Updates the camera scroll as well as special effects like screen-shake or fades.</haxe_doc>
		</update>
		<updateScroll public="1" set="method" line="997">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Updates (bounds) the camera scroll.
	 * Called every frame by camera's `update()` method.</haxe_doc>
		</updateScroll>
		<updateFollow public="1" set="method" line="1016">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Updates camera's scroll.
	 * Called every frame by camera's `update()` method (if camera's `target` isn't `null`).</haxe_doc>
		</updateFollow>
		<updateFlash set="method" line="1102"><f a="elapsed">
	<x path="Float"/>
	<x path="Void"/>
</f></updateFlash>
		<updateFade set="method" line="1115"><f a="elapsed">
	<x path="Float"/>
	<x path="Void"/>
</f></updateFade>
		<completeFade set="method" line="1140"><f a=""><x path="Void"/></f></completeFade>
		<updateShake set="method" line="1147"><f a="elapsed">
	<x path="Float"/>
	<x path="Void"/>
</f></updateShake>
		<updateFlashSpritePosition set="method" line="1177">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Recalculates `flashSprite` position.
	 * Called every frame by camera's `update()` method and every time you change camera's position.</haxe_doc>
		</updateFlashSpritePosition>
		<updateFlashOffset set="method" line="1190">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Recalculates `_flashOffset` point, which is used for positioning flashSprite in the game.
	 * It's called every time you resize the camera or the game.</haxe_doc>
		</updateFlashOffset>
		<updateScrollRect set="method" line="1204">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Updates `_scrollRect` sprite to crop graphics of the camera:
	 * 1) `scrollRect` property of this sprite
	 * 2) position of this sprite inside `flashSprite`
	 * 
	 * It takes camera's size and game's scale into account.
	 * It's called every time you resize the camera or the game.</haxe_doc>
		</updateScrollRect>
		<updateInternalSpritePositions set="method" line="1228">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Modifies position of `_flashBitmap` in blit render mode and `canvas` and `debugSprite`
	 * in tile render mode (these objects are children of `_scrollRect` sprite).
	 * It takes camera's size and game's scale into account.
	 * It's called every time you resize the camera or the game.</haxe_doc>
		</updateInternalSpritePositions>
		<follow public="1" set="method" line="1271">
			<f a="Target:?Style:?Lerp">
				<c path="flixel.FlxObject"/>
				<e path="flixel.FlxCameraFollowStyle"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Tells this camera object what `FlxObject` to track.
	 * 
	 * @param   Target   The object you want the camera to track. Set to `null` to not follow anything.
	 * @param   Style    Leverage one of the existing "deadzone" presets. Default is `LOCKON`.
	 *                   If you use a custom deadzone, ignore this parameter and
	 *                   manually specify the deadzone after calling `follow()`.
	 * @param   Lerp     How much lag the camera should have (can help smooth out the camera movement).</haxe_doc>
		</follow>
		<snapToTarget public="1" set="method" line="1322">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Snaps the camera to the current `target`. Useful to move the camera without
	 * any easing when the `target` position changes and there is a `followLerp`.</haxe_doc>
		</snapToTarget>
		<focusOn public="1" get="inline" set="null" line="1333">
			<f a="point">
				<c path="flixel.math.FlxPoint"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Move the camera focus to this location instantly.
	 * 
	 * @param   Point   Where you want the camera to focus.</haxe_doc>
		</focusOn>
		<flash public="1" set="method" line="1347">
			<f a="?Color:?Duration:?OnComplete:?Force" v="FlxColor.WHITE:1::false">
				<x path="flixel.util.FlxColor"/>
				<x path="Float"/>
				<f a=""><x path="Void"/></f>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ Force : false, Duration : 1, Color : FlxColor.WHITE }</e></m></meta>
			<haxe_doc>* The screen is filled with this color and gradually returns to normal.
	 * 
	 * @param   Color        The color you want to use.
	 * @param   Duration     How long it takes for the flash to fade.
	 * @param   OnComplete   A function you want to run when the flash finishes.
	 * @param   Force        Force the effect to reset.</haxe_doc>
		</flash>
		<fade public="1" set="method" line="1370">
			<f a="?Color:?Duration:?FadeIn:?OnComplete:?Force" v="FlxColor.BLACK:1:false::false">
				<x path="flixel.util.FlxColor"/>
				<x path="Float"/>
				<x path="Bool"/>
				<f a=""><x path="Void"/></f>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ Force : false, FadeIn : false, Duration : 1, Color : FlxColor.BLACK }</e></m></meta>
			<haxe_doc>* The screen is gradually filled with this color.
	 * 
	 * @param   Color        The color you want to use.
	 * @param   Duration     How long it takes for the fade to finish.
	 * @param   FadeIn       `true` fades from a color, `false` fades to it.
	 * @param   OnComplete   A function you want to run when the fade finishes.
	 * @param   Force        Force the effect to reset.</haxe_doc>
		</fade>
		<shake public="1" set="method" line="1398">
			<f a="?Intensity:?Duration:?OnComplete:?Force:?Axes" v="0.05:0.5::true:">
				<x path="Float"/>
				<x path="Float"/>
				<f a=""><x path="Void"/></f>
				<x path="Bool"/>
				<e path="flixel.util.FlxAxes"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ Force : true, Duration : 0.5, Intensity : 0.05 }</e></m></meta>
			<haxe_doc>* A simple screen-shake effect.
	 * 
	 * @param   Intensity    Percentage of screen size representing the maximum distance
	 *                       that the screen can move while shaking.
	 * @param   Duration     The length in seconds that the shaking effect should last.
	 * @param   OnComplete   A function you want to run when the shake effect finishes.
	 * @param   Force        Force the effect to reset (default = `true`, unlike `flash()` and `fade()`!).
	 * @param   Axes         On what axes to shake. Default value is `FlxAxes.XY` / both.</haxe_doc>
		</shake>
		<stopFX public="1" set="method" line="1416">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Just turns off all the camera effects instantly.</haxe_doc>
		</stopFX>
		<setFilters public="1" set="method" line="1427">
			<f a="filters">
				<c path="Array"><c path="openfl.filters.BitmapFilter"/></c>
				<x path="Void"/>
			</f>
			<haxe_doc>* Sets the filter array to be applied to the camera.</haxe_doc>
		</setFilters>
		<copyFrom public="1" set="method" line="1438">
			<f a="Camera">
				<c path="flixel.FlxCamera"/>
				<c path="flixel.FlxCamera"/>
			</f>
			<haxe_doc>* Copy the bounds, focus object, and `deadzone` info from an existing camera.
	 * 
	 * @param   Camera  The camera you want to copy from.
	 * @return  A reference to this `FlxCamera` object.</haxe_doc>
		</copyFrom>
		<fill public="1" set="method" line="1468">
			<f a="Color:?BlendAlpha:?FxAlpha:?graphics" v=":true:1.0:">
				<x path="flixel.util.FlxColor"/>
				<x path="Bool"/>
				<x path="Float"/>
				<t path="flash.display.Graphics"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ FxAlpha : 1.0, BlendAlpha : true }</e></m></meta>
			<haxe_doc>* Fill the camera with the specified color.
	 * 
	 * @param   Color        The color to fill with in `0xAARRGGBB` hex format.
	 * @param   BlendAlpha   Whether to blend the alpha value or just wipe the previous contents. Default is `true`.</haxe_doc>
		</fill>
		<drawFX set="method" line="1503">
			<f a=""><x path="Void"/></f>
			<meta><m n=":allow"><e>flixel.system.frontEnds.CameraFrontEnd</e></m></meta>
			<haxe_doc>* Internal helper function, handles the actual drawing of all the special effects.</haxe_doc>
		</drawFX>
		<checkResize set="method" line="1539">
			<f a=""><x path="Void"/></f>
			<meta><m n=":allow"><e>flixel.system.frontEnds.CameraFrontEnd</e></m></meta>
		</checkResize>
		<updateBlitMatrix get="inline" set="null" line="1561"><f a=""><x path="Void"/></f></updateBlitMatrix>
		<setSize public="1" get="inline" set="null" line="1576">
			<f a="Width:Height">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Shortcut for setting both `width` and `height`.
	 * 
	 * @param   Width    The new camera width.
	 * @param   Height   The new camera height.</haxe_doc>
		</setSize>
		<setPosition public="1" get="inline" set="null" line="1589">
			<f a="?X:?Y" v="0:0">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ Y : 0, X : 0 }</e></m></meta>
			<haxe_doc>* Helper function to set the coordinates of this camera.
	 * Handy since it only requires one line of code.
	 * 
	 * @param   X   The new x position.
	 * @param   Y   The new y position.</haxe_doc>
		</setPosition>
		<setScrollBoundsRect public="1" set="method" line="1604">
			<f a="?X:?Y:?Width:?Height:?UpdateWorld" v="0:0:0:0:false">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ UpdateWorld : false, Height : 0, Width : 0, Y : 0, X : 0 }</e></m></meta>
			<haxe_doc>* Specify the bounding rectangle of where the camera is allowed to move.
	 * 
	 * @param   X             The smallest X value of your level (usually `0`).
	 * @param   Y             The smallest Y value of your level (usually `0`).
	 * @param   Width         The largest X value of your level (usually the level width).
	 * @param   Height        The largest Y value of your level (usually the level height).
	 * @param   UpdateWorld   Whether the global quad-tree's dimensions should be updated to match (default: `false`).</haxe_doc>
		</setScrollBoundsRect>
		<setScrollBounds public="1" set="method" line="1624">
			<f a="MinX:MaxX:MinY:MaxY">
				<t path="Null"><x path="Float"/></t>
				<t path="Null"><x path="Float"/></t>
				<t path="Null"><x path="Float"/></t>
				<t path="Null"><x path="Float"/></t>
				<x path="Void"/>
			</f>
			<haxe_doc>* Specify the bounds of where the camera is allowed to move.
	 * Set the boundary of a side to `null` to leave that side unbounded.
	 * 
	 * @param   MinX   The minimum X value the camera can scroll to
	 * @param   MaxX   The maximum X value the camera can scroll to
	 * @param   MinY   The minimum Y value the camera can scroll to
	 * @param   MaxY   The maximum Y value the camera can scroll to</haxe_doc>
		</setScrollBounds>
		<setScale public="1" set="method" line="1640">
			<f a="X:Y">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Helper function to set the scale of this camera.
	 * Handy since it only requires one line of code.
	 * 
	 * @param   X   The new scale on x axis
	 * @param   Y   The new scale of y axis</haxe_doc>
		</setScale>
		<onResize public="1" set="method" line="1677">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Called by camera front end every time you resize the game.
	 * It triggers reposition of camera's internal display objects.</haxe_doc>
		</onResize>
		<containsPoint public="1" get="inline" set="null" line="1688">
			<f a="point:?width:?height" v=":0:0">
				<c path="flixel.math.FlxPoint"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":value"><e>{ height : 0, width : 0 }</e></m></meta>
			<haxe_doc>* Checks whether this camera contains a given point or rectangle, in
	 * screen coordinates.
	 * @since 4.3.0</haxe_doc>
		</containsPoint>
		<set_followLerp set="method" line="1693"><f a="Value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_followLerp>
		<set_width set="method" line="1698"><f a="Value">
	<x path="Int"/>
	<x path="Int"/>
</f></set_width>
		<set_height set="method" line="1713"><f a="Value">
	<x path="Int"/>
	<x path="Int"/>
</f></set_height>
		<set_zoom set="method" line="1728"><f a="Zoom">
	<x path="Float"/>
	<x path="Float"/>
</f></set_zoom>
		<set_alpha set="method" line="1735"><f a="Alpha">
	<x path="Float"/>
	<x path="Float"/>
</f></set_alpha>
		<set_angle set="method" line="1749"><f a="Angle">
	<x path="Float"/>
	<x path="Float"/>
</f></set_angle>
		<set_color set="method" line="1756"><f a="Color">
	<x path="flixel.util.FlxColor"/>
	<x path="flixel.util.FlxColor"/>
</f></set_color>
		<set_antialiasing set="method" line="1790"><f a="Antialiasing">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_antialiasing>
		<set_x set="method" line="1800"><f a="x">
	<x path="Float"/>
	<x path="Float"/>
</f></set_x>
		<set_y set="method" line="1807"><f a="y">
	<x path="Float"/>
	<x path="Float"/>
</f></set_y>
		<set_visible set="method" line="1814" override="1"><f a="visible">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_visible>
		<calcOffsetX get="inline" set="null" line="1823"><f a=""><x path="Void"/></f></calcOffsetX>
		<calcOffsetY get="inline" set="null" line="1830"><f a=""><x path="Void"/></f></calcOffsetY>
		<new public="1" set="method" line="862">
			<f a="?X:?Y:?Width:?Height:?Zoom" v="0:0:0:0:0">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ Zoom : 0, Height : 0, Width : 0, Y : 0, X : 0 }</e></m></meta>
			<haxe_doc>* Instantiates a new camera at the specified location, with the specified size and zoom level.
	 * 
	 * @param   X        X location of the camera's display in pixels. Uses native, 1:1 resolution, ignores zoom.
	 * @param   Y        Y location of the camera's display in pixels. Uses native, 1:1 resolution, ignores zoom.
	 * @param   Width    The width of the camera display in pixels.
	 * @param   Height   The height of the camera display in pixels.
	 * @param   Zoom     The initial zoom level of the camera.
	 *                   A zoom level of 2 will make all pixels display at 2x resolution.</haxe_doc>
		</new>
		<haxe_doc><![CDATA[* The camera class is used to display the game's visuals.
 * By default one camera is created automatically, that is the same size as window.
 * You can add more cameras or even replace the main camera using utilities in `FlxG.cameras`.
 * 
 * Every camera has following display list:
 * `flashSprite:Sprite` (which is a container for everything else in the camera, it's added to FlxG.game sprite)
 *     |-> `_scrollRect:Sprite` (which is used for cropping camera's graphic, mostly in tile render mode)
 *         |-> `_flashBitmap:Bitmap`  (its bitmapData property is buffer BitmapData, this var is used in blit render mode.
 *                                    Everything is rendered on buffer in blit render mode)
 *         |-> `canvas:Sprite`        (its graphics is used for rendering objects in tile render mode)
 *         |-> `debugLayer:Sprite`    (this sprite is used in tile render mode for rendering debug info, like bounding boxes)]]></haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<enum path="flixel.FlxCameraFollowStyle" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/FlxCamera.hx" module="flixel.FlxCamera">
		<LOCKON><haxe_doc>* Camera has no deadzone, just tracks the focus object directly.</haxe_doc></LOCKON>
		<PLATFORMER><haxe_doc>* Camera's deadzone is narrow but tall.</haxe_doc></PLATFORMER>
		<TOPDOWN><haxe_doc>* Camera's deadzone is a medium-size square around the focus object.</haxe_doc></TOPDOWN>
		<TOPDOWN_TIGHT><haxe_doc>* Camera's deadzone is a small square around the focus object.</haxe_doc></TOPDOWN_TIGHT>
		<SCREEN_BY_SCREEN><haxe_doc>* Camera will move screenwise.</haxe_doc></SCREEN_BY_SCREEN>
		<NO_DEAD_ZONE><haxe_doc>* Camera has no deadzone, just tracks the focus object directly and centers it.</haxe_doc></NO_DEAD_ZONE>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<class path="flixel.system.FlxVersion" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/system/FlxVersion.hx">
		<sha public="1" set="null" expr="&quot;&quot;" line="39" static="1">
			<d/>
			<meta><m n=":value"><e>""</e></m></meta>
		</sha>
		<major public="1" set="null"><x path="Int"/></major>
		<minor public="1" set="null"><x path="Int"/></minor>
		<patch public="1" set="null"><x path="Int"/></patch>
		<toString public="1" set="method" line="26">
			<f a=""><c path="String"/></f>
			<haxe_doc>* Formats the version in the format "HaxeFlixel MAJOR.MINOR.PATCH-COMMIT_SHA", 
	 * e.g. HaxeFlixel 3.0.4.
	 * If this is a dev version, the git sha is included.</haxe_doc>
		</toString>
		<new public="1" set="method" line="14"><f a="Major:Minor:Patch">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>* Helper object for semantic versioning.
 * @see   http://semver.org/</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>flixel.system.macros.FlxGitSHA.buildGitSHA("flixel")</e></m>
		</meta>
	</class>
	<class path="flixel.system.frontEnds.BitmapFrontEnd" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/system/frontEnds/BitmapFrontEnd.hx">
		<maxTextureSize public="1" get="accessor" set="null">
			<x path="Int"/>
			<haxe_doc>* Gets max texture size for native targets</haxe_doc>
		</maxTextureSize>
		<whitePixel public="1" get="accessor" set="null">
			<c path="flixel.graphics.frames.FlxFrame"/>
			<haxe_doc>* Helper FlxFrame object. Containing only one frame.
	 * Useful for drawing colored rectangles of all sizes in FlxG.renderTile mode.</haxe_doc>
		</whitePixel>
		<_cache>
			<x path="Map">
				<c path="String"/>
				<c path="flixel.graphics.FlxGraphic"/>
			</x>
			<meta><m n=":allow"><e>flixel.system.frontEnds.BitmapLogFrontEnd</e></m></meta>
		</_cache>
		<_whitePixel><c path="flixel.graphics.frames.FlxFrame"/></_whitePixel>
		<_lastUniqueKeyIndex expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</_lastUniqueKeyIndex>
		<onAssetsReload public="1" set="method" line="46"><f a="_">
	<unknown/>
	<x path="Void"/>
</f></onAssetsReload>
		<onContext public="1" set="method" line="62">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* New context handler.
	 * Regenerates tilesheets for all dumped graphics objects in the cache.</haxe_doc>
		</onContext>
		<dumpCache public="1" set="method" line="78">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Dumps bits of all graphics in the cache. This frees some memory, but you can't read/write pixels on those graphics anymore.
	 * You can call undump() method for each FlxGraphic (or undumpCache()) object which will restore it again.</haxe_doc>
		</dumpCache>
		<undumpCache public="1" set="method" line="95">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Restores graphics of all dumped objects in the cache.</haxe_doc>
		</undumpCache>
		<checkCache public="1" get="inline" set="null" line="115">
			<f a="Key">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Check the local bitmap cache to see if a bitmap with this key has been loaded already.
	 * 
	 * @param	Key		The string key identifying the bitmap.
	 * @return	Whether or not this file can be found in the cache.</haxe_doc>
		</checkCache>
		<create public="1" set="method" line="130">
			<f a="Width:Height:Color:?Unique:?Key" v=":::false:">
				<x path="Int"/>
				<x path="Int"/>
				<x path="flixel.util.FlxColor"/>
				<x path="Bool"/>
				<c path="String"/>
				<c path="flixel.graphics.FlxGraphic"/>
			</f>
			<meta><m n=":value"><e>{ Unique : false }</e></m></meta>
			<haxe_doc>* Generates a new BitmapData object (a colored rectangle) and caches it.
	 * 
	 * @param	Width	How wide the rectangle should be.
	 * @param	Height	How high the rectangle should be.
	 * @param	Color	What color the rectangle should be (0xAARRGGBB)
	 * @param	Unique	Ensures that the bitmap data uses a new slot in the cache.
	 * @param	Key		Force the cache to use a specific Key to index the bitmap.
	 * @return	The BitmapData we just created.</haxe_doc>
		</create>
		<add public="1" set="method" line="146">
			<f a="Graphic:?Unique:?Key" v=":false:">
				<t path="flixel.system.FlxGraphicAsset"/>
				<x path="Bool"/>
				<c path="String"/>
				<c path="flixel.graphics.FlxGraphic"/>
			</f>
			<meta><m n=":value"><e>{ Unique : false }</e></m></meta>
			<haxe_doc>* Loads a bitmap from a file, clones it if necessary and caches it.
	 * @param	Graphic		Optional FlxGraphics object to create FlxGraphic from.
	 * @param	Frames			Optional FlxFramesCollection object to create FlxGraphic from.
	 * @param	Bitmap			Optional BitmapData object to create FlxGraphic from.
	 * @param	BitmapClass	Optional Class for BitmapData to create FlxGraphic from.
	 * @param	Str			Optional String key to use for FlxGraphic instantiation.
	 * @param	Unique			Ensures that the bitmap data uses a new slot in the cache.
	 * @param	Key				Force the cache to use a specific Key to index the bitmap.
	 * @return	The FlxGraphic we just created.</haxe_doc>
		</add>
		<addGraphic public="1" get="inline" set="null" line="167">
			<f a="graphic">
				<c path="flixel.graphics.FlxGraphic"/>
				<c path="flixel.graphics.FlxGraphic"/>
			</f>
			<haxe_doc>* Caches specified FlxGraphic object.
	 * 
	 * @param	graphic	FlxGraphic to store in the cache.
	 * @return	cached FlxGraphic object.</haxe_doc>
		</addGraphic>
		<get public="1" get="inline" set="null" line="178">
			<f a="key">
				<c path="String"/>
				<c path="flixel.graphics.FlxGraphic"/>
			</f>
			<haxe_doc>* Gets FlxGraphic object from this storage by specified key. 
	 * @param	key	Key for FlxGraphic object (its name)
	 * @return	FlxGraphic with the key name, or null if there is no such object</haxe_doc>
		</get>
		<findKeyForBitmap public="1" set="method" line="189">
			<f a="bmd">
				<t path="flash.display.BitmapData"/>
				<c path="String"/>
			</f>
			<haxe_doc>* Gets key from bitmap cache for specified BitmapData
	 * 
	 * @param	bmd	BitmapData to find in cache
	 * @return	BitmapData's key or null if there isn't such BitmapData in cache</haxe_doc>
		</findKeyForBitmap>
		<getKeyForClass public="1" get="inline" set="null" line="205">
			<f a="source">
				<x path="Class"><d/></x>
				<c path="String"/>
			</f>
			<haxe_doc>* Helper method for getting cache key for FlxGraphic objects created from the class.
	 * 
	 * @param	source	BitmapData source class. 
	 * @return	Full name for provided class.</haxe_doc>
		</getKeyForClass>
		<generateKey public="1" set="method" line="218">
			<f a="systemKey:userKey:?unique" v="::false">
				<c path="String"/>
				<c path="String"/>
				<x path="Bool"/>
				<c path="String"/>
			</f>
			<meta><m n=":value"><e>{ unique : false }</e></m></meta>
			<haxe_doc>* Creates string key for further caching.
	 * 
	 * @param	systemKey	The first string key to use as a base for a new key. It's usually a key from openfl.Assets ("assets/image.png").
	 * @param	userKey		The second string key to use as a base for a new key. It's usually a key provided by the user
	 * @param	unique		Whether generated key should be unique or not.
	 * @return	Created key.</haxe_doc>
		</generateKey>
		<getUniqueKey public="1" set="method" line="236">
			<f a="?baseKey">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>* Gets unique key for bitmap cache
	 * 
	 * @param	baseKey	key's prefix
	 * @return	unique key</haxe_doc>
		</getUniqueKey>
		<getKeyWithSpacesAndBorders public="1" set="method" line="267">
			<f a="baseKey:?frameSize:?frameSpacing:?frameBorder:?region">
				<c path="String"/>
				<c path="flixel.math.FlxPoint"/>
				<c path="flixel.math.FlxPoint"/>
				<c path="flixel.math.FlxPoint"/>
				<c path="flixel.math.FlxRect"/>
				<c path="String"/>
			</f>
			<haxe_doc>* Generates key from provided base key and information about tile size and offsets in spritesheet 
	 * and the region of image to use as spritesheet graphics source.
	 * 
	 * @param	baseKey			Beginning of the key. Usually it is the key for original spritesheet graphics (like "assets/tile.png") 
	 * @param	frameSize		the size of tile in spritesheet
	 * @param	frameSpacing	offsets between tiles in offsets
	 * @param	region			region of image to use as spritesheet graphics source
	 * @return	Generated key for spritesheet with inserted spaces between tiles</haxe_doc>
		</getKeyWithSpacesAndBorders>
		<remove public="1" set="method" line="290">
			<f a="graphic">
				<c path="flixel.graphics.FlxGraphic"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Totally removes specified FlxGraphic object.
	 * @param	FlxGraphic object you want to remove and destroy.</haxe_doc>
		</remove>
		<removeByKey public="1" set="method" line="303">
			<f a="key">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Totally removes FlxGraphic object with specified key.
	 * @param	key	the key for cached FlxGraphic object.</haxe_doc>
		</removeByKey>
		<removeIfNoUse public="1" set="method" line="315"><f a="graphic">
	<c path="flixel.graphics.FlxGraphic"/>
	<x path="Void"/>
</f></removeIfNoUse>
		<clearCache public="1" set="method" line="325">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Clears image cache (and destroys those images).
	 * Graphics object will be removed and destroyed only if it shouldn't persist in the cache and its useCount is 0.</haxe_doc>
		</clearCache>
		<removeKey get="inline" set="null" line="344"><f a="key">
	<c path="String"/>
	<x path="Void"/>
</f></removeKey>
		<reset public="1" set="method" line="356">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Completely resets bitmap cache, which means destroying ALL of the cached FlxGraphic objects.</haxe_doc>
		</reset>
		<clearUnused public="1" set="method" line="378">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Removes all unused graphics from cache,
	 * but skips graphics which should persist in cache and shouldn't be destroyed on no use.</haxe_doc>
		</clearUnused>
		<get_maxTextureSize set="method" line="391"><f a=""><x path="Int"/></f></get_maxTextureSize>
		<get_whitePixel set="method" line="397"><f a=""><c path="flixel.graphics.frames.FlxFrame"/></f></get_whitePixel>
		<new public="1" set="method" line="41"><f a=""><x path="Void"/></f></new>
		<haxe_doc>* Internal storage system to prevent graphics from being used repeatedly in memory.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="flixel.system.frontEnds.BitmapLogFrontEnd" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/system/frontEnds/BitmapLogFrontEnd.hx">
		<add public="1" get="inline" set="null" line="8">
			<f a="Data:?Name" v=":&quot;&quot;">
				<t path="flash.display.BitmapData"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ Name : "" }</e></m></meta>
		</add>
		<clear public="1" get="inline" set="null" line="18">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Clears all bitmaps</haxe_doc>
		</clear>
		<clearAt public="1" get="inline" set="null" line="29">
			<f a="?Index" v="-1">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ Index : -1 }</e></m></meta>
			<haxe_doc>* Clear one bitmap object from the log -- the last one, by default 
	 * @param	Index</haxe_doc>
		</clearAt>
		<viewCache public="1" set="method" line="39">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Clears the bitmapLog window and adds the entire cache to it.</haxe_doc>
		</viewCache>
		<new set="method" line="51">
			<f a=""><x path="Void"/></f>
			<meta><m n=":allow"><e>flixel.FlxG</e></m></meta>
		</new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="flixel.system.frontEnds.CameraFrontEnd" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/system/frontEnds/CameraFrontEnd.hx">
		<list public="1" set="null" expr="[]">
			<c path="Array"><c path="flixel.FlxCamera"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
			<haxe_doc>* An array listing FlxCamera objects that are used to draw stuff.
	 * By default flixel creates one camera the size of the screen.</haxe_doc>
		</list>
		<bgColor public="1" get="accessor" set="accessor">
			<x path="flixel.util.FlxColor"/>
			<haxe_doc>* The current (global, applies to all cameras) bgColor.</haxe_doc>
		</bgColor>
		<cameraAdded public="1" set="null" expr="new FlxTypedSignal&lt;FlxCamera&gt;()">
			<x path="flixel.util.FlxTypedSignal"><f a="">
	<c path="flixel.FlxCamera"/>
	<x path="Void"/>
</f></x>
			<meta><m n=":value"><e><![CDATA[new FlxTypedSignal<FlxCamera>()]]></e></m></meta>
			<haxe_doc>@since 4.2.0</haxe_doc>
		</cameraAdded>
		<cameraRemoved public="1" set="null" expr="new FlxTypedSignal&lt;FlxCamera&gt;()">
			<x path="flixel.util.FlxTypedSignal"><f a="">
	<c path="flixel.FlxCamera"/>
	<x path="Void"/>
</f></x>
			<meta><m n=":value"><e><![CDATA[new FlxTypedSignal<FlxCamera>()]]></e></m></meta>
			<haxe_doc>@since 4.2.0</haxe_doc>
		</cameraRemoved>
		<cameraResized public="1" set="null" expr="new FlxTypedSignal&lt;FlxCamera&gt;()">
			<x path="flixel.util.FlxTypedSignal"><f a="">
	<c path="flixel.FlxCamera"/>
	<x path="Void"/>
</f></x>
			<meta><m n=":value"><e><![CDATA[new FlxTypedSignal<FlxCamera>()]]></e></m></meta>
			<haxe_doc>@since 4.2.0</haxe_doc>
		</cameraResized>
		<useBufferLocking public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
			<haxe_doc>* Allows you to possibly slightly optimize the rendering process IF
	 * you are not doing any pre-processing in your game state's draw() call.</haxe_doc>
		</useBufferLocking>
		<_cameraRect expr="new Rectangle()">
			<t path="flash.geom.Rectangle"/>
			<meta><m n=":value"><e>new Rectangle()</e></m></meta>
			<haxe_doc>* Internal helper variable for clearing the cameras each frame.</haxe_doc>
		</_cameraRect>
		<add public="1" params="T" set="method" line="49">
			<f a="NewCamera">
				<c path="add.T"/>
				<c path="add.T"/>
			</f>
			<haxe_doc>* Add a new camera object to the game.
	 * Handy for PiP, split-screen, etc.
	 * 
	 * @param	NewCamera	The camera you want to add.
	 * @return	This FlxCamera instance.</haxe_doc>
		</add>
		<remove public="1" set="method" line="64">
			<f a="Camera:?Destroy" v=":true">
				<c path="flixel.FlxCamera"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ Destroy : true }</e></m></meta>
			<haxe_doc>* Remove a camera from the game.
	 * 
	 * @param   Camera    The camera you want to remove.
	 * @param   Destroy   Whether to call destroy() on the camera, default value is true.</haxe_doc>
		</remove>
		<reset public="1" set="method" line="98">
			<f a="?NewCamera">
				<c path="flixel.FlxCamera"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Dumps all the current cameras and resets to just one camera.
	 * Handy for doing split-screen especially.
	 * 
	 * @param	NewCamera	Optional; specify a specific camera object to be the new main camera.</haxe_doc>
		</reset>
		<flash public="1" set="method" line="120">
			<f a="?Color:?Duration:?OnComplete:?Force" v="FlxColor.WHITE:1::false">
				<x path="flixel.util.FlxColor"/>
				<x path="Float"/>
				<f a=""><x path="Void"/></f>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ Force : false, Duration : 1, Color : FlxColor.WHITE }</e></m></meta>
			<haxe_doc>* All screens are filled with this color and gradually return to normal.
	 * 
	 * @param	Color		The color you want to use.
	 * @param	Duration	How long it takes for the flash to fade.
	 * @param	OnComplete	A function you want to run when the flash finishes.
	 * @param	Force		Force the effect to reset.</haxe_doc>
		</flash>
		<fade public="1" set="method" line="137">
			<f a="?Color:?Duration:?FadeIn:?OnComplete:?Force" v="FlxColor.BLACK:1:false::false">
				<x path="flixel.util.FlxColor"/>
				<x path="Float"/>
				<x path="Bool"/>
				<f a=""><x path="Void"/></f>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ Force : false, FadeIn : false, Duration : 1, Color : FlxColor.BLACK }</e></m></meta>
			<haxe_doc>* The screen is gradually filled with this color.
	 * 
	 * @param	Color		The color you want to use.
	 * @param	Duration	How long it takes for the fade to finish.
	 * @param 	FadeIn 		True fades from a color, false fades to it.
	 * @param	OnComplete	A function you want to run when the fade finishes.
	 * @param	Force		Force the effect to reset.</haxe_doc>
		</fade>
		<shake public="1" set="method" line="154">
			<f a="?Intensity:?Duration:?OnComplete:?Force:?Axes" v="0.05:0.5::true:">
				<x path="Float"/>
				<x path="Float"/>
				<f a=""><x path="Void"/></f>
				<x path="Bool"/>
				<e path="flixel.util.FlxAxes"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ Force : true, Duration : 0.5, Intensity : 0.05 }</e></m></meta>
			<haxe_doc>* A simple screen-shake effect.
	 * 
	 * @param	Intensity	Percentage of screen size representing the maximum distance that the screen can move while shaking.
	 * @param	Duration	The length in seconds that the shaking effect should last.
	 * @param	OnComplete	A function you want to run when the shake effect finishes.
	 * @param	Force		Force the effect to reset (default = true, unlike flash() and fade()!).
	 * @param	Axes		On what axes to shake. Default value is XY / both.</haxe_doc>
		</shake>
		<lock get="inline" set="null" line="172">
			<f a=""><x path="Void"/></f>
			<meta><m n=":allow"><e>flixel.FlxGame</e></m></meta>
			<haxe_doc>* Called by the game object to lock all the camera buffers and clear them for the next draw pass.</haxe_doc>
		</lock>
		<render get="inline" set="null" line="214">
			<f a=""><x path="Void"/></f>
			<meta><m n=":allow"><e>flixel.FlxGame</e></m></meta>
		</render>
		<unlock get="inline" set="null" line="232">
			<f a=""><x path="Void"/></f>
			<meta><m n=":allow"><e>flixel.FlxGame</e></m></meta>
			<haxe_doc>* Called by the game object to draw the special FX and unlock all the camera buffers.</haxe_doc>
		</unlock>
		<update get="inline" set="null" line="259">
			<f a="elapsed">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":allow"><e>flixel.FlxGame</e></m></meta>
			<haxe_doc>* Called by the game object to update the cameras and their tracking/special effects logic.</haxe_doc>
		</update>
		<resize set="method" line="274">
			<f a=""><x path="Void"/></f>
			<meta><m n=":allow"><e>flixel.FlxGame</e></m></meta>
			<haxe_doc>* Resizes and moves cameras when the game resizes (onResize signal).</haxe_doc>
		</resize>
		<get_bgColor set="method" line="282"><f a=""><x path="flixel.util.FlxColor"/></f></get_bgColor>
		<set_bgColor set="method" line="287"><f a="Color">
	<x path="flixel.util.FlxColor"/>
	<x path="flixel.util.FlxColor"/>
</f></set_bgColor>
		<new set="method" line="163">
			<f a=""><x path="Void"/></f>
			<meta><m n=":allow"><e>flixel.FlxG</e></m></meta>
		</new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="flixel.system.frontEnds.ConsoleFrontEnd" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/system/frontEnds/ConsoleFrontEnd.hx">
		<autoPause public="1" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
			<haxe_doc>* Whether the console should auto-pause or not when it's focused.</haxe_doc>
		</autoPause>
		<stepAfterCommand public="1" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
			<haxe_doc>* Whether the console should `step()` the game after a command is entered.
	 * Setting this to `false` allows inputting multiple console commands within the same frame.
	 * Use the `step()` command to step the game from the console.
	 * @since 4.2.0</haxe_doc>
		</stepAfterCommand>
		<registerFunction public="1" get="inline" set="null" line="26">
			<f a="FunctionAlias:Function">
				<c path="String"/>
				<d/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Register a new function to use in any command.
	 * 
	 * @param 	FunctionAlias		The name with which you want to access the function.
	 * @param 	Function			The function to register.</haxe_doc>
		</registerFunction>
		<registerObject public="1" get="inline" set="null" line="39">
			<f a="ObjectAlias:AnyObject">
				<c path="String"/>
				<d/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Register a new object to use in any command.
	 * 
	 * @param 	ObjectAlias		The name with which you want to access the object.
	 * @param 	AnyObject		The object to register.</haxe_doc>
		</registerObject>
		<registerClass public="1" get="inline" set="null" line="51">
			<f a="cl">
				<x path="Class"><d/></x>
				<x path="Void"/>
			</f>
			<haxe_doc>* Register a new class to use in any command.
	 * 
	 * @param 	cl	The class to register.</haxe_doc>
		</registerClass>
		<new set="method" line="62">
			<f a=""><x path="Void"/></f>
			<meta><m n=":allow"><e>flixel.FlxG</e></m></meta>
			<haxe_doc>* Just needed to create an instance.</haxe_doc>
		</new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="flixel.system.frontEnds.DebuggerFrontEnd" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/system/frontEnds/DebuggerFrontEnd.hx">
		<precision public="1" expr="3">
			<x path="Int"/>
			<meta><m n=":value"><e>3</e></m></meta>
			<haxe_doc>* The amount of decimals Floats are rounded to in the debugger.</haxe_doc>
		</precision>
		<toggleKeys public="1" expr="[F2, GRAVEACCENT, BACKSLASH]">
			<c path="Array"><x path="flixel.input.keyboard.FlxKey"/></c>
			<meta><m n=":value"><e>[F2, GRAVEACCENT, BACKSLASH]</e></m></meta>
			<haxe_doc>* The key codes used to toggle the debugger (see FlxG.keys for the keys available).
	 * Default keys: F2, ` and \. Set to null to deactivate.</haxe_doc>
		</toggleKeys>
		<drawDebug public="1" set="accessor" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
			<haxe_doc>* Whether to draw the hitboxes of FlxObjects.</haxe_doc>
		</drawDebug>
		<drawDebugChanged public="1" set="null" expr="new FlxSignal()">
			<t path="flixel.util.FlxSignal"/>
			<meta><m n=":value"><e>new FlxSignal()</e></m></meta>
			<haxe_doc>* Dispatched when `drawDebug` is changed.</haxe_doc>
		</drawDebugChanged>
		<visibilityChanged public="1" set="null" expr="new FlxSignal()">
			<t path="flixel.util.FlxSignal"/>
			<meta><m n=":value"><e>new FlxSignal()</e></m></meta>
			<haxe_doc>* Dispatched when `visible` is changed.
	 * @since 4.1.0</haxe_doc>
		</visibilityChanged>
		<visible public="1" set="accessor" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</visible>
		<setLayout public="1" get="inline" set="null" line="51">
			<f a="Layout">
				<e path="flixel.system.debug.FlxDebuggerLayout"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Change the way the debugger's windows are laid out.
	 * 
	 * @param	Layout	The layout codes can be found in FlxDebugger, for example FlxDebugger.MICRO</haxe_doc>
		</setLayout>
		<resetLayout public="1" get="inline" set="null" line="61">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Just resets the debugger windows to whatever the last selected layout was (STANDARD by default).</haxe_doc>
		</resetLayout>
		<addButton public="1" set="method" line="78">
			<f a="Alignment:Icon:UpHandler:?ToggleMode:?UpdateLayout" v=":::false:true">
				<e path="flixel.util.FlxHorizontalAlign"/>
				<t path="flash.display.BitmapData"/>
				<f a=""><x path="Void"/></f>
				<x path="Bool"/>
				<x path="Bool"/>
				<c path="flixel.system.ui.FlxSystemButton"/>
			</f>
			<meta><m n=":value"><e>{ UpdateLayout : true, ToggleMode : false }</e></m></meta>
			<haxe_doc>* Create and add a new debugger button.
	 * 
	 * @param   Position       Either LEFT, CENTER or RIGHT.
	 * @param   Icon           The icon to use for the button
	 * @param   UpHandler      The function to be called when the button is pressed.
	 * @param   ToggleMode     Whether this is a toggle button or not.
	 * @param   UpdateLayout   Whether to update the button layout.
	 * @return  The added button.</haxe_doc>
		</addButton>
		<track public="1" set="method" line="94">
			<f a="ObjectOrClass:?WindowTitle">
				<d/>
				<c path="String"/>
				<c path="flixel.system.debug.Window"/>
			</f>
			<haxe_doc>* Creates a new tracker window if there exists a tracking profile for the class / class of the object.
	 * By default, flixel classes like FlxBasic, FlxRect and FlxPoint are supported.
	 * 
	 * @param	ObjectOrClass	The object or class to track
	 * @param	WindowTitle	Title of the tracker window, uses the class name by default</haxe_doc>
		</track>
		<addTrackerProfile public="1" get="inline" set="null" line="118">
			<f a="Profile">
				<c path="flixel.system.debug.watch.TrackerProfile"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Adds a new TrackerProfile for track(). This also overrides existing profiles.
	 * 
	 * @param	Profile	The TrackerProfile</haxe_doc>
		</addTrackerProfile>
		<removeButton public="1" set="method" line="131">
			<f a="Button:?UpdateLayout" v=":true">
				<c path="flixel.system.ui.FlxSystemButton"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ UpdateLayout : true }</e></m></meta>
			<haxe_doc>* Removes and destroys a button from the debugger.
	 * 
	 * @param	Button			The FlxSystemButton instance to remove.
	 * @param	UpdateLayout	Whether to update the button layout.</haxe_doc>
		</removeButton>
		<set_drawDebug set="method" line="141"><f a="Value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_drawDebug>
		<set_visible set="method" line="154">
			<f a="Value">
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":access"><e>flixel.FlxGame.onFocus</e></m></meta>
		</set_visible>
		<new set="method" line="139">
			<f a=""><x path="Void"/></f>
			<meta><m n=":allow"><e>flixel.FlxG</e></m></meta>
		</new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="flixel.system.frontEnds.InputFrontEnd" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/system/frontEnds/InputFrontEnd.hx">
		<list public="1" set="null" expr="[]">
			<c path="Array"><c path="flixel.input.IFlxInputManager"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
			<haxe_doc>* A read-only list of all inputs.</haxe_doc>
		</list>
		<resetOnStateSwitch public="1" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
			<haxe_doc>* Whether inputs are reset on state switches.
	 * Disable if you need persistent input states across states.</haxe_doc>
		</resetOnStateSwitch>
		<add public="1" params="T" set="method" line="27">
			<f a="Input">
				<c path="add.T"/>
				<c path="add.T"/>
			</f>
			<meta><m n=":generic"/></meta>
			<haxe_doc>* Add an input to the system
	 * 
	 * @param	Input 	The input to add
	 * @return	The input</haxe_doc>
		</add>
		<remove public="1" params="T" set="method" line="49">
			<f a="Input">
				<c path="remove.T"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":generic"/></meta>
			<haxe_doc>* Removes an input from the system
	 * 
	 * @param	Input	The input to remove
	 * @return	Bool indicating whether it was removed or not</haxe_doc>
		</remove>
		<replace public="1" params="T" set="method" line="72">
			<f a="Old:New">
				<c path="replace.T"/>
				<c path="replace.T"/>
				<c path="replace.T"/>
			</f>
			<meta><m n=":generic"/></meta>
			<haxe_doc>* Replace an existing input in the system with a new one
	 * 
	 * @param	Old 	The old input to replace
	 * @param	New 	The new input to put in its place
	 * @return	If successful returns New. Otherwise returns null.</haxe_doc>
		</replace>
		<reset public="1" set="method" line="94"><f a=""><x path="Void"/></f></reset>
		<update get="inline" set="null" line="106">
			<f a=""><x path="Void"/></f>
			<meta><m n=":allow"><e>flixel.FlxGame</e></m></meta>
		</update>
		<onFocus get="inline" set="null" line="115">
			<f a=""><x path="Void"/></f>
			<meta><m n=":allow"><e>flixel.FlxGame</e></m></meta>
		</onFocus>
		<onFocusLost get="inline" set="null" line="124">
			<f a=""><x path="Void"/></f>
			<meta><m n=":allow"><e>flixel.FlxGame</e></m></meta>
		</onFocusLost>
		<onStateSwitch set="method" line="134">
			<f a=""><x path="Void"/></f>
			<meta>
				<m n=":allow"><e>flixel.FlxGame</e></m>
				<m n=":allow"><e>flixel.FlxState.resetSubState</e></m>
			</meta>
		</onStateSwitch>
		<destroy set="method" line="142"><f a=""><x path="Void"/></f></destroy>
		<new set="method" line="103">
			<f a=""><x path="Void"/></f>
			<meta><m n=":allow"><e>flixel.FlxG</e></m></meta>
		</new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="flixel.system.frontEnds.LogFrontEnd" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/system/frontEnds/LogFrontEnd.hx">
		<redirectTraces public="1" set="accessor" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
			<haxe_doc>* Whether everything you trace() is being redirected into the log window.</haxe_doc>
		</redirectTraces>
		<_standardTraceFunction><d/></_standardTraceFunction>
		<add public="1" get="inline" set="null" line="18"><f a="Data">
	<d/>
	<x path="Void"/>
</f></add>
		<warn public="1" get="inline" set="null" line="25"><f a="Data">
	<d/>
	<x path="Void"/>
</f></warn>
		<error public="1" get="inline" set="null" line="32"><f a="Data">
	<d/>
	<x path="Void"/>
</f></error>
		<notice public="1" get="inline" set="null" line="39"><f a="Data">
	<d/>
	<x path="Void"/>
</f></notice>
		<advanced public="1" set="method" line="53">
			<f a="Data:?Style:?FireOnce" v="::false">
				<d/>
				<c path="flixel.system.debug.log.LogStyle"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ FireOnce : false }</e></m></meta>
			<haxe_doc>* Add an advanced log message to the debugger by also specifying a LogStyle. Backend to FlxG.log.add(), FlxG.log.warn(), FlxG.log.error() and FlxG.log.notice().
	 * 
	 * @param	Data  		Any Data to log.
	 * @param  	Style   	The LogStyle to use, for example LogStyle.WARNING. You can also create your own by importing the LogStyle class.
	 * @param  	FireOnce   	Whether you only want to log the Data in case it hasn't been added already</haxe_doc>
		</advanced>
		<clear public="1" get="inline" set="null" line="101">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Clears the log output.</haxe_doc>
		</clear>
		<set_redirectTraces get="inline" set="null" line="114"><f a="Redirect">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_redirectTraces>
		<processTraceData set="method" line="126">
			<f a="Data:?Info">
				<d/>
				<t path="haxe.PosInfos"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Internal function used as a interface between trace() and add().
	 * 
	 * @param	Data	The data that has been traced
	 * @param	Inf		Information about the position at which trace() was called</haxe_doc>
		</processTraceData>
		<new set="method" line="109">
			<f a=""><x path="Void"/></f>
			<meta><m n=":allow"><e>flixel.FlxG</e></m></meta>
		</new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="haxe.Log" params="" file="D:\HaxeToolkit\haxe\std/haxe/Log.hx">
		<trace public="1" set="dynamic" line="47" static="1">
			<f a="v:?infos">
				<d/>
				<t path="haxe.PosInfos"/>
				<x path="Void"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Outputs `v` in a platform-dependent way.

		The second parameter `infos` is injected by the compiler and contains
		information about the position where the `trace()` call was made.

		This method can be rebound to a custom function:
			var oldTrace = haxe.Log.trace; // store old function
			haxe.Log.trace = function(v, ?infos) {
			  // handle trace
			}
			...
			haxe.Log.trace = oldTrace;

		If it is bound to null, subsequent calls to `trace()` will cause an
		exception.</haxe_doc>
		</trace>
		<haxe_doc>Log primarily provides the `trace()` method, which is invoked upon a call to
	`trace()` in Haxe code.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="flixel.math.FlxRandom" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/math/FlxRandom.hx">
		<rangeBound get="inline" set="null" line="440" static="1">
			<f a="Value">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>* Internal shared function to ensure an arbitrary value is in the valid range of seed values.</haxe_doc>
		</rangeBound>
		<_arrayFloatHelper expr="null" line="448" static="1">
			<c path="Array"><x path="Float"/></c>
			<meta><m n=":value"><e>null</e></m></meta>
			<haxe_doc>* Internal shared helper variable. Used by getObject().</haxe_doc>
		</_arrayFloatHelper>
		<MULTIPLIER get="inline" set="null" expr="48271.0" line="459" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>48271.0</e></m></meta>
			<haxe_doc>* Constants used in the pseudorandom number generation equation.
	 * These are the constants suggested by the revised MINSTD pseudorandom number generator,
	 * and they use the full range of possible integer values.
	 * 
	 * @see http://en.wikipedia.org/wiki/Linear_congruential_generator
	 * @see Stephen K. Park and Keith W. Miller and Paul K. Stockmeyer (1988).
	 *      "Technical Correspondence". Communications of the ACM 36 (7): 105â€“110.</haxe_doc>
		</MULTIPLIER>
		<MODULUS get="inline" set="null" expr="FlxMath.MAX_VALUE_INT" line="460" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>FlxMath.MAX_VALUE_INT</e></m></meta>
		</MODULUS>
		<initialSeed public="1" set="accessor" expr="1">
			<x path="Int"/>
			<meta><m n=":value"><e>1</e></m></meta>
			<haxe_doc>* The global base random number generator seed (for deterministic behavior in recordings and saves).
	 * If you want, you can set the seed with an integer between 1 and 2,147,483,647 inclusive.
	 * Altering this yourself may break recording functionality!</haxe_doc>
		</initialSeed>
		<currentSeed public="1" get="accessor" set="accessor">
			<x path="Int"/>
			<haxe_doc>* Current seed used to generate new random numbers. You can retrieve this value if,
	 * for example, you want to store the seed that was used to randomly generate a level.</haxe_doc>
		</currentSeed>
		<resetInitialSeed public="1" get="inline" set="null" line="47">
			<f a=""><x path="Int"/></f>
			<haxe_doc>* Function to easily set the global seed to a new random number.
	 * Please note that this function is not deterministic!
	 * If you call it in your game, recording may not function as expected.
	 * 
	 * @return  The new initial seed.</haxe_doc>
		</resetInitialSeed>
		<int public="1" set="method" line="61">
			<f a="?Min:?Max:?Excludes" v="0:FlxMath.MAX_VALUE_INT:">
				<x path="Int"/>
				<x path="Int"/>
				<c path="Array"><x path="Int"/></c>
				<x path="Int"/>
			</f>
			<meta><m n=":value"><e>{ Max : FlxMath.MAX_VALUE_INT, Min : 0 }</e></m></meta>
			<haxe_doc>* Returns a pseudorandom integer between Min and Max, inclusive.
	 * Will not return a number in the Excludes array, if provided.
	 * Please note that large Excludes arrays can slow calculations.
	 * 
	 * @param   Min        The minimum value that should be returned. 0 by default.
	 * @param   Max        The maximum value that should be returned. 2,147,483,647 by default.
	 * @param   Excludes   Optional array of values that should not be returned.</haxe_doc>
		</int>
		<float public="1" set="method" line="109">
			<f a="?Min:?Max:?Excludes" v="0:1:">
				<x path="Float"/>
				<x path="Float"/>
				<c path="Array"><x path="Float"/></c>
				<x path="Float"/>
			</f>
			<meta><m n=":value"><e>{ Max : 1, Min : 0 }</e></m></meta>
			<haxe_doc>* Returns a pseudorandom float value between Min and Max, inclusive.
	 * Will not return a number in the Excludes array, if provided.
	 * Please note that large Excludes arrays can slow calculations.
	 * 
	 * @param   Min        The minimum value that should be returned. 0 by default.
	 * @param   Max        The maximum value that should be returned. 1 by default.
	 * @param   Excludes   Optional array of values that should not be returned.</haxe_doc>
		</float>
		<_hasFloatNormalSpare expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</_hasFloatNormalSpare>
		<_floatNormalRand1 expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</_floatNormalRand1>
		<_floatNormalRand2 expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</_floatNormalRand2>
		<_twoPI expr="Math.PI * 2">
			<x path="Float"/>
			<meta><m n=":value"><e>Math.PI * 2</e></m></meta>
		</_twoPI>
		<_floatNormalRho expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</_floatNormalRho>
		<floatNormal public="1" set="method" line="165">
			<f a="?Mean:?StdDev" v="0:1">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":value"><e>{ StdDev : 1, Mean : 0 }</e></m></meta>
			<haxe_doc>* Returns a pseudorandom float value in a statistical normal distribution centered on Mean with a standard deviation size of StdDev.
	 * (This uses the Box-Muller transform algorithm for gaussian pseudorandom numbers)
	 * 
	 * Normal distribution: 68% values are within 1 standard deviation, 95% are in 2 StdDevs, 99% in 3 StdDevs.
	 * See this image: https://github.com/HaxeFlixel/flixel-demos/blob/dev/Performance/FlxRandom/normaldistribution.png
	 * 
	 * @param	Mean		The Mean around which the normal distribution is centered
	 * @param	StdDev		Size of the standard deviation</haxe_doc>
		</floatNormal>
		<bool public="1" get="inline" set="null" line="195">
			<f a="?Chance" v="50">
				<x path="Float"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":value"><e>{ Chance : 50 }</e></m></meta>
			<haxe_doc>* Returns true or false based on the chance value (default 50%). 
	 * For example if you wanted a player to have a 30.5% chance of getting a bonus,
	 * call bool(30.5) - true means the chance passed, false means it failed.
	 * 
	 * @param   Chance   The chance of receiving the value.
	 *                   Should be given as a number between 0 and 100 (effectively 0% to 100%)
	 * @return  Whether the roll passed or not.</haxe_doc>
		</bool>
		<sign public="1" get="inline" set="null" line="207">
			<f a="?Chance" v="50">
				<x path="Float"/>
				<x path="Int"/>
			</f>
			<meta><m n=":value"><e>{ Chance : 50 }</e></m></meta>
			<haxe_doc>* Returns either a 1 or -1. 
	 * 
	 * @param   Chance   The chance of receiving a positive value.
	 *                   Should be given as a number between 0 and 100 (effectively 0% to 100%)
	 * @return  1 or -1</haxe_doc>
		</sign>
		<weightedPick public="1" set="method" line="221">
			<f a="WeightsArray">
				<c path="Array"><x path="Float"/></c>
				<x path="Int"/>
			</f>
			<haxe_doc>* Pseudorandomly select from an array of weighted options. For example, if you passed in an array of [50, 30, 20]
	 * there would be a 50% chance of returning a 0, a 30% chance of returning a 1, and a 20% chance of returning a 2.
	 * Note that the values in the array do not have to add to 100 or any other number.
	 * The percent chance will be equal to a given value in the array divided by the total of all values in the array.
	 * 
	 * @param   WeightsArray   An array of weights.
	 * @return  A value between 0 and (SelectionArray.length - 1), with a probability equivalent to the values in SelectionArray.</haxe_doc>
		</weightedPick>
		<getObject public="1" params="T" set="method" line="259">
			<f a="Objects:?WeightsArray:?StartIndex:?EndIndex" v="::0:">
				<c path="Array"><c path="getObject.T"/></c>
				<c path="Array"><x path="Float"/></c>
				<x path="Int"/>
				<x path="Int"/>
				<c path="getObject.T"/>
			</f>
			<meta>
				<m n=":value"><e>{ StartIndex : 0 }</e></m>
				<m n=":generic"/>
			</meta>
			<haxe_doc>* Returns a random object from an array.
	 * 
	 * @param   Objects        An array from which to return an object.
	 * @param   WeightsArray   Optional array of weights which will determine the likelihood of returning a given value from Objects.
	 * 						   If none is passed, all objects in the Objects array will have an equal likelihood of being returned.
	 *                         Values in WeightsArray will correspond to objects in Objects exactly.
	 * @param   StartIndex     Optional index from which to restrict selection. Default value is 0, or the beginning of the Objects array.
	 * @param   EndIndex       Optional index at which to restrict selection. Ignored if 0, which is the default value.
	 * @return  A pseudorandomly chosen object from Objects.</haxe_doc>
		</getObject>
		<shuffleArray public="1" params="T" set="method" line="308">
			<f a="Objects:HowManyTimes">
				<c path="Array"><c path="shuffleArray.T"/></c>
				<x path="Int"/>
				<c path="Array"><c path="shuffleArray.T"/></c>
			</f>
			<meta>
				<m n=":generic"/>
				<m n=":deprecated"><e>"Unless you rely on reproducing the exact output of shuffleArray(), you should use shuffle() instead, which is both faster and higher quality."</e></m>
			</meta>
			<haxe_doc>* Shuffles the entries in an array into a new pseudorandom order.
	 * 
	 * @param   Objects        An array to shuffle.
	 * @param   HowManyTimes   How many swaps to perform during the shuffle operation. 
	 *                         A good rule of thumb is 2-4 times the number of objects in the list.
	 * @return  The newly shuffled array.</haxe_doc>
		</shuffleArray>
		<shuffle public="1" params="T" set="method" line="335">
			<f a="array">
				<c path="Array"><c path="shuffle.T"/></c>
				<x path="Void"/>
			</f>
			<meta><m n=":generic"/></meta>
			<haxe_doc>* Shuffles the entries in an array in-place into a new pseudorandom order,
	 * using the standard Fisher-Yates shuffle algorithm.
	 *
	 * @param  array  The array to shuffle.
	 * @since  4.2.0</haxe_doc>
		</shuffle>
		<color public="1" set="method" line="356">
			<f a="?Min:?Max:?Alpha:?GreyScale" v=":::false">
				<x path="flixel.util.FlxColor"/>
				<x path="flixel.util.FlxColor"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="flixel.util.FlxColor"/>
			</f>
			<meta><m n=":value"><e>{ GreyScale : false }</e></m></meta>
			<haxe_doc>* Returns a random color.
	 * 
	 * @param   Min        An optional FlxColor representing the lower bounds for the generated color.
	 * @param   Max        An optional FlxColor representing the upper bounds for the generated color.
	 * @param 	Alpha      An optional value for the alpha channel of the generated color.
	 * @param   GreyScale  Whether or not to create a color that is strictly a shade of grey. False by default.
	 * @return  A color value as a FlxColor.</haxe_doc>
		</color>
		<generate get="inline" set="null" line="401">
			<f a=""><x path="Float"/></f>
			<haxe_doc>* Internal method to quickly generate a pseudorandom number. Used only by other functions of this class.
	 * Also updates the internal seed, which will then be used to generate the next pseudorandom number.
	 * 
	 * @return  A new pseudorandom number.</haxe_doc>
		</generate>
		<internalSeed expr="1">
			<x path="Float"/>
			<meta><m n=":value"><e>1</e></m></meta>
			<haxe_doc>* The actual internal seed. Stored as a Float value to prevent inaccuracies due to
	 * integer overflow in the generate() equation.</haxe_doc>
		</internalSeed>
		<set_initialSeed get="inline" set="null" line="416">
			<f a="NewSeed">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>* Internal function to update the current seed whenever the initial seed is reset,
	 * and keep the initial seed's value in range.</haxe_doc>
		</set_initialSeed>
		<get_currentSeed get="inline" set="null" line="424">
			<f a=""><x path="Int"/></f>
			<haxe_doc>* Returns the internal seed as an integer.</haxe_doc>
		</get_currentSeed>
		<set_currentSeed get="inline" set="null" line="432">
			<f a="NewSeed">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>* Sets the internal seed to an integer value.</haxe_doc>
		</set_currentSeed>
		<new public="1" set="method" line="28">
			<f a="?InitialSeed">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Create a new FlxRandom object.
	 * 
	 * @param	InitialSeed  The first seed of this FlxRandom object. If ignored, a random seed will be generated.</haxe_doc>
		</new>
		<haxe_doc>* A class containing a set of functions for random generation.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="flixel.util.FlxSave" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/util/FlxSave.hx">
		<implements path="flixel.util.IFlxDestroyable"/>
		<data public="1" set="null">
			<d/>
			<haxe_doc>* Allows you to directly access the data container in the local shared object.</haxe_doc>
		</data>
		<name public="1" set="null">
			<c path="String"/>
			<haxe_doc>* The name of the local shared object.</haxe_doc>
		</name>
		<_sharedObject>
			<t path="flash.net.SharedObject"/>
			<haxe_doc>* The local shared object itself.</haxe_doc>
		</_sharedObject>
		<_onComplete>
			<f a="">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Internal tracker for callback function in case save takes too long.</haxe_doc>
		</_onComplete>
		<_closeRequested expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
			<haxe_doc>* Internal tracker for save object close request.</haxe_doc>
		</_closeRequested>
		<destroy public="1" set="method" line="42">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Clean up memory.</haxe_doc>
		</destroy>
		<bind public="1" set="method" line="58">
			<f a="Name">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc><![CDATA[* Automatically creates or reconnects to locally saved data.
	 * 
	 * @param	Name	The name of the object (should be the same each time to access old data).
	 * 					May not contain spaces or any of the following characters: `~ % & \ ; : " ' , < > ? #`
	 * @return	Whether or not you successfully connected to the save data.]]></haxe_doc>
		</bind>
		<close public="1" set="method" line="85">
			<f a="?MinFileSize:?OnComplete" v="0:">
				<x path="Int"/>
				<f a="">
					<x path="Bool"/>
					<x path="Void"/>
				</f>
				<x path="Bool"/>
			</f>
			<meta><m n=":value"><e>{ MinFileSize : 0 }</e></m></meta>
			<haxe_doc>* A way to safely call flush() and destroy() on your save file.
	 * Will correctly handle storage size popups and all that good stuff.
	 * If you don't want to save your changes first, just call destroy() instead.
	 * 
	 * @param	MinFileSize		If you need X amount of space for your save, specify it here.
	 * @param	OnComplete		This callback will be triggered when the data is written successfully.
	 * @return	The result of result of the flush() call (see below for more details).</haxe_doc>
		</close>
		<flush public="1" set="method" line="98">
			<f a="?MinFileSize:?OnComplete" v="0:">
				<x path="Int"/>
				<f a="">
					<x path="Bool"/>
					<x path="Void"/>
				</f>
				<x path="Bool"/>
			</f>
			<meta><m n=":value"><e>{ MinFileSize : 0 }</e></m></meta>
			<haxe_doc>* Writes the local shared object to disk immediately. Leaves the object open in memory.
	 * 
	 * @param	MinFileSize		If you need X amount of space for your save, specify it here.
	 * @param	OnComplete		This callback will be triggered when the data is written successfully.
	 * @return	Whether or not the data was written immediately. False could be an error OR a storage request popup.</haxe_doc>
		</flush>
		<erase public="1" set="method" line="125">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>* Erases everything stored in the local shared object.
	 * Data is immediately erased and the object is saved that way,
	 * so use with caution!
	 * 
	 * @return	Returns false if the save object is not bound yet.</haxe_doc>
		</erase>
		<onDone set="method" line="143">
			<f a="Result">
				<e path="flixel.util.FlxSaveStatus"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Event handler for special case storage requests.
	 * Handles logging of errors and calling of callback.
	 * 
	 * @param	Result		One of the result codes (PENDING, ERROR, or SUCCESS).
	 * @return	Whether the operation was a success or not.</haxe_doc>
		</onDone>
		<checkBinding set="method" line="168">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>* Handy utility function for checking and warning if the shared object is bound yet or not.
	 * 
	 * @return	Whether the shared object was bound yet.</haxe_doc>
		</checkBinding>
		<new public="1" set="method" line="37"><f a=""><x path="Void"/></f></new>
		<haxe_doc>* A class to help automate and simplify save game functionality.
 * Basically a wrapper for the Flash SharedObject thing, but
 * handles some annoying storage request stuff too.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="flixel.system.scaleModes.BaseScaleMode" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/system/scaleModes/BaseScaleMode.hx">
		<deviceSize public="1" set="null"><c path="flixel.math.FlxPoint"/></deviceSize>
		<gameSize public="1" set="null"><c path="flixel.math.FlxPoint"/></gameSize>
		<scale public="1" set="null"><c path="flixel.math.FlxPoint"/></scale>
		<offset public="1" set="null"><c path="flixel.math.FlxPoint"/></offset>
		<horizontalAlign public="1" set="accessor" expr="CENTER">
			<e path="flixel.util.FlxHorizontalAlign"/>
			<meta><m n=":value"><e>CENTER</e></m></meta>
		</horizontalAlign>
		<verticalAlign public="1" set="accessor" expr="CENTER">
			<e path="flixel.util.FlxVerticalAlign"/>
			<meta><m n=":value"><e>CENTER</e></m></meta>
		</verticalAlign>
		<onMeasure public="1" set="method" line="26"><f a="Width:Height">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></onMeasure>
		<updateGameSize set="method" line="37"><f a="Width:Height">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></updateGameSize>
		<updateDeviceSize set="method" line="42"><f a="Width:Height">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></updateDeviceSize>
		<updateScaleOffset set="method" line="47"><f a=""><x path="Void"/></f></updateScaleOffset>
		<updateOffsetX set="method" line="55"><f a=""><x path="Void"/></f></updateOffsetX>
		<updateOffsetY set="method" line="68"><f a=""><x path="Void"/></f></updateOffsetY>
		<updateGamePosition set="method" line="81"><f a=""><x path="Void"/></f></updateGamePosition>
		<set_horizontalAlign set="method" line="90"><f a="value">
	<e path="flixel.util.FlxHorizontalAlign"/>
	<e path="flixel.util.FlxHorizontalAlign"/>
</f></set_horizontalAlign>
		<set_verticalAlign set="method" line="101"><f a="value">
	<e path="flixel.util.FlxVerticalAlign"/>
	<e path="flixel.util.FlxVerticalAlign"/>
</f></set_verticalAlign>
		<new public="1" set="method" line="18"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="flixel.system.scaleModes.RatioScaleMode" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/system/scaleModes/RatioScaleMode.hx">
		<extends path="flixel.system.scaleModes.BaseScaleMode"/>
		<fillScreen><x path="Bool"/></fillScreen>
		<updateGameSize set="method" line="19" override="1"><f a="Width:Height">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></updateGameSize>
		<new public="1" set="method" line="13">
			<f a="?fillScreen" v="false">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ fillScreen : false }</e></m></meta>
			<haxe_doc>* @param fillScreen Whether to cut the excess side to fill the
	 * screen or always display everything.</haxe_doc>
		</new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="flixel.system.frontEnds.SignalFrontEnd" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/system/frontEnds/SignalFrontEnd.hx">
		<stateSwitched public="1" set="null" expr="new FlxSignal()">
			<t path="flixel.util.FlxSignal"/>
			<meta><m n=":value"><e>new FlxSignal()</e></m></meta>
			<haxe_doc>* Gets dispatched when a state change occurs.</haxe_doc>
		</stateSwitched>
		<preStateCreate public="1" set="null" expr="new FlxTypedSignal&lt;FlxState&gt;()">
			<x path="flixel.util.FlxTypedSignal"><f a="">
	<c path="flixel.FlxState"/>
	<x path="Void"/>
</f></x>
			<meta><m n=":value"><e><![CDATA[new FlxTypedSignal<FlxState>()]]></e></m></meta>
		</preStateCreate>
		<gameResized public="1" set="null" expr="new FlxTypedSignal&lt;Int -&gt; Int&gt;()">
			<x path="flixel.util.FlxTypedSignal"><f a=":">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></x>
			<meta><m n=":value"><e><![CDATA[new FlxTypedSignal<Int -> Int>()]]></e></m></meta>
			<haxe_doc>* Gets dispatched when the game is resized. 
	 * Passes the new window width and height to callback functions.</haxe_doc>
		</gameResized>
		<preGameReset public="1" set="null" expr="new FlxSignal()">
			<t path="flixel.util.FlxSignal"/>
			<meta><m n=":value"><e>new FlxSignal()</e></m></meta>
		</preGameReset>
		<postGameReset public="1" set="null" expr="new FlxSignal()">
			<t path="flixel.util.FlxSignal"/>
			<meta><m n=":value"><e>new FlxSignal()</e></m></meta>
		</postGameReset>
		<gameStarted public="1" set="null" expr="new FlxSignal()">
			<t path="flixel.util.FlxSignal"/>
			<meta><m n=":value"><e>new FlxSignal()</e></m></meta>
			<haxe_doc>* Gets dispatched when the game is started (first state after the splash screen).</haxe_doc>
		</gameStarted>
		<preUpdate public="1" set="null" expr="new FlxSignal()">
			<t path="flixel.util.FlxSignal"/>
			<meta><m n=":value"><e>new FlxSignal()</e></m></meta>
		</preUpdate>
		<postUpdate public="1" set="null" expr="new FlxSignal()">
			<t path="flixel.util.FlxSignal"/>
			<meta><m n=":value"><e>new FlxSignal()</e></m></meta>
		</postUpdate>
		<preDraw public="1" set="null" expr="new FlxSignal()">
			<t path="flixel.util.FlxSignal"/>
			<meta><m n=":value"><e>new FlxSignal()</e></m></meta>
		</preDraw>
		<postDraw public="1" set="null" expr="new FlxSignal()">
			<t path="flixel.util.FlxSignal"/>
			<meta><m n=":value"><e>new FlxSignal()</e></m></meta>
		</postDraw>
		<focusGained public="1" set="null" expr="new FlxSignal()">
			<t path="flixel.util.FlxSignal"/>
			<meta><m n=":value"><e>new FlxSignal()</e></m></meta>
		</focusGained>
		<focusLost public="1" set="null" expr="new FlxSignal()">
			<t path="flixel.util.FlxSignal"/>
			<meta><m n=":value"><e>new FlxSignal()</e></m></meta>
		</focusLost>
		<new set="method" line="31">
			<f a=""><x path="Void"/></f>
			<meta><m n=":allow"><e>flixel.FlxG</e></m></meta>
		</new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="flixel.system.frontEnds.WatchFrontEnd" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/system/frontEnds/WatchFrontEnd.hx">
		<add public="1" get="inline" set="null" line="21">
			<f a="object:field:?displayName">
				<d/>
				<c path="String"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Add a variable to the watch list in the debugger.
	 * This lets you see the value of the variable all the time.
	 * 
	 * @param	object		A reference to any object in your game, e.g. Player or Robot or this.
	 * @param	field		The name of the variable you want to watch, in quotes, as a string: e.g. "speed" or "health".
	 * @param	displayName	Optional, display your own string instead of the class name + variable name: e.g. "enemy count".</haxe_doc>
		</add>
		<remove public="1" get="inline" set="null" line="34">
			<f a="object:field">
				<d/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Remove a variable from the watch list in the debugger.
	 * 
	 * @param	object	A reference to any object in your game, e.g. Player or Robot or this.
	 * @param	field	The name of the variable you want to watch, in quotes, as a string: e.g. "speed" or "health".</haxe_doc>
		</remove>
		<addQuick public="1" get="inline" set="null" line="49">
			<f a="displayName:value">
				<c path="String"/>
				<d/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Add or update a quickWatch entry to the watch list in the debugger.
	 * Extremely useful when called in update() functions when there 
	 * doesn't exist a variable for a value you want to watch - so you won't have to create one.
	 * 
	 * @param	displayName	The name of the quickWatch entry, for example `"mousePressed"`.
	 * @param	value		The new value for this entry, for example `FlxG.mouse.pressed`.</haxe_doc>
		</addQuick>
		<removeQuick public="1" get="inline" set="null" line="61">
			<f a="displayName">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Remove a quickWatch entry from the watch list of the debugger.
	 * 
	 * @param	displayName	The name of the quickWatch entry you want to remove.</haxe_doc>
		</removeQuick>
		<addExpression public="1" set="method" line="76">
			<f a="expression:?displayName">
				<c path="String"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Add an expression to the watch list in the debugger.
	 * The expression gets evaluated with hscript, and you can see its current value all the time.
	 * 
	 * @param   expression    A Haxe expression written as a string that will be evaluated and watched.
	 * @param   displayName   Optional, display your own string instead of the expression string: e.g. "enemy count".
	 * @since   4.1.0</haxe_doc>
		</addExpression>
		<removeExpression public="1" set="method" line="93">
			<f a="displayName">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Remove an expression from the watch list in the debugger.
	 * 
	 * @param   displayName   The display name of the registered expression, if you supplied one, or the Haxe expression that you want to remove, in string form.
	 * @since   4.1.0</haxe_doc>
		</removeExpression>
		<addMouse public="1" get="inline" set="null" line="104">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Add the mouse coords to the watch window. Useful for quickly 
	 * getting coordinates for object placement during prototyping!</haxe_doc>
		</addMouse>
		<removeMouse public="1" get="inline" set="null" line="114">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Removes the mouse coords from the watch window.</haxe_doc>
		</removeMouse>
		<new public="1" set="method" line="11"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="flixel.FlxG" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/FlxG.hx">
		<autoPause public="1" expr="true" line="71" static="1">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
			<haxe_doc>* Whether the game should be paused when focus is lost or not. Use `-D FLX_NO_FOCUS_LOST_SCREEN`
	 * if you only want to get rid of the default pause screen.
	 * Override `onFocus()` and `onFocusLost()` for your own behaviour in your state.</haxe_doc>
		</autoPause>
		<fixedTimestep public="1" expr="true" line="76" static="1">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
			<haxe_doc>* WARNING: Changing this can lead to issues with physics and the recording system. Setting this to
	 * `false` might lead to smoother animations (even at lower fps) at the cost of physics accuracy.</haxe_doc>
		</fixedTimestep>
		<timeScale public="1" expr="1" line="80" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>1</e></m></meta>
			<haxe_doc>* How fast or slow time should pass in the game; default is `1.0`.</haxe_doc>
		</timeScale>
		<worldDivisions public="1" expr="6" line="86" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>6</e></m></meta>
			<haxe_doc>* How many times the quad tree should divide the world on each axis.
	 * Generally, sparse collisions can have fewer divisons,
	 * while denser collision activity usually profits from more. Default value is `6`.</haxe_doc>
		</worldDivisions>
		<camera public="1" static="1">
			<c path="flixel.FlxCamera"/>
			<haxe_doc>* By default this just refers to the first entry in the `FlxG.cameras.list`
	 * array but you can do what you like with it.</haxe_doc>
		</camera>
		<VERSION public="1" set="null" expr="new FlxVersion(4, 3, 0)" line="97" static="1">
			<c path="flixel.system.FlxVersion"/>
			<meta><m n=":value"><e>new FlxVersion(4, 3, 0)</e></m></meta>
			<haxe_doc>* The HaxeFlixel version, in semantic versioning syntax. Use `Std.string()`
	 * on it to get a `String` formatted like this: `"HaxeFlixel MAJOR.MINOR.PATCH-COMMIT_SHA"`.</haxe_doc>
		</VERSION>
		<game public="1" set="null" static="1">
			<c path="flixel.FlxGame"/>
			<haxe_doc>* Internal tracker for game object.</haxe_doc>
		</game>
		<stage public="1" get="accessor" set="null" static="1">
			<t path="flash.display.Stage"/>
			<haxe_doc>* The Flash stage object (required for event listeners).
	 * Will be `null` if it's not safe/useful yet.</haxe_doc>
		</stage>
		<state public="1" get="accessor" set="null" static="1">
			<c path="flixel.FlxState"/>
			<haxe_doc>* Access the current game state from anywhere. Consider using `addChildBelowMouse()`
	 * if you want to add a `DisplayObject` to the stage instead of directly adding it here!</haxe_doc>
		</state>
		<updateFramerate public="1" set="accessor" static="1">
			<x path="Int"/>
			<haxe_doc>* How many times you want your game to update each second.
	 * More updates usually means better collisions and smoother motion.
	 * NOTE: This is NOT the same thing as the draw framerate!</haxe_doc>
		</updateFramerate>
		<drawFramerate public="1" set="accessor" static="1">
			<x path="Int"/>
			<haxe_doc>* How many times you want your game to step each second. More steps usually means greater responsiveness,
	 * but it can also slowdown your game if the stage can't keep up with the update routine.
	 * NOTE: This is NOT the same thing as the update framerate!</haxe_doc>
		</drawFramerate>
		<onMobile public="1" get="accessor" set="null" static="1">
			<x path="Bool"/>
			<haxe_doc>* Whether the game is running on a mobile device.
	 * If on HTML5, it returns `FlxG.html5.onMobile`.
	 * Otherwise, it checks whether the `mobile` haxedef is defined.
	 * @since 4.2.0</haxe_doc>
		</onMobile>
		<renderMethod public="1" set="null" static="1"><e path="flixel.FlxRenderMethod"/></renderMethod>
		<renderBlit public="1" set="null" static="1"><x path="Bool"/></renderBlit>
		<renderTile public="1" set="null" static="1"><x path="Bool"/></renderTile>
		<elapsed public="1" set="null" expr="0" line="143" static="1">
			<x path="Float"/>
			<meta>
				<m n=":value"><e>0</e></m>
				<m n=":allow"><e>flixel.FlxGame.updateElapsed</e></m>
			</meta>
			<haxe_doc>* Represents the amount of time in seconds that passed since last frame.</haxe_doc>
		</elapsed>
		<maxElapsed public="1" expr="0.1" line="150" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>0.1</e></m></meta>
			<haxe_doc>* Useful when the timestep is NOT fixed (i.e. variable),
	 * to prevent jerky movement or erratic behavior at very low fps.
	 * Essentially locks the framerate to a minimum value - any slower and you'll get
	 * slowdown instead of frameskip; default is 1/10th of a second.</haxe_doc>
		</maxElapsed>
		<width public="1" set="null" static="1">
			<x path="Int"/>
			<meta><m n=":allow"><e>flixel.system.scaleModes</e></m></meta>
			<haxe_doc>* The width of the screen in game pixels. Read-only, use `resizeGame()` to change.</haxe_doc>
		</width>
		<height public="1" set="null" static="1">
			<x path="Int"/>
			<meta><m n=":allow"><e>flixel.system.scaleModes</e></m></meta>
			<haxe_doc>* The height of the screen in game pixels. Read-only, use `resizeGame()` to change.</haxe_doc>
		</height>
		<scaleMode public="1" set="accessor" expr="new RatioScaleMode()" line="165" static="1">
			<c path="flixel.system.scaleModes.BaseScaleMode"/>
			<meta><m n=":value"><e>new RatioScaleMode()</e></m></meta>
			<haxe_doc>* The scale mode the game should use - available policies are found in `flixel.system.scaleModes`.</haxe_doc>
		</scaleMode>
		<fullscreen public="1" get="accessor" set="accessor" static="1">
			<x path="Bool"/>
			<haxe_doc>* Use this to toggle between fullscreen and normal mode. Works on CPP, Neko and Flash.
	 * You can easily toggle fullscreen with e.g.: `FlxG.fullscreen = !FlxG.fullscreen;`</haxe_doc>
		</fullscreen>
		<worldBounds public="1" set="null" expr="FlxRect.get()" line="175" static="1">
			<c path="flixel.math.FlxRect"/>
			<meta><m n=":value"><e>FlxRect.get()</e></m></meta>
			<haxe_doc>* The dimensions of the game world, used by the quad tree for collisions and overlap checks.
	 * Use `.set()` instead of creating a new object!</haxe_doc>
		</worldBounds>
		<save public="1" set="null" expr="new FlxSave()" line="181" static="1">
			<c path="flixel.util.FlxSave"/>
			<meta><m n=":value"><e>new FlxSave()</e></m></meta>
			<haxe_doc>* A `FlxSave` used internally by flixel to save sound preferences and
	 * the history of the console window, but no reason you can't use it for your own stuff too!</haxe_doc>
		</save>
		<random public="1" set="null" expr="new FlxRandom()" line="187" static="1">
			<c path="flixel.math.FlxRandom"/>
			<meta><m n=":value"><e>new FlxRandom()</e></m></meta>
			<haxe_doc>* A `FlxRandom` object which can be used to generate random numbers.
	 * Also used by Flixel internally.</haxe_doc>
		</random>
		<mouse public="1" set="accessor" static="1">
			<c path="flixel.input.mouse.FlxMouse"/>
			<haxe_doc>* Used for mouse input. e.g.: check if the left mouse button
	 * is pressed with `if (FlxG.mouse.pressed) { })` in `update()`.</haxe_doc>
		</mouse>
		<touches public="1" set="null" static="1">
			<c path="flixel.input.touch.FlxTouchManager"/>
			<haxe_doc>* Useful for devices with multitouch support.</haxe_doc>
		</touches>
		<swipes public="1" set="null" expr="[]" line="208" static="1">
			<c path="Array"><c path="flixel.input.FlxSwipe"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
			<haxe_doc>* Contains all "swipes" from both mouse and touch input that have just ended.</haxe_doc>
		</swipes>
		<keys public="1" set="null" static="1">
			<c path="flixel.input.keyboard.FlxKeyboard"/>
			<haxe_doc>* Used for keyboard input e.g.: check if the left arrow key is
	 * pressed with `if (FlxG.keys.pressed.LEFT) { }` in `update()`.</haxe_doc>
		</keys>
		<gamepads public="1" set="null" static="1">
			<c path="flixel.input.gamepad.FlxGamepadManager"/>
			<haxe_doc>* Allows accessing the available gamepads.</haxe_doc>
		</gamepads>
		<inputs public="1" set="null" expr="new InputFrontEnd()" line="250" static="1">
			<c path="flixel.system.frontEnds.InputFrontEnd"/>
			<meta><m n=":value"><e>new InputFrontEnd()</e></m></meta>
			<haxe_doc>* Mostly used internally, but you can use it too to reset inputs and create input classes of your own.</haxe_doc>
		</inputs>
		<console public="1" set="null" expr="new ConsoleFrontEnd()" line="254" static="1">
			<c path="flixel.system.frontEnds.ConsoleFrontEnd"/>
			<meta><m n=":value"><e>new ConsoleFrontEnd()</e></m></meta>
			<haxe_doc>* Used to register functions and objects or add new commands to the console window.</haxe_doc>
		</console>
		<log public="1" set="null" expr="new LogFrontEnd()" line="258" static="1">
			<c path="flixel.system.frontEnds.LogFrontEnd"/>
			<meta><m n=":value"><e>new LogFrontEnd()</e></m></meta>
			<haxe_doc>* Used to add messages to the log window or enable `trace()` redirection.</haxe_doc>
		</log>
		<bitmapLog public="1" set="null" expr="new BitmapLogFrontEnd()" line="262" static="1">
			<c path="flixel.system.frontEnds.BitmapLogFrontEnd"/>
			<meta><m n=":value"><e>new BitmapLogFrontEnd()</e></m></meta>
			<haxe_doc>* Used to add images to the bitmap log window.</haxe_doc>
		</bitmapLog>
		<watch public="1" set="null" expr="new WatchFrontEnd()" line="266" static="1">
			<c path="flixel.system.frontEnds.WatchFrontEnd"/>
			<meta><m n=":value"><e>new WatchFrontEnd()</e></m></meta>
			<haxe_doc>* Used to add or remove things to / from the watch window.</haxe_doc>
		</watch>
		<debugger public="1" set="null" expr="new DebuggerFrontEnd()" line="271" static="1">
			<c path="flixel.system.frontEnds.DebuggerFrontEnd"/>
			<meta><m n=":value"><e>new DebuggerFrontEnd()</e></m></meta>
			<haxe_doc>* Used it to show / hide the debugger, change its layout,
	 * activate debug drawing or change the key used to toggle it.</haxe_doc>
		</debugger>
		<vcr public="1" set="null" static="1">
			<c path="flixel.system.frontEnds.VCRFrontEnd"/>
			<haxe_doc>* Contains all the functions needed for recording and replaying.</haxe_doc>
		</vcr>
		<bitmap public="1" set="null" expr="new BitmapFrontEnd()" line="281" static="1">
			<c path="flixel.system.frontEnds.BitmapFrontEnd"/>
			<meta><m n=":value"><e>new BitmapFrontEnd()</e></m></meta>
			<haxe_doc>* Contains things related to bitmaps, for example regarding the `BitmapData` cache and the cache itself.</haxe_doc>
		</bitmap>
		<cameras public="1" set="null" expr="new CameraFrontEnd()" line="285" static="1">
			<c path="flixel.system.frontEnds.CameraFrontEnd"/>
			<meta><m n=":value"><e>new CameraFrontEnd()</e></m></meta>
			<haxe_doc>* Contains things related to cameras, a list of all cameras and several effects like `flash()` or `fade()`.</haxe_doc>
		</cameras>
		<plugins public="1" set="null" static="1">
			<c path="flixel.system.frontEnds.PluginFrontEnd"/>
			<haxe_doc>* Contains a list of all plugins and the functions required to `add()`, `remove()` them etc.</haxe_doc>
		</plugins>
		<initialWidth public="1" set="null" expr="0" line="291" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</initialWidth>
		<initialHeight public="1" set="null" expr="0" line="292" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</initialHeight>
		<initialZoom public="1" set="null" expr="0" line="293" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</initialZoom>
		<sound public="1" set="null" static="1">
			<c path="flixel.system.frontEnds.SoundFrontEnd"/>
			<haxe_doc>* Contains a list of all sounds and other things to manage or `play()` sounds.</haxe_doc>
		</sound>
		<signals public="1" set="null" expr="new SignalFrontEnd()" line="305" static="1">
			<c path="flixel.system.frontEnds.SignalFrontEnd"/>
			<meta><m n=":value"><e>new SignalFrontEnd()</e></m></meta>
			<haxe_doc>* Contains system-wide signals like `gameResized` or `stateSwitched`.</haxe_doc>
		</signals>
		<resizeGame public="1" get="inline" set="null" line="310" static="1">
			<f a="Width:Height">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Resizes the game within the window by reapplying the current scale mode.</haxe_doc>
		</resizeGame>
		<resizeWindow public="1" set="method" line="318" static="1">
			<f a="Width:Height">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Resizes the window. Only works on desktop targets (Neko, Windows, Linux, Mac).</haxe_doc>
		</resizeWindow>
		<resetGame public="1" get="inline" set="null" line="332" static="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Like hitting the reset button a game console, this will re-launch the game as if it just started.</haxe_doc>
		</resetGame>
		<switchState public="1" get="inline" set="null" line="341" static="1">
			<f a="nextState">
				<c path="flixel.FlxState"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Attempts to switch from the current game state to `nextState`.
	 * The state switch is successful if `switchTo()` of the current `state` returns `true`.</haxe_doc>
		</switchState>
		<resetState public="1" get="inline" set="null" line="351" static="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Request a reset of the current game state.
	 * Calls `switchState()` with a new instance of the current `state`.</haxe_doc>
		</resetState>
		<overlap public="1" set="method" line="380" static="1">
			<f a="?ObjectOrGroup1:?ObjectOrGroup2:?NotifyCallback:?ProcessCallback">
				<c path="flixel.FlxBasic"/>
				<c path="flixel.FlxBasic"/>
				<f a=":">
					<d/>
					<d/>
					<x path="Void"/>
				</f>
				<f a=":">
					<d/>
					<d/>
					<x path="Bool"/>
				</f>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Call this function to see if one `FlxObject` overlaps another within `FlxG.worldBounds`.
	 * Can be called with one object and one group, or two groups, or two objects,
	 * whatever floats your boat! For maximum performance try bundling a lot of objects
	 * together using a `FlxGroup` (or even bundling groups together!).
	 *
	 * NOTE: does NOT take objects' `scrollFactor` into account, all overlaps are checked in world space.
	 *
	 * NOTE: this takes the entire area of `FlxTilemap`s into account (including "empty" tiles).
	 *       Use `FlxTilemap#overlaps()` if you don't want that.
	 * 
	 * @param   ObjectOrGroup1    The first object or group you want to check.
	 * @param   ObjectOrGroup2    The second object or group you want to check. If it is the same as the first,
	 *                            Flixel knows to just do a comparison within that group.
	 * @param   NotifyCallback    A function with two `FlxObject` parameters -
	 *                            e.g. `onOverlap(object1:FlxObject, object2:FlxObject)` -
	 *                            that is called if those two objects overlap.
	 * @param   ProcessCallback   A function with two `FlxObject` parameters -
	 *                            e.g. `onOverlap(object1:FlxObject, object2:FlxObject)` -
	 *                            that is called if those two objects overlap.
	 *                            If a `ProcessCallback` is provided, then `NotifyCallback`
	 *                            will only be called if `ProcessCallback` returns true for those objects!
	 * @return  Whether any overlaps were detected.</haxe_doc>
		</overlap>
		<pixelPerfectOverlap public="1" get="inline" set="null" line="410" static="1">
			<f a="Sprite1:Sprite2:?AlphaTolerance:?Camera" v="::255:">
				<c path="flixel.FlxSprite"/>
				<c path="flixel.FlxSprite"/>
				<x path="Int"/>
				<c path="flixel.FlxCamera"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":value"><e>{ AlphaTolerance : 255 }</e></m></meta>
			<haxe_doc>* A pixel perfect collision check between two `FlxSprite` objects.
	 * It will do a bounds check first, and if that passes it will run a
	 * pixel perfect match on the intersecting area. Works with rotated and animated sprites.
	 * May be slow, so use it sparingly.
	 * 
	 * @param   Sprite1          The first `FlxSprite` to test against.
	 * @param   Sprite2          The second `FlxSprite` to test again, sprite order is irrelevant.
	 * @param   AlphaTolerance   The tolerance value above which alpha pixels are included.
	 *                           Default to `255` (must be fully opaque for collision).
	 * @param   Camera           If the collision is taking place in a camera other than
	 *                          `FlxG.camera` (the default/current) then pass it here.
	 * @return  Whether the sprites collide</haxe_doc>
		</pixelPerfectOverlap>
		<collide public="1" get="inline" set="null" line="434" static="1">
			<f a="?ObjectOrGroup1:?ObjectOrGroup2:?NotifyCallback">
				<c path="flixel.FlxBasic"/>
				<c path="flixel.FlxBasic"/>
				<f a=":">
					<d/>
					<d/>
					<x path="Void"/>
				</f>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Call this function to see if one `FlxObject` collides with another within `FlxG.worldBounds`.
	 * Can be called with one object and one group, or two groups, or two objects,
	 * whatever floats your boat! For maximum performance try bundling a lot of objects
	 * together using a FlxGroup (or even bundling groups together!).
	 *
	 * This function just calls `FlxG.overlap` and presets the `ProcessCallback` parameter to `FlxObject.separate`.
	 * To create your own collision logic, write your own `ProcessCallback` and use `FlxG.overlap` to set it up.
	 * NOTE: does NOT take objects' `scrollFactor` into account, all overlaps are checked in world space.
	 * 
	 * @param   ObjectOrGroup1   The first object or group you want to check.
	 * @param   ObjectOrGroup2   The second object or group you want to check. If it is the same as the first,
	 *                           Flixel knows to just do a comparison within that group.
	 * @param   NotifyCallback   A function with two `FlxObject` parameters -
	 *                           e.g. `onOverlap(object1:FlxObject, object2:FlxObject)` -
	 *                           that is called if those two objects overlap.
	 * @return  Whether any objects were successfully collided/separated.</haxe_doc>
		</collide>
		<addChildBelowMouse public="1" params="T" set="method" line="449" static="1">
			<f a="Child:?IndexModifier" v=":0">
				<c path="addChildBelowMouse.T"/>
				<x path="Int"/>
				<c path="addChildBelowMouse.T"/>
			</f>
			<meta>
				<m n=":value"><e>{ IndexModifier : 0 }</e></m>
				<m n=":generic"/>
			</meta>
			<haxe_doc>* Regular `DisplayObject`s are normally displayed over the Flixel cursor and the Flixel debugger if simply
	 * added to `stage`. This function simplifies things by adding a `DisplayObject` directly below mouse level.
	 * 
	 * @param   Child           The `DisplayObject` to add
	 * @param   IndexModifier   Amount to add to the index - makes sure the index stays within bounds.
	 * @return  The added `DisplayObject`</haxe_doc>
		</addChildBelowMouse>
		<removeChild public="1" params="T" get="inline" set="null" line="466" static="1">
			<f a="Child">
				<c path="removeChild.T"/>
				<c path="removeChild.T"/>
			</f>
			<meta><m n=":generic"/></meta>
			<haxe_doc>* Removes a child from the Flixel display list, if it is part of it.
	 * 
	 * @param   Child   The `DisplayObject` to add
	 * @return  The removed `DisplayObject`</haxe_doc>
		</removeChild>
		<addPostProcess public="1" set="method" line="473" static="1"><f a="postProcess">
	<c path="flixel.effects.postprocess.PostProcess"/>
	<c path="flixel.effects.postprocess.PostProcess"/>
</f></addPostProcess>
		<removePostProcess public="1" set="method" line="499" static="1"><f a="postProcess">
	<c path="flixel.effects.postprocess.PostProcess"/>
	<x path="Void"/>
</f></removePostProcess>
		<chainPostProcesses set="method" line="514" static="1"><f a=""><x path="Void"/></f></chainPostProcesses>
		<openURL public="1" get="inline" set="null" line="536" static="1">
			<f a="URL:?Target" v=":&quot;_blank&quot;">
				<c path="String"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ Target : "_blank" }</e></m></meta>
			<haxe_doc>* Opens a web page, by default a new tab or window. If the URL does not 
	 * already start with `"http://"` or `"https://"`, it gets added automatically.
	 * 
	 * @param   URL      The address of the web page.
	 * @param   Target   `"_blank"`, `"_self"`, `"_parent"` or `"_top"`</haxe_doc>
		</openURL>
		<init set="method" line="549" static="1">
			<f a="Game:Width:Height:Zoom">
				<c path="flixel.FlxGame"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":allow"><e>flixel.FlxGame.new</e></m></meta>
			<haxe_doc>* Called by `FlxGame` to set up `FlxG` during `FlxGame`'s constructor.</haxe_doc>
		</init>
		<initRenderMethod set="method" line="597" static="1"><f a=""><x path="Void"/></f></initRenderMethod>
		<reset set="method" line="633" static="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":allow"><e>flixel.FlxGame</e></m></meta>
			<haxe_doc>* Called whenever the game is reset, doesn't have to do quite as much work as the basic initialization stuff.</haxe_doc>
		</reset>
		<set_scaleMode set="method" line="651" static="1"><f a="ScaleMode">
	<c path="flixel.system.scaleModes.BaseScaleMode"/>
	<c path="flixel.system.scaleModes.BaseScaleMode"/>
</f></set_scaleMode>
		<set_mouse set="method" line="659" static="1"><f a="NewMouse">
	<c path="flixel.input.mouse.FlxMouse"/>
	<c path="flixel.input.mouse.FlxMouse"/>
</f></set_mouse>
		<set_updateFramerate set="method" line="678" static="1"><f a="Framerate">
	<x path="Int"/>
	<x path="Int"/>
</f></set_updateFramerate>
		<set_drawFramerate set="method" line="695" static="1"><f a="Framerate">
	<x path="Int"/>
	<x path="Int"/>
</f></set_drawFramerate>
		<get_fullscreen set="method" line="714" static="1"><f a=""><x path="Bool"/></f></get_fullscreen>
		<set_fullscreen set="method" line="720" static="1"><f a="Value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_fullscreen>
		<get_stage get="inline" set="null" line="726" static="1"><f a=""><t path="flash.display.Stage"/></f></get_stage>
		<get_state get="inline" set="null" line="731" static="1"><f a=""><c path="flixel.FlxState"/></f></get_state>
		<get_onMobile get="inline" set="null" line="736" static="1"><f a=""><x path="Bool"/></f></get_onMobile>
		<haxe_doc>* Global helper class for audio, input, the camera system, the debugger and other global properties.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<enum path="flixel.FlxRenderMethod" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/FlxG.hx" module="flixel.FlxG">
		<DRAW_TILES/>
		<BLITTING/>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<class path="flixel.FlxGame" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/FlxGame.hx">
		<extends path="openfl.display.Sprite"/>
		<focusLostFramerate public="1" expr="10">
			<x path="Int"/>
			<meta><m n=":value"><e>10</e></m></meta>
			<haxe_doc>* Framerate to use on focus lost. Default is `10`.</haxe_doc>
		</focusLostFramerate>
		<soundTray public="1" set="null">
			<c path="flixel.system.ui.FlxSoundTray"/>
			<haxe_doc>* The sound tray display container.</haxe_doc>
		</soundTray>
		<debugger public="1" set="null">
			<c path="flixel.system.debug.FlxDebugger"/>
			<haxe_doc>* The debugger overlay object.</haxe_doc>
		</debugger>
		<ticks public="1" set="null" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* Time in milliseconds that has passed (amount of "ticks" passed) since the game has started.</haxe_doc>
		</ticks>
		<filtersEnabled public="1" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
			<haxe_doc>* Enables or disables the filters set via `setFilters()`.</haxe_doc>
		</filtersEnabled>
		<_gameJustStarted expr="false">
			<x path="Bool"/>
			<meta>
				<m n=":value"><e>false</e></m>
				<m n=":allow"><e>flixel.system.FlxSplash</e></m>
			</meta>
			<haxe_doc>* A flag for triggering the `gameStarted` "event".</haxe_doc>
		</_gameJustStarted>
		<_initialState>
			<x path="Class"><c path="flixel.FlxState"/></x>
			<haxe_doc>* Class type of the initial/first game state for the game, usually `MenuState` or something like that.</haxe_doc>
		</_initialState>
		<_state>
			<c path="flixel.FlxState"/>
			<haxe_doc>* Current game state.</haxe_doc>
		</_state>
		<_total expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* Total number of milliseconds elapsed since game start.</haxe_doc>
		</_total>
		<_startTime expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* Time stamp of game startup. Needed on JS where `Lib.getTimer()`
	 * returns time stamp of current date, not the time passed since app start.</haxe_doc>
		</_startTime>
		<_accumulator>
			<x path="Float"/>
			<haxe_doc>* Total number of milliseconds elapsed since last update loop.
	 * Counts down as we step through the game loop.</haxe_doc>
		</_accumulator>
		<_elapsedMS>
			<x path="Float"/>
			<haxe_doc>* Milliseconds of time since last step.</haxe_doc>
		</_elapsedMS>
		<_stepMS>
			<x path="Float"/>
			<haxe_doc>* Milliseconds of time per step of the game loop. e.g. 60 fps = 16ms.</haxe_doc>
		</_stepMS>
		<_stepSeconds>
			<x path="Float"/>
			<haxe_doc>* Optimization so we don't have to divide step by 1000 to get its value in seconds every frame.</haxe_doc>
		</_stepSeconds>
		<_maxAccumulation>
			<x path="Float"/>
			<haxe_doc>* Max allowable accumulation (see `_accumulator`).
	 * Should always (and automatically) be set to roughly 2x the stage framerate.</haxe_doc>
		</_maxAccumulation>
		<_lostFocus expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
			<haxe_doc>* Whether the game lost focus.</haxe_doc>
		</_lostFocus>
		<_filters>
			<c path="Array"><c path="openfl.filters.BitmapFilter"/></c>
			<haxe_doc>* The filters array to be applied to the game.</haxe_doc>
		</_filters>
		<_focusLostScreen>
			<c path="flixel.system.ui.FlxFocusLostScreen"/>
			<haxe_doc>* The "focus lost" screen.</haxe_doc>
		</_focusLostScreen>
		<_inputContainer>
			<t path="flash.display.Sprite"/>
			<meta>
				<m n=":allow"><e>flixel.FlxG</e></m>
				<m n=":allow"><e>flixel.system.frontEnds.CameraFrontEnd</e></m>
			</meta>
			<haxe_doc>* Mouse cursor.</haxe_doc>
		</_inputContainer>
		<_customSoundTray expr="FlxSoundTray">
			<x path="Class"><c path="flixel.system.ui.FlxSoundTray"/></x>
			<meta><m n=":value"><e>FlxSoundTray</e></m></meta>
			<haxe_doc>* Change this after calling `super()` in the `FlxGame` constructor
	 * to use a customized sound tray based on `FlxSoundTray`.</haxe_doc>
		</_customSoundTray>
		<_customFocusLostScreen expr="FlxFocusLostScreen">
			<x path="Class"><c path="flixel.system.ui.FlxFocusLostScreen"/></x>
			<meta><m n=":value"><e>FlxFocusLostScreen</e></m></meta>
			<haxe_doc>* Change this after calling `super()` in the `FlxGame` constructor
	 * to use a customized screen which will be show when the application lost focus.</haxe_doc>
		</_customFocusLostScreen>
		<_skipSplash expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
			<haxe_doc>* Whether the splash screen should be skipped.</haxe_doc>
		</_skipSplash>
		<_requestedState>
			<c path="flixel.FlxState"/>
			<haxe_doc>* If a state change was requested, the new state object is stored here until we switch to it.</haxe_doc>
		</_requestedState>
		<_resetGame expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
			<haxe_doc>* A flag for keeping track of whether a game reset was requested or not.</haxe_doc>
		</_resetGame>
		<postProcessLayer expr="new Sprite()">
			<t path="flash.display.Sprite"/>
			<meta><m n=":value"><e>new Sprite()</e></m></meta>
			<haxe_doc>* `Sprite` for postprocessing effects</haxe_doc>
		</postProcessLayer>
		<postProcesses expr="[]">
			<c path="Array"><c path="flixel.effects.postprocess.PostProcess"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
			<haxe_doc>* Post process effects active on the `postProcessLayer`.</haxe_doc>
		</postProcesses>
		<setFilters public="1" set="method" line="287">
			<f a="filters">
				<c path="Array"><c path="openfl.filters.BitmapFilter"/></c>
				<x path="Void"/>
			</f>
			<haxe_doc>* Sets the filter array to be applied to the game.</haxe_doc>
		</setFilters>
		<create set="method" line="295">
			<f a="_">
				<unknown/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Used to instantiate the guts of the flixel game object once we have a valid reference to the root.</haxe_doc>
		</create>
		<onFocus set="method" line="371"><f a="_">
	<unknown/>
	<x path="Void"/>
</f></onFocus>
		<onFocusLost set="method" line="415"><f a="event">
	<t path="flash.events.Event"/>
	<x path="Void"/>
</f></onFocusLost>
		<onResize set="method" line="451">
			<f a="_">
				<unknown/>
				<x path="Void"/>
			</f>
			<meta><m n=":allow"><e>flixel.FlxG</e></m></meta>
		</onResize>
		<resizeGame set="method" line="464"><f a="width:height">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></resizeGame>
		<onEnterFrame set="method" line="496">
			<f a="_">
				<unknown/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Handles the `onEnterFrame` call and figures out how many updates and draw calls to do.</haxe_doc>
		</onEnterFrame>
		<resetGame get="inline" set="null" line="564">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Internal method to create a new instance of `_initialState` and reset the game.
	 * This gets called when the game is created, as well as when a new state is requested.</haxe_doc>
		</resetGame>
		<switchState set="method" line="600">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* If there is a state change requested during the update loop,
	 * this function handles actual destroying the old state and related processes,
	 * and calls creates on the new state and plugs it into the game object.</haxe_doc>
		</switchState>
		<gameStart set="method" line="637"><f a=""><x path="Void"/></f></gameStart>
		<step set="method" line="649">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* This is the main game update logic section.
	 * The `onEnterFrame()` handler is in charge of calling this
	 * the appropriate number of times each frame.
	 * This block handles state changes, replays, all that good stuff.</haxe_doc>
		</step>
		<handleReplayRequests set="method" line="672"><f a=""><x path="Void"/></f></handleReplayRequests>
		<update set="method" line="706">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* This function is called by `step()` and updates the actual game state.
	 * May be called multiple times per "frame" or draw call.</haxe_doc>
		</update>
		<updateElapsed set="method" line="751"><f a=""><x path="Void"/></f></updateElapsed>
		<updateInput set="method" line="767"><f a=""><x path="Void"/></f></updateInput>
		<draw set="method" line="830">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Goes through the game state and draws all the game objects and special effects.</haxe_doc>
		</draw>
		<getTicks get="inline" set="null" line="874"><f a=""><x path="Int"/></f></getTicks>
		<getTimer set="dynamic" line="879"><f a=""><x path="Int"/></f></getTimer>
		<new public="1" set="method" line="249">
			<f a="?GameWidth:?GameHeight:?InitialState:?Zoom:?UpdateFramerate:?DrawFramerate:?SkipSplash:?StartFullscreen" v="0:0::1:60:60:false:false">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Class"><c path="flixel.FlxState"/></x>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ StartFullscreen : false, SkipSplash : false, DrawFramerate : 60, UpdateFramerate : 60, Zoom : 1, GameHeight : 0, GameWidth : 0 }</e></m></meta>
			<haxe_doc>* Instantiate a new game object.
	 * 
	 * @param GameWidth       The width of your game in game pixels, not necessarily final display pixels (see `Zoom`).
	 *                        If equal to `0`, the window width specified in the `Project.xml` is used.
	 * @param GameHeight      The height of your game in game pixels, not necessarily final display pixels (see `Zoom`).
	 *                        If equal to `0`, the window height specified in the `Project.xml` is used.
	 * @param InitialState    The class name of the state you want to create and switch to first (e.g. `MenuState`).
	 * @param Zoom            The default level of zoom for the game's cameras (e.g. `2` = all pixels are now drawn at 2x).
	 * @param UpdateFramerate How frequently the game should update (default is `60` times per second).
	 * @param DrawFramerate   Sets the actual display / draw framerate for the game (default is `60` times per second).
	 * @param SkipSplash      Whether you want to skip the flixel splash screen with `FLX_NO_DEBUG`.
	 * @param StartFullscreen Whether to start the game in fullscreen mode (desktop targets only).</haxe_doc>
		</new>
		<haxe_doc>* `FlxGame` is the heart of all Flixel games, and contains a bunch of basic game loops and things.
 * It is a long and sloppy file that you shouldn't have to worry about too much!
 * It is basically only used to create your game object in the first place,
 * after that `FlxG` and `FlxState` have all the useful stuff you actually need.</haxe_doc>
		<meta><m n=":allow"><e>flixel.FlxG</e></m></meta>
	</class>
	<class path="flixel.FlxObject" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/FlxObject.hx">
		<extends path="flixel.FlxBasic"/>
		<defaultPixelPerfectPosition public="1" expr="false" line="26" static="1">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
			<haxe_doc>* Default value for `FlxObject`'s `pixelPerfectPosition` var.</haxe_doc>
		</defaultPixelPerfectPosition>
		<SEPARATE_BIAS public="1" expr="4" line="33" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>4</e></m></meta>
			<haxe_doc>* This value dictates the maximum number of pixels two objects have to intersect
	 * before collision stops trying to separate them.
	 * Don't modify this unless your objects are passing through each other.</haxe_doc>
		</SEPARATE_BIAS>
		<LEFT public="1" get="inline" set="null" expr="0x0001" line="37" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x0001</e></m></meta>
			<haxe_doc>* Generic value for "left". Used by `facing`, `allowCollisions`, and `touching`.</haxe_doc>
		</LEFT>
		<RIGHT public="1" get="inline" set="null" expr="0x0010" line="41" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x0010</e></m></meta>
			<haxe_doc>* Generic value for "right". Used by `facing`, `allowCollisions`, and `touching`.</haxe_doc>
		</RIGHT>
		<UP public="1" get="inline" set="null" expr="0x0100" line="45" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x0100</e></m></meta>
			<haxe_doc>* Generic value for "up". Used by `facing`, `allowCollisions`, and `touching`.</haxe_doc>
		</UP>
		<DOWN public="1" get="inline" set="null" expr="0x1000" line="49" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x1000</e></m></meta>
			<haxe_doc>* Generic value for "down". Used by `facing`, `allowCollisions`, and `touching`.</haxe_doc>
		</DOWN>
		<NONE public="1" get="inline" set="null" expr="0x0000" line="53" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x0000</e></m></meta>
			<haxe_doc>* Special-case constant meaning no collisions, used mainly by `allowCollisions` and `touching`.</haxe_doc>
		</NONE>
		<CEILING public="1" get="inline" set="null" expr="UP" line="57" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>UP</e></m></meta>
			<haxe_doc>* Special-case constant meaning up, used mainly by `allowCollisions` and `touching`.</haxe_doc>
		</CEILING>
		<FLOOR public="1" get="inline" set="null" expr="DOWN" line="61" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>DOWN</e></m></meta>
			<haxe_doc>* Special-case constant meaning down, used mainly by `allowCollisions` and `touching`.</haxe_doc>
		</FLOOR>
		<WALL public="1" get="inline" set="null" expr="LEFT | RIGHT" line="65" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>LEFT | RIGHT</e></m></meta>
			<haxe_doc>* Special-case constant meaning only the left and right sides, used mainly by `allowCollisions` and `touching`.</haxe_doc>
		</WALL>
		<ANY public="1" get="inline" set="null" expr="LEFT | RIGHT | UP | DOWN" line="69" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>LEFT | RIGHT | UP | DOWN</e></m></meta>
			<haxe_doc>* Special-case constant meaning any direction, used mainly by `allowCollisions` and `touching`.</haxe_doc>
		</ANY>
		<_firstSeparateFlxRect expr="FlxRect.get()" line="72" static="1">
			<c path="flixel.math.FlxRect"/>
			<meta>
				<m n=":value"><e>FlxRect.get()</e></m>
				<m n=":noCompletion"/>
			</meta>
		</_firstSeparateFlxRect>
		<_secondSeparateFlxRect expr="FlxRect.get()" line="74" static="1">
			<c path="flixel.math.FlxRect"/>
			<meta>
				<m n=":value"><e>FlxRect.get()</e></m>
				<m n=":noCompletion"/>
			</meta>
		</_secondSeparateFlxRect>
		<separate public="1" set="method" line="83" static="1">
			<f a="Object1:Object2">
				<c path="flixel.FlxObject"/>
				<c path="flixel.FlxObject"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* The main collision resolution function in Flixel.
	 * 
	 * @param   Object1   Any `FlxObject`.
	 * @param   Object2   Any other `FlxObject`.
	 * @return  Whether the objects in fact touched and were separated.</haxe_doc>
		</separate>
		<updateTouchingFlags public="1" set="method" line="98" static="1">
			<f a="Object1:Object2">
				<c path="flixel.FlxObject"/>
				<c path="flixel.FlxObject"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Similar to `separate()`, but only checks whether any overlap is found and updates
	 * the `touching` flags of the input objects, but no separation is performed.
	 * 
	 * @param   Object1   Any `FlxObject`.
	 * @param   Object2   Any other `FlxObject`.
	 * @return  Whether the objects in fact touched.</haxe_doc>
		</updateTouchingFlags>
		<computeOverlapX set="method" line="111" static="1">
			<f a="Object1:Object2:?checkMaxOverlap" v="::true">
				<c path="flixel.FlxObject"/>
				<c path="flixel.FlxObject"/>
				<x path="Bool"/>
				<x path="Float"/>
			</f>
			<meta>
				<m n=":value"><e>{ checkMaxOverlap : true }</e></m>
				<m n=":noCompletion"/>
			</meta>
			<haxe_doc>* Internal function that computes overlap among two objects on the X axis. It also updates the `touching` variable.
	 * `checkMaxOverlap` is used to determine whether we want to exclude (therefore check) overlaps which are
	 * greater than a certain maximum (linked to `SEPARATE_BIAS`). Default is `true`, handy for `separateX` code.</haxe_doc>
		</computeOverlapX>
		<separateX public="1" set="method" line="170" static="1">
			<f a="Object1:Object2">
				<c path="flixel.FlxObject"/>
				<c path="flixel.FlxObject"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* The X-axis component of the object separation process.
	 * 
	 * @param   Object1   Any `FlxObject`.
	 * @param   Object2   Any other `FlxObject`.
	 * @return  Whether the objects in fact touched and were separated along the X axis.</haxe_doc>
		</separateX>
		<updateTouchingFlagsX public="1" set="method" line="236" static="1">
			<f a="Object1:Object2">
				<c path="flixel.FlxObject"/>
				<c path="flixel.FlxObject"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Checking overlap and updating `touching` variables, X-axis part used by `updateTouchingFlags`.
	 * 
	 * @param   Object1   Any `FlxObject`.
	 * @param   Object2   Any other `FlxObject`.
	 * @return  Whether the objects in fact touched along the X axis.</haxe_doc>
		</updateTouchingFlagsX>
		<computeOverlapY set="method" line="259" static="1">
			<f a="Object1:Object2:?checkMaxOverlap" v="::true">
				<c path="flixel.FlxObject"/>
				<c path="flixel.FlxObject"/>
				<x path="Bool"/>
				<x path="Float"/>
			</f>
			<meta>
				<m n=":value"><e>{ checkMaxOverlap : true }</e></m>
				<m n=":noCompletion"/>
			</meta>
			<haxe_doc>* Internal function that computes overlap among two objects on the Y axis. It also updates the `touching` variable.
	 * `checkMaxOverlap` is used to determine whether we want to exclude (therefore check) overlaps which are
	 * greater than a certain maximum (linked to `SEPARATE_BIAS`). Default is `true`, handy for `separateY` code.</haxe_doc>
		</computeOverlapY>
		<separateY public="1" set="method" line="318" static="1">
			<f a="Object1:Object2">
				<c path="flixel.FlxObject"/>
				<c path="flixel.FlxObject"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* The Y-axis component of the object separation process.
	 * 
	 * @param   Object1   Any `FlxObject`.
	 * @param   Object2   Any other `FlxObject`.
	 * @return  Whether the objects in fact touched and were separated along the Y axis.</haxe_doc>
		</separateY>
		<updateTouchingFlagsY public="1" set="method" line="396" static="1">
			<f a="Object1:Object2">
				<c path="flixel.FlxObject"/>
				<c path="flixel.FlxObject"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Checking overlap and updating touching variables, Y-axis part used by `updateTouchingFlags`.
	 * 
	 * @param   Object1   Any `FlxObject`.
	 * @param   Object2   Any other `FlxObject`.
	 * @return  Whether the objects in fact touched along the Y axis.</haxe_doc>
		</updateTouchingFlagsY>
		<x public="1" set="accessor" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* X position of the upper left corner of this object in world space.</haxe_doc>
		</x>
		<y public="1" set="accessor" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* Y position of the upper left corner of this object in world space.</haxe_doc>
		</y>
		<width public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<meta><m n=":isVar"/></meta>
			<haxe_doc>* The width of this object's hitbox. For sprites, use `offset` to control the hitbox position.</haxe_doc>
		</width>
		<height public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<meta><m n=":isVar"/></meta>
			<haxe_doc>* The height of this object's hitbox. For sprites, use `offset` to control the hitbox position.</haxe_doc>
		</height>
		<pixelPerfectRender public="1" set="accessor">
			<t path="Null"><x path="Bool"/></t>
			<haxe_doc>* Whether or not the coordinates should be rounded during rendering.
	 * Does not affect `copyPixels()`, which can only render on whole pixels.
	 * Defaults to the camera's global `pixelPerfectRender` value,
	 * but overrides that value if not equal to `null`.</haxe_doc>
		</pixelPerfectRender>
		<pixelPerfectPosition public="1" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
			<haxe_doc>* Whether or not the position of this object should be rounded before any `draw()` or collision checking.</haxe_doc>
		</pixelPerfectPosition>
		<angle public="1" set="accessor" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* Set the angle (in degrees) of a sprite to rotate it. WARNING: rotating sprites
	 * decreases their rendering performance by a factor of ~10x when using blitting!</haxe_doc>
		</angle>
		<moves public="1" set="accessor" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
			<haxe_doc>* Set this to `false` if you want to skip the automatic motion/movement stuff (see `updateMotion()`).
	 * `FlxObject` and `FlxSprite` default to `true`. `FlxText`, `FlxTileblock` and `FlxTilemap` default to `false`.</haxe_doc>
		</moves>
		<immovable public="1" set="accessor" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
			<haxe_doc>* Whether an object will move/alter position after a collision.</haxe_doc>
		</immovable>
		<solid public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<haxe_doc>* Whether the object collides or not. For more control over what directions the object will collide from,
	 * use collision constants (like `LEFT`, `FLOOR`, etc) to set the value of `allowCollisions` directly.</haxe_doc>
		</solid>
		<scrollFactor public="1" set="null">
			<c path="flixel.math.FlxPoint"/>
			<haxe_doc>* Controls how much this object is affected by camera scrolling. `0` = no movement (e.g. a background layer),
	 * `1` = same movement speed as the foreground. Default value is `(1,1)`,
	 * except for UI elements like `FlxButton` where it's `(0,0)`.</haxe_doc>
		</scrollFactor>
		<velocity public="1" set="null">
			<c path="flixel.math.FlxPoint"/>
			<haxe_doc>* The basic speed of this object (in pixels per second).</haxe_doc>
		</velocity>
		<acceleration public="1" set="null">
			<c path="flixel.math.FlxPoint"/>
			<haxe_doc>* How fast the speed of this object is changing (in pixels per second).
	 * Useful for smooth movement and gravity.</haxe_doc>
		</acceleration>
		<drag public="1" set="null">
			<c path="flixel.math.FlxPoint"/>
			<haxe_doc>* This isn't drag exactly, more like deceleration that is only applied
	 * when `acceleration` is not affecting the sprite.</haxe_doc>
		</drag>
		<maxVelocity public="1" set="null">
			<c path="flixel.math.FlxPoint"/>
			<haxe_doc>* If you are using `acceleration`, you can use `maxVelocity` with it
	 * to cap the speed automatically (very useful!).</haxe_doc>
		</maxVelocity>
		<last public="1" set="null">
			<c path="flixel.math.FlxPoint"/>
			<haxe_doc>* Important variable for collision processing.
	 * By default this value is set automatically during at the start of `update()`.</haxe_doc>
		</last>
		<mass public="1" expr="1">
			<x path="Float"/>
			<meta><m n=":value"><e>1</e></m></meta>
			<haxe_doc>* The virtual mass of the object. Default value is 1. Currently only used with elasticity 
	 * during collision resolution. Change at your own risk; effects seem crazy unpredictable so far!</haxe_doc>
		</mass>
		<elasticity public="1" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* The bounciness of this object. Only affects collisions. Default value is 0, or "not bouncy at all."</haxe_doc>
		</elasticity>
		<angularVelocity public="1" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* This is how fast you want this sprite to spin (in degrees per second).</haxe_doc>
		</angularVelocity>
		<angularAcceleration public="1" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* How fast the spin speed should change (in degrees per second).</haxe_doc>
		</angularAcceleration>
		<angularDrag public="1" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* Like drag but for spinning.</haxe_doc>
		</angularDrag>
		<maxAngular public="1" expr="10000">
			<x path="Float"/>
			<meta><m n=":value"><e>10000</e></m></meta>
			<haxe_doc>* Use in conjunction with angularAcceleration for fluid spin speed control.</haxe_doc>
		</maxAngular>
		<health public="1" expr="1">
			<x path="Float"/>
			<meta><m n=":value"><e>1</e></m></meta>
			<haxe_doc>* Handy for storing health percentage or armor points or whatever.</haxe_doc>
		</health>
		<touching public="1" expr="NONE">
			<x path="Int"/>
			<meta><m n=":value"><e>NONE</e></m></meta>
			<haxe_doc>* Bit field of flags (use with UP, DOWN, LEFT, RIGHT, etc) indicating surface contacts. Use bitwise operators to check the values 
	 * stored here, or use isTouching(), justTouched(), etc. You can even use them broadly as boolean values if you're feeling saucy!</haxe_doc>
		</touching>
		<wasTouching public="1" expr="NONE">
			<x path="Int"/>
			<meta><m n=":value"><e>NONE</e></m></meta>
			<haxe_doc>* Bit field of flags (use with UP, DOWN, LEFT, RIGHT, etc) indicating surface contacts from the previous game loop step. Use bitwise operators to check the values 
	 * stored here, or use isTouching(), justTouched(), etc. You can even use them broadly as boolean values if you're feeling saucy!</haxe_doc>
		</wasTouching>
		<allowCollisions public="1" set="accessor" expr="ANY">
			<x path="Int"/>
			<meta><m n=":value"><e>ANY</e></m></meta>
			<haxe_doc>* Bit field of flags (use with UP, DOWN, LEFT, RIGHT, etc) indicating collision directions. Use bitwise operators to check the values stored here.
	 * Useful for things like one-way platforms (e.g. allowCollisions = UP;). The accessor "solid" just flips this variable between NONE and ANY.</haxe_doc>
		</allowCollisions>
		<collisonXDrag public="1" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
			<haxe_doc>* Whether this sprite is dragged along with the horizontal movement of objects it collides with 
	 * (makes sense for horizontally-moving platforms in platformers for example).</haxe_doc>
		</collisonXDrag>
		<debugBoundingBoxColor public="1" expr="null">
			<t path="Null"><x path="flixel.util.FlxColor"/></t>
			<meta><m n=":value"><e>null</e></m></meta>
			<haxe_doc>* Overriding this will force a specific color to be used for debug rect
	 * (ignoring any of the other debug bounding box colors specified).</haxe_doc>
		</debugBoundingBoxColor>
		<debugBoundingBoxColorSolid public="1" set="accessor" expr="FlxColor.RED">
			<x path="flixel.util.FlxColor"/>
			<meta><m n=":value"><e>FlxColor.RED</e></m></meta>
			<haxe_doc>* Color used for the debug rect if `allowCollisions == FlxObject.ANY`.
	 * @since 4.2.0</haxe_doc>
		</debugBoundingBoxColorSolid>
		<debugBoundingBoxColorNotSolid public="1" set="accessor" expr="FlxColor.BLUE">
			<x path="flixel.util.FlxColor"/>
			<meta><m n=":value"><e>FlxColor.BLUE</e></m></meta>
			<haxe_doc>* Color used for the debug rect if `allowCollisions == FlxObject.NONE`.
	 * @since 4.2.0</haxe_doc>
		</debugBoundingBoxColorNotSolid>
		<debugBoundingBoxColorPartial public="1" set="accessor" expr="FlxColor.GREEN">
			<x path="flixel.util.FlxColor"/>
			<meta><m n=":value"><e>FlxColor.GREEN</e></m></meta>
			<haxe_doc>* Color used for the debug rect if this object collides partially
	 * (`immovable` in the case of `FlxObject`, or `allowCollisions` not equal to
	 * `FlxObject.ANY` or `FlxObject.NONE` in the case of tiles in `FlxTilemap`).
	 * @since 4.2.0</haxe_doc>
		</debugBoundingBoxColorPartial>
		<ignoreDrawDebug public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
			<haxe_doc>* Setting this to `true` will prevent the object from appearing
	 * when `FlxG.debugger.drawDebug` is `true`.</haxe_doc>
		</ignoreDrawDebug>
		<path public="1" set="accessor" expr="null">
			<c path="flixel.util.FlxPath"/>
			<meta><m n=":value"><e>null</e></m></meta>
			<haxe_doc>* The path this object follows. Not initialized by default.
	 * Assign a `new FlxPath()` object and `start()` it if you want to this object to follow a path.
	 * Set `path` to `null` again to stop following the path.
	 * See `flixel.util.FlxPath` for more info and usage examples.</haxe_doc>
		</path>
		<_point expr="FlxPoint.get()">
			<c path="flixel.math.FlxPoint"/>
			<meta>
				<m n=":value"><e>FlxPoint.get()</e></m>
				<m n=":noCompletion"/>
			</meta>
		</_point>
		<_rect expr="FlxRect.get()">
			<c path="flixel.math.FlxRect"/>
			<meta>
				<m n=":value"><e>FlxRect.get()</e></m>
				<m n=":noCompletion"/>
			</meta>
		</_rect>
		<initVars set="method" line="610">
			<f a=""><x path="Void"/></f>
			<meta><m n=":noCompletion"/></meta>
			<haxe_doc>* Internal function for initialization of some object's variables.</haxe_doc>
		</initVars>
		<initMotionVars get="inline" set="null" line="624">
			<f a=""><x path="Void"/></f>
			<meta><m n=":noCompletion"/></meta>
			<haxe_doc>* Internal function for initialization of some variables that are used in `updateMotion()`.</haxe_doc>
		</initMotionVars>
		<destroy public="1" set="method" line="642" override="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* **WARNING:** A destroyed `FlxBasic` can't be used anymore.
	 * It may even cause crashes if it is still part of a group or state.
	 * You may want to use `kill()` instead if you want to disable the object temporarily only and `revive()` it later.
	 * 
	 * This function is usually not called manually (Flixel calls it automatically during state switches for all `add()`ed objects).
	 * 
	 * Override this function to `null` out variables manually or call `destroy()` on class members if necessary.
	 * Don't forget to call `super.destroy()`!</haxe_doc>
		</destroy>
		<update public="1" set="method" line="660" override="1">
			<f a="elapsed">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Override this function to update your class's position and appearance.
	 * This is where most of your game rules and behavioral code will go.</haxe_doc>
		</update>
		<updateMotion set="method" line="685">
			<f a="elapsed">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
			<haxe_doc>* Internal function for updating the position and speed of this object.
	 * Useful for cases when you need to update this but are buried down in too many supers.
	 * Does a slightly fancier-than-normal integration to help with higher fidelity framerate-independent motion.</haxe_doc>
		</updateMotion>
		<draw public="1" set="method" line="708" override="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Rarely called, and in this case just increments the visible objects count and calls `drawDebug()` if necessary.</haxe_doc>
		</draw>
		<overlaps public="1" set="method" line="730">
			<f a="ObjectOrGroup:?InScreenSpace:?Camera" v=":false:">
				<c path="flixel.FlxBasic"/>
				<x path="Bool"/>
				<c path="flixel.FlxCamera"/>
				<x path="Bool"/>
			</f>
			<meta>
				<m n=":value"><e>{ InScreenSpace : false }</e></m>
				<m n=":access"><e>flixel.group.FlxTypedGroup</e></m>
			</meta>
			<haxe_doc>* Checks to see if some `FlxObject` overlaps this `FlxObject` or `FlxGroup`.
	 * If the group has a LOT of things in it, it might be faster to use `FlxG.overlap()`.
	 * WARNING: Currently tilemaps do NOT support screen space overlap checks!
	 * 
	 * @param   ObjectOrGroup   The object or group being tested.
	 * @param   InScreenSpace   Whether to take scroll factors into account when checking for overlap.
	 *                          Default is `false`, or "only compare in world space."
	 * @param   Camera          Specify which game camera you want.
	 *                          If `null`, it will just grab the first global camera.
	 * @return  Whether or not the two objects overlap.</haxe_doc>
		</overlaps>
		<overlapsCallback get="inline" set="null" line="764">
			<f a="ObjectOrGroup:X:Y:InScreenSpace:Camera">
				<c path="flixel.FlxBasic"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Bool"/>
				<c path="flixel.FlxCamera"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</overlapsCallback>
		<overlapsAt public="1" set="method" line="789">
			<f a="X:Y:ObjectOrGroup:?InScreenSpace:?Camera" v=":::false:">
				<x path="Float"/>
				<x path="Float"/>
				<c path="flixel.FlxBasic"/>
				<x path="Bool"/>
				<c path="flixel.FlxCamera"/>
				<x path="Bool"/>
			</f>
			<meta>
				<m n=":value"><e>{ InScreenSpace : false }</e></m>
				<m n=":access"><e>flixel.group.FlxTypedGroup</e></m>
			</meta>
			<haxe_doc>* Checks to see if this `FlxObject` were located at the given position,
	 * would it overlap the `FlxObject` or `FlxGroup`?
	 * This is distinct from `overlapsPoint()`, which just checks that point,
	 * rather than taking the object's size into account.
	 * WARNING: Currently tilemaps do NOT support screen space overlap checks!
	 * 
	 * @param   X               The X position you want to check.
	 *                          Pretends this object (the caller, not the parameter) is located here.
	 * @param   Y               The Y position you want to check.
	 *                          Pretends this object (the caller, not the parameter) is located here.
	 * @param   ObjectOrGroup   The object or group being tested.
	 * @param   InScreenSpace   Whether to take scroll factors into account when checking for overlap.
	 *                          Default is `false`, or "only compare in world space."
	 * @param   Camera          Specify which game camera you want.
	 *                          If `null`, it will just grab the first global camera.
	 * @return  Whether or not the two objects overlap.</haxe_doc>
		</overlapsAt>
		<overlapsAtCallback get="inline" set="null" line="826">
			<f a="ObjectOrGroup:X:Y:InScreenSpace:Camera">
				<c path="flixel.FlxBasic"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Bool"/>
				<c path="flixel.FlxCamera"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</overlapsAtCallback>
		<overlapsPoint public="1" set="method" line="841">
			<f a="point:?InScreenSpace:?Camera" v=":false:">
				<c path="flixel.math.FlxPoint"/>
				<x path="Bool"/>
				<c path="flixel.FlxCamera"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":value"><e>{ InScreenSpace : false }</e></m></meta>
			<haxe_doc>* Checks to see if a point in 2D world space overlaps this `FlxObject`.
	 * 
	 * @param   Point           The point in world space you want to check.
	 * @param   InScreenSpace   Whether to take scroll factors into account when checking for overlap.
	 * @param   Camera          Specify which game camera you want.
	 *                          If `null`, it will just grab the first global camera.
	 * @return  Whether or not the point overlaps this object.</haxe_doc>
		</overlapsPoint>
		<inWorldBounds public="1" get="inline" set="null" line="865">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>* Check and see if this object is currently within the world bounds -
	 * useful for killing objects that get too far away.
	 * 
	 * @return   Whether the object is within the world bounds or not.</haxe_doc>
		</inWorldBounds>
		<getScreenPosition public="1" set="method" line="880">
			<f a="?point:?Camera">
				<c path="flixel.math.FlxPoint"/>
				<c path="flixel.FlxCamera"/>
				<c path="flixel.math.FlxPoint"/>
			</f>
			<haxe_doc>* Call this function to figure out the on-screen position of the object.
	 * 
	 * @param   Point    Takes a `FlxPoint` object and assigns the post-scrolled X and Y values of this object to it.
	 * @param   Camera   Specify which game camera you want.
	 *                   If `null`, it will just grab the first global camera.
	 * @return  The Point you passed in, or a new Point if you didn't pass one,
	 *          containing the screen X and Y position of this object.</haxe_doc>
		</getScreenPosition>
		<getPosition public="1" set="method" line="895"><f a="?point">
	<c path="flixel.math.FlxPoint"/>
	<c path="flixel.math.FlxPoint"/>
</f></getPosition>
		<getMidpoint public="1" set="method" line="909">
			<f a="?point">
				<c path="flixel.math.FlxPoint"/>
				<c path="flixel.math.FlxPoint"/>
			</f>
			<haxe_doc>* Retrieve the midpoint of this object in world coordinates.
	 * 
	 * @param   point   Allows you to pass in an existing `FlxPoint` object if you're so inclined.
	 *                  Otherwise a new one is created.
	 * @return  A `FlxPoint` object containing the midpoint of this object in world coordinates.</haxe_doc>
		</getMidpoint>
		<getHitbox public="1" set="method" line="916"><f a="?rect">
	<c path="flixel.math.FlxRect"/>
	<c path="flixel.math.FlxRect"/>
</f></getHitbox>
		<reset public="1" set="method" line="930">
			<f a="X:Y">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Handy function for reviving game objects.
	 * Resets their existence flags and position.
	 * 
	 * @param   X   The new X position of this object.
	 * @param   Y   The new Y position of this object.</haxe_doc>
		</reset>
		<isOnScreen public="1" set="method" line="947">
			<f a="?Camera">
				<c path="flixel.FlxCamera"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Check and see if this object is currently on screen.
	 * 
	 * @param   Camera   Specify which game camera you want.
	 *                   If `null`, it will just grab the first global camera.
	 * @return  Whether the object is on screen or not.</haxe_doc>
		</isOnScreen>
		<isPixelPerfectRender public="1" set="method" line="959">
			<f a="?Camera">
				<c path="flixel.FlxCamera"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Check if object is rendered pixel perfect on a specific camera.</haxe_doc>
		</isPixelPerfectRender>
		<isTouching public="1" get="inline" set="null" line="973">
			<f a="Direction">
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Handy function for checking if this object is touching a particular surface.
	 * Be sure to check it before calling `super.update()`, as that will reset the flags.
	 * 
	 * @param   Direction   Any of the collision flags (e.g. `LEFT`, `FLOOR`, etc).
	 * @return  Whether the object is touching an object in (any of) the specified direction(s) this frame.</haxe_doc>
		</isTouching>
		<justTouched public="1" get="inline" set="null" line="985">
			<f a="Direction">
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Handy function for checking if this object is just landed on a particular surface.
	 * Be sure to check it before calling `super.update()`, as that will reset the flags.
	 * 
	 * @param   Direction   Any of the collision flags (e.g. `LEFT`, `FLOOR`, etc).
	 * @return  Whether the object just landed on (any of) the specified surface(s) this frame.</haxe_doc>
		</justTouched>
		<hurt public="1" set="method" line="996">
			<f a="Damage">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Reduces the `health` variable of this object by the amount specified in `Damage`.
	 * Calls `kill()` if health drops to or below zero.
	 * 
	 * @param   Damage   How much health to take away (use a negative number to give a health bonus).</haxe_doc>
		</hurt>
		<screenCenter public="1" set="method" line="1009">
			<f a="?axes">
				<e path="flixel.util.FlxAxes"/>
				<c path="flixel.FlxObject"/>
			</f>
			<haxe_doc>* Centers this `FlxObject` on the screen, either by the x axis, y axis, or both.
	 * 
	 * @param   axes   On what axes to center the object - default is `FlxAxes.XY` / both.
	 * @return  This FlxObject for chaining</haxe_doc>
		</screenCenter>
		<setPosition public="1" set="method" line="1029">
			<f a="?X:?Y" v="0:0">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ Y : 0, X : 0 }</e></m></meta>
			<haxe_doc>* Helper function to set the coordinates of this object.
	 * Handy since it only requires one line of code.
	 * 
	 * @param   X   The new x position
	 * @param   Y   The new y position</haxe_doc>
		</setPosition>
		<setSize public="1" set="method" line="1041">
			<f a="Width:Height">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Shortcut for setting both width and Height.
	 * 
	 * @param   Width    The new hitbox width.
	 * @param   Height   The new hitbox height.</haxe_doc>
		</setSize>
		<drawDebug public="1" set="method" line="1048"><f a=""><x path="Void"/></f></drawDebug>
		<drawDebugOnCamera public="1" set="method" line="1068">
			<f a="camera">
				<c path="flixel.FlxCamera"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Override this function to draw custom "debug mode" graphics to the
	 * specified camera while the debugger's `drawDebug` mode is toggled on.
	 * 
	 * @param   Camera   Which camera to draw the debug visuals to.</haxe_doc>
		</drawDebugOnCamera>
		<drawDebugBoundingBox set="method" line="1079"><f a="gfx:rect:allowCollisions:partial">
	<t path="flash.display.Graphics"/>
	<c path="flixel.math.FlxRect"/>
	<x path="Int"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></drawDebugBoundingBox>
		<beginDrawDebug get="inline" set="null" line="1100"><f a="camera">
	<c path="flixel.FlxCamera"/>
	<t path="flash.display.Graphics"/>
</f></beginDrawDebug>
		<endDrawDebug get="inline" set="null" line="1113"><f a="camera">
	<c path="flixel.FlxCamera"/>
	<x path="Void"/>
</f></endDrawDebug>
		<getBoundingBox set="method" line="1121">
			<f a="camera">
				<c path="flixel.FlxCamera"/>
				<c path="flixel.math.FlxRect"/>
			</f>
			<meta><m n=":access"><e>flixel.FlxCamera</e></m></meta>
		</getBoundingBox>
		<toString public="1" set="method" line="1139" override="1">
			<f a=""><c path="String"/></f>
			<haxe_doc>* Convert object to readable string name. Useful for debugging, save games, etc.</haxe_doc>
		</toString>
		<set_x set="method" line="1151">
			<f a="NewX">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_x>
		<set_y set="method" line="1157">
			<f a="NewY">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_y>
		<set_width set="method" line="1163">
			<f a="Width">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_width>
		<set_height set="method" line="1177">
			<f a="Height">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_height>
		<get_width set="method" line="1191">
			<f a=""><x path="Float"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_width>
		<get_height set="method" line="1197">
			<f a=""><x path="Float"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_height>
		<get_solid get="inline" set="null" line="1203">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_solid>
		<set_solid set="method" line="1209">
			<f a="Solid">
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_solid>
		<set_angle set="method" line="1216">
			<f a="Value">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_angle>
		<set_moves set="method" line="1222">
			<f a="Value">
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_moves>
		<set_immovable set="method" line="1228">
			<f a="Value">
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_immovable>
		<set_pixelPerfectRender set="method" line="1234">
			<f a="Value">
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_pixelPerfectRender>
		<set_allowCollisions set="method" line="1240">
			<f a="Value">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_allowCollisions>
		<set_debugBoundingBoxColorSolid set="method" line="1246"><f a="color">
	<x path="flixel.util.FlxColor"/>
	<x path="flixel.util.FlxColor"/>
</f></set_debugBoundingBoxColorSolid>
		<set_debugBoundingBoxColorNotSolid set="method" line="1251"><f a="color">
	<x path="flixel.util.FlxColor"/>
	<x path="flixel.util.FlxColor"/>
</f></set_debugBoundingBoxColorNotSolid>
		<set_debugBoundingBoxColorPartial set="method" line="1256"><f a="color">
	<x path="flixel.util.FlxColor"/>
	<x path="flixel.util.FlxColor"/>
</f></set_debugBoundingBoxColorPartial>
		<set_path set="method" line="1263">
			<f a="path">
				<c path="flixel.util.FlxPath"/>
				<c path="flixel.util.FlxPath"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_path>
		<new public="1" set="method" line="594">
			<f a="?X:?Y:?Width:?Height" v="0:0:0:0">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ Height : 0, Width : 0, Y : 0, X : 0 }</e></m></meta>
			<haxe_doc>* @param   X        The X-coordinate of the point in space.
	 * @param   Y        The Y-coordinate of the point in space.
	 * @param   Width    Desired width of the rectangle.
	 * @param   Height   Desired height of the rectangle.</haxe_doc>
		</new>
		<haxe_doc>* This is the base class for most of the display objects (`FlxSprite`, `FlxText`, etc).
 * It includes some basic attributes about game objects, basic state information,
 * sizes, scrolling, and basic physics and motion.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="flixel.FlxSprite" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/FlxSprite.hx">
		<extends path="flixel.FlxObject"/>
		<animation public="1">
			<c path="flixel.animation.FlxAnimationController"/>
			<haxe_doc>* Class that handles adding and playing animations on this sprite.</haxe_doc>
		</animation>
		<framePixels public="1">
			<t path="flash.display.BitmapData"/>
			<haxe_doc>* The current display state of the sprite including current animation frame,
	 * tint, flip etc... may be `null` unless `useFramePixels` is `true`.</haxe_doc>
		</framePixels>
		<useFramePixels public="1" set="accessor" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
			<haxe_doc>* Always `true` on `FlxG.renderBlit`. On `FlxG.renderTile` it determines whether
	 * `framePixels` is used and defaults to `false` for performance reasons.</haxe_doc>
		</useFramePixels>
		<antialiasing public="1" set="accessor" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
			<haxe_doc>* Controls whether the object is smoothed when rotated, affects performance.</haxe_doc>
		</antialiasing>
		<dirty public="1" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
			<haxe_doc>* Set this flag to true to force the sprite to update during the `draw()` call.
	 * NOTE: Rarely if ever necessary, most sprite operations will flip this flag automatically.</haxe_doc>
		</dirty>
		<pixels public="1" get="accessor" set="accessor">
			<t path="flash.display.BitmapData"/>
			<haxe_doc>* This sprite's graphic / `BitmapData` object.
	 * Automatically adjusts graphic size and render helpers if changed.</haxe_doc>
		</pixels>
		<frame public="1" set="accessor">
			<c path="flixel.graphics.frames.FlxFrame"/>
			<haxe_doc>* Link to current `FlxFrame` from loaded atlas</haxe_doc>
		</frame>
		<frameWidth public="1" set="null" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* The width of the actual graphic or image being displayed (not necessarily the game object/bounding box).</haxe_doc>
		</frameWidth>
		<frameHeight public="1" set="null" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* The height of the actual graphic or image being displayed (not necessarily the game object/bounding box).</haxe_doc>
		</frameHeight>
		<numFrames public="1" set="null" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* The total number of frames in this image.
	 * WARNING: assumes each row in the sprite sheet is full!</haxe_doc>
		</numFrames>
		<frames public="1" set="accessor">
			<c path="flixel.graphics.frames.FlxFramesCollection"/>
			<haxe_doc>* Rendering variables.</haxe_doc>
		</frames>
		<graphic public="1" set="accessor"><c path="flixel.graphics.FlxGraphic"/></graphic>
		<bakedRotationAngle public="1" set="null" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* The minimum angle (out of 360Â°) for which a new baked rotation exists. Example: `90` means there
	 * are 4 baked rotations in the spritesheet. `0` if this sprite does not have any baked rotations.</haxe_doc>
		</bakedRotationAngle>
		<alpha public="1" set="accessor" expr="1.0">
			<x path="Float"/>
			<meta><m n=":value"><e>1.0</e></m></meta>
			<haxe_doc>* Set alpha to a number between `0` and `1` to change the opacity of the sprite.</haxe_doc>
		</alpha>
		<facing public="1" set="accessor" expr="FlxObject.RIGHT">
			<x path="Int"/>
			<meta><m n=":value"><e>FlxObject.RIGHT</e></m></meta>
			<haxe_doc>* Can be set to `FlxObject.LEFT`, `RIGHT`, `UP`, and `DOWN` to take advantage
	 * of flipped sprites and/or just track player orientation more easily.</haxe_doc>
		</facing>
		<flipX public="1" set="accessor" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
			<haxe_doc>* Whether this sprite is flipped on the X axis.</haxe_doc>
		</flipX>
		<flipY public="1" set="accessor" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
			<haxe_doc>* Whether this sprite is flipped on the Y axis.</haxe_doc>
		</flipY>
		<origin public="1" set="null">
			<c path="flixel.math.FlxPoint"/>
			<haxe_doc>* WARNING: The `origin` of the sprite will default to its center. If you change this,
	 * the visuals and the collisions will likely be pretty out-of-sync if you do any rotation.</haxe_doc>
		</origin>
		<offset public="1" set="null">
			<c path="flixel.math.FlxPoint"/>
			<haxe_doc>* Controls the position of the sprite's hitbox. Likely needs to be adjusted after
	 * changing a sprite's `width`, `height` or `scale`.</haxe_doc>
		</offset>
		<scale public="1" set="null">
			<c path="flixel.math.FlxPoint"/>
			<haxe_doc>* Change the size of your sprite's graphic.
	 * NOTE: The hitbox is not automatically adjusted, use `updateHitbox()` for that (or `setGraphicSize()`).
	 * WARNING: With `FlxG.renderBlit`, scaling sprites decreases rendering performance by a factor of about x10!</haxe_doc>
		</scale>
		<blend public="1" set="accessor">
			<t path="flash.display.BlendMode"/>
			<haxe_doc>* Blending modes, just like Photoshop or whatever, e.g. "multiply", "screen", etc.</haxe_doc>
		</blend>
		<color public="1" set="accessor" expr="0xffffff">
			<x path="flixel.util.FlxColor"/>
			<meta><m n=":value"><e>0xffffff</e></m></meta>
			<haxe_doc>* Tints the whole sprite to a color (`0xRRGGBB` format) - similar to OpenGL vertex colors. You can use
	 * `0xAARRGGBB` colors, but the alpha value will simply be ignored. To change the opacity use `alpha`.</haxe_doc>
		</color>
		<colorTransform public="1" set="null"><t path="flash.geom.ColorTransform"/></colorTransform>
		<useColorTransform public="1" set="null" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
			<haxe_doc>* Whether or not to use a `ColorTransform` set via `setColorTransform()`.</haxe_doc>
		</useColorTransform>
		<clipRect public="1" set="accessor">
			<c path="flixel.math.FlxRect"/>
			<haxe_doc>* Clipping rectangle for this sprite.
	 * Changing the rect's properties directly doesn't have any effect,
	 * reassign the property to update it (`sprite.clipRect = sprite.clipRect;`).
	 * Set to `null` to discard graphic frame clipping.</haxe_doc>
		</clipRect>
		<shader public="1">
			<t path="flixel.system.FlxShader"/>
			<haxe_doc>* GLSL shader for this sprite. Only works with OpenFL Next or WebGL.
	 * Avoid changing it frequently as this is a costly operation.
	 * @since 4.1.0</haxe_doc>
		</shader>
		<_frame>
			<c path="flixel.graphics.frames.FlxFrame"/>
			<meta><m n=":noCompletion"/></meta>
			<haxe_doc>* The actual frame used for sprite rendering</haxe_doc>
		</_frame>
		<_frameGraphic>
			<c path="flixel.graphics.FlxGraphic"/>
			<meta><m n=":noCompletion"/></meta>
			<haxe_doc>* Graphic of `_frame`. Used in tile render mode, when `useFramePixels` is `true`.</haxe_doc>
		</_frameGraphic>
		<_facingHorizontalMult expr="1">
			<x path="Int"/>
			<meta>
				<m n=":value"><e>1</e></m>
				<m n=":noCompletion"/>
			</meta>
		</_facingHorizontalMult>
		<_facingVerticalMult expr="1">
			<x path="Int"/>
			<meta>
				<m n=":value"><e>1</e></m>
				<m n=":noCompletion"/>
			</meta>
		</_facingVerticalMult>
		<_flashPoint>
			<t path="flash.geom.Point"/>
			<meta><m n=":noCompletion"/></meta>
			<haxe_doc>* Internal, reused frequently during drawing and animating.</haxe_doc>
		</_flashPoint>
		<_flashRect>
			<t path="flash.geom.Rectangle"/>
			<meta><m n=":noCompletion"/></meta>
			<haxe_doc>* Internal, reused frequently during drawing and animating.</haxe_doc>
		</_flashRect>
		<_flashRect2>
			<t path="flash.geom.Rectangle"/>
			<meta><m n=":noCompletion"/></meta>
			<haxe_doc>* Internal, reused frequently during drawing and animating.</haxe_doc>
		</_flashRect2>
		<_flashPointZero>
			<t path="flash.geom.Point"/>
			<meta><m n=":noCompletion"/></meta>
			<haxe_doc>* Internal, reused frequently during drawing and animating. Always contains `(0,0)`.</haxe_doc>
		</_flashPointZero>
		<_matrix>
			<c path="flixel.math.FlxMatrix"/>
			<meta><m n=":noCompletion"/></meta>
			<haxe_doc>* Internal, helps with animation, caching and drawing.</haxe_doc>
		</_matrix>
		<_halfSize>
			<c path="flixel.math.FlxPoint"/>
			<meta><m n=":noCompletion"/></meta>
			<haxe_doc>* Rendering helper variable</haxe_doc>
		</_halfSize>
		<_sinAngle expr="0">
			<x path="Float"/>
			<meta>
				<m n=":value"><e>0</e></m>
				<m n=":noCompletion"/>
			</meta>
			<haxe_doc>* These vars are being used for rendering in some of `FlxSprite` subclasses (`FlxTileblock`, `FlxBar`,
	 * and `FlxBitmapText`) and for checks if the sprite is in camera's view.</haxe_doc>
		</_sinAngle>
		<_cosAngle expr="1">
			<x path="Float"/>
			<meta>
				<m n=":value"><e>1</e></m>
				<m n=":noCompletion"/>
			</meta>
		</_cosAngle>
		<_angleChanged expr="true">
			<x path="Bool"/>
			<meta>
				<m n=":value"><e>true</e></m>
				<m n=":noCompletion"/>
			</meta>
		</_angleChanged>
		<_facingFlip expr="new Map&lt;Int,{ var x : Bool; var y : Bool}&gt;()">
			<x path="Map">
				<x path="Int"/>
				<a>
					<y><x path="Bool"/></y>
					<x><x path="Bool"/></x>
				</a>
			</x>
			<meta>
				<m n=":value"><e><![CDATA[new Map<Int,{ var x : Bool; var y : Bool}>()]]></e></m>
				<m n=":noCompletion"/>
			</meta>
			<haxe_doc>* Maps `FlxObject` direction constants to axis flips</haxe_doc>
		</_facingFlip>
		<initVars set="method" line="253" override="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":noCompletion"/></meta>
		</initVars>
		<destroy public="1" set="method" line="281" override="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* **WARNING:** A destroyed `FlxBasic` can't be used anymore.
	 * It may even cause crashes if it is still part of a group or state.
	 * You may want to use `kill()` instead if you want to disable the object temporarily only and `revive()` it later.
	 * 
	 * This function is usually not called manually (Flixel calls it automatically during state switches for all `add()`ed objects).
	 * 
	 * Override this function to `null` out variables manually or call `destroy()` on class members if necessary.
	 * Don't forget to call `super.destroy()`!</haxe_doc>
		</destroy>
		<clone public="1" set="method" line="310"><f a=""><c path="flixel.FlxSprite"/></f></clone>
		<loadGraphicFromSprite public="1" set="method" line="322">
			<f a="Sprite">
				<c path="flixel.FlxSprite"/>
				<c path="flixel.FlxSprite"/>
			</f>
			<haxe_doc>* Load graphic from another `FlxSprite` and copy its tile sheet data.
	 * This method can useful for non-flash targets.
	 * 
	 * @param   Sprite   The `FlxSprite` from which you want to load graphic data.
	 * @return  This `FlxSprite` instance (nice for chaining stuff together, if you're into that).</haxe_doc>
		</loadGraphicFromSprite>
		<loadGraphic public="1" set="method" line="359">
			<f a="Graphic:?Animated:?Width:?Height:?Unique:?Key" v=":false:0:0:false:">
				<t path="flixel.system.FlxGraphicAsset"/>
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
				<c path="String"/>
				<c path="flixel.FlxSprite"/>
			</f>
			<meta><m n=":value"><e>{ Unique : false, Height : 0, Width : 0, Animated : false }</e></m></meta>
			<haxe_doc>* Load an image from an embedded graphic file.
	 *
	 * HaxeFlixel's graphic caching system keeps track of loaded image data.
	 * When you load an identical copy of a previously used image, by default
	 * HaxeFlixel copies the previous reference onto the `pixels` field instead
	 * of creating another copy of the image data, to save memory.
	 * 
	 * @param   Graphic    The image you want to use.
	 * @param   Animated   Whether the `Graphic` parameter is a single sprite or a row / grid of sprites.
	 * @param   Width      Specify the width of your sprite
	 *                     (helps figure out what to do with non-square sprites or sprite sheets).
	 * @param   Height     Specify the height of your sprite
	 *                     (helps figure out what to do with non-square sprites or sprite sheets).
	 * @param   Unique     Whether the graphic should be a unique instance in the graphics cache.
	 *                     Set this to `true` if you want to modify the `pixels` field without changing
	 *                     the `pixels` of other sprites with the same `BitmapData`.
	 * @param   Key        Set this parameter if you're loading `BitmapData`.
	 * @return  This `FlxSprite` instance (nice for chaining stuff together, if you're into that).</haxe_doc>
		</loadGraphic>
		<loadRotatedGraphic public="1" set="method" line="402">
			<f a="Graphic:?Rotations:?Frame:?AntiAliasing:?AutoBuffer:?Key" v=":16:-1:false:false:">
				<t path="flixel.system.FlxGraphicAsset"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<c path="String"/>
				<c path="flixel.FlxSprite"/>
			</f>
			<meta><m n=":value"><e>{ AutoBuffer : false, AntiAliasing : false, Frame : -1, Rotations : 16 }</e></m></meta>
			<haxe_doc>* Create a pre-rotated sprite sheet from a simple sprite.
	 * This can make a huge difference in graphical performance!
	 * 
	 * @param   Graphic        The image you want to rotate and stamp.
	 * @param   Rotations      The number of rotation frames the final sprite should have.
	 *                         For small sprites this can be quite a large number (`360` even) without any problems.
	 * @param   Frame          If the `Graphic` has a single row of square animation frames on it,
	 *                         you can specify which of the frames you want to use here.
	 *                         Default is `-1`, or "use whole graphic."
	 * @param   AntiAliasing   Whether to use high quality rotations when creating the graphic. Default is `false`.
	 * @param   AutoBuffer     Whether to automatically increase the image size to accommodate rotated corners.
	 *                         Will create frames that are 150% larger on each axis than the original frame or graphic.
	 * @param   Key            Optional, set this parameter if you're loading `BitmapData`.
	 * @return  This `FlxSprite` instance (nice for chaining stuff together, if you're into that).</haxe_doc>
		</loadRotatedGraphic>
		<loadRotatedFrame public="1" set="method" line="464">
			<f a="Frame:?Rotations:?AntiAliasing:?AutoBuffer" v=":16:false:false">
				<c path="flixel.graphics.frames.FlxFrame"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<c path="flixel.FlxSprite"/>
			</f>
			<meta><m n=":value"><e>{ AutoBuffer : false, AntiAliasing : false, Rotations : 16 }</e></m></meta>
			<haxe_doc>* Helper method which allows using `FlxFrame` as graphic source for sprite's `loadRotatedGraphic()` method.
	 * 
	 * @param   frame          Frame to load into this sprite.
	 * @param   rotations      The number of rotation frames the final sprite should have.
	 *                         For small sprites this can be quite a large number (`360` even) without any problems.
	 * @param   antiAliasing   Whether to use high quality rotations when creating the graphic. Default is `false`.
	 * @param   autoBuffer     Whether to automatically increase the image size to accommodate rotated corners.
	 *                         Will create frames that are 150% larger on each axis than the original frame or graphic.
	 * @return  this FlxSprite with loaded rotated graphic in it.</haxe_doc>
		</loadRotatedFrame>
		<makeGraphic public="1" set="method" line="500">
			<f a="Width:Height:?Color:?Unique:?Key" v="::FlxColor.WHITE:false:">
				<x path="Int"/>
				<x path="Int"/>
				<x path="flixel.util.FlxColor"/>
				<x path="Bool"/>
				<c path="String"/>
				<c path="flixel.FlxSprite"/>
			</f>
			<meta><m n=":value"><e>{ Unique : false, Color : FlxColor.WHITE }</e></m></meta>
			<haxe_doc>* This function creates a flat colored rectangular image dynamically.
	 *
	 * HaxeFlixel's graphic caching system keeps track of loaded image data.
	 * When you make an identical copy of a previously used image, by default
	 * HaxeFlixel copies the previous reference onto the pixels field instead
	 * of creating another copy of the image data, to save memory.
	 * 
	 * @param   Width    The width of the sprite you want to generate.
	 * @param   Height   The height of the sprite you want to generate.
	 * @param   Color    Specifies the color of the generated block (ARGB format).
	 * @param   Unique   Whether the graphic should be a unique instance in the graphics cache. Default is `false`.
	 *                   Set this to `true` if you want to modify the `pixels` field without changing the
	 *                   `pixels` of other sprites with the same `BitmapData`.
	 * @param   Key      An optional `String` key to identify this graphic in the cache.
	 *                   If `null`, the key is determined by `Width`, `Height` and `Color`.
	 *                   If `Unique` is `true` and a graphic with this `Key` already exists,
	 *                   it is used as a prefix to find a new unique name like `"Key3"`.
	 * @return  This `FlxSprite` instance (nice for chaining stuff together, if you're into that).</haxe_doc>
		</makeGraphic>
		<graphicLoaded public="1" set="method" line="511">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Called whenever a new graphic is loaded for this sprite (after `loadGraphic()`, `makeGraphic()` etc).</haxe_doc>
		</graphicLoaded>
		<resetSize public="1" get="inline" set="null" line="516">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Resets some internal variables used for frame `BitmapData` calculation.</haxe_doc>
		</resetSize>
		<resetFrameSize public="1" get="inline" set="null" line="527">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Resets frame size to frame dimensions.</haxe_doc>
		</resetFrameSize>
		<resetSizeFromFrame public="1" get="inline" set="null" line="541">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Resets sprite's size back to frame size.</haxe_doc>
		</resetSizeFromFrame>
		<resetFrame public="1" get="inline" set="null" line="553">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Helper method just for convenience, so you don't need to type
	 * `sprite.frame = sprite.frame;`
	 * You may need this method in tile render mode,
	 * when you want sprite to use its original graphic, not the graphic generated from its `framePixels`.</haxe_doc>
		</resetFrame>
		<setGraphicSize public="1" set="method" line="565">
			<f a="?Width:?Height" v="0:0">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ Height : 0, Width : 0 }</e></m></meta>
			<haxe_doc><![CDATA[* Helper function to set the graphic's dimensions by using `scale`, allowing you to keep the current aspect ratio
	 * should one of the Integers be `<= 0`. It might make sense to call `updateHitbox()` afterwards!
	 * 
	 * @param   Width    How wide the graphic should be. If `<= 0`, and `Height` is set, the aspect ratio will be kept.
	 * @param   Height   How high the graphic should be. If `<= 0`, and `Width` is set, the aspect ratio will be kept.]]></haxe_doc>
		</setGraphicSize>
		<updateHitbox public="1" set="method" line="584">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Updates the sprite's hitbox (`width`, `height`, `offset`) according to the current `scale`.
	 * Also calls `centerOrigin()`.</haxe_doc>
		</updateHitbox>
		<resetHelpers set="method" line="596">
			<f a=""><x path="Void"/></f>
			<meta><m n=":noCompletion"/></meta>
			<haxe_doc>* Resets some important variables for sprite optimization and rendering.</haxe_doc>
		</resetHelpers>
		<update public="1" set="method" line="618" override="1"><f a="elapsed">
	<x path="Float"/>
	<x path="Void"/>
</f></update>
		<updateAnimation set="method" line="627">
			<f a="elapsed">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* This is separated out so it can be easily overridden.</haxe_doc>
		</updateAnimation>
		<checkEmptyFrame set="method" line="633">
			<f a=""><x path="Void"/></f>
			<meta><m n=":noCompletion"/></meta>
		</checkEmptyFrame>
		<draw public="1" set="method" line="642" override="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Called by game loop, updates then blits or renders current frame of animation to the screen.</haxe_doc>
		</draw>
		<drawSimple set="method" line="676">
			<f a="camera">
				<c path="flixel.FlxCamera"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</drawSimple>
		<drawComplex set="method" line="687">
			<f a="camera">
				<c path="flixel.FlxCamera"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</drawComplex>
		<stamp public="1" set="method" line="721">
			<f a="Brush:?X:?Y" v=":0:0">
				<c path="flixel.FlxSprite"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ Y : 0, X : 0 }</e></m></meta>
			<haxe_doc>* Stamps / draws another `FlxSprite` onto this `FlxSprite`.
	 * This function is NOT intended to replace `draw()`!
	 * 
	 * @param   Brush   The sprite you want to use as a brush or stamp or pen or whatever.
	 * @param   X       The X coordinate of the brush's top left corner on this sprite.
	 * @param   Y       They Y coordinate of the brush's top left corner on this sprite.</haxe_doc>
		</stamp>
		<drawFrame public="1" set="method" line="767">
			<f a="?Force" v="false">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ Force : false }</e></m></meta>
			<haxe_doc>* Request (or force) that the sprite update the frame before rendering.
	 * Useful if you are doing procedural generation or other weirdness!
	 * 
	 * @param   Force   Force the frame to redraw, even if its not flagged as necessary.</haxe_doc>
		</drawFrame>
		<centerOffsets public="1" set="method" line="789">
			<f a="?AdjustPosition" v="false">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ AdjustPosition : false }</e></m></meta>
			<haxe_doc>* Helper function that adjusts the offset automatically to center the bounding box within the graphic.
	 * 
	 * @param   AdjustPosition   Adjusts the actual X and Y position just once to match the offset change.</haxe_doc>
		</centerOffsets>
		<centerOrigin public="1" get="inline" set="null" line="804">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Sets the sprite's origin to its center - useful after adjusting
	 * `scale` to make sure rotations work as expected.</haxe_doc>
		</centerOrigin>
		<replaceColor public="1" set="method" line="818">
			<f a="Color:NewColor:?FetchPositions" v="::false">
				<x path="flixel.util.FlxColor"/>
				<x path="flixel.util.FlxColor"/>
				<x path="Bool"/>
				<c path="Array"><c path="flixel.math.FlxPoint"/></c>
			</f>
			<meta><m n=":value"><e>{ FetchPositions : false }</e></m></meta>
			<haxe_doc>* Replaces all pixels with specified `Color` with `NewColor` pixels.
	 * WARNING: very expensive (especially on big graphics) as it iterates over every single pixel.
	 * 
	 * @param   Color            Color to replace
	 * @param   NewColor         New color
	 * @param   FetchPositions   Whether we need to store positions of pixels which colors were replaced.
	 * @return  `Array` with replaced pixels positions</haxe_doc>
		</replaceColor>
		<setColorTransform public="1" set="method" line="839">
			<f a="?redMultiplier:?greenMultiplier:?blueMultiplier:?alphaMultiplier:?redOffset:?greenOffset:?blueOffset:?alphaOffset" v="1.0:1.0:1.0:1.0:0:0:0:0">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ alphaOffset : 0, blueOffset : 0, greenOffset : 0, redOffset : 0, alphaMultiplier : 1.0, blueMultiplier : 1.0, greenMultiplier : 1.0, redMultiplier : 1.0 }</e></m></meta>
			<haxe_doc>* Sets the sprite's color transformation with control over color offsets.
	 * With `FlxG.renderTile`, offsets are only supported on OpenFL Next version 3.6.0 or higher.
	 * 
	 * @param   redMultiplier     The value for the red multiplier, in the range from `0` to `1`.
	 * @param   greenMultiplier   The value for the green multiplier, in the range from `0` to `1`.
	 * @param   blueMultiplier    The value for the blue multiplier, in the range from `0` to `1`.
	 * @param   alphaMultiplier   The value for the alpha transparency multiplier, in the range from `0` to `1`.
	 * @param   redOffset         The offset value for the red color channel, in the range from `-255` to `255`.
	 * @param   greenOffset       The offset value for the green color channel, in the range from `-255` to `255`.
	 * @param   blueOffset        The offset for the blue color channel value, in the range from `-255` to `255`.
	 * @param   alphaOffset       The offset for alpha transparency channel value, in the range from `-255` to `255`.</haxe_doc>
		</setColorTransform>
		<updateColorTransform set="method" line="852"><f a=""><x path="Void"/></f></updateColorTransform>
		<pixelsOverlapPoint public="1" set="method" line="875">
			<f a="point:?Mask:?Camera" v=":0xFF:">
				<c path="flixel.math.FlxPoint"/>
				<x path="Int"/>
				<c path="flixel.FlxCamera"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":value"><e>{ Mask : 0xFF }</e></m></meta>
			<haxe_doc>* Checks to see if a point in 2D world space overlaps this `FlxSprite` object's current displayed pixels.
	 * This check is ALWAYS made in screen space, and always takes `scrollFactor` into account.
	 * 
	 * @param   Point    The point in world space you want to check.
	 * @param   Mask     Used in the pixel hit test to determine what counts as solid.
	 * @param   Camera   Specify which game camera you want.  If `null`, it will just grab the first global camera.
	 * @return  Whether or not the point overlaps this object.</haxe_doc>
		</pixelsOverlapPoint>
		<calcFrame set="method" line="906">
			<f a="?RunOnCpp" v="false">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":value"><e>{ RunOnCpp : false }</e></m>
				<m n=":noCompletion"/>
			</meta>
			<haxe_doc>* Internal function to update the current animation frame.
	 * 
	 * @param   RunOnCpp   Whether the frame should also be recalculated if we're on a non-flash target</haxe_doc>
		</calcFrame>
		<updateFramePixels public="1" set="method" line="919">
			<f a=""><t path="flash.display.BitmapData"/></f>
			<haxe_doc>* Retrieves the `BitmapData` of the current `FlxFrame`. Updates `framePixels`.</haxe_doc>
		</updateFramePixels>
		<getGraphicMidpoint public="1" set="method" line="969">
			<f a="?point">
				<c path="flixel.math.FlxPoint"/>
				<c path="flixel.math.FlxPoint"/>
			</f>
			<haxe_doc>* Retrieve the midpoint of this sprite's graphic in world coordinates.
	 * 
	 * @param   point   Allows you to pass in an existing `FlxPoint` if you're so inclined.
	 *                  Otherwise a new one is created.
	 * @return  A `FlxPoint` containing the midpoint of this sprite's graphic in world coordinates.</haxe_doc>
		</getGraphicMidpoint>
		<isOnScreen public="1" set="method" line="983" override="1">
			<f a="?Camera">
				<c path="flixel.FlxCamera"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Check and see if this object is currently on screen. Differs from `FlxObject`'s implementation
	 * in that it takes the actual graphic into account, not just the hitbox or bounding box or whatever.
	 * 
	 * @param   Camera  Specify which game camera you want. If `null`, it will just grab the first global camera.
	 * @return  Whether the object is on screen or not.</haxe_doc>
		</isOnScreen>
		<isSimpleRender public="1" set="method" line="1034">
			<f a="?camera">
				<c path="flixel.FlxCamera"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Returns the result of `isSimpleRenderBlit()` if `FlxG.renderBlit` is
	 * `true`, or `false` if `FlxG.renderTile` is `true`.</haxe_doc>
		</isSimpleRender>
		<isSimpleRenderBlit public="1" set="method" line="1050">
			<f a="?camera">
				<c path="flixel.FlxCamera"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Determines the function used for rendering in blitting:
	 * `copyPixels()` for simple sprites, `draw()` for complex ones.
	 * Sprites are considered simple when they have an `angle` of `0`, a `scale` of `1`,
	 * don't use `blend` and `pixelPerfectRender` is `true`.
	 * 
	 * @param   camera   If a camera is passed its `pixelPerfectRender` flag is taken into account</haxe_doc>
		</isSimpleRenderBlit>
		<setFacingFlip public="1" get="inline" set="null" line="1068">
			<f a="Direction:FlipX:FlipY">
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Set how a sprite flips when facing in a particular direction.
	 * 
	 * @param   Direction   Use constants from `FlxObject`: `LEFT`, `RIGHT`, `UP`, and `DOWN`.
	 *                      These may be combined with the bitwise OR operator.
	 *                      E.g. To make a sprite flip horizontally when it is facing both `UP` and `LEFT`,
	 *                      use `setFacingFlip(FlxObject.LEFT | FlxObject.UP, true, false);`
	 * @param   FlipX       Whether to flip the sprite on the X axis.
	 * @param   FlipY       Whether to flip the sprite on the Y axis.</haxe_doc>
		</setFacingFlip>
		<setFrames public="1" set="method" line="1081">
			<f a="Frames:?saveAnimations" v=":true">
				<c path="flixel.graphics.frames.FlxFramesCollection"/>
				<x path="Bool"/>
				<c path="flixel.FlxSprite"/>
			</f>
			<meta>
				<m n=":value"><e>{ saveAnimations : true }</e></m>
				<m n=":access"><e>flixel.animation.FlxAnimationController</e></m>
			</meta>
			<haxe_doc>* Sets frames and allows you to save animations in sprite's animation controller
	 * 
	 * @param   Frames           Frames collection to set for this sprite.
	 * @param   saveAnimations   Whether to save animations in animation controller or not.
	 * @return  This sprite with loaded frames</haxe_doc>
		</setFrames>
		<get_pixels set="method" line="1117">
			<f a=""><t path="flash.display.BitmapData"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_pixels>
		<set_pixels set="method" line="1123">
			<f a="Pixels">
				<t path="flash.display.BitmapData"/>
				<t path="flash.display.BitmapData"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_pixels>
		<set_frame set="method" line="1142">
			<f a="Value">
				<c path="flixel.graphics.frames.FlxFrame"/>
				<c path="flixel.graphics.frames.FlxFrame"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_frame>
		<set_facing set="method" line="1178">
			<f a="Direction">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_facing>
		<set_alpha set="method" line="1191">
			<f a="Alpha">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_alpha>
		<set_color set="method" line="1203">
			<f a="Color">
				<x path="flixel.util.FlxColor"/>
				<x path="Int"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_color>
		<set_angle set="method" line="1215" override="1">
			<f a="Value">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_angle>
		<updateTrig get="inline" set="null" line="1228">
			<f a=""><x path="Void"/></f>
			<meta><m n=":noCompletion"/></meta>
		</updateTrig>
		<set_blend set="method" line="1240">
			<f a="Value">
				<t path="flash.display.BlendMode"/>
				<t path="flash.display.BlendMode"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_blend>
		<set_graphic set="method" line="1250">
			<f a="Value">
				<c path="flixel.graphics.FlxGraphic"/>
				<c path="flixel.graphics.FlxGraphic"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
			<haxe_doc>* Internal function for setting graphic property for this object.
	 * It changes graphics' `useCount` also for better memory tracking.</haxe_doc>
		</set_graphic>
		<set_clipRect set="method" line="1268">
			<f a="rect">
				<c path="flixel.math.FlxRect"/>
				<c path="flixel.math.FlxRect"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_clipRect>
		<set_frames set="method" line="1289">
			<f a="Frames">
				<c path="flixel.graphics.frames.FlxFramesCollection"/>
				<c path="flixel.graphics.frames.FlxFramesCollection"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
			<haxe_doc>* Frames setter. Used by `loadGraphic` methods, but you can load generated frames yourself
	 * (this should be even faster since engine doesn't need to do bunch of additional stuff).
	 * 
	 * @param   Frames   frames to load into this sprite.
	 * @return  loaded frames.</haxe_doc>
		</set_frames>
		<set_flipX set="method" line="1319">
			<f a="Value">
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_flipX>
		<set_flipY set="method" line="1330">
			<f a="Value">
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_flipY>
		<set_antialiasing set="method" line="1341">
			<f a="value">
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_antialiasing>
		<set_useFramePixels set="method" line="1347">
			<f a="value">
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_useFramePixels>
		<checkFlipX get="inline" set="null" line="1372">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":noCompletion"/></meta>
		</checkFlipX>
		<checkFlipY get="inline" set="null" line="1383">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":noCompletion"/></meta>
		</checkFlipY>
		<new public="1" set="method" line="243">
			<f a="?X:?Y:?SimpleGraphic" v="0:0:">
				<x path="Float"/>
				<x path="Float"/>
				<t path="flixel.system.FlxGraphicAsset"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ Y : 0, X : 0 }</e></m></meta>
			<haxe_doc>* Creates a `FlxSprite` at a specified position with a specified one-frame graphic.
	 * If none is provided, a 16x16 image of the HaxeFlixel logo is used.
	 * 
	 * @param   X               The initial X position of the sprite.
	 * @param   Y               The initial Y position of the sprite.
	 * @param   SimpleGraphic   The graphic you want to display
	 *                          (OPTIONAL - for simple stuff only, do NOT use for animated images!).</haxe_doc>
		</new>
		<haxe_doc>* The main "game object" class, the sprite is a `FlxObject`
 * with a bunch of graphics options and abilities, like animation and stamping.
 *
 * Load an image onto a sprite using the `loadGraphic*()` functions,
 * or create a base monochromatic rectangle using `makeGraphic()`.
 * The image `BitmapData` is stored in the `pixels` field.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="flixel.IFlxSprite" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/FlxSprite.hx" module="flixel.FlxSprite" interface="1">
		<extends path="flixel.IFlxBasic"/>
		<set_x public="1" set="method">
			<f a="value">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":compilerGenerated"/></meta>
		</set_x>
		<set_y public="1" set="method">
			<f a="value">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":compilerGenerated"/></meta>
		</set_y>
		<set_alpha public="1" set="method">
			<f a="value">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":compilerGenerated"/></meta>
		</set_alpha>
		<set_angle public="1" set="method">
			<f a="value">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":compilerGenerated"/></meta>
		</set_angle>
		<set_facing public="1" set="method">
			<f a="value">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":compilerGenerated"/></meta>
		</set_facing>
		<set_moves public="1" set="method">
			<f a="value">
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":compilerGenerated"/></meta>
		</set_moves>
		<set_immovable public="1" set="method">
			<f a="value">
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":compilerGenerated"/></meta>
		</set_immovable>
		<x public="1" set="accessor"><x path="Float"/></x>
		<y public="1" set="accessor"><x path="Float"/></y>
		<alpha public="1" set="accessor"><x path="Float"/></alpha>
		<angle public="1" set="accessor"><x path="Float"/></angle>
		<facing public="1" set="accessor"><x path="Int"/></facing>
		<moves public="1" set="accessor"><x path="Bool"/></moves>
		<immovable public="1" set="accessor"><x path="Bool"/></immovable>
		<offset public="1" set="null"><c path="flixel.math.FlxPoint"/></offset>
		<origin public="1" set="null"><c path="flixel.math.FlxPoint"/></origin>
		<scale public="1" set="null"><c path="flixel.math.FlxPoint"/></scale>
		<velocity public="1" set="null"><c path="flixel.math.FlxPoint"/></velocity>
		<maxVelocity public="1" set="null"><c path="flixel.math.FlxPoint"/></maxVelocity>
		<acceleration public="1" set="null"><c path="flixel.math.FlxPoint"/></acceleration>
		<drag public="1" set="null"><c path="flixel.math.FlxPoint"/></drag>
		<scrollFactor public="1" set="null"><c path="flixel.math.FlxPoint"/></scrollFactor>
		<reset public="1" set="method"><f a="X:Y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></reset>
		<setPosition public="1" set="method">
			<f a="?X:?Y" v="0:0">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ Y : 0, X : 0 }</e></m></meta>
		</setPosition>
	</class>
	<class path="flixel.group.FlxTypedGroup" params="T" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/group/FlxGroup.hx" module="flixel.group.FlxGroup">
		<extends path="flixel.FlxBasic"/>
		<overlaps set="method" line="22" static="1">
			<f a="Callback:Group:X:Y:InScreenSpace:Camera">
				<f a="::::">
					<c path="flixel.FlxBasic"/>
					<x path="Float"/>
					<x path="Float"/>
					<x path="Bool"/>
					<c path="flixel.FlxCamera"/>
					<x path="Bool"/>
				</f>
				<c path="flixel.group.FlxTypedGroup"><c path="flixel.FlxBasic"/></c>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Bool"/>
				<c path="flixel.FlxCamera"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
			<haxe_doc>* Helper for overlap functions in `FlxObject` and `FlxTilemap`.</haxe_doc>
		</overlaps>
		<resolveGroup set="method" line="47" static="1">
			<f a="ObjectOrGroup">
				<c path="flixel.FlxBasic"/>
				<c path="flixel.group.FlxTypedGroup"><c path="flixel.FlxBasic"/></c>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</resolveGroup>
		<members public="1" set="null">
			<c path="Array"><c path="flixel.group.FlxTypedGroup.T"/></c>
			<haxe_doc>* `Array` of all the members in this group.</haxe_doc>
		</members>
		<maxSize public="1" set="accessor">
			<x path="Int"/>
			<haxe_doc>* The maximum capacity of this group. Default is `0`, meaning no max capacity, and the group can just grow.</haxe_doc>
		</maxSize>
		<length public="1" set="null" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* The number of entries in the members array. For performance and safety you should check this
	 * variable instead of `members.length` unless you really know what you're doing!</haxe_doc>
		</length>
		<_marker expr="0">
			<x path="Int"/>
			<meta>
				<m n=":value"><e>0</e></m>
				<m n=":noCompletion"/>
			</meta>
			<haxe_doc>* Internal helper variable for recycling objects a la `FlxEmitter`.</haxe_doc>
		</_marker>
		<destroy public="1" set="method" line="106" override="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* **WARNING:** A destroyed `FlxBasic` can't be used anymore.
	 * It may even cause crashes if it is still part of a group or state.
	 * You may want to use `kill()` instead if you want to disable the object temporarily only and `revive()` it later.
	 * 
	 * This function is usually not called manually (Flixel calls it automatically during state switches for all `add()`ed objects).
	 * 
	 * Override this function to `null` out variables manually or call `destroy()` on class members if necessary.
	 * Don't forget to call `super.destroy()`!</haxe_doc>
		</destroy>
		<update public="1" set="method" line="130" override="1">
			<f a="elapsed">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Automatically goes through and calls update on everything you added.</haxe_doc>
		</update>
		<draw public="1" set="method" line="149" override="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Automatically goes through and calls render on everything you added.</haxe_doc>
		</draw>
		<add public="1" set="method" line="175">
			<f a="Object">
				<c path="flixel.group.FlxTypedGroup.T"/>
				<c path="flixel.group.FlxTypedGroup.T"/>
			</f>
			<haxe_doc>* Adds a new `FlxBasic` subclass (`FlxBasic`, `FlxSprite`, `Enemy`, etc) to the group.
	 * `FlxGroup` will try to replace a `null` member of the array first.
	 * Failing that, `FlxGroup` will add it to the end of the member array.
	 * WARNING: If the group has a `maxSize` that has already been met,
	 * the object will NOT be added to the group!
	 * 
	 * @param   Object   The object you want to add to the group.
	 * @return  The same `FlxBasic` object that was passed in.</haxe_doc>
		</add>
		<insert public="1" set="method" line="224">
			<f a="position:object">
				<x path="Int"/>
				<c path="flixel.group.FlxTypedGroup.T"/>
				<c path="flixel.group.FlxTypedGroup.T"/>
			</f>
			<haxe_doc>* Inserts a new `FlxBasic` subclass (`FlxBasic`, `FlxSprite`, `Enemy`, etc)
	 * into the group at the specified position.
	 * `FlxGroup` will try to replace a `null` member at the specified position of the array first.
	 * Failing that, `FlxGroup` will insert it at the position of the member array.
	 * WARNING: If the group has a `maxSize` that has already been met,
	 * the object will NOT be inserted to the group!
	 * 
	 * @param   position   The position in the group where you want to insert the object.
	 * @param   object     The object you want to insert into the group.
	 * @return  The same `FlxBasic` object that was passed in.</haxe_doc>
		</insert>
		<recycle public="1" set="method" line="279">
			<f a="?ObjectClass:?ObjectFactory:?Force:?Revive" v="::false:true">
				<x path="Class"><c path="flixel.group.FlxTypedGroup.T"/></x>
				<f a=""><c path="flixel.group.FlxTypedGroup.T"/></f>
				<x path="Bool"/>
				<x path="Bool"/>
				<c path="flixel.group.FlxTypedGroup.T"/>
			</f>
			<meta><m n=":value"><e>{ Revive : true, Force : false }</e></m></meta>
			<haxe_doc><![CDATA[* Recycling is designed to help you reuse game objects without always re-allocating or "newing" them.
	 * It behaves differently depending on whether `maxSize` equals `0` or is bigger than `0`.
	 * 
	 * `maxSize > 0` / "rotating-recycling" (used by `FlxEmitter`):
	 *   - at capacity:  returns the next object in line, no matter its properties like `alive`, `exists` etc.
	 *   - otherwise:    returns a new object.
	 * 
	 * `maxSize == 0` / "grow-style-recycling"
	 *   - tries to find the first object with `exists == false`
	 *   - otherwise: adds a new object to the `members` array
	 *
	 * WARNING: If this function needs to create a new object, and no object class was provided,
	 * it will return `null` instead of a valid object!
	 * 
	 * @param   ObjectClass     The class type you want to recycle (e.g. `FlxSprite`, `EvilRobot`, etc).
	 * @param   ObjectFactory   Optional factory function to create a new object
	 *                          if there aren't any dead members to recycle.
	 *                          If `null`, `Type.createInstance()` is used,
	 *                          which requires the class to have no constructor parameters.
	 * @param   Force           Force the object to be an `ObjectClass` and not a super class of `ObjectClass`.
	 * @param   Revive          Whether recycled members should automatically be revived
	 *                          (by calling `revive()` on them).
	 * @return  A reference to the object that was created.]]></haxe_doc>
		</recycle>
		<recycleCreateObject get="inline" set="null" line="322">
			<f a="?ObjectClass:?ObjectFactory">
				<x path="Class"><c path="flixel.group.FlxTypedGroup.T"/></x>
				<f a=""><c path="flixel.group.FlxTypedGroup.T"/></f>
				<c path="flixel.group.FlxTypedGroup.T"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</recycleCreateObject>
		<remove public="1" set="method" line="341">
			<f a="Object:?Splice" v=":false">
				<c path="flixel.group.FlxTypedGroup.T"/>
				<x path="Bool"/>
				<c path="flixel.group.FlxTypedGroup.T"/>
			</f>
			<meta><m n=":value"><e>{ Splice : false }</e></m></meta>
			<haxe_doc>* Removes an object from the group.
	 * 
	 * @param   Object   The `FlxBasic` you want to remove.
	 * @param   Splice   Whether the object should be cut from the array entirely or not.
	 * @return  The removed object.</haxe_doc>
		</remove>
		<replace public="1" set="method" line="370">
			<f a="OldObject:NewObject">
				<c path="flixel.group.FlxTypedGroup.T"/>
				<c path="flixel.group.FlxTypedGroup.T"/>
				<c path="flixel.group.FlxTypedGroup.T"/>
			</f>
			<haxe_doc>* Replaces an existing `FlxBasic` with a new one.
	 * Does not do anything and returns `null` if the old object is not part of the group.
	 * 
	 * @param   OldObject   The object you want to replace.
	 * @param   NewObject   The new object you want to use instead.
	 * @return  The new object.</haxe_doc>
		</replace>
		<sort public="1" get="inline" set="null" line="392">
			<f a="Function:?Order" v=":FlxSort.ASCENDING">
				<f a="::">
					<x path="Int"/>
					<c path="flixel.group.FlxTypedGroup.T"/>
					<c path="flixel.group.FlxTypedGroup.T"/>
					<x path="Int"/>
				</f>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ Order : FlxSort.ASCENDING }</e></m></meta>
			<haxe_doc>* Call this function to sort the group according to a particular value and order.
	 * For example, to sort game objects for Zelda-style overlaps you might call
	 * `group.sort(FlxSort.byY, FlxSort.ASCENDING)` at the bottom of your `FlxState#update()` override.
	 * 
	 * @param   Function   The sorting function to use - you can use one of the premade ones in
	 *                     `FlxSort` or write your own using `FlxSort.byValues()` as a "backend".
	 * @param   Order      A constant that defines the sort order.
	 *                     Possible values are `FlxSort.ASCENDING` (default) and `FlxSort.DESCENDING`.</haxe_doc>
		</sort>
		<getFirstAvailable public="1" set="method" line="406">
			<f a="?ObjectClass:?Force" v=":false">
				<x path="Class"><c path="flixel.group.FlxTypedGroup.T"/></x>
				<x path="Bool"/>
				<c path="flixel.group.FlxTypedGroup.T"/>
			</f>
			<meta><m n=":value"><e>{ Force : false }</e></m></meta>
			<haxe_doc>* Call this function to retrieve the first object with `exists == false` in the group.
	 * This is handy for recycling in general, e.g. respawning enemies.
	 * 
	 * @param   ObjectClass   An optional parameter that lets you narrow the
	 *                        results to instances of this particular class.
	 * @param   Force         Force the object to be an `ObjectClass` and not a super class of `ObjectClass`.
	 * @return  A `FlxBasic` currently flagged as not existing.</haxe_doc>
		</getFirstAvailable>
		<getFirstNull public="1" set="method" line="434">
			<f a=""><x path="Int"/></f>
			<haxe_doc>* Call this function to retrieve the first index set to `null`.
	 * Returns `-1` if no index stores a `null` object.
	 * 
	 * @return  An `Int` indicating the first `null` slot in the group.</haxe_doc>
		</getFirstNull>
		<getFirstExisting public="1" set="method" line="454">
			<f a=""><c path="flixel.group.FlxTypedGroup.T"/></f>
			<haxe_doc>* Call this function to retrieve the first object with `exists == true` in the group.
	 * This is handy for checking if everything's wiped out, or choosing a squad leader, etc.
	 * 
	 * @return  A `FlxBasic` currently flagged as existing.</haxe_doc>
		</getFirstExisting>
		<getFirstAlive public="1" set="method" line="476">
			<f a=""><c path="flixel.group.FlxTypedGroup.T"/></f>
			<haxe_doc>* Call this function to retrieve the first object with `dead == false` in the group.
	 * This is handy for checking if everything's wiped out, or choosing a squad leader, etc.
	 * 
	 * @return  A `FlxBasic` currently flagged as not dead.</haxe_doc>
		</getFirstAlive>
		<getFirstDead public="1" set="method" line="498">
			<f a=""><c path="flixel.group.FlxTypedGroup.T"/></f>
			<haxe_doc>* Call this function to retrieve the first object with `dead == true` in the group.
	 * This is handy for checking if everything's wiped out, or choosing a squad leader, etc.
	 * 
	 * @return  A `FlxBasic` currently flagged as dead.</haxe_doc>
		</getFirstDead>
		<countLiving public="1" set="method" line="519">
			<f a=""><x path="Int"/></f>
			<haxe_doc>* Call this function to find out how many members of the group are not dead.
	 * 
	 * @return  The number of `FlxBasic`s flagged as not dead. Returns `-1` if group is empty.</haxe_doc>
		</countLiving>
		<countDead public="1" set="method" line="546">
			<f a=""><x path="Int"/></f>
			<haxe_doc>* Call this function to find out how many members of the group are dead.
	 * 
	 * @return  The number of `FlxBasic`s flagged as dead. Returns `-1` if group is empty.</haxe_doc>
		</countDead>
		<getRandom public="1" set="method" line="576">
			<f a="?StartIndex:?Length" v="0:0">
				<x path="Int"/>
				<x path="Int"/>
				<c path="flixel.group.FlxTypedGroup.T"/>
			</f>
			<meta><m n=":value"><e>{ Length : 0, StartIndex : 0 }</e></m></meta>
			<haxe_doc>* Returns a member at random from the group.
	 * 
	 * @param   StartIndex  Optional offset off the front of the array.
	 *                      Default value is `0`, or the beginning of the array.
	 * @param   Length      Optional restriction on the number of values you want to randomly select from.
	 * @return  A `FlxBasic` from the `members` list.</haxe_doc>
		</getRandom>
		<clear public="1" set="method" line="590">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Remove all instances of `FlxBasic` subclasses (`FlxSprite`, `FlxTileblock`, etc) from the list.
	 * WARNING: does not `destroy()` or `kill()` any of these objects!</haxe_doc>
		</clear>
		<kill public="1" set="method" line="600" override="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Calls `kill()` on the group's `members` and then on the group itself.
	 * You can revive this group later via `revive()` after this.</haxe_doc>
		</kill>
		<revive public="1" set="method" line="619" override="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Calls `revive()` on the group's members and then on the group itself.</haxe_doc>
		</revive>
		<iterator public="1" get="inline" set="null" line="638">
			<f a="?filter">
				<f a="">
					<c path="flixel.group.FlxTypedGroup.T"/>
					<x path="Bool"/>
				</f>
				<c path="flixel.group.FlxTypedGroupIterator"><c path="flixel.group.FlxTypedGroup.T"/></c>
			</f>
			<haxe_doc>* Iterates through every member.</haxe_doc>
		</iterator>
		<forEach public="1" set="method" line="649">
			<f a="Function:?Recurse" v=":false">
				<f a="">
					<c path="flixel.group.FlxTypedGroup.T"/>
					<x path="Void"/>
				</f>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ Recurse : false }</e></m></meta>
			<haxe_doc>* Applies a function to all members.
	 * 
	 * @param   Function   A function that modifies one element at a time.
	 * @param   Recurse    Whether or not to apply the function to members of subgroups as well.</haxe_doc>
		</forEach>
		<forEachAlive public="1" set="method" line="678">
			<f a="Function:?Recurse" v=":false">
				<f a="">
					<c path="flixel.group.FlxTypedGroup.T"/>
					<x path="Void"/>
				</f>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ Recurse : false }</e></m></meta>
			<haxe_doc>* Applies a function to all `alive` members.
	 * 
	 * @param   Function   A function that modifies one element at a time.
	 * @param   Recurse    Whether or not to apply the function to members of subgroups as well.</haxe_doc>
		</forEachAlive>
		<forEachDead public="1" set="method" line="707">
			<f a="Function:?Recurse" v=":false">
				<f a="">
					<c path="flixel.group.FlxTypedGroup.T"/>
					<x path="Void"/>
				</f>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ Recurse : false }</e></m></meta>
			<haxe_doc>* Applies a function to all dead members.
	 * 
	 * @param   Function   A function that modifies one element at a time.
	 * @param   Recurse    Whether or not to apply the function to members of subgroups as well.</haxe_doc>
		</forEachDead>
		<forEachExists public="1" set="method" line="736">
			<f a="Function:?Recurse" v=":false">
				<f a="">
					<c path="flixel.group.FlxTypedGroup.T"/>
					<x path="Void"/>
				</f>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ Recurse : false }</e></m></meta>
			<haxe_doc>* Applies a function to all existing members.
	 * 
	 * @param   Function   A function that modifies one element at a time.
	 * @param   Recurse    Whether or not to apply the function to members of subgroups as well.</haxe_doc>
		</forEachExists>
		<forEachOfType public="1" params="K" set="method" line="766">
			<f a="ObjectClass:Function:?Recurse" v="::false">
				<x path="Class"><c path="forEachOfType.K"/></x>
				<f a="">
					<c path="forEachOfType.K"/>
					<x path="Void"/>
				</f>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ Recurse : false }</e></m></meta>
			<haxe_doc><![CDATA[* Applies a function to all members of type `Class<K>`.
	 * 
	 * @param   ObjectClass   A class that objects will be checked against before Function is applied, ex: `FlxSprite`.
	 * @param   Function      A function that modifies one element at a time.
	 * @param   Recurse       Whether or not to apply the function to members of subgroups as well.]]></haxe_doc>
		</forEachOfType>
		<set_maxSize set="method" line="791">
			<f a="Size">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_maxSize>
		<new public="1" set="method" line="87">
			<f a="?MaxSize" v="0">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ MaxSize : 0 }</e></m></meta>
			<haxe_doc>* @param   MaxSize   Maximum amount of members allowed.</haxe_doc>
		</new>
		<haxe_doc>* This is an organizational class that can update and render a bunch of `FlxBasic`s.
 * NOTE: Although `FlxGroup` extends `FlxBasic`, it will not automatically
 * add itself to the global collisions quad tree, it will only add its members.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="flixel.FlxState" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/FlxState.hx">
		<extends path="flixel.group.FlxTypedGroup"><c path="flixel.FlxBasic"/></extends>
		<persistentUpdate public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
			<haxe_doc>* Determines whether or not this state is updated even when it is not the active state.
	 * For example, if you have your game state first, and then you push a menu state on top of it,
	 * if this is set to `true`, the game state would continue to update in the background.
	 * By default this is `false`, so background states will be "paused" when they are not active.</haxe_doc>
		</persistentUpdate>
		<persistentDraw public="1" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
			<haxe_doc>* Determines whether or not this state is updated even when it is not the active state.
	 * For example, if you have your game state first, and then you push a menu state on top of it,
	 * if this is set to `true`, the game state would continue to be drawn behind the pause state.
	 * By default this is `true`, so background states will continue to be drawn behind the current state.
	 * 
	 * If background states are not `visible` when you have a different state on top,
	 * you should set this to `false` for improved performance.</haxe_doc>
		</persistentDraw>
		<destroySubStates public="1" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
			<haxe_doc>* If substates get destroyed when they are closed, setting this to
	 * `false` might reduce state creation time, at greater memory cost.</haxe_doc>
		</destroySubStates>
		<bgColor public="1" get="accessor" set="accessor">
			<x path="flixel.util.FlxColor"/>
			<haxe_doc>* The natural background color the cameras default to. In `AARRGGBB` format.</haxe_doc>
		</bgColor>
		<subState public="1" set="null">
			<c path="flixel.FlxSubState"/>
			<haxe_doc>* Current substate. Substates also can be nested.</haxe_doc>
		</subState>
		<_requestedSubState>
			<c path="flixel.FlxSubState"/>
			<meta><m n=":noCompletion"/></meta>
			<haxe_doc>* If a state change was requested, the new state object is stored here until we switch to it.</haxe_doc>
		</_requestedSubState>
		<_requestSubStateReset expr="false">
			<x path="Bool"/>
			<meta>
				<m n=":value"><e>false</e></m>
				<m n=":noCompletion"/>
			</meta>
			<haxe_doc>* Whether to reset the substate (when it changes, or when it's closed).</haxe_doc>
		</_requestSubStateReset>
		<create public="1" set="method" line="65">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* This function is called after the game engine successfully switches states.
	 * Override this function, NOT the constructor, to initialize or set up your game state.
	 * We do NOT recommend overriding the constructor, unless you want some crazy unpredictable things to happen!</haxe_doc>
		</create>
		<draw public="1" set="method" line="67" override="1"><f a=""><x path="Void"/></f></draw>
		<openSubState public="1" set="method" line="76"><f a="SubState">
	<c path="flixel.FlxSubState"/>
	<x path="Void"/>
</f></openSubState>
		<closeSubState public="1" set="method" line="85">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Closes the substate of this state, if one exists.</haxe_doc>
		</closeSubState>
		<resetSubState public="1" set="method" line="93">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Load substate for this state</haxe_doc>
		</resetSubState>
		<destroy public="1" set="method" line="127" override="1"><f a=""><x path="Void"/></f></destroy>
		<switchTo public="1" set="method" line="143">
			<f a="nextState">
				<c path="flixel.FlxState"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Called from `FlxG.switchState()`. If `false` is returned, the state
	 * switch is cancelled - the default implementation returns `true`.
	 * 
	 * Useful for customizing state switches, e.g. for transition effects.</haxe_doc>
		</switchTo>
		<onFocusLost public="1" set="method" line="152">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* This method is called after the game loses focus.
	 * Can be useful for third party libraries, such as tweening engines.</haxe_doc>
		</onFocusLost>
		<onFocus public="1" set="method" line="158">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* This method is called after the game receives focus.
	 * Can be useful for third party libraries, such as tweening engines.</haxe_doc>
		</onFocus>
		<onResize public="1" set="method" line="166">
			<f a="Width:Height">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* This function is called whenever the window size has been changed.
	 * 
	 * @param   Width    The new window width
	 * @param   Height   The new window Height</haxe_doc>
		</onResize>
		<tryUpdate set="method" line="169">
			<f a="elapsed">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":allow"><e>flixel.FlxGame</e></m></meta>
		</tryUpdate>
		<get_bgColor set="method" line="186">
			<f a=""><x path="flixel.util.FlxColor"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_bgColor>
		<set_bgColor set="method" line="192">
			<f a="Value">
				<x path="flixel.util.FlxColor"/>
				<x path="flixel.util.FlxColor"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_bgColor>
		<new public="1" set="method" line="11"><f a="?MaxSize">
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>* This is the basic game "state" object - e.g. in a simple game you might have a menu state and a play state.
 * It is for all intents and purpose a fancy `FlxGroup`. And really, it's not even that fancy.</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":keepSub"/>
		</meta>
	</class>
	<class path="flixel.FlxSubState" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/FlxSubState.hx">
		<extends path="flixel.FlxState"/>
		<openCallback public="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Callback method for state open/resume event.
	 * @since 4.3.0</haxe_doc>
		</openCallback>
		<closeCallback public="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Callback method for state close event.</haxe_doc>
		</closeCallback>
		<_bgSprite>
			<c path="flixel.system.FlxBGSprite"/>
			<meta><m n=":noCompletion"/></meta>
			<haxe_doc>* Helper sprite object for non-flash targets. Draws the background.</haxe_doc>
		</_bgSprite>
		<_parentState>
			<c path="flixel.FlxState"/>
			<meta>
				<m n=":noCompletion"/>
				<m n=":allow"><e>flixel.FlxState.resetSubState</e></m>
			</meta>
			<haxe_doc>* Helper var for `close()` so `closeSubState()` can be called on the parent.</haxe_doc>
		</_parentState>
		<_bgColor>
			<x path="flixel.util.FlxColor"/>
			<meta><m n=":noCompletion"/></meta>
		</_bgColor>
		<_created expr="false">
			<x path="Bool"/>
			<meta>
				<m n=":value"><e>false</e></m>
				<m n=":noCompletion"/>
				<m n=":allow"><e>flixel.FlxState.resetSubState</e></m>
			</meta>
		</_created>
		<draw public="1" set="method" line="58" override="1"><f a=""><x path="Void"/></f></draw>
		<destroy public="1" set="method" line="77" override="1"><f a=""><x path="Void"/></f></destroy>
		<close public="1" set="method" line="89">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Closes this substate.</haxe_doc>
		</close>
		<get_bgColor get="inline" set="null" line="96" override="1">
			<f a=""><x path="flixel.util.FlxColor"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_bgColor>
		<set_bgColor set="method" line="102" override="1">
			<f a="Value">
				<x path="flixel.util.FlxColor"/>
				<x path="flixel.util.FlxColor"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_bgColor>
		<new public="1" set="method" line="47">
			<f a="?BGColor" v="FlxColor.TRANSPARENT">
				<x path="flixel.util.FlxColor"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ BGColor : FlxColor.TRANSPARENT }</e></m></meta>
			<haxe_doc>* @param   BGColor   background color for this substate</haxe_doc>
		</new>
		<haxe_doc>* A `FlxSubState` can be opened inside of a `FlxState`.
 * By default, it also stops the parent state from updating,
 * making it convenient for pause screens or menus.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="flixel.animation.FlxBaseAnimation" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/animation/FlxBaseAnimation.hx">
		<implements path="flixel.util.IFlxDestroyable"/>
		<parent public="1">
			<c path="flixel.animation.FlxAnimationController"/>
			<haxe_doc>* Animation controller this animation belongs to</haxe_doc>
		</parent>
		<name public="1">
			<c path="String"/>
			<haxe_doc>* String name of the animation (e.g. `"walk"`)</haxe_doc>
		</name>
		<curIndex public="1" set="accessor" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* Keeps track of the current index into the tile sheet based on animation or rotation.</haxe_doc>
		</curIndex>
		<set_curIndex set="method" line="26"><f a="Value">
	<x path="Int"/>
	<x path="Int"/>
</f></set_curIndex>
		<destroy public="1" set="method" line="44"><f a=""><x path="Void"/></f></destroy>
		<update public="1" set="method" line="50"><f a="elapsed">
	<x path="Float"/>
	<x path="Void"/>
</f></update>
		<clone public="1" set="method" line="52"><f a="Parent">
	<c path="flixel.animation.FlxAnimationController"/>
	<c path="flixel.animation.FlxBaseAnimation"/>
</f></clone>
		<new public="1" set="method" line="38"><f a="Parent:Name">
	<c path="flixel.animation.FlxAnimationController"/>
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>* ...
 * @author Zaphod</haxe_doc>
	</class>
	<class path="flixel.animation.FlxAnimation" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/animation/FlxAnimation.hx">
		<extends path="flixel.animation.FlxBaseAnimation"/>
		<frameRate public="1" set="accessor">
			<x path="Int"/>
			<haxe_doc>* Animation frameRate - the speed in frames per second that the animation should play at.</haxe_doc>
		</frameRate>
		<curFrame public="1" set="accessor" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* Keeps track of the current frame of animation.
	 * This is NOT an index into the tile sheet, but the frame number in the animation object.</haxe_doc>
		</curFrame>
		<numFrames public="1" get="accessor" set="null">
			<x path="Int"/>
			<haxe_doc>* Accessor for `frames.length`</haxe_doc>
		</numFrames>
		<delay public="1" set="null" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* Seconds between frames (basically the framerate)</haxe_doc>
		</delay>
		<finished public="1" set="null" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
			<haxe_doc>* Whether the current animation has finished.</haxe_doc>
		</finished>
		<paused public="1" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
			<haxe_doc>* Whether the current animation gets updated or not.</haxe_doc>
		</paused>
		<looped public="1" set="null" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
			<haxe_doc>* Whether or not the animation is looped.</haxe_doc>
		</looped>
		<reversed public="1" set="null" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
			<haxe_doc>* Whether or not this animation is being played backwards.</haxe_doc>
		</reversed>
		<flipX public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
			<haxe_doc>* Whether or not the frames of this animation are horizontally flipped</haxe_doc>
		</flipX>
		<flipY public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
			<haxe_doc>* Whether or not the frames of this animation are vertically flipped</haxe_doc>
		</flipY>
		<frames public="1">
			<c path="Array"><x path="Int"/></c>
			<haxe_doc>* A list of frames stored as int indices
	 * @since 4.2.0</haxe_doc>
		</frames>
		<_frameTimer expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* Internal, used to time each frame of animation.</haxe_doc>
		</_frameTimer>
		<destroy public="1" set="method" line="95" override="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Clean up memory.</haxe_doc>
		</destroy>
		<play public="1" set="method" line="113">
			<f a="?Force:?Reversed:?Frame" v="false:false:0">
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ Frame : 0, Reversed : false, Force : false }</e></m></meta>
			<haxe_doc>* Starts this animation playback.
	 * 
	 * @param   Force      Whether to force this animation to restart.
	 * @param   Reversed   Whether to play animation backwards or not.
	 * @param   Frame      The frame number in this animation you want to start from (`0` by default).
	 *                     If you pass a negative value then it will start from a random frame.
	 *                     If you `Reversed` is `true`, the frame value will be "reversed"
	 *                     (`Frame = numFrames - 1 - Frame`), so `Frame` value will mean frame index
	 *                     from the animation's end in this case.</haxe_doc>
		</play>
		<restart public="1" set="method" line="143"><f a=""><x path="Void"/></f></restart>
		<stop public="1" set="method" line="148"><f a=""><x path="Void"/></f></stop>
		<reset public="1" set="method" line="154"><f a=""><x path="Void"/></f></reset>
		<finish public="1" set="method" line="160"><f a=""><x path="Void"/></f></finish>
		<pause public="1" set="method" line="166"><f a=""><x path="Void"/></f></pause>
		<resume public="1" get="inline" set="null" line="171"><f a=""><x path="Void"/></f></resume>
		<reverse public="1" set="method" line="176"><f a=""><x path="Void"/></f></reverse>
		<update public="1" set="method" line="183" override="1"><f a="elapsed">
	<x path="Float"/>
	<x path="Void"/>
</f></update>
		<clone public="1" set="method" line="209" override="1"><f a="Parent">
	<c path="flixel.animation.FlxAnimationController"/>
	<c path="flixel.animation.FlxAnimation"/>
</f></clone>
		<set_frameRate set="method" line="214"><f a="value">
	<x path="Int"/>
	<x path="Int"/>
</f></set_frameRate>
		<set_curFrame set="method" line="223"><f a="Frame">
	<x path="Int"/>
	<x path="Int"/>
</f></set_curFrame>
		<get_numFrames get="inline" set="null" line="251"><f a=""><x path="Int"/></f></get_numFrames>
		<new public="1" set="method" line="80">
			<f a="Parent:Name:Frames:?FrameRate:?Looped:?FlipX:?FlipY" v=":::0:true:false:false">
				<c path="flixel.animation.FlxAnimationController"/>
				<c path="String"/>
				<c path="Array"><x path="Int"/></c>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ FlipY : false, FlipX : false, Looped : true, FrameRate : 0 }</e></m></meta>
			<haxe_doc>* @param   Name        What this animation should be called (e.g. `"run"`).
	 * @param   Frames      An array of numbers indicating what frames to play in what order (e.g. `[1, 2, 3]`).
	 * @param   FrameRate   The speed in frames per second that the animation should play at (e.g. `40`).
	 * @param   Looped      Whether or not the animation is looped or just plays once.
	 * @param   FlipX       Whether or not the frames of this animation are horizontally flipped.
	 * @param   FlipY       Whether or not the frames of this animation are vertically flipped.</haxe_doc>
		</new>
		<haxe_doc>* Just a helper structure for the `FlxSprite` animation system.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="flixel.animation.FlxAnimationController" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/animation/FlxAnimationController.hx">
		<implements path="flixel.util.IFlxDestroyable"/>
		<curAnim public="1" get="accessor" set="accessor">
			<c path="flixel.animation.FlxAnimation"/>
			<haxe_doc>* Property access for currently playing animation (warning: can be `null`).</haxe_doc>
		</curAnim>
		<frameIndex public="1" set="accessor" expr="-1">
			<x path="Int"/>
			<meta><m n=":value"><e>-1</e></m></meta>
			<haxe_doc>* The frame index of the current animation. Can be changed manually.</haxe_doc>
		</frameIndex>
		<frameName public="1" get="accessor" set="accessor">
			<c path="String"/>
			<haxe_doc>* Tell the sprite to change to a frame with specific name.
	 * Useful for sprites with loaded TexturePacker atlas.</haxe_doc>
		</frameName>
		<name public="1" get="accessor" set="accessor">
			<c path="String"/>
			<haxe_doc>* Gets or sets the currently playing animation (warning: can be `null`).</haxe_doc>
		</name>
		<paused public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<haxe_doc>* Pause or resume the current animation.</haxe_doc>
		</paused>
		<finished public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<haxe_doc>* Whether the current animation has finished playing.</haxe_doc>
		</finished>
		<frames public="1" get="accessor" set="null">
			<x path="Int"/>
			<haxe_doc>* The total number of frames in this image.
	 * WARNING: assumes each row in the sprite sheet is full!</haxe_doc>
		</frames>
		<callback public="1">
			<f a="::">
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* If assigned, will be called each time the current animation's frame changes.
	 * A function that has 3 parameters: a string name, a frame number, and a frame index.</haxe_doc>
		</callback>
		<finishCallback public="1">
			<f a="">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* If assigned, will be called each time the current animation finishes.
	 * A function that has 1 parameter: a string name - animation name.</haxe_doc>
		</finishCallback>
		<_sprite>
			<c path="flixel.FlxSprite"/>
			<haxe_doc>* Internal, reference to owner sprite.</haxe_doc>
		</_sprite>
		<_curAnim>
			<c path="flixel.animation.FlxAnimation"/>
			<meta><m n=":allow"><e>flixel.animation</e></m></meta>
			<haxe_doc>* Internal, currently playing animation.</haxe_doc>
		</_curAnim>
		<_animations set="null">
			<x path="Map">
				<c path="String"/>
				<c path="flixel.animation.FlxAnimation"/>
			</x>
			<haxe_doc>* Internal, stores all the animation that were added to this sprite.</haxe_doc>
		</_animations>
		<_prerotated><c path="flixel.animation.FlxPrerotatedAnimation"/></_prerotated>
		<update public="1" set="method" line="83"><f a="elapsed">
	<x path="Float"/>
	<x path="Void"/>
</f></update>
		<copyFrom public="1" set="method" line="95"><f a="controller">
	<c path="flixel.animation.FlxAnimationController"/>
	<c path="flixel.animation.FlxAnimationController"/>
</f></copyFrom>
		<createPrerotated public="1" set="method" line="119"><f a="?Controller">
	<c path="flixel.animation.FlxAnimationController"/>
	<x path="Void"/>
</f></createPrerotated>
		<destroyAnimations public="1" set="method" line="127"><f a=""><x path="Void"/></f></destroyAnimations>
		<destroy public="1" set="method" line="133"><f a=""><x path="Void"/></f></destroy>
		<clearPrerotated set="method" line="141"><f a=""><x path="Void"/></f></clearPrerotated>
		<clearAnimations set="method" line="150"><f a=""><x path="Void"/></f></clearAnimations>
		<add public="1" set="method" line="179">
			<f a="Name:Frames:?FrameRate:?Looped:?FlipX:?FlipY" v="::30:true:false:false">
				<c path="String"/>
				<c path="Array"><x path="Int"/></c>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ FlipY : false, FlipX : false, Looped : true, FrameRate : 30 }</e></m></meta>
			<haxe_doc>* Adds a new animation to the sprite.
	 * 
	 * @param   Name        What this animation should be called (e.g. `"run"`).
	 * @param   Frames      An array of indices indicating what frames to play in what order (e.g. `[0, 1, 2]`).
	 * @param   FrameRate   The speed in frames per second that the animation should play at (e.g. `40` fps).
	 * @param   Looped      Whether or not the animation is looped or just plays once.
	 * @param   FlipX       Whether the frames should be flipped horizontally.
	 * @param   FlipY       Whether the frames should be flipped vertically.</haxe_doc>
		</add>
		<remove public="1" set="method" line="213">
			<f a="Name">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Removes (and destroys) an animation.
	 * 
	 * @param   Name   The name of animation to remove.</haxe_doc>
		</remove>
		<append public="1" set="method" line="231">
			<f a="Name:Frames">
				<c path="String"/>
				<c path="Array"><x path="Int"/></c>
				<x path="Void"/>
			</f>
			<haxe_doc>* Adds to an existing animation in the sprite by appending the specified frames to the existing frames.
	 * Use this method when the indices of the frames in the atlas are already known.
	 * The animation must already exist in order to append frames to it.
	 * 
	 * @param   Name     What the existing animation is called (e.g. `"run"`).
	 * @param   Frames   An array of indices indicating what frames to append (e.g. `[0, 1, 2]`).</haxe_doc>
		</append>
		<addByNames public="1" set="method" line="265">
			<f a="Name:FrameNames:?FrameRate:?Looped:?FlipX:?FlipY" v="::30:true:false:false">
				<c path="String"/>
				<c path="Array"><c path="String"/></c>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ FlipY : false, FlipX : false, Looped : true, FrameRate : 30 }</e></m></meta>
			<haxe_doc>* Adds a new animation to the sprite.
	 * 
	 * @param   Name         What this animation should be called (e.g. `"run"`).
	 * @param   FrameNames   An array of image names from the atlas indicating what frames to play in what order.
	 * @param   FrameRate    The speed in frames per second that the animation should play at (e.g. `40` fps).
	 * @param   Looped       Whether or not the animation is looped or just plays once.
	 * @param   FlipX        Whether the frames should be flipped horizontally.
	 * @param   FlipY        Whether the frames should be flipped vertically.</haxe_doc>
		</addByNames>
		<appendByNames public="1" set="method" line="289">
			<f a="Name:FrameNames">
				<c path="String"/>
				<c path="Array"><c path="String"/></c>
				<x path="Void"/>
			</f>
			<haxe_doc>* Adds to an existing animation in the sprite by appending the specified frames to the existing frames.
	 * Use this method when the exact name of each frame from the atlas is known (e.g. `"walk00.png"`, `"walk01.png"`).
	 * The animation must already exist in order to append frames to it.
	 * 
	 * @param   Name         What the existing animation is called (e.g. `"run"`).
	 * @param   FrameNames   An array of image names from atlas indicating what frames to append.</haxe_doc>
		</appendByNames>
		<addByStringIndices public="1" set="method" line="317">
			<f a="Name:Prefix:Indices:Postfix:?FrameRate:?Looped:?FlipX:?FlipY" v="::::30:true:false:false">
				<c path="String"/>
				<c path="String"/>
				<c path="Array"><c path="String"/></c>
				<c path="String"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ FlipY : false, FlipX : false, Looped : true, FrameRate : 30 }</e></m></meta>
			<haxe_doc>* Adds a new animation to the sprite. Should be slightly faster than `addByIndices()`.
	 * 
	 * @param   Name        What this animation should be called (e.g. `"run"`).
	 * @param   Prefix      Common beginning of image names in the atlas (e.g. `"tiles-"`).
	 * @param   Indices     An array of strings indicating what frames to play in what order
	 *                      (e.g. `["01", "02", "03"]`).
	 * @param   Postfix     Common ending of image names in atlas (e.g. `".png"`).
	 * @param   FrameRate   The speed in frames per second that the animation should play at (e.g. `40` fps).
	 * @param   Looped      Whether or not the animation is looped or just plays once.
	 * @param   FlipX       Whether the frames should be flipped horizontally.
	 * @param   FlipY       Whether the frames should be flipped vertically.</haxe_doc>
		</addByStringIndices>
		<appendByStringIndices public="1" set="method" line="345">
			<f a="Name:Prefix:Indices:Postfix">
				<c path="String"/>
				<c path="String"/>
				<c path="Array"><c path="String"/></c>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Adds to an existing animation in the sprite by appending the specified frames to the existing frames.
	 * Should be slightly faster than `appendByIndices()`. Use this method when the names of each frame from
	 * the atlas share a common prefix and postfix (e.g. `"walk00.png"`, `"walk01.png"`).
	 * The animation must already exist in order to append frames to it. FrameRate and Looped are unchanged.
	 * 
	 * @param   Name      What the existing animation is called (e.g. `"run"`).
	 * @param   Prefix    Common beginning of image names in the atlas (e.g. `"tiles-"`).
	 * @param   Indices   An array of strings indicating what frames to append (e.g. `["01", "02", "03"]`).
	 * @param   Postfix   Common ending of image names in atlas (e.g. `".png"`).</haxe_doc>
		</appendByStringIndices>
		<addByIndices public="1" set="method" line="373">
			<f a="Name:Prefix:Indices:Postfix:?FrameRate:?Looped:?FlipX:?FlipY" v="::::30:true:false:false">
				<c path="String"/>
				<c path="String"/>
				<c path="Array"><x path="Int"/></c>
				<c path="String"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ FlipY : false, FlipX : false, Looped : true, FrameRate : 30 }</e></m></meta>
			<haxe_doc>* Adds a new animation to the sprite.
	 * 
	 * @param   Name        What this animation should be called (e.g. `"run"`).
	 * @param   Prefix      Common beginning of image names in the atlas (e.g. "tiles-").
	 * @param   Indices     An array of numbers indicating what frames to play in what order (e.g. `[0, 1, 2]`).
	 * @param   Postfix     Common ending of image names in the atlas (e.g. `".png"`).
	 * @param   FrameRate   The speed in frames per second that the animation should play at (e.g. `40` fps).
	 * @param   Looped      Whether or not the animation is looped or just plays once.
	 * @param   FlipX       Whether the frames should be flipped horizontally.
	 * @param   FlipY       Whether the frames should be flipped vertically.</haxe_doc>
		</addByIndices>
		<appendByIndices public="1" set="method" line="402">
			<f a="Name:Prefix:Indices:Postfix">
				<c path="String"/>
				<c path="String"/>
				<c path="Array"><x path="Int"/></c>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Adds to an existing animation in the sprite by appending the specified frames to the existing frames.
	 * Use this method when the names of each frame from the atlas share a common prefix
	 * and postfix (e.g. `"walk00.png"`, `"walk01.png"`).
	 * Leading zeroes are ignored for matching indices (`5` will match `"5"` and `"005"`).
	 * The animation must already exist in order to append frames to it.
	 * 
	 * @param   Name      What the existing animation is called (e.g. `"run"`).
	 * @param   Prefix    Common beginning of image names in atlas (e.g. `"tiles-"`).
	 * @param   Indices   An array of numbers indicating what frames to append (e.g. `[0, 1, 2]`).
	 * @param   Postfix   Common ending of image names in atlas (e.g. `".png"`).</haxe_doc>
		</appendByIndices>
		<findSpriteFrame set="method" line="424">
			<f a="Prefix:Index:Postfix">
				<c path="String"/>
				<x path="Int"/>
				<c path="String"/>
				<x path="Int"/>
			</f>
			<haxe_doc>* Find a sprite frame so that for `Prefix = "file"; Index = 5; Postfix = ".png"`
	 * It will find frame with name `"file5.png"`. If it doesn't exist it will try
	 * to find `"file05.png"`, allowing 99 frames per animation.
	 * Returns the found frame or `-1` on failure.</haxe_doc>
		</findSpriteFrame>
		<addByPrefix public="1" set="method" line="454">
			<f a="Name:Prefix:?FrameRate:?Looped:?FlipX:?FlipY" v="::30:true:false:false">
				<c path="String"/>
				<c path="String"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ FlipY : false, FlipX : false, Looped : true, FrameRate : 30 }</e></m></meta>
			<haxe_doc>* Adds a new animation to the sprite.
	 * 
	 * @param   Name        What this animation should be called (e.g. `"run"`).
	 * @param   Prefix      Common beginning of image names in atlas (e.g. `"tiles-"`).
	 * @param   FrameRate   The speed in frames per second that the animation should play at (e.g. `40` fps).
	 * @param   Looped      Whether or not the animation is looped or just plays once.
	 * @param   FlipX       Whether the frames should be flipped horizontally.
	 * @param   FlipY       Whether the frames should be flipped vertically.</haxe_doc>
		</addByPrefix>
		<appendByPrefix public="1" set="method" line="486">
			<f a="Name:Prefix">
				<c path="String"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Adds to an existing animation in the sprite by appending the specified frames to the existing frames.
	 * Use this method when the names of each frame from the atlas share a common prefix
	 * (e.g. `"walk00.png"`, `"walk01.png"`).
	 * Frames are sorted numerically while ignoring postfixes (e.g. `".png"`, `".gif"`).
	 * The animation must already exist in order to append frames to it.
	 * 
	 * @param   Name     What the existing animation is called (e.g. `"run"`).
	 * @param   Prefix   Common beginning of image names in atlas (e.g. `"tiles-"`)</haxe_doc>
		</appendByPrefix>
		<play public="1" set="method" line="518">
			<f a="AnimName:?Force:?Reversed:?Frame" v=":false:false:0">
				<c path="String"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ Frame : 0, Reversed : false, Force : false }</e></m></meta>
			<haxe_doc>* Plays an existing animation (e.g. `"run"`).
	 * If you call an animation that is already playing, it will be ignored.
	 * 
	 * @param   AnimName   The string name of the animation you want to play.
	 * @param   Force      Whether to force the animation to restart.
	 * @param   Reversed   Whether to play animation backwards or not.
	 * @param   Frame      The frame number in the animation you want to start from.
	 *                     If a negative value is passed, a random frame is used.</haxe_doc>
		</play>
		<reset public="1" get="inline" set="null" line="556">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Stops current animation and resets its frame index to zero.</haxe_doc>
		</reset>
		<finish public="1" set="method" line="567">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Stops current animation and sets its frame to the last one.</haxe_doc>
		</finish>
		<stop public="1" set="method" line="578">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Just stops current animation.</haxe_doc>
		</stop>
		<pause public="1" get="inline" set="null" line="589">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Pauses the current animation.</haxe_doc>
		</pause>
		<resume public="1" get="inline" set="null" line="600">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Resumes the current animation if it exists.</haxe_doc>
		</resume>
		<reverse public="1" get="inline" set="null" line="611">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Reverses current animation if it exists.</haxe_doc>
		</reverse>
		<getByName public="1" get="inline" set="null" line="622">
			<f a="Name">
				<c path="String"/>
				<c path="flixel.animation.FlxAnimation"/>
			</f>
			<haxe_doc>* Gets the FlxAnimation object with the specified name.</haxe_doc>
		</getByName>
		<randomFrame public="1" set="method" line="631">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Changes to a random animation frame.
	 * Useful for instantiating particles or other weird things.</haxe_doc>
		</randomFrame>
		<fireCallback get="inline" set="null" line="641"><f a=""><x path="Void"/></f></fireCallback>
		<fireFinishCallback get="inline" set="null" line="652">
			<f a="?name">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":allow"><e>flixel.animation</e></m></meta>
		</fireFinishCallback>
		<byNamesHelper set="method" line="660"><f a="AddTo:FrameNames">
	<c path="Array"><x path="Int"/></c>
	<c path="Array"><c path="String"/></c>
	<x path="Void"/>
</f></byNamesHelper>
		<byStringIndicesHelper set="method" line="672"><f a="AddTo:Prefix:Indices:Postfix">
	<c path="Array"><x path="Int"/></c>
	<c path="String"/>
	<c path="Array"><c path="String"/></c>
	<c path="String"/>
	<x path="Void"/>
</f></byStringIndicesHelper>
		<byIndicesHelper set="method" line="685"><f a="AddTo:Prefix:Indices:Postfix">
	<c path="Array"><x path="Int"/></c>
	<c path="String"/>
	<c path="Array"><x path="Int"/></c>
	<c path="String"/>
	<x path="Void"/>
</f></byIndicesHelper>
		<byPrefixHelper set="method" line="697"><f a="AddTo:AnimFrames:Prefix">
	<c path="Array"><x path="Int"/></c>
	<c path="Array"><c path="flixel.graphics.frames.FlxFrame"/></c>
	<c path="String"/>
	<x path="Void"/>
</f></byPrefixHelper>
		<findByPrefix set="method" line="710"><f a="AnimFrames:Prefix">
	<c path="Array"><c path="flixel.graphics.frames.FlxFrame"/></c>
	<c path="String"/>
	<x path="Void"/>
</f></findByPrefix>
		<set_frameIndex set="method" line="721"><f a="Frame">
	<x path="Int"/>
	<x path="Int"/>
</f></set_frameIndex>
		<get_frameName get="inline" set="null" line="734"><f a=""><c path="String"/></f></get_frameName>
		<set_frameName set="method" line="739"><f a="Value">
	<c path="String"/>
	<c path="String"/>
</f></set_frameName>
		<get_name set="method" line="759"><f a=""><c path="String"/></f></get_name>
		<set_name set="method" line="769"><f a="AnimName">
	<c path="String"/>
	<c path="String"/>
</f></set_name>
		<get_curAnim get="inline" set="null" line="775"><f a=""><c path="flixel.animation.FlxAnimation"/></f></get_curAnim>
		<set_curAnim get="inline" set="null" line="780"><f a="Anim">
	<c path="flixel.animation.FlxAnimation"/>
	<c path="flixel.animation.FlxAnimation"/>
</f></set_curAnim>
		<get_paused get="inline" set="null" line="797"><f a=""><x path="Bool"/></f></get_paused>
		<set_paused get="inline" set="null" line="807"><f a="Value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_paused>
		<get_finished set="method" line="823"><f a=""><x path="Bool"/></f></get_finished>
		<set_finished get="inline" set="null" line="833"><f a="Value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_finished>
		<get_frames get="inline" set="null" line="842"><f a=""><x path="Int"/></f></get_frames>
		<getFrameIndex public="1" get="inline" set="null" line="853">
			<f a="Frame">
				<c path="flixel.graphics.frames.FlxFrame"/>
				<x path="Int"/>
			</f>
			<haxe_doc>* Helper function used for finding index of `FlxFrame` in `_framesData`'s frames array
	 * 
	 * @param   Frame   `FlxFrame` to find
	 * @return  position of specified `FlxFrame` object.</haxe_doc>
		</getFrameIndex>
		<new public="1" set="method" line="77"><f a="Sprite">
	<c path="flixel.FlxSprite"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="flixel.animation.FlxPrerotatedAnimation" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/animation/FlxPrerotatedAnimation.hx">
		<extends path="flixel.animation.FlxBaseAnimation"/>
		<PREROTATED public="1" get="inline" set="null" expr="&quot;prerotated_animation&quot;" line="9" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"prerotated_animation"</e></m></meta>
		</PREROTATED>
		<rotations><x path="Int"/></rotations>
		<baked><x path="Float"/></baked>
		<angle public="1" set="accessor" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</angle>
		<set_angle set="method" line="24"><f a="Value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_angle>
		<set_curIndex set="method" line="44" override="1"><f a="Value">
	<x path="Int"/>
	<x path="Int"/>
</f></set_curIndex>
		<clone public="1" set="method" line="56" override="1"><f a="Parent">
	<c path="flixel.animation.FlxAnimationController"/>
	<c path="flixel.animation.FlxPrerotatedAnimation"/>
</f></clone>
		<new public="1" set="method" line="15"><f a="Parent:Baked">
	<c path="flixel.animation.FlxAnimationController"/>
	<x path="Float"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>* ...
 * @author Zaphod</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="flixel.effects.FlxFlicker" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/effects/FlxFlicker.hx">
		<implements path="flixel.util.IFlxDestroyable"/>
		<_pool expr="new FlxPool&lt;FlxFlicker&gt;(FlxFlicker)" line="15" static="1">
			<c path="flixel.util.FlxPool_flixel_effects_FlxFlicker"/>
			<meta><m n=":value"><e><![CDATA[new FlxPool<FlxFlicker>(FlxFlicker)]]></e></m></meta>
		</_pool>
		<_boundObjects expr="new Map&lt;FlxObject,FlxFlicker&gt;()" line="20" static="1">
			<x path="Map">
				<c path="flixel.FlxObject"/>
				<c path="flixel.effects.FlxFlicker"/>
			</x>
			<meta><m n=":value"><e><![CDATA[new Map<FlxObject,FlxFlicker>()]]></e></m></meta>
			<haxe_doc>* Internal map for looking up which objects are currently flickering and getting their flicker data.</haxe_doc>
		</_boundObjects>
		<flicker public="1" set="method" line="36" static="1">
			<f a="Object:?Duration:?Interval:?EndVisibility:?ForceRestart:?CompletionCallback:?ProgressCallback" v=":1:0.04:true:true::">
				<c path="flixel.FlxObject"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<f a="">
					<c path="flixel.effects.FlxFlicker"/>
					<x path="Void"/>
				</f>
				<f a="">
					<c path="flixel.effects.FlxFlicker"/>
					<x path="Void"/>
				</f>
				<c path="flixel.effects.FlxFlicker"/>
			</f>
			<meta><m n=":value"><e>{ ForceRestart : true, EndVisibility : true, Interval : 0.04, Duration : 1 }</e></m></meta>
			<haxe_doc><![CDATA[* A simple flicker effect for sprites using a ping-pong tween by toggling visibility.
	 * 
	 * @param   Object               The object.
	 * @param   Duration             How long to flicker for (in seconds). `0` means "forever".
	 * @param   Interval             In what interval to toggle visibility. Set to `FlxG.elapsed` if `<= 0`!
	 * @param   EndVisibility        Force the visible value when the flicker completes,
	 *                               useful with fast repetitive use.
	 * @param   ForceRestart         Force the flicker to restart from beginning,
	 *                               discarding the flickering effect already in progress if there is one.
	 * @param   CompletionCallback   An optional callback that will be triggered when a flickering has finished.
	 * @param   ProgressCallback     An optional callback that will be triggered when visibility is toggled.
	 * @return The `FlxFlicker` object. `FlxFlicker`s are pooled internally, so beware of storing references.]]></haxe_doc>
		</flicker>
		<isFlickering public="1" set="method" line="68" static="1">
			<f a="Object">
				<c path="flixel.FlxObject"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Returns whether the object is flickering or not.
	 * 
	 * @param   Object The object to test.</haxe_doc>
		</isFlickering>
		<stopFlickering public="1" set="method" line="78" static="1">
			<f a="Object">
				<c path="flixel.FlxObject"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Stops flickering of the object. Also it will make the object visible.
	 * 
	 * @param   Object The object to stop flickering.</haxe_doc>
		</stopFlickering>
		<object public="1" set="null">
			<c path="flixel.FlxObject"/>
			<haxe_doc>* The flickering object.</haxe_doc>
		</object>
		<endVisibility public="1" set="null">
			<x path="Bool"/>
			<haxe_doc>* The final visibility of the object after flicker is complete.</haxe_doc>
		</endVisibility>
		<timer public="1" set="null">
			<c path="flixel.util.FlxTimer"/>
			<haxe_doc>* The flicker timer. You can check how many seconds has passed since flickering started etc.</haxe_doc>
		</timer>
		<completionCallback public="1" set="null">
			<f a="">
				<c path="flixel.effects.FlxFlicker"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* The callback that will be triggered after flicker has completed.</haxe_doc>
		</completionCallback>
		<progressCallback public="1" set="null">
			<f a="">
				<c path="flixel.effects.FlxFlicker"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* The callback that will be triggered every time object visiblity is changed.</haxe_doc>
		</progressCallback>
		<duration public="1" set="null">
			<x path="Float"/>
			<haxe_doc>* The duration of the flicker (in seconds). `0` means "forever".</haxe_doc>
		</duration>
		<interval public="1" set="null">
			<x path="Float"/>
			<haxe_doc>* The interval of the flicker.</haxe_doc>
		</interval>
		<destroy public="1" set="method" line="125">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Nullifies the references to prepare object for reuse and avoid memory leaks.</haxe_doc>
		</destroy>
		<start set="method" line="136">
			<f a="Object:Duration:Interval:EndVisibility:?CompletionCallback:?ProgressCallback">
				<c path="flixel.FlxObject"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Bool"/>
				<f a="">
					<c path="flixel.effects.FlxFlicker"/>
					<x path="Void"/>
				</f>
				<f a="">
					<c path="flixel.effects.FlxFlicker"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<haxe_doc>* Starts flickering behavior.</haxe_doc>
		</start>
		<stop public="1" set="method" line="151">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Prematurely ends flickering.</haxe_doc>
		</stop>
		<release set="method" line="161">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Unbinds the object from flicker and releases it into pool for reuse.</haxe_doc>
		</release>
		<flickerProgress set="method" line="170">
			<f a="Timer">
				<c path="flixel.util.FlxTimer"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Just a helper function for flicker() to update object's visibility.</haxe_doc>
		</flickerProgress>
		<new set="method" line="194">
			<f a=""><x path="Void"/></f>
			<meta><m n=":keep"/></meta>
			<haxe_doc>* Internal constructor. Use static methods.</haxe_doc>
		</new>
		<haxe_doc>* The retro flickering effect with callbacks.
 * You can use this as a mixin in any FlxObject subclass or by calling the static functions.
 * @author pixelomatic</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<typedef path="flixel.effects.particles.FlxEmitter" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/effects/particles/FlxEmitter.hx"><c path="flixel.effects.particles.FlxTypedEmitter"><c path="flixel.effects.particles.FlxParticle"/></c></typedef>
	<class path="flixel.effects.particles.FlxTypedEmitter" params="T" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/effects/particles/FlxEmitter.hx" module="flixel.effects.particles.FlxEmitter">
		<extends path="flixel.group.FlxTypedGroup"><c path="flixel.effects.particles.FlxTypedEmitter.T"/></extends>
		<particleClass public="1" expr="cast FlxParticle">
			<x path="Class"><c path="flixel.effects.particles.FlxTypedEmitter.T"/></x>
			<meta><m n=":value"><e>cast FlxParticle</e></m></meta>
			<haxe_doc>* Set your own particle class type here. The custom class must extend `FlxParticle`. Default is `FlxParticle`.</haxe_doc>
		</particleClass>
		<emitting public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
			<haxe_doc>* Determines whether the emitter is currently emitting particles. It is totally safe to directly toggle this.</haxe_doc>
		</emitting>
		<frequency public="1" expr="0.1">
			<x path="Float"/>
			<meta><m n=":value"><e>0.1</e></m></meta>
			<haxe_doc>* How often a particle is emitted (if emitter is started with `Explode == false`).</haxe_doc>
		</frequency>
		<blend public="1">
			<t path="flash.display.BlendMode"/>
			<haxe_doc>* Sets particle's blend mode. `null` by default. Warning: Expensive on Flash.</haxe_doc>
		</blend>
		<x public="1" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* The x position of this emitter.</haxe_doc>
		</x>
		<y public="1" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* The y position of this emitter.</haxe_doc>
		</y>
		<width public="1" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* The width of this emitter. Particles can be randomly generated from anywhere within this box.</haxe_doc>
		</width>
		<height public="1" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* The height of this emitter. Particles can be randomly generated from anywhere within this box.</haxe_doc>
		</height>
		<launchMode public="1" expr="FlxEmitterMode.CIRCLE">
			<e path="flixel.effects.particles.FlxEmitterMode"/>
			<meta><m n=":value"><e>FlxEmitterMode.CIRCLE</e></m></meta>
			<haxe_doc>* How particles should be launched. If `CIRCLE`, particles will use `launchAngle` and `speed`.
	 * Otherwise, particles will just use `velocity.x` and `velocity.y`.</haxe_doc>
		</launchMode>
		<keepScaleRatio public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
			<haxe_doc>* Keep the scale ratio of the particle. Uses the `x` values of `scale`.</haxe_doc>
		</keepScaleRatio>
		<velocity public="1" set="null" expr="new FlxPointRangeBounds(-100, -100, 100, 100)">
			<c path="flixel.util.helpers.FlxPointRangeBounds"/>
			<meta><m n=":value"><e>new FlxPointRangeBounds(-100, -100, 100, 100)</e></m></meta>
			<haxe_doc>* Sets the velocity range of particles launched from this emitter. Only used with `FlxEmitterMode.SQUARE`.</haxe_doc>
		</velocity>
		<speed public="1" set="null" expr="new FlxRangeBounds&lt;Float&gt;(0, 100)">
			<c path="flixel.util.helpers.FlxRangeBounds"><x path="Float"/></c>
			<meta><m n=":value"><e><![CDATA[new FlxRangeBounds<Float>(0, 100)]]></e></m></meta>
			<haxe_doc>* Set the speed range of particles launched from this emitter. Only used with `FlxEmitterMode.CIRCLE`.</haxe_doc>
		</speed>
		<angularAcceleration public="1" set="null" expr="new FlxRangeBounds&lt;Float&gt;(0, 0)">
			<c path="flixel.util.helpers.FlxRangeBounds"><x path="Float"/></c>
			<meta><m n=":value"><e><![CDATA[new FlxRangeBounds<Float>(0, 0)]]></e></m></meta>
			<haxe_doc>* Set the angular acceleration range of particles launched from this emitter.</haxe_doc>
		</angularAcceleration>
		<angularDrag public="1" set="null" expr="new FlxRangeBounds&lt;Float&gt;(0, 0)">
			<c path="flixel.util.helpers.FlxRangeBounds"><x path="Float"/></c>
			<meta><m n=":value"><e><![CDATA[new FlxRangeBounds<Float>(0, 0)]]></e></m></meta>
			<haxe_doc>* Set the angular drag range of particles launched from this emitter.</haxe_doc>
		</angularDrag>
		<angularVelocity public="1" set="null" expr="new FlxRangeBounds&lt;Float&gt;(0, 0)">
			<c path="flixel.util.helpers.FlxRangeBounds"><x path="Float"/></c>
			<meta><m n=":value"><e><![CDATA[new FlxRangeBounds<Float>(0, 0)]]></e></m></meta>
			<haxe_doc>* The angular velocity range of particles launched from this emitter.</haxe_doc>
		</angularVelocity>
		<angle public="1" set="null" expr="new FlxRangeBounds&lt;Float&gt;(0)">
			<c path="flixel.util.helpers.FlxRangeBounds"><x path="Float"/></c>
			<meta><m n=":value"><e><![CDATA[new FlxRangeBounds<Float>(0)]]></e></m></meta>
			<haxe_doc>* The angle range of particles launched from this emitter.
	 * `angle.end` is ignored unless `ignoreAngularVelocity` is set to `true`.</haxe_doc>
		</angle>
		<ignoreAngularVelocity public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
			<haxe_doc>* Set this if you want to specify the beginning and ending value of angle,
	 * instead of using `angularVelocity` (or `angularAcceleration`).</haxe_doc>
		</ignoreAngularVelocity>
		<launchAngle public="1" set="null" expr="new FlxBounds&lt;Float&gt;(-180, 180)">
			<c path="flixel.util.helpers.FlxBounds"><x path="Float"/></c>
			<meta><m n=":value"><e><![CDATA[new FlxBounds<Float>(-180, 180)]]></e></m></meta>
			<haxe_doc>* The angle range at which particles will be launched from this emitter.
	 * Ignored unless `launchMode` is set to `FlxEmitterMode.CIRCLE`.</haxe_doc>
		</launchAngle>
		<lifespan public="1" set="null" expr="new FlxBounds&lt;Float&gt;(3)">
			<c path="flixel.util.helpers.FlxBounds"><x path="Float"/></c>
			<meta><m n=":value"><e><![CDATA[new FlxBounds<Float>(3)]]></e></m></meta>
			<haxe_doc>* The life, or duration, range of particles launched from this emitter.</haxe_doc>
		</lifespan>
		<scale public="1" set="null" expr="new FlxPointRangeBounds(1, 1)">
			<c path="flixel.util.helpers.FlxPointRangeBounds"/>
			<meta><m n=":value"><e>new FlxPointRangeBounds(1, 1)</e></m></meta>
			<haxe_doc>* Sets `scale` range of particles launched from this emitter.</haxe_doc>
		</scale>
		<alpha public="1" set="null" expr="new FlxRangeBounds&lt;Float&gt;(1)">
			<c path="flixel.util.helpers.FlxRangeBounds"><x path="Float"/></c>
			<meta><m n=":value"><e><![CDATA[new FlxRangeBounds<Float>(1)]]></e></m></meta>
			<haxe_doc>* Sets `alpha` range of particles launched from this emitter.</haxe_doc>
		</alpha>
		<color public="1" set="null" expr="new FlxRangeBounds(FlxColor.WHITE, FlxColor.WHITE)">
			<c path="flixel.util.helpers.FlxRangeBounds"><x path="flixel.util.FlxColor"/></c>
			<meta><m n=":value"><e>new FlxRangeBounds(FlxColor.WHITE, FlxColor.WHITE)</e></m></meta>
			<haxe_doc>* Sets `color` range of particles launched from this emitter.</haxe_doc>
		</color>
		<drag public="1" set="null" expr="new FlxPointRangeBounds(0, 0)">
			<c path="flixel.util.helpers.FlxPointRangeBounds"/>
			<meta><m n=":value"><e>new FlxPointRangeBounds(0, 0)</e></m></meta>
			<haxe_doc>* Sets X and Y drag component of particles launched from this emitter.</haxe_doc>
		</drag>
		<acceleration public="1" set="null" expr="new FlxPointRangeBounds(0, 0)">
			<c path="flixel.util.helpers.FlxPointRangeBounds"/>
			<meta><m n=":value"><e>new FlxPointRangeBounds(0, 0)</e></m></meta>
			<haxe_doc>* Sets the `acceleration` range of particles launched from this emitter.
	 * Set acceleration y-values to give particles gravity.</haxe_doc>
		</acceleration>
		<elasticity public="1" set="null" expr="new FlxRangeBounds&lt;Float&gt;(0)">
			<c path="flixel.util.helpers.FlxRangeBounds"><x path="Float"/></c>
			<meta><m n=":value"><e><![CDATA[new FlxRangeBounds<Float>(0)]]></e></m></meta>
			<haxe_doc>* Sets the `elasticity`, or bounce, range of particles launched from this emitter.</haxe_doc>
		</elasticity>
		<immovable public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
			<haxe_doc>* Sets the `immovable` flag for particles launched from this emitter.</haxe_doc>
		</immovable>
		<autoUpdateHitbox public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
			<haxe_doc>* Sets the `autoUpdateHitbox` flag for particles launched from this emitter.
	 * If true, the particles' hitbox will be updated to match scale.</haxe_doc>
		</autoUpdateHitbox>
		<allowCollisions public="1" expr="FlxObject.NONE">
			<x path="Int"/>
			<meta><m n=":value"><e>FlxObject.NONE</e></m></meta>
			<haxe_doc>* Sets the `allowCollisions` value for particles launched from this emitter.
	 * Set to `NONE` by default. Don't forget to call `FlxG.collide()` in your update loop!</haxe_doc>
		</allowCollisions>
		<solid public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<haxe_doc>* Shorthand for toggling `allowCollisions` between `ANY` (if `true`) and `NONE` (if `false`).
	 * Don't forget to call `FlxG.collide()` in your update loop!</haxe_doc>
		</solid>
		<_quantity expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* Internal helper for deciding how many particles to launch.</haxe_doc>
		</_quantity>
		<_explode expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
			<haxe_doc>* Internal helper for the style of particle emission (all at once, or one at a time).</haxe_doc>
		</_explode>
		<_timer expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* Internal helper for deciding when to launch particles or kill them.</haxe_doc>
		</_timer>
		<_counter expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* Internal counter for figuring out how many particles to launch.</haxe_doc>
		</_counter>
		<_point expr="FlxPoint.get()">
			<c path="flixel.math.FlxPoint"/>
			<meta><m n=":value"><e>FlxPoint.get()</e></m></meta>
			<haxe_doc>* Internal point object, handy for reusing for memory management purposes.</haxe_doc>
		</_point>
		<_waitForKill expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
			<haxe_doc>* Internal helper for automatically calling the `kill()` method</haxe_doc>
		</_waitForKill>
		<destroy public="1" set="method" line="197" override="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Clean up memory.</haxe_doc>
		</destroy>
		<loadParticles public="1" set="method" line="235">
			<f a="Graphics:?Quantity:?bakedRotationAngles:?Multiple:?AutoBuffer" v=":50:16:false:false">
				<t path="flixel.system.FlxGraphicAsset"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<c path="flixel.effects.particles.FlxTypedEmitter"><c path="flixel.effects.particles.FlxTypedEmitter.T"/></c>
			</f>
			<meta><m n=":value"><e>{ AutoBuffer : false, Multiple : false, bakedRotationAngles : 16, Quantity : 50 }</e></m></meta>
			<haxe_doc>* This function generates a new array of particle sprites to attach to the emitter.
	 * 
	 * @param   Graphics         If you opted to not pre-configure an array of `FlxParticle` objects,
	 *                           you can simply pass in a particle image or sprite sheet.
	 * @param   Quantity         The number of particles to generate when using the "create from image" option.
	 * @param   BakedRotations   How many frames of baked rotation to use (boosts performance).
	 *                           Set to zero to not use baked rotations.
	 * @param   Multiple         Whether the image in the `Graphics` param is a single particle or a bunch of particles
	 *                           (if it's a bunch, they need to be square!).
	 * @param   AutoBuffer       Whether to automatically increase the image size to accommodate rotated corners.
	 *                           Default is `false`. Will create frames that are 150% larger on each axis than the
	 *                           original frame or graphic.
	 * @return  This `FlxEmitter` instance (nice for chaining stuff together).</haxe_doc>
		</loadParticles>
		<loadParticle set="method" line="255">
			<f a="Graphics:Quantity:bakedRotationAngles:?Multiple:?AutoBuffer:totalFrames" v=":::false:false:">
				<t path="flixel.system.FlxGraphicAsset"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Int"/>
				<c path="flixel.effects.particles.FlxTypedEmitter.T"/>
			</f>
			<meta><m n=":value"><e>{ AutoBuffer : false, Multiple : false }</e></m></meta>
		</loadParticle>
		<makeParticles public="1" set="method" line="281">
			<f a="?Width:?Height:?Color:?Quantity" v="2:2:FlxColor.WHITE:50">
				<x path="Int"/>
				<x path="Int"/>
				<x path="flixel.util.FlxColor"/>
				<x path="Int"/>
				<c path="flixel.effects.particles.FlxTypedEmitter"><c path="flixel.effects.particles.FlxTypedEmitter.T"/></c>
			</f>
			<meta><m n=":value"><e>{ Quantity : 50, Color : FlxColor.WHITE, Height : 2, Width : 2 }</e></m></meta>
			<haxe_doc>* Similar to `FlxSprite#makeGraphic()`, this function allows you to quickly make single-color particles.
	 * 
	 * @param   Width      The width of the generated particles. Default is `2` pixels.
	 * @param   Height     The height of the generated particles. Default is `2` pixels.
	 * @param   Color      The color of the generated particles. Default is white.
	 * @param   Quantity   How many particles to generate. Default is `50`.
	 * @return  This `FlxEmitter` instance (nice for chaining stuff together).</haxe_doc>
		</makeParticles>
		<update public="1" set="method" line="297" override="1">
			<f a="elapsed">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Called automatically by the game loop, decides when to launch particles and when to "die".</haxe_doc>
		</update>
		<explode set="method" line="320"><f a=""><x path="Void"/></f></explode>
		<emitContinuously set="method" line="332"><f a="elapsed">
	<x path="Float"/>
	<x path="Void"/>
</f></emitContinuously>
		<emitParticleContinuously set="method" line="351"><f a=""><x path="Void"/></f></emitParticleContinuously>
		<onFinished set="method" line="360"><f a=""><x path="Void"/></f></onFinished>
		<kill public="1" set="method" line="370" override="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Call this function to turn off all the particles and the emitter.</haxe_doc>
		</kill>
		<start public="1" set="method" line="387">
			<f a="?Explode:?Frequency:?Quantity" v="true:0.1:0">
				<x path="Bool"/>
				<x path="Float"/>
				<x path="Int"/>
				<c path="flixel.effects.particles.FlxTypedEmitter"><c path="flixel.effects.particles.FlxTypedEmitter.T"/></c>
			</f>
			<meta><m n=":value"><e>{ Quantity : 0, Frequency : 0.1, Explode : true }</e></m></meta>
			<haxe_doc>* Call this function to start emitting particles.
	 * 
	 * @param   Explode     Whether the particles should all burst out at once.
	 * @param   Frequency   Ignored if `Explode` is set to `true`. `Frequency` is how often to emit a particle.
	 *                      `0` = never emit, `0.1` = 1 particle every 0.1 seconds, `5` = 1 particle every 5 seconds.
	 * @param   Quantity    How many particles to launch. `0` = "all of the particles".
	 * @return  This `FlxEmitter` instance (nice for chaining stuff together).</haxe_doc>
		</start>
		<emitParticle public="1" set="method" line="408">
			<f a=""><c path="flixel.effects.particles.FlxTypedEmitter.T"/></f>
			<haxe_doc>* This function can be used both internally and externally to emit the next particle.</haxe_doc>
		</emitParticle>
		<focusOn public="1" set="method" line="583">
			<f a="Object">
				<c path="flixel.FlxObject"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Change the emitter's midpoint to match the midpoint of a `FlxObject`.
	 * 
	 * @param   Object   The `FlxObject` that you want to sync up with.</haxe_doc>
		</focusOn>
		<setPosition public="1" get="inline" set="null" line="594">
			<f a="?X:?Y" v="0:0">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ Y : 0, X : 0 }</e></m></meta>
			<haxe_doc>* Helper function to set the coordinates of this object.</haxe_doc>
		</setPosition>
		<setSize public="1" get="inline" set="null" line="600"><f a="Width:Height">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></setSize>
		<get_solid get="inline" set="null" line="606"><f a=""><x path="Bool"/></f></get_solid>
		<set_solid set="method" line="611"><f a="Solid">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_solid>
		<new public="1" set="method" line="186">
			<f a="?X:?Y:?Size" v="0:0:0">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ Size : 0, Y : 0, X : 0 }</e></m></meta>
			<haxe_doc>* Creates a new `FlxTypedEmitter` object at a specific position.
	 * Does NOT automatically generate or attach particles!
	 * 
	 * @param   X      The X position of the emitter.
	 * @param   Y      The Y position of the emitter.
	 * @param   Size   Optional, specifies a maximum capacity for this emitter.</haxe_doc>
		</new>
		<haxe_doc>* FlxTypedEmitter is a lightweight particle emitter.
 * It can be used for one-time explosions or for continuous fx like rain and fire.
 * `FlxEmitter` is not optimized or anything; all it does is launch `FlxParticle` objects out
 * at set intervals by setting their positions and velocities accordingly.
 * It is easy to use and relatively efficient, relying on `FlxGroup`'s RECYCLE POWERS.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<enum path="flixel.effects.particles.FlxEmitterMode" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/effects/particles/FlxEmitter.hx" module="flixel.effects.particles.FlxEmitter">
		<SQUARE/>
		<CIRCLE/>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<class path="flixel.effects.particles.IFlxParticle" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/effects/particles/FlxParticle.hx" module="flixel.effects.particles.FlxParticle" interface="1">
		<extends path="flixel.IFlxSprite"/>
		<lifespan public="1"><x path="Float"/></lifespan>
		<age public="1" set="null"><x path="Float"/></age>
		<percent public="1" set="null"><x path="Float"/></percent>
		<autoUpdateHitbox public="1"><x path="Bool"/></autoUpdateHitbox>
		<velocityRange public="1"><c path="flixel.util.helpers.FlxRange"><c path="flixel.math.FlxPoint"/></c></velocityRange>
		<angularVelocityRange public="1"><c path="flixel.util.helpers.FlxRange"><x path="Float"/></c></angularVelocityRange>
		<scaleRange public="1"><c path="flixel.util.helpers.FlxRange"><c path="flixel.math.FlxPoint"/></c></scaleRange>
		<alphaRange public="1"><c path="flixel.util.helpers.FlxRange"><x path="Float"/></c></alphaRange>
		<colorRange public="1"><c path="flixel.util.helpers.FlxRange"><x path="flixel.util.FlxColor"/></c></colorRange>
		<dragRange public="1"><c path="flixel.util.helpers.FlxRange"><c path="flixel.math.FlxPoint"/></c></dragRange>
		<accelerationRange public="1"><c path="flixel.util.helpers.FlxRange"><c path="flixel.math.FlxPoint"/></c></accelerationRange>
		<elasticityRange public="1"><c path="flixel.util.helpers.FlxRange"><x path="Float"/></c></elasticityRange>
		<onEmit public="1" set="method"><f a=""><x path="Void"/></f></onEmit>
	</class>
	<class path="flixel.effects.particles.FlxParticle" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/effects/particles/FlxParticle.hx">
		<extends path="flixel.FlxSprite"/>
		<implements path="flixel.effects.particles.IFlxParticle"/>
		<lifespan public="1" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* How long this particle lives before it disappears. Set to `0` to never `kill()` the particle automatically.
	 * NOTE: this is a maximum, not a minimum; the object could get recycled before its `lifespan` is up.</haxe_doc>
		</lifespan>
		<age public="1" set="null" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* How long this particle has lived so far.</haxe_doc>
		</age>
		<percent public="1" set="null" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* What percentage progress this particle has made of its total life.
	 * Essentially just `(age / lifespan)` on a scale from `0` to `1`.</haxe_doc>
		</percent>
		<autoUpdateHitbox public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
			<haxe_doc>* Whether or not the hitbox should be updated each frame when scaling.</haxe_doc>
		</autoUpdateHitbox>
		<velocityRange public="1">
			<c path="flixel.util.helpers.FlxRange"><c path="flixel.math.FlxPoint"/></c>
			<haxe_doc>* The range of values for `velocity` over this particle's `lifespan`.</haxe_doc>
		</velocityRange>
		<angularVelocityRange public="1">
			<c path="flixel.util.helpers.FlxRange"><x path="Float"/></c>
			<haxe_doc>* The range of values for `angularVelocity` over this particle's `lifespan`.</haxe_doc>
		</angularVelocityRange>
		<scaleRange public="1">
			<c path="flixel.util.helpers.FlxRange"><c path="flixel.math.FlxPoint"/></c>
			<haxe_doc>* The range of values for `scale` over this particle's `lifespan`.</haxe_doc>
		</scaleRange>
		<alphaRange public="1">
			<c path="flixel.util.helpers.FlxRange"><x path="Float"/></c>
			<haxe_doc>* The range of values for `alpha` over this particle's `lifespan`.</haxe_doc>
		</alphaRange>
		<colorRange public="1">
			<c path="flixel.util.helpers.FlxRange"><x path="flixel.util.FlxColor"/></c>
			<haxe_doc>* The range of values for `color` over this particle's `lifespan`.</haxe_doc>
		</colorRange>
		<dragRange public="1">
			<c path="flixel.util.helpers.FlxRange"><c path="flixel.math.FlxPoint"/></c>
			<haxe_doc>* The range of values for `drag` over this particle's `lifespan`.</haxe_doc>
		</dragRange>
		<accelerationRange public="1">
			<c path="flixel.util.helpers.FlxRange"><c path="flixel.math.FlxPoint"/></c>
			<haxe_doc>* The range of values for `acceleration` over this particle's `lifespan`.</haxe_doc>
		</accelerationRange>
		<elasticityRange public="1">
			<c path="flixel.util.helpers.FlxRange"><x path="Float"/></c>
			<haxe_doc>* The range of values for `elasticity` over this particle's `lifespan`.</haxe_doc>
		</elasticityRange>
		<_delta expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* The amount of change from the previous frame.</haxe_doc>
		</_delta>
		<destroy public="1" set="method" line="98" override="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Clean up memory.</haxe_doc>
		</destroy>
		<update public="1" set="method" line="136" override="1">
			<f a="elapsed">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* The particle's main update logic. Basically updates properties if alive, based on ranged properties.</haxe_doc>
		</update>
		<reset public="1" set="method" line="199" override="1"><f a="X:Y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></reset>
		<onEmit public="1" set="method" line="210">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Triggered whenever this object is launched by a `FlxEmitter`.
	 * You can override this to add custom behavior like a sound or AI or something.</haxe_doc>
		</onEmit>
		<new public="1" set="method" line="79">
			<f a=""><x path="Void"/></f>
			<meta><m n=":keep"/></meta>
			<haxe_doc>* Instantiate a new particle. Like `FlxSprite`, all meaningful creation
	 * happens during `loadGraphic()` or `makeGraphic()` or whatever.</haxe_doc>
		</new>
		<haxe_doc>* This is a simple particle class that extends the default behavior
 * of `FlxSprite` to have slightly more specialized behavior
 * common to many game scenarios. You can override and extend this class
 * just like you would FlxSprite. While FlxEmitter
 * used to work with just any old sprite, it now requires a
 * `FlxParticle` based class.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="flixel.effects.postprocess._PostProcess.Uniform" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/effects/postprocess/PostProcess.hx" private="1" module="flixel.effects.postprocess.PostProcess">
		<id public="1"><x path="Int"/></id>
		<value public="1"><x path="Float"/></value>
		<new public="1" set="method" line="21"><f a="id:value">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="openfl.display.DirectRenderer" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/display/DirectRenderer.hx">
		<extends path="openfl.display.DisplayObject"/>
		<render public="1" get="accessor" set="accessor"><d/></render>
		<__render>
			<d/>
			<meta><m n=":noCompletion"/></meta>
		</__render>
		<get_render set="method" line="30">
			<f a=""><d/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_render>
		<set_render set="method" line="37">
			<f a="value">
				<d/>
				<d/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_render>
		<new public="1" set="method" line="16">
			<f a="?type" v="&quot;DirectRenderer&quot;">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ type : "DirectRenderer" }</e></m></meta>
		</new>
	</class>
	<class path="openfl.display.OpenGLView" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/display/OpenGLView.hx">
		<extends path="openfl.display.DirectRenderer"/>
		<CONTEXT_LOST public="1" get="inline" set="null" expr="&quot;glcontextlost&quot;" line="24" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"glcontextlost"</e></m></meta>
		</CONTEXT_LOST>
		<CONTEXT_RESTORED public="1" get="inline" set="null" expr="&quot;glcontextrestored&quot;" line="25" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"glcontextrestored"</e></m></meta>
		</CONTEXT_RESTORED>
		<isSupported public="1" get="accessor" set="null" static="1"><x path="Bool"/></isSupported>
		<get_isSupported set="method" line="211" static="1"><f a=""><x path="Bool"/></f></get_isSupported>
		<__added><x path="Bool"/></__added>
		<__initialized><x path="Bool"/></__initialized>
		<__renderCanvas public="1" set="method" line="87" override="1"><f a="renderSession">
	<c path="openfl._internal.renderer.RenderSession"/>
	<x path="Void"/>
</f></__renderCanvas>
		<__renderDOM public="1" set="method" line="103" override="1"><f a="renderSession">
	<c path="openfl._internal.renderer.RenderSession"/>
	<x path="Void"/>
</f></__renderDOM>
		<__renderGL public="1" set="method" line="179" override="1"><f a="renderSession">
	<c path="openfl._internal.renderer.RenderSession"/>
	<x path="Void"/>
</f></__renderGL>
		<new public="1" set="method" line="33"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":access"><e>lime.graphics.opengl.GL</e></m>
		</meta>
	</class>
	<class path="flixel.effects.postprocess.PostProcess" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/effects/postprocess/PostProcess.hx">
		<extends path="openfl.display.OpenGLView"/>
		<VERTEX_SHADER get="inline" set="null" expr="&quot;\r\n#ifdef GL_ES\r\n\tprecision mediump float;\r\n#endif\r\n\r\nattribute vec2 aVertex;\r\nattribute vec2 aTexCoord;\r\nvarying vec2 vTexCoord;\r\n\r\nvoid main() {\r\n\tvTexCoord = aTexCoord;\r\n\tgl_Position = vec4(aVertex, 0.0, 1.0);\r\n}&quot;" line="258" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"\r\n#ifdef GL_ES\r\n\tprecision mediump float;\r\n#endif\r\n\r\nattribute vec2 aVertex;\r\nattribute vec2 aTexCoord;\r\nvarying vec2 vTexCoord;\r\n\r\nvoid main() {\r\n\tvTexCoord = aTexCoord;\r\n\tgl_Position = vec4(aVertex, 0.0, 1.0);\r\n}"</e></m></meta>
		</VERTEX_SHADER>
		<vertices get="accessor" set="null" static="1"><c path="Array"><x path="Float"/></c></vertices>
		<get_vertices get="inline" set="null" line="273" static="1"><f a=""><c path="Array"><x path="Float"/></c></f></get_vertices>
		<screenWidth><x path="Int"/></screenWidth>
		<screenHeight><x path="Int"/></screenHeight>
		<setUniform public="1" set="method" line="92">
			<f a="uniform:value">
				<c path="String"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Set a uniform value in the shader
	 *
	 * @param   uniform   The uniform name within the shader source
	 * @param   value     Value to set the uniform to</haxe_doc>
		</setUniform>
		<to public="1" get="null" set="accessor">
			<c path="flixel.effects.postprocess.PostProcess"/>
			<haxe_doc>* Allows multi pass rendering by passing the framebuffer to another post processing class.
	 * Renders to a `PostProcess` framebuffer instead of the screen, if set.
	 * Set to `null` to render to the screen.</haxe_doc>
		</to>
		<set_to set="method" line="120"><f a="value">
	<c path="flixel.effects.postprocess.PostProcess"/>
	<c path="flixel.effects.postprocess.PostProcess"/>
</f></set_to>
		<rebuild public="1" set="method" line="129">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Rebuilds the renderbuffer to match screen dimensions.</haxe_doc>
		</rebuild>
		<createRenderbuffer get="inline" set="null" line="144"><f a="width:height">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></createRenderbuffer>
		<createTexture get="inline" set="null" line="156"><f a="width:height">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></createTexture>
		<capture public="1" set="method" line="175">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Capture what is subsequently rendered to this framebuffer.</haxe_doc>
		</capture>
		<update public="1" set="method" line="181"><f a="elapsed">
	<x path="Float"/>
	<x path="Void"/>
</f></update>
		<framebuffer><t path="openfl.gl.GLFramebuffer"/></framebuffer>
		<renderbuffer><t path="openfl.gl.GLRenderbuffer"/></renderbuffer>
		<texture><t path="openfl.gl.GLTexture"/></texture>
		<postProcessShader><c path="flixel.effects.postprocess.Shader"/></postProcessShader>
		<buffer><t path="openfl.gl.GLBuffer"/></buffer>
		<renderTo><t path="openfl.gl.GLFramebuffer"/></renderTo>
		<defaultFramebuffer expr="null">
			<t path="openfl.gl.GLFramebuffer"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</defaultFramebuffer>
		<time expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</time>
		<vertexSlot><x path="Int"/></vertexSlot>
		<texCoordSlot><x path="Int"/></texCoordSlot>
		<imageUniform><x path="Int"/></imageUniform>
		<resolutionUniform><x path="Int"/></resolutionUniform>
		<timeUniform><x path="Int"/></timeUniform>
		<uniforms><x path="Map">
	<c path="String"/>
	<c path="flixel.effects.postprocess._PostProcess.Uniform"/>
</x></uniforms>
		<new public="1" set="method" line="42">
			<f a="fragmentShader">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Create a new PostProcess object
	 *
	 * @param  fragmentShader  A GLSL file in your assets path</haxe_doc>
		</new>
		<haxe_doc>* Fullscreen post processing class.
 * Uses GLSL shaders to produce post processing effects.</haxe_doc>
	</class>
	<class path="flixel.effects.postprocess.Shader" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/effects/postprocess/Shader.hx">
		<program><t path="openfl.gl.GLProgram"/></program>
		<compile set="method" line="49">
			<f a="source:type">
				<c path="String"/>
				<x path="Int"/>
				<t path="openfl.gl.GLShader"/>
			</f>
			<haxe_doc>* Compiles the shader source into a GlShader object and prints any errors
	 *
	 * @param   source   The shader source code
	 * @param   type     The type of shader to compile (fragment, vertex)</haxe_doc>
		</compile>
		<attribute public="1" get="inline" set="null" line="69">
			<f a="a">
				<c path="String"/>
				<x path="Int"/>
			</f>
			<haxe_doc>* Return the attribute location in this shader
	 *
	 * @param   a   The attribute name to find</haxe_doc>
		</attribute>
		<uniform public="1" get="inline" set="null" line="79">
			<f a="u">
				<c path="String"/>
				<x path="Int"/>
			</f>
			<haxe_doc>* Return the uniform location in this shader
	 *
	 * @param   a   The uniform name to find</haxe_doc>
		</uniform>
		<bind public="1" get="inline" set="null" line="87">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Bind the program for rendering</haxe_doc>
		</bind>
		<new public="1" set="method" line="20">
			<f a="sources">
				<c path="Array"><t path="flixel.effects.postprocess.ShaderSource"/></c>
				<x path="Void"/>
			</f>
			<haxe_doc>* Creates a new Shader
	 * 
	 * @param  sources   A list of GLSL shader sources to compile and link into a program</haxe_doc>
		</new>
		<haxe_doc>* GLSL Shader object</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<typedef path="flixel.effects.postprocess.ShaderSource" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/effects/postprocess/Shader.hx" module="flixel.effects.postprocess.Shader"><a>
	<src><c path="String"/></src>
	<fragment><x path="Bool"/></fragment>
</a></typedef>
	<class path="flixel.graphics.FlxGraphic" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/graphics/FlxGraphic.hx">
		<implements path="flixel.util.IFlxDestroyable"/>
		<defaultPersist public="1" expr="false" line="26" static="1">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
			<haxe_doc>* The default value for the `persist` variable
	 * at creation if none is specified in the constructor.</haxe_doc>
		</defaultPersist>
		<fromAssetKey public="1" set="method" line="38" static="1">
			<f a="Source:?Unique:?Key:?Cache" v=":false::true">
				<c path="String"/>
				<x path="Bool"/>
				<c path="String"/>
				<x path="Bool"/>
				<c path="flixel.graphics.FlxGraphic"/>
			</f>
			<meta><m n=":value"><e>{ Cache : true, Unique : false }</e></m></meta>
			<haxe_doc>* Creates and caches FlxGraphic object from openfl.Assets key string.
	 * 
	 * @param   Source   `openfl.Assets` key string. For example: `"assets/image.png"`.
	 * @param   Unique   Ensures that the `BitmapData` uses a new slot in the cache.
	 *                   If `true`, then `BitmapData` for this `FlxGraphic` will be cloned, which means extra memory.
	 * @param   Key      Force the cache to use a specific key to index the bitmap.
	 * @param   Cache    Whether to use graphic caching or not. Default value is `true`, which means automatic caching.
	 * @return  Cached `FlxGraphic` object we just created.</haxe_doc>
		</fromAssetKey>
		<fromClass public="1" set="method" line="74" static="1">
			<f a="Source:?Unique:?Key:?Cache" v=":false::true">
				<x path="Class"><t path="flash.display.BitmapData"/></x>
				<x path="Bool"/>
				<c path="String"/>
				<x path="Bool"/>
				<c path="flixel.graphics.FlxGraphic"/>
			</f>
			<meta><m n=":value"><e>{ Cache : true, Unique : false }</e></m></meta>
			<haxe_doc><![CDATA[* Creates and caches `FlxGraphic` object from a specified `Class<BitmapData>`.
	 * 
	 * @param   Source   `Class<BitmapData>` to create `BitmapData` for `FlxGraphic` from.
	 * @param   Unique   Ensures that the `BitmapData` uses a new slot in the cache.
	 *                   If `true`, then `BitmapData` for this `FlxGraphic` will be cloned, which means extra memory.
	 * @param   Key      Force the cache to use a specific key to index the bitmap.
	 * @param   Cache    Whether to use graphic caching or not. Default value is `true`, which means automatic caching.
	 * @return  `FlxGraphic` object we just created.]]></haxe_doc>
		</fromClass>
		<fromBitmapData public="1" set="method" line="106" static="1">
			<f a="Source:?Unique:?Key:?Cache" v=":false::true">
				<t path="flash.display.BitmapData"/>
				<x path="Bool"/>
				<c path="String"/>
				<x path="Bool"/>
				<c path="flixel.graphics.FlxGraphic"/>
			</f>
			<meta><m n=":value"><e>{ Cache : true, Unique : false }</e></m></meta>
			<haxe_doc>* Creates and caches `FlxGraphic` object from specified `BitmapData` object.
	 * 
	 * @param   Source   `BitmapData` for `FlxGraphic` to use.
	 * @param   Unique   Ensures that the `BitmapData` uses a new slot in the cache.
	 *                   If `true`, then `BitmapData` for this `FlxGraphic` will be cloned, which means extra memory.
	 * @param   Key      Force the cache to use a specific key to index the bitmap.
	 * @param   Cache    Whether to use graphic caching or not. Default value is `true`, which means automatic caching.
	 * @return  `FlxGraphic` object we just created.</haxe_doc>
		</fromBitmapData>
		<fromFrame public="1" set="method" line="146" static="1">
			<f a="Source:?Unique:?Key:?Cache" v=":false::true">
				<c path="flixel.graphics.frames.FlxFrame"/>
				<x path="Bool"/>
				<c path="String"/>
				<x path="Bool"/>
				<c path="flixel.graphics.FlxGraphic"/>
			</f>
			<meta><m n=":value"><e>{ Cache : true, Unique : false }</e></m></meta>
			<haxe_doc>* Creates and (optionally) caches a `FlxGraphic` object from the specified `FlxFrame`.
	 * It uses frame's `BitmapData`, not the `frame.parent.bitmap`.
	 * 
	 * @param   Source   `FlxFrame` to get the `BitmapData` from.
	 * @param   Unique   Ensures that the bitmap data uses a new slot in the cache.
	 *                   If `true`, then `BitmapData` for this `FlxGraphic` will be cloned, which means extra memory.
	 * @param   Key      Force the cache to use a specific key to index the bitmap.
	 * @param   Cache    Whether to use graphic caching or not. Default value is `true`, which means automatic caching.
	 * @return  `FlxGraphic` object we just created.</haxe_doc>
		</fromFrame>
		<fromFrames public="1" get="inline" set="null" line="175" static="1">
			<f a="Source:?Unique:?Key" v=":false:">
				<c path="flixel.graphics.frames.FlxFramesCollection"/>
				<x path="Bool"/>
				<c path="String"/>
				<c path="flixel.graphics.FlxGraphic"/>
			</f>
			<meta><m n=":value"><e>{ Unique : false }</e></m></meta>
			<haxe_doc>* Creates and caches a FlxGraphic object from the specified `FlxFramesCollection`.
	 * It uses `frames.parent.bitmap` as a source for the `FlxGraphic`'s `BitmapData`.
	 * It also copies all the frames collections onto the newly created `FlxGraphic`.
	 * 
	 * @param   Source   `FlxFramesCollection` to get the `BitmapData` from.
	 * @param   Unique   Ensures that the `BitmapData` uses a new slot in the cache.
	 *                   If `true`, then `BitmapData` for this `FlxGraphic` will be cloned, which means extra memory.
	 * @param   Key      Force the cache to use a specific key to index the bitmap.
	 * @return  Cached `FlxGraphic` object we just created.</haxe_doc>
		</fromFrames>
		<fromGraphic public="1" set="method" line="190" static="1">
			<f a="Source:?Unique:?Key" v=":false:">
				<c path="flixel.graphics.FlxGraphic"/>
				<x path="Bool"/>
				<c path="String"/>
				<c path="flixel.graphics.FlxGraphic"/>
			</f>
			<meta><m n=":value"><e>{ Unique : false }</e></m></meta>
			<haxe_doc>* Creates and caches a `FlxGraphic` object from the specified `FlxGraphic` object.
	 * It copies all the frame collections onto the newly created `FlxGraphic`.
	 * 
	 * @param   Source   `FlxGraphic` to get the `BitmapData` from.
	 * @param   Unique   Ensures that the `BitmapData` uses a new slot in the cache.
	 *                   If `true`, then `BitmapData` for this `FlxGraphic` will be cloned, which means extra memory.
	 * @param   Key      Force the cache to use a specific key to index the bitmap.
	 * @return  Cached `FlxGraphic` object we just created.</haxe_doc>
		</fromGraphic>
		<fromRectangle public="1" set="method" line="213" static="1">
			<f a="Width:Height:Color:?Unique:?Key" v=":::false:">
				<x path="Int"/>
				<x path="Int"/>
				<x path="flixel.util.FlxColor"/>
				<x path="Bool"/>
				<c path="String"/>
				<c path="flixel.graphics.FlxGraphic"/>
			</f>
			<meta><m n=":value"><e>{ Unique : false }</e></m></meta>
			<haxe_doc>* Generates and caches new `FlxGraphic` object with a colored rectangle.
	 * 
	 * @param   Width    How wide the rectangle should be.
	 * @param   Height   How high the rectangle should be.
	 * @param   Color    What color the rectangle should have (`0xAARRGGBB`).
	 * @param   Unique   Ensures that the `BitmapData` uses a new slot in the cache.
	 * @param   Key      Force the cache to use a specific key to index the bitmap.
	 * @return  The `FlxGraphic` object we just created.</haxe_doc>
		</fromRectangle>
		<getBitmap get="inline" set="null" line="233" static="1">
			<f a="Bitmap:?Unique" v=":false">
				<t path="flash.display.BitmapData"/>
				<x path="Bool"/>
				<t path="flash.display.BitmapData"/>
			</f>
			<meta><m n=":value"><e>{ Unique : false }</e></m></meta>
			<haxe_doc>* Helper method for cloning specified `BitmapData` if necessary.
	 * 
	 * @param   Bitmap   `BitmapData` to process
	 * @param   Unique   Whether we need to clone specified `BitmapData` object or not
	 * @return  Processed `BitmapData`</haxe_doc>
		</getBitmap>
		<createGraphic set="method" line="248" static="1">
			<f a="Bitmap:Key:?Unique:?Cache" v="::false:true">
				<t path="flash.display.BitmapData"/>
				<c path="String"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<c path="flixel.graphics.FlxGraphic"/>
			</f>
			<meta><m n=":value"><e>{ Cache : true, Unique : false }</e></m></meta>
			<haxe_doc>* Creates and caches the specified `BitmapData` object.
	 * 
	 * @param   Bitmap   `BitmapData` to use as a graphic source for the new `FlxGraphic`.
	 * @param   Key      Key to use as a cache key for the created `FlxGraphic`.
	 * @param   Unique   Whether the new `FlxGraphic` object uses a unique `BitmapData` or not.
	 *                   If `true`, the specified `BitmapData` will be cloned.
	 * @param   Cache    Whether to use graphic caching or not. Default value is `true`, which means automatic caching.
	 * @return  Created `FlxGraphic` object.</haxe_doc>
		</createGraphic>
		<key public="1" set="null">
			<c path="String"/>
			<haxe_doc>* Key used in the `BitmapFrontEnd` cache.</haxe_doc>
		</key>
		<bitmap public="1" set="accessor">
			<t path="flash.display.BitmapData"/>
			<haxe_doc>* The Cached `BitmapData` object.</haxe_doc>
		</bitmap>
		<width public="1" set="null" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* Width of the cached `BitmapData`.</haxe_doc>
		</width>
		<height public="1" set="null" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* Height of the cached `BitmapData`.</haxe_doc>
		</height>
		<assetsKey public="1" set="null">
			<c path="String"/>
			<haxe_doc>* Asset name from `openfl.Assets`.</haxe_doc>
		</assetsKey>
		<assetsClass public="1" set="null">
			<x path="Class"><t path="flash.display.BitmapData"/></x>
			<haxe_doc>* Class name for the `BitmapData`.</haxe_doc>
		</assetsClass>
		<persist public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
			<haxe_doc>* Whether this graphic object should stay in cache after state changes or not.</haxe_doc>
		</persist>
		<destroyOnNoUse public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<haxe_doc>* Whether this `FlxGraphic` should be destroyed object when `useCount` become zero.
	 * Default is `true`.</haxe_doc>
		</destroyOnNoUse>
		<isDumped public="1" set="null" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
			<haxe_doc>* Whether the `BitmapData` of this graphic object has been dumped or not.</haxe_doc>
		</isDumped>
		<canBeDumped public="1" get="accessor" set="null">
			<x path="Bool"/>
			<haxe_doc>* Whether the `BitmapData` of this graphic object can be dumped for decreased memory usage,
	 * but may cause some issues (when you need direct access to pixels of this graphic.
	 * If the graphic is dumped then you should call `undump()` and have total access to pixels.</haxe_doc>
		</canBeDumped>
		<tilesheet public="1" get="accessor" set="null">
			<c path="openfl.display.Tilesheet"/>
			<haxe_doc>* Tilesheet for this graphic object. It is used only for `FlxG.renderTile` mode.</haxe_doc>
		</tilesheet>
		<useCount public="1" get="accessor" set="accessor">
			<x path="Int"/>
			<haxe_doc>* Usage counter for this `FlxGraphic` object.</haxe_doc>
		</useCount>
		<imageFrame public="1" get="accessor" set="null">
			<c path="flixel.graphics.frames.FlxImageFrame"/>
			<haxe_doc>* `FlxImageFrame` object for the whole bitmap.</haxe_doc>
		</imageFrame>
		<atlasFrames public="1" get="accessor" set="null">
			<c path="flixel.graphics.frames.FlxAtlasFrames"/>
			<haxe_doc>* Atlas frames for this graphic.
	 * You should fill it yourself with one of `FlxAtlasFrames`'s static methods
	 * (like `fromTexturePackerJson()`, `fromTexturePackerXml()`, etc).</haxe_doc>
		</atlasFrames>
		<frameCollections>
			<x path="Map">
				<e path="flixel.graphics.frames.FlxFrameCollectionType"/>
				<c path="Array"><d/></c>
			</x>
			<haxe_doc>* Storage for all available frame collection of all types for this graphic object.</haxe_doc>
		</frameCollections>
		<frameCollectionTypes>
			<c path="Array"><e path="flixel.graphics.frames.FlxFrameCollectionType"/></c>
			<haxe_doc>* All types of frames collection which had been added to this graphic object.
	 * It helps to avoid map iteration, which produces a lot of garbage.</haxe_doc>
		</frameCollectionTypes>
		<unique public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
			<haxe_doc>* Shows whether this object unique in cache or not.
	 * 
	 * Whether undumped `BitmapData` should be cloned or not.
	 * It is `false` by default, since it significantly increases memory consumption.</haxe_doc>
		</unique>
		<_imageFrame>
			<c path="flixel.graphics.frames.FlxImageFrame"/>
			<haxe_doc>* Internal var holding `FlxImageFrame` for the whole bitmap of this graphic.
	 * Use public `imageFrame` var to access/generate it.</haxe_doc>
		</_imageFrame>
		<_tilesheet>
			<c path="openfl.display.Tilesheet"/>
			<haxe_doc>* Internal var holding Tilesheet for bitmap of this graphic.
	 * It is used only in `FlxG.renderTile` mode</haxe_doc>
		</_tilesheet>
		<_useCount expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</_useCount>
		<_destroyOnNoUse expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</_destroyOnNoUse>
		<dump public="1" set="method" line="395">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Dumps bits of `BitmapData` to decrease memory usage, but you can't read/write pixels on it anymore
	 * (but you can call `onContext()` (or `undump()`) method which will restore it again).</haxe_doc>
		</dump>
		<undump public="1" set="method" line="409">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Undumps bits of the `BitmapData` - regenerates it and regenerate tilesheet data for this object</haxe_doc>
		</undump>
		<onContext public="1" set="method" line="421">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Use this method to restore cached `BitmapData` (if it's possible).
	 * It's called automatically when the RESIZE event occurs.</haxe_doc>
		</onContext>
		<onAssetsReload public="1" set="method" line="435">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Asset reload callback for this graphic object.
	 * It regenerated its tilesheet and resets frame bitmaps.</haxe_doc>
		</onAssetsReload>
		<destroy public="1" set="method" line="449">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Trying to free the memory as much as possible</haxe_doc>
		</destroy>
		<addFrameCollection public="1" set="method" line="480">
			<f a="collection">
				<c path="flixel.graphics.frames.FlxFramesCollection"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Stores specified `FlxFrame` collection in internal map (this helps reduce object creation).
	 * 
	 * @param   collection   frame collection to store.</haxe_doc>
		</addFrameCollection>
		<getFramesCollections public="1" get="inline" set="null" line="495">
			<f a="type">
				<e path="flixel.graphics.frames.FlxFrameCollectionType"/>
				<c path="Array"><d/></c>
			</f>
			<haxe_doc>* Searches frame collections of specified type for this `FlxGraphic` object.
	 * 
	 * @param   type   The type of frames collections to search for.
	 * @return  Array of available frames collections of specified type for this object.</haxe_doc>
		</getFramesCollections>
		<getEmptyFrame public="1" get="inline" set="null" line="513">
			<f a="size">
				<c path="flixel.math.FlxPoint"/>
				<c path="flixel.graphics.frames.FlxFrame"/>
			</f>
			<haxe_doc>* Creates empty frame for this graphic with specified size.
	 * This method could be useful for tile frames, in case when you'll need empty tile.
	 * 
	 * @param   size   dimensions of the frame to add.
	 * @return  Empty frame with specified size which belongs to this `FlxGraphic` object.</haxe_doc>
		</getEmptyFrame>
		<get_tilesheet set="method" line="525">
			<f a=""><c path="openfl.display.Tilesheet"/></f>
			<haxe_doc>* Tilesheet getter. Generates new one (and regenerates) if there is no tilesheet for this graphic yet.</haxe_doc>
		</get_tilesheet>
		<getBitmapFromSystem set="method" line="547">
			<f a=""><t path="flash.display.BitmapData"/></f>
			<haxe_doc>* Gets the `BitmapData` for this graphic object from OpenFL.
	 * This method is used for undumping graphic.</haxe_doc>
		</getBitmapFromSystem>
		<get_canBeDumped get="inline" set="null" line="561"><f a=""><x path="Bool"/></f></get_canBeDumped>
		<get_useCount set="method" line="566"><f a=""><x path="Int"/></f></get_useCount>
		<set_useCount set="method" line="571"><f a="Value">
	<x path="Int"/>
	<x path="Int"/>
</f></set_useCount>
		<get_destroyOnNoUse set="method" line="579"><f a=""><x path="Bool"/></f></get_destroyOnNoUse>
		<set_destroyOnNoUse set="method" line="584"><f a="Value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_destroyOnNoUse>
		<get_imageFrame set="method" line="594"><f a=""><c path="flixel.graphics.frames.FlxImageFrame"/></f></get_imageFrame>
		<get_atlasFrames set="method" line="602"><f a=""><c path="flixel.graphics.frames.FlxAtlasFrames"/></f></get_atlasFrames>
		<set_bitmap set="method" line="607"><f a="value">
	<t path="flash.display.BitmapData"/>
	<t path="flash.display.BitmapData"/>
</f></set_bitmap>
		<new set="method" line="381">
			<f a="Key:Bitmap:?Persist">
				<c path="String"/>
				<t path="flash.display.BitmapData"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* `FlxGraphic` constructor
	 *
	 * @param   Key       Key string for this graphic object, with which you can get it from bitmap cache.
	 * @param   Bitmap    `BitmapData` for this graphic object.
	 * @param   Persist   Whether or not this graphic stay in the cache after resetting it.
	 *                    Default value is `false`, which means that this graphic will be destroyed at the cache reset.</haxe_doc>
		</new>
		<haxe_doc>* `BitmapData` wrapper which is used for rendering.
 * It stores info about all frames, generated for specific `BitmapData` object.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="flixel.graphics.atlas.FlxAtlas" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/graphics/atlas/FlxAtlas.hx">
		<implements path="flixel.util.IFlxDestroyable"/>
		<point expr="new Point()" line="27" static="1">
			<t path="flash.geom.Point"/>
			<meta><m n=":value"><e>new Point()</e></m></meta>
		</point>
		<matrix expr="new Matrix()" line="28" static="1">
			<c path="openfl.geom.Matrix"/>
			<meta><m n=":value"><e>new Matrix()</e></m></meta>
		</matrix>
		<defaultMinSize public="1" expr="new FlxPoint(128, 128)" line="33" static="1">
			<c path="flixel.math.FlxPoint"/>
			<meta><m n=":value"><e>new FlxPoint(128, 128)</e></m></meta>
			<haxe_doc>* Default minimum size for atlases.</haxe_doc>
		</defaultMinSize>
		<defaultMaxSize public="1" expr="new FlxPoint(1024, 1024)" line="38" static="1">
			<c path="flixel.math.FlxPoint"/>
			<meta><m n=":value"><e>new FlxPoint(1024, 1024)</e></m></meta>
			<haxe_doc>* Default maximum size for atlases.</haxe_doc>
		</defaultMaxSize>
		<root public="1" set="null">
			<c path="flixel.graphics.atlas.FlxNode"/>
			<haxe_doc>* Root node of the atlas.</haxe_doc>
		</root>
		<name public="1" set="null">
			<c path="String"/>
			<haxe_doc>* Name of this atlas, used as a key in the bitmap cache.</haxe_doc>
		</name>
		<nodes public="1" set="null"><x path="Map">
	<c path="String"/>
	<c path="flixel.graphics.atlas.FlxNode"/>
</x></nodes>
		<bitmapData public="1" set="accessor">
			<t path="flash.display.BitmapData"/>
			<haxe_doc>* `BitmapData` of this atlas, combines all images into a big one.</haxe_doc>
		</bitmapData>
		<graphic public="1" get="accessor" set="null">
			<c path="flixel.graphics.FlxGraphic"/>
			<haxe_doc>* Graphic for this atlas.</haxe_doc>
		</graphic>
		<persist public="1" set="accessor" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
			<haxe_doc>* Whether this atlas should stay in memory after state switch.
	 * Default value if `false`.</haxe_doc>
		</persist>
		<border public="1" set="null" expr="1">
			<x path="Int"/>
			<meta><m n=":value"><e>1</e></m></meta>
			<haxe_doc>* Offsets between nodes.</haxe_doc>
		</border>
		<width public="1" get="accessor" set="accessor">
			<x path="Int"/>
			<meta><m n=":isVar"/></meta>
			<haxe_doc>* Total width of the atlas.</haxe_doc>
		</width>
		<height public="1" get="accessor" set="accessor">
			<x path="Int"/>
			<meta><m n=":isVar"/></meta>
			<haxe_doc>* Total height of the atlas.</haxe_doc>
		</height>
		<minWidth public="1" set="accessor" expr="128">
			<x path="Int"/>
			<meta><m n=":value"><e>128</e></m></meta>
			<haxe_doc>* Minimum width for this atlas.</haxe_doc>
		</minWidth>
		<minHeight public="1" set="accessor" expr="128">
			<x path="Int"/>
			<meta><m n=":value"><e>128</e></m></meta>
			<haxe_doc>* Minimum height for this atlas</haxe_doc>
		</minHeight>
		<maxWidth public="1" set="accessor" expr="1024">
			<x path="Int"/>
			<meta><m n=":value"><e>1024</e></m></meta>
			<haxe_doc>* Maximum width for this atlas.</haxe_doc>
		</maxWidth>
		<maxHeight public="1" set="accessor" expr="1024">
			<x path="Int"/>
			<meta><m n=":value"><e>1024</e></m></meta>
			<haxe_doc>* Maximum height for this atlas.</haxe_doc>
		</maxHeight>
		<allowRotation public="1" set="null" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
			<haxe_doc>* Whether to allow image rotation for packing in atlas.</haxe_doc>
		</allowRotation>
		<powerOfTwo public="1" set="accessor" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
			<haxe_doc>* Whether the size of this atlas should be the power of 2 or not.</haxe_doc>
		</powerOfTwo>
		<_graphic><c path="flixel.graphics.FlxGraphic"/></_graphic>
		<_tempStorage>
			<c path="Array"><t path="flixel.graphics.atlas.TempAtlasObj"/></c>
			<haxe_doc>* Internal storage for building atlas from queue</haxe_doc>
		</_tempStorage>
		<initRoot set="method" line="152"><f a=""><x path="Void"/></f></initRoot>
		<addNode public="1" set="method" line="175">
			<f a="Graphic:?Key">
				<t path="flixel.system.FlxGraphicSource"/>
				<c path="String"/>
				<c path="flixel.graphics.atlas.FlxNode"/>
			</f>
			<haxe_doc><![CDATA[* Adds a new node to the atlas.
	 *
	 * @param   Graphic   Image to store. Could be a `BitmapData`, `String`
	 *                    (key from OpenFL's asset cache) or a `Class<Dynamic>`.
	 * @param   Key       Image name, optional.
	 *                    You can omit it if you pass `String` or `Class<Dynamic>` as a `Graphic` source.
	 * @return  Newly created and added node, or `null` if there is no space for it.]]></haxe_doc>
		</addNode>
		<wrapRoot set="method" line="217"><f a=""><x path="Void"/></f></wrapRoot>
		<tryInsert set="method" line="224"><f a="data:key">
	<t path="flash.display.BitmapData"/>
	<c path="String"/>
	<c path="flixel.graphics.atlas.FlxNode"/>
</f></tryInsert>
		<needToDivideHorizontally set="method" line="260"><f a="nodeToDivide:insertWidth:insertHeight">
	<c path="flixel.graphics.atlas.FlxNode"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Bool"/>
</f></needToDivideHorizontally>
		<divideNode set="method" line="268">
			<f a="nodeToDivide:insertWidth:insertHeight:divideHorizontally:?firstGrandChildData:?firstGrandChildKey:?firstGrandChildRotated" v="::::::false">
				<c path="flixel.graphics.atlas.FlxNode"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
				<t path="flash.display.BitmapData"/>
				<c path="String"/>
				<x path="Bool"/>
				<c path="flixel.graphics.atlas.FlxNode"/>
			</f>
			<meta><m n=":value"><e>{ firstGrandChildRotated : false }</e></m></meta>
		</divideNode>
		<insertFirstNodeInRoot set="method" line="355"><f a="data:key">
	<t path="flash.display.BitmapData"/>
	<c path="String"/>
	<c path="flixel.graphics.atlas.FlxNode"/>
</f></insertFirstNodeInRoot>
		<expand set="method" line="400"><f a="data:key">
	<t path="flash.display.BitmapData"/>
	<c path="String"/>
	<c path="flixel.graphics.atlas.FlxNode"/>
</f></expand>
		<expandRoot set="method" line="554">
			<f a="newWidth:newHeight:divideHorizontally:?decideHowToDivide" v=":::false">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ decideHowToDivide : false }</e></m></meta>
		</expandRoot>
		<expandBitmapData set="method" line="569"><f a=""><x path="Void"/></f></expandBitmapData>
		<getNextPowerOfTwo set="method" line="587"><f a="number">
	<x path="Float"/>
	<x path="Int"/>
</f></getNextPowerOfTwo>
		<addNodeWithSpacesAndBorders public="1" set="method" line="611">
			<f a="Graphic:?Key:tileSize:tileSpacing:?tileBorder:?region">
				<t path="flixel.system.FlxGraphicSource"/>
				<c path="String"/>
				<c path="flixel.math.FlxPoint"/>
				<c path="flixel.math.FlxPoint"/>
				<c path="flixel.math.FlxPoint"/>
				<c path="flixel.math.FlxRect"/>
				<c path="flixel.graphics.frames.FlxTileFrames"/>
			</f>
			<haxe_doc><![CDATA[* Generates a new `BitmapData` with spaces between tiles, adds this `BitmapData` to this atlas,
	 * generates a `FlxTileFrames` object for the added node and returns it. Can be useful for tilemaps.
	 * 
	 * @param   Graphic        Source image for node, where spaces will be inserted
	 *                        (could be a `BitmapData`, `String` or `Class<Dynamic>`).
	 * @param   Key           Optional key for image
	 * @param   tileSize      The size of tile in spritesheet
	 * @param   tileSpacing   Offsets to add in spritesheet between tiles
	 * @param   tileBorder    Border to add around tiles (helps to avoid "tearing" problem)
	 * @param   region        Region of source image to use as a source graphic
	 * @return  Generated `FlxTileFrames` for the added node]]></haxe_doc>
		</addNodeWithSpacesAndBorders>
		<getAtlasFrames public="1" set="method" line="665">
			<f a=""><c path="flixel.graphics.frames.FlxAtlasFrames"/></f>
			<haxe_doc>* Gets the `FlxAtlasFrames` object for this atlas.
	 * It caches graphic of this atlas and generates `FlxAtlasFrames` if it doesn't exist yet.
	 *
	 * @return `FlxAtlasFrames` for this atlas</haxe_doc>
		</getAtlasFrames>
		<addNodeToAtlasFrames set="method" line="681"><f a="node">
	<c path="flixel.graphics.atlas.FlxNode"/>
	<x path="Void"/>
</f></addNodeToAtlasFrames>
		<hasNodeWithName public="1" set="method" line="706">
			<f a="nodeName">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Checks if the atlas already contains node with the same name.
	 *
	 * @param   nodeName   Node name to check.
	 * @return  `true` if atlas already contains node with the name.</haxe_doc>
		</hasNodeWithName>
		<getNode public="1" set="method" line="717">
			<f a="key">
				<c path="String"/>
				<c path="flixel.graphics.atlas.FlxNode"/>
			</f>
			<haxe_doc>* Gets a node by it's name.
	 *
	 * @param   key   Node name to search for.
	 * @return  node with searched name. `null` if atlas doesn't contain any node with that name.</haxe_doc>
		</getNode>
		<addNodes public="1" set="method" line="730">
			<f a="bitmaps:keys">
				<c path="Array"><t path="flash.display.BitmapData"/></c>
				<c path="Array"><c path="String"/></c>
				<c path="flixel.graphics.atlas.FlxAtlas"/>
			</f>
			<haxe_doc>* Optimized version of method for adding multiple nodes to atlas.
	 * Uses less of the atlas' area (it sorts images by the size before adding them to atlas).
	 *
	 * @param   bitmaps   `BitmapData`'s to insert
	 * @param   keys      Names of these `BitmapData` objects.
	 * @return  `this` `FlxAtlas`</haxe_doc>
		</addNodes>
		<addFromAtlasObjects set="method" line="753"><f a="objects">
	<c path="Array"><t path="flixel.graphics.atlas.TempAtlasObj"/></c>
	<x path="Void"/>
</f></addFromAtlasObjects>
		<bitmapSorter set="method" line="767">
			<f a="obj1:obj2">
				<t path="flixel.graphics.atlas.TempAtlasObj"/>
				<t path="flixel.graphics.atlas.TempAtlasObj"/>
				<x path="Int"/>
			</f>
			<haxe_doc>* Internal method for sorting bitmaps</haxe_doc>
		</bitmapSorter>
		<createQueue public="1" set="method" line="789">
			<f a=""><c path="flixel.graphics.atlas.FlxAtlas"/></f>
			<haxe_doc>* Creates a new "queue" for adding new nodes.
	 * This method should be used with the `addToQueue()` and `generateFromQueue()` methods:
	 * - first, you create queue, like `atlas.createQueue()`;
	 * - second, you add several bitmaps to the queue: `atlas.addToQueue(bmd1, "key1").addToQueue(bmd2, "key2");`
	 * - third, you actually bake those bitmaps onto the atlas: `atlas.generateFromQueue();`</haxe_doc>
		</createQueue>
		<addToQueue public="1" set="method" line="801">
			<f a="data:key">
				<t path="flash.display.BitmapData"/>
				<c path="String"/>
				<c path="flixel.graphics.atlas.FlxAtlas"/>
			</f>
			<haxe_doc>* Adds new object to queue for later creation of new node
	 *
	 * @param   data   `BitmapData` to bake on atlas
	 * @param   key    "name" of the `BitmapData`. You'll use it as a key for accessing the created node.</haxe_doc>
		</addToQueue>
		<generateFromQueue public="1" set="method" line="813">
			<f a=""><c path="flixel.graphics.atlas.FlxAtlas"/></f>
			<haxe_doc>* Adds all objects in "queue" to existing atlas. Doesn't remove any nodes.</haxe_doc>
		</generateFromQueue>
		<onClear set="method" line="821"><f a="_">
	<c path="flixel.FlxState"/>
	<x path="Void"/>
</f></onClear>
		<destroy public="1" set="method" line="831">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Destroys the atlas. Use only if you want to clear memory and don't need this atlas anymore,
	 * since it disposes the `BitmapData` and removes it from the cache.</haxe_doc>
		</destroy>
		<clear public="1" set="method" line="849">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Clears all data in atlas. Use it when you want reuse this atlas.
	 * WARNING: it will destroy the graphic of this image, so you can get
	 * null pointer exceptions if you're still using it for your sprites.</haxe_doc>
		</clear>
		<getLibGdxData public="1" set="method" line="862">
			<f a=""><c path="String"/></f>
			<haxe_doc>* Returns atlas data in LibGdx packer format.</haxe_doc>
		</getLibGdxData>
		<deleteSubtree set="method" line="894"><f a="node">
	<c path="flixel.graphics.atlas.FlxNode"/>
	<x path="Void"/>
</f></deleteSubtree>
		<findNodeToInsert set="method" line="905"><f a="insertWidth:insertHeight">
	<x path="Int"/>
	<x path="Int"/>
	<c path="flixel.graphics.atlas.FlxNode"/>
</f></findNodeToInsert>
		<set_bitmapData set="method" line="971"><f a="value">
	<t path="flash.display.BitmapData"/>
	<t path="flash.display.BitmapData"/>
</f></set_bitmapData>
		<get_graphic set="method" line="980"><f a=""><c path="flixel.graphics.FlxGraphic"/></f></get_graphic>
		<set_persist set="method" line="991"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_persist>
		<set_minWidth set="method" line="999"><f a="value">
	<x path="Int"/>
	<x path="Int"/>
</f></set_minWidth>
		<set_minHeight set="method" line="1011"><f a="value">
	<x path="Int"/>
	<x path="Int"/>
</f></set_minHeight>
		<get_width set="method" line="1023"><f a=""><x path="Int"/></f></get_width>
		<set_width set="method" line="1031"><f a="value">
	<x path="Int"/>
	<x path="Int"/>
</f></set_width>
		<get_height set="method" line="1050"><f a=""><x path="Int"/></f></get_height>
		<set_height set="method" line="1057"><f a="value">
	<x path="Int"/>
	<x path="Int"/>
</f></set_height>
		<set_maxWidth set="method" line="1076"><f a="value">
	<x path="Int"/>
	<x path="Int"/>
</f></set_maxWidth>
		<set_maxHeight set="method" line="1084"><f a="value">
	<x path="Int"/>
	<x path="Int"/>
</f></set_maxHeight>
		<set_powerOfTwo set="method" line="1092"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_powerOfTwo>
		<new public="1" set="method" line="130">
			<f a="name:?powerOfTwo:?border:?rotate:?minSize:?maxSize" v=":false:1:false::">
				<c path="String"/>
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Bool"/>
				<c path="flixel.math.FlxPoint"/>
				<c path="flixel.math.FlxPoint"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ rotate : false, border : 1, powerOfTwo : false }</e></m></meta>
			<haxe_doc>* Atlas constructor
	 *
	 * @param   name         The name of this atlas. It will be used for caching `BitmapData` of this atlas.
	 * @param   powerOfTwo   Whether the size of this atlas should be the power of 2 or not.
	 * @param   border       Gap between nodes to insert.
	 * @param   rotate       Whether to rotate added images for less atlas size.
	 * @param   minSize      Min size of atlas.
	 * @param   maxSize      Max size of atlas.</haxe_doc>
		</new>
		<haxe_doc>* Class for packing multiple images in big one and generating frame data for each of them
 * so you can easily load regions of atlas in sprites and tilemaps as a source of graphic</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<typedef path="flixel.graphics.atlas.TempAtlasObj" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/graphics/atlas/FlxAtlas.hx" module="flixel.graphics.atlas.FlxAtlas"><a>
	<keyStr><c path="String"/></keyStr>
	<bmd><t path="flash.display.BitmapData"/></bmd>
</a></typedef>
	<class path="flixel.graphics.atlas.FlxNode" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/graphics/atlas/FlxNode.hx">
		<implements path="flixel.util.IFlxDestroyable"/>
		<left public="1">
			<c path="flixel.graphics.atlas.FlxNode"/>
			<haxe_doc>* Left child of this node.</haxe_doc>
		</left>
		<right public="1">
			<c path="flixel.graphics.atlas.FlxNode"/>
			<haxe_doc>* Right child of this node.</haxe_doc>
		</right>
		<rect public="1">
			<c path="flixel.math.FlxRect"/>
			<haxe_doc>* Region of the atlas which this node holds, includes spacings between nodes.</haxe_doc>
		</rect>
		<key public="1">
			<c path="String"/>
			<haxe_doc>* The "name" of this node. You can get access to this node with it:
	 * `atlas.getNode(key);`</haxe_doc>
		</key>
		<filled public="1" set="null">
			<x path="Bool"/>
			<haxe_doc>* Logical flag showing whether this node has an image in it or not.</haxe_doc>
		</filled>
		<atlas public="1">
			<c path="flixel.graphics.atlas.FlxAtlas"/>
			<haxe_doc>* Atlas object which contains this node.</haxe_doc>
		</atlas>
		<x public="1" get="accessor" set="null">
			<x path="Int"/>
			<haxe_doc>* The x coordinate of the top-left corner of this node.</haxe_doc>
		</x>
		<y public="1" get="accessor" set="null">
			<x path="Int"/>
			<haxe_doc>* The y coordinate of the top-left corner of this node.</haxe_doc>
		</y>
		<width public="1" get="accessor" set="accessor">
			<x path="Int"/>
			<haxe_doc>* The width of this node.</haxe_doc>
		</width>
		<height public="1" get="accessor" set="accessor">
			<x path="Int"/>
			<haxe_doc>* The height of this node.</haxe_doc>
		</height>
		<isEmpty public="1" get="accessor" set="null">
			<x path="Bool"/>
			<haxe_doc>* Logical flag, showing whether this node have any child nodes or image in it.</haxe_doc>
		</isEmpty>
		<rotated public="1" set="null"><x path="Bool"/></rotated>
		<destroy public="1" get="inline" set="null" line="86"><f a=""><x path="Void"/></f></destroy>
		<canPlace public="1" get="inline" set="null" line="98">
			<f a="width:height">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Whether we place node with specified width and height in this node.</haxe_doc>
		</canPlace>
		<getTileFrames public="1" set="method" line="111">
			<f a="tileSize:?tileSpacing:?tileBorder">
				<c path="flixel.math.FlxPoint"/>
				<c path="flixel.math.FlxPoint"/>
				<c path="flixel.math.FlxPoint"/>
				<c path="flixel.graphics.frames.FlxTileFrames"/>
			</f>
			<haxe_doc>* Generates TileFrames object for this node
	 *
	 * @param   tileSize      The size of tile in spritesheet.
	 * @param   tileSpacing   Offsets between tiles in spritesheet.
	 * @param   tileBorder    Border to add around tiles (helps to avoid "tearing" problem).
	 * @return  Created TileFrames object for this node.</haxe_doc>
		</getTileFrames>
		<getImageFrame public="1" set="method" line="132">
			<f a=""><c path="flixel.graphics.frames.FlxImageFrame"/></f>
			<haxe_doc>* Generates a `FlxImageFrame` object for this node.
	 *
	 * @return  `FlxImageFrame` for the whole node</haxe_doc>
		</getImageFrame>
		<get_isEmpty get="inline" set="null" line="143"><f a=""><x path="Bool"/></f></get_isEmpty>
		<get_x get="inline" set="null" line="148"><f a=""><x path="Int"/></f></get_x>
		<get_y get="inline" set="null" line="153"><f a=""><x path="Int"/></f></get_y>
		<get_width get="inline" set="null" line="158"><f a=""><x path="Int"/></f></get_width>
		<set_width set="method" line="163"><f a="value">
	<x path="Int"/>
	<x path="Int"/>
</f></set_width>
		<get_height get="inline" set="null" line="169"><f a=""><x path="Int"/></f></get_height>
		<set_height set="method" line="174"><f a="value">
	<x path="Int"/>
	<x path="Int"/>
</f></set_height>
		<new public="1" set="method" line="75">
			<f a="rect:atlas:?filled:?key:?rotated" v="::false:&quot;&quot;:false">
				<c path="flixel.math.FlxRect"/>
				<c path="flixel.graphics.atlas.FlxAtlas"/>
				<x path="Bool"/>
				<c path="String"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ rotated : false, key : "", filled : false }</e></m></meta>
			<haxe_doc>* Node constructor
	 *
	 * @param   rect     Region of atlas this node holds.
	 * @param   atlas    Atlas this node belongs to.
	 * @param   filled   Whether this node contains image or not.
	 * @param   key      The name of image in this node, and the name of this node.</haxe_doc>
		</new>
		<haxe_doc>* Atlas node holds information about image on Atlas.
 * Plus it have few methods for easy frame data generation,
 * which can be loaded in sprites and in tilemaps.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="flixel.graphics.frames.FlxFramesCollection" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/graphics/frames/FlxFramesCollection.hx">
		<implements path="flixel.util.IFlxDestroyable"/>
		<frames public="1">
			<c path="Array"><c path="flixel.graphics.frames.FlxFrame"/></c>
			<haxe_doc>* Array with all frames of this collection.</haxe_doc>
		</frames>
		<numFrames public="1" get="accessor" set="null">
			<x path="Int"/>
			<haxe_doc>* Number of frames in this collection.</haxe_doc>
		</numFrames>
		<framesHash public="1">
			<x path="Map">
				<c path="String"/>
				<c path="flixel.graphics.frames.FlxFrame"/>
			</x>
			<haxe_doc>* Hash of frames for this frame collection.
	 * Used only in `FlxAtlasFrames` and `FlxBitmapFont` (not implemented yet),
	 * but you can try to use it for other types of collections
	 * (give names to your frames).</haxe_doc>
		</framesHash>
		<parent public="1">
			<c path="flixel.graphics.FlxGraphic"/>
			<haxe_doc>* Graphic object this frames belongs to.</haxe_doc>
		</parent>
		<type public="1" set="null">
			<e path="flixel.graphics.frames.FlxFrameCollectionType"/>
			<haxe_doc>* Type of this frame collection.
	 * Used for faster type detection (less casting).</haxe_doc>
		</type>
		<border public="1" set="null">
			<c path="flixel.math.FlxPoint"/>
			<haxe_doc>* How much space was trimmed around the original frames.
	 * Use `addBorder()` to add borders.</haxe_doc>
		</border>
		<getByName public="1" get="inline" set="null" line="71">
			<f a="name">
				<c path="String"/>
				<c path="flixel.graphics.frames.FlxFrame"/>
			</f>
			<haxe_doc>* Finds a frame in `framesHash` by its name.
	 * 
	 * @param   name   The name of the frame to find.
	 * @return  Frame with specified name (if there is one).</haxe_doc>
		</getByName>
		<getByIndex public="1" get="inline" set="null" line="82">
			<f a="index">
				<x path="Int"/>
				<c path="flixel.graphics.frames.FlxFrame"/>
			</f>
			<haxe_doc>* Finds frame in frames array by its index.
	 * 
	 * @param   index   Index of the frame in the frames array.
	 * @return  Frame with specified index in this frames collection (if there is one).</haxe_doc>
		</getByIndex>
		<getIndexByName public="1" set="method" line="93">
			<f a="name">
				<c path="String"/>
				<x path="Int"/>
			</f>
			<haxe_doc>* Finds frame index by its name.
	 * 
	 * @param   name  Name of the frame.
	 * @return  Index of the frame with specified name.</haxe_doc>
		</getIndexByName>
		<getFrameIndex public="1" get="inline" set="null" line="110">
			<f a="frame">
				<c path="flixel.graphics.frames.FlxFrame"/>
				<x path="Int"/>
			</f>
			<haxe_doc>* Finds the index of the specified frame in the frames array.
	 * 
	 * @param   frame   Frame to find.
	 * @return  Index of the specified frame.</haxe_doc>
		</getFrameIndex>
		<destroy public="1" set="method" line="115"><f a=""><x path="Void"/></f></destroy>
		<addEmptyFrame public="1" set="method" line="131">
			<f a="size">
				<c path="flixel.math.FlxRect"/>
				<c path="flixel.graphics.frames.FlxFrame"/>
			</f>
			<haxe_doc>* Adds empty frame into this frame collection.
	 * An empty frame is doing almost nothing for all the time.
	 * 
	 * @param   size   Dimensions of the frame to add.
	 * @return  Newly added empty frame.</haxe_doc>
		</addEmptyFrame>
		<addSpriteSheetFrame public="1" set="method" line="147">
			<f a="region">
				<c path="flixel.math.FlxRect"/>
				<c path="flixel.graphics.frames.FlxFrame"/>
			</f>
			<haxe_doc>* Adds new regular (not rotated) `FlxFrame` to this frame collection.
	 * 
	 * @param   region   Region of image which new frame will display.
	 * @return  Newly created `FlxFrame` object for specified region of image.</haxe_doc>
		</addSpriteSheetFrame>
		<addAtlasFrame public="1" set="method" line="171">
			<f a="frame:sourceSize:offset:?name:?angle:?flipX:?flipY" v="::::0:false:false">
				<c path="flixel.math.FlxRect"/>
				<c path="flixel.math.FlxPoint"/>
				<c path="flixel.math.FlxPoint"/>
				<c path="String"/>
				<x path="flixel.graphics.frames.FlxFrameAngle"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<c path="flixel.graphics.frames.FlxFrame"/>
			</f>
			<meta><m n=":value"><e>{ flipY : false, flipX : false, angle : 0 }</e></m></meta>
			<haxe_doc>* Adds new frame to this frame collection.
	 * This method runs additional check, and can add rotated frames (from texture atlases).
	 *
	 * @param   frame        Region of image.
	 * @param   sourceSize   Original size of packed image
	 *                       (if image had been cropped, then original size will be bigger than frame size).
	 * @param   offset       How frame region is located on original frame image
	 *                       (offset from top left corner of original image).
	 * @param   name         Name for this frame (name of packed image file).
	 * @param   angle        Rotation of packed image (can be `0`, `90` or `-90`).
	 * @param   flipX        If packed image should be horizontally flipped.
	 * @param   flipY        If packed image should be vertically flipped.
	 * @return  Newly created and added frame object.</haxe_doc>
		</addAtlasFrame>
		<checkFrame set="method" line="196">
			<f a="frame:?name">
				<c path="flixel.math.FlxRect"/>
				<c path="String"/>
				<c path="flixel.math.FlxRect"/>
			</f>
			<haxe_doc>* Checks if frame's area fits into atlas image, and trims if it's out of atlas image bounds.
	 *
	 * @param   frame   Frame area to check.
	 * @param   name    Optional frame name for debugging info.
	 * @return  Checked and trimmed frame rectangle.</haxe_doc>
		</checkFrame>
		<pushFrame public="1" set="method" line="218">
			<f a="frameObj">
				<c path="flixel.graphics.frames.FlxFrame"/>
				<c path="flixel.graphics.frames.FlxFrame"/>
			</f>
			<haxe_doc>* Helper method for a adding frame to the collection.
	 * 
	 * @param   frameObj   Frame to add.
	 * @return  Added frame.</haxe_doc>
		</pushFrame>
		<addBorder public="1" set="method" line="239">
			<f a="border">
				<c path="flixel.math.FlxPoint"/>
				<c path="flixel.graphics.frames.FlxFramesCollection"/>
			</f>
			<haxe_doc>* Generates new frames collection from this collection but trims frames by specified borders.
	 * 
	 * @param   border   How much space trim around the frames.
	 * @return  Generated frames collection.</haxe_doc>
		</addBorder>
		<toString public="1" set="method" line="245"><f a=""><c path="String"/></f></toString>
		<get_numFrames get="inline" set="null" line="252"><f a=""><x path="Int"/></f></get_numFrames>
		<new public="1" set="method" line="53"><f a="parent:?type:?border">
	<c path="flixel.graphics.FlxGraphic"/>
	<e path="flixel.graphics.frames.FlxFrameCollectionType"/>
	<c path="flixel.math.FlxPoint"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>* Base class for all frame collections.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="flixel.graphics.frames.FlxAtlasFrames" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/graphics/frames/FlxAtlasFrames.hx">
		<extends path="flixel.graphics.frames.FlxFramesCollection"/>
		<fromTexturePackerJson public="1" set="method" line="37" static="1">
			<f a="Source:Description">
				<t path="flixel.system.FlxGraphicAsset"/>
				<t path="flixel.system.FlxTexturePackerSource"/>
				<c path="flixel.graphics.frames.FlxAtlasFrames"/>
			</f>
			<haxe_doc>* Parsing method for TexturePacker atlases in JSON format.
	 *
	 * @param   Source        The image source (can be `FlxGraphic`, `String`, or `BitmapData`).
	 * @param   Description   Contents of JSON file with atlas description.
	 *                        You can get it with `Assets.getText(path/to/description.json)`.
	 *                        Or you can just a pass path to the JSON file in the assets directory.
	 *                        You can also directly pass in the parsed object.
	 * @return  Newly created `FlxAtlasFrames` collection.</haxe_doc>
		</fromTexturePackerJson>
		<texturePackerHelper set="method" line="97" static="1">
			<f a="FrameName:FrameData:Frames">
				<c path="String"/>
				<d/>
				<c path="flixel.graphics.frames.FlxAtlasFrames"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Internal method for TexturePacker parsing. Parses the actual frame data.
	 *
	 * @param   FrameName   Name of the frame (file name of the original source image).
	 * @param   FrameData   The TexturePacker data excluding "filename".
	 * @param   Frames      The `FlxAtlasFrames` to add this frame to.</haxe_doc>
		</texturePackerHelper>
		<fromLibGdx public="1" set="method" line="128" static="1">
			<f a="Source:Description">
				<t path="flixel.system.FlxGraphicAsset"/>
				<c path="String"/>
				<c path="flixel.graphics.frames.FlxAtlasFrames"/>
			</f>
			<haxe_doc>* Parsing method for LibGDX atlases.
	 * 
	 * @param   Source        The image source (can be `FlxGraphic`, `String` or `BitmapData`).
	 * @param   Description   Contents of the file with atlas description.
	 *                        You can get it with `Assets.getText(path/to/description/file)`.
	 *                        Or you can just pass path to the description file in the assets directory.
	 * @return  Newly created `FlxAtlasFrames` collection.</haxe_doc>
		</fromLibGdx>
		<getDimensions set="method" line="215" static="1">
			<f a="line:size">
				<c path="String"/>
				<c path="Array"><x path="Int"/></c>
				<c path="Array"><x path="Int"/></c>
			</f>
			<haxe_doc>* Internal method for LibGDX atlas parsing. It tries to extract dimensions info from specified string.
	 * 
	 * @param   line   `String` to extract info from.
	 * @param   size   `Array` to store extracted info to.
	 * @return  `Array` filled with dimensions info.</haxe_doc>
		</getDimensions>
		<fromSparrow public="1" set="method" line="236" static="1">
			<f a="Source:Description">
				<t path="flixel.system.FlxGraphicAsset"/>
				<c path="String"/>
				<c path="flixel.graphics.frames.FlxAtlasFrames"/>
			</f>
			<haxe_doc>* Parsing method for Sparrow texture atlases
	 * (they can be generated with Shoebox http://renderhjs.net/shoebox/ for example).
	 * 
	 * @param   Source        The image source (can be `FlxGraphic`, `String` or `BitmapData`).
	 * @param   Description   Contents of the XML file with atlas description.
	 *                        You can get it with `Assets.getText(path/to/description.xml)`.
	 *                        Or you can just pass a path to the XML file in the assets directory.
	 * @return  Newly created `FlxAtlasFrames` collection.</haxe_doc>
		</fromSparrow>
		<fromTexturePackerXml public="1" set="method" line="301" static="1">
			<f a="Source:Description">
				<t path="flixel.system.FlxGraphicAsset"/>
				<c path="String"/>
				<c path="flixel.graphics.frames.FlxAtlasFrames"/>
			</f>
			<haxe_doc>* Parsing method for TexturePacker atlases in generic XML format.
	 * 
	 * @param   Source        The image source (can be `FlxGraphic`, `String` or `BitmapData`).
	 * @param   Description   Contents of the XML file with atlas description.
	 *                        You can get it with `Assets.getText(path/to/description.xml)`.
	 *                        Or you can just pass a path to the XML file in the assets directory.
	 * @return  Newly created `FlxAtlasFrames` collection.</haxe_doc>
		</fromTexturePackerXml>
		<fromSpriteSheetPacker public="1" set="method" line="354" static="1">
			<f a="Source:Description">
				<t path="flixel.system.FlxGraphicAsset"/>
				<c path="String"/>
				<c path="flixel.graphics.frames.FlxAtlasFrames"/>
			</f>
			<haxe_doc>* Parsing method for Sprite Sheet Packer atlases (http://spritesheetpacker.codeplex.com/).
	 * 
	 * @param   Source        The image source (can be `FlxGraphic`, `String` or `BitmapData`).
	 * @param   Description   Contents of the file with atlas description.
	 *                        You can get it with `Assets.getText(path/to/description/file)`.
	 *                        Or you can just pass a path to the description file in the assets directory.
	 * @return  Newly created `FlxAtlasFrames` collection.</haxe_doc>
		</fromSpriteSheetPacker>
		<findFrame public="1" set="method" line="400" static="1">
			<f a="graphic:?border">
				<c path="flixel.graphics.FlxGraphic"/>
				<c path="flixel.math.FlxPoint"/>
				<c path="flixel.graphics.frames.FlxAtlasFrames"/>
			</f>
			<haxe_doc>* Returns the `FlxAtlasFrame` of the specified `FlxGraphic` object.
	 * 
	 * @param   graphic   `FlxGraphic` object to find the `FlxAtlasFrames` collection for.
	 * @return  `FlxAtlasFrames` collection for the specified `FlxGraphic` object
	 *          Could be `null` if `FlxGraphic` doesn't have it yet.</haxe_doc>
		</findFrame>
		<addBorder public="1" set="method" line="414" override="1"><f a="border">
	<c path="flixel.math.FlxPoint"/>
	<c path="flixel.graphics.frames.FlxAtlasFrames"/>
</f></addBorder>
		<new public="1" set="method" line="22"><f a="parent:?border">
	<c path="flixel.graphics.FlxGraphic"/>
	<c path="flixel.math.FlxPoint"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>* Atlas frames collection. It makes possible to use texture atlases in Flixel.
 * Plus it contains few packer parser methods for most commonly used atlas formats.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<typedef path="flixel.graphics.frames.TexturePackerObject" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/graphics/frames/FlxAtlasFrames.hx" module="flixel.graphics.frames.FlxAtlasFrames"><a><frames><d/></frames></a></typedef>
	<class path="flixel.graphics.frames.FlxFrame" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/graphics/frames/FlxFrame.hx">
		<implements path="flixel.util.IFlxDestroyable"/>
		<sort public="1" set="method" line="31" static="1">
			<f a="frames:prefixLength:postfixLength">
				<c path="Array"><c path="flixel.graphics.frames.FlxFrame"/></c>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Sorts an array of `FlxFrame` objects by their name, e.g.
	 * `["tiles-001.png", "tiles-003.png", "tiles-002.png"]`
	 * with `"tiles-".length == prefixLength` and `".png".length == postfixLength`.</haxe_doc>
		</sort>
		<sortByName public="1" set="method" line="36" static="1"><f a="frame1:frame2:prefixLength:postfixLength">
	<c path="flixel.graphics.frames.FlxFrame"/>
	<c path="flixel.graphics.frames.FlxFrame"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></sortByName>
		<point1 expr="new Point()">
			<t path="flash.geom.Point"/>
			<meta><m n=":value"><e>new Point()</e></m></meta>
		</point1>
		<point2 expr="new Point()">
			<t path="flash.geom.Point"/>
			<meta><m n=":value"><e>new Point()</e></m></meta>
		</point2>
		<rect expr="new Rectangle()">
			<t path="flash.geom.Rectangle"/>
			<meta><m n=":value"><e>new Rectangle()</e></m></meta>
		</rect>
		<matrix expr="new FlxMatrix()">
			<c path="flixel.math.FlxMatrix"/>
			<meta><m n=":value"><e>new FlxMatrix()</e></m></meta>
		</matrix>
		<name public="1"><c path="String"/></name>
		<frame public="1" set="accessor">
			<c path="flixel.math.FlxRect"/>
			<haxe_doc>* Region of the image to render.</haxe_doc>
		</frame>
		<uv public="1">
			<c path="flixel.math.FlxRect"/>
			<haxe_doc>* UV coordinates for this frame.
	 * WARNING: For optimization purposes, width and height of this rect
	 * contain right and bottom coordinates (`x + width` and `y + height`).</haxe_doc>
		</uv>
		<parent public="1"><c path="flixel.graphics.FlxGraphic"/></parent>
		<angle public="1">
			<x path="flixel.graphics.frames.FlxFrameAngle"/>
			<haxe_doc>* Rotation angle of this frame.
	 * Required for packed atlas images.</haxe_doc>
		</angle>
		<flipX public="1"><x path="Bool"/></flipX>
		<flipY public="1"><x path="Bool"/></flipY>
		<sourceSize public="1" set="null">
			<c path="flixel.math.FlxPoint"/>
			<haxe_doc>* Original (uncropped) image size.</haxe_doc>
		</sourceSize>
		<offset public="1" set="null">
			<c path="flixel.math.FlxPoint"/>
			<haxe_doc>* Frame offset from top left corner of original image.</haxe_doc>
		</offset>
		<type public="1">
			<x path="flixel.graphics.frames.FlxFrameType"/>
			<haxe_doc>* The type of this frame.</haxe_doc>
		</type>
		<tileMatrix><x path="haxe.ds.Vector"><x path="Float"/></x></tileMatrix>
		<blitMatrix><x path="haxe.ds.Vector"><x path="Float"/></x></blitMatrix>
		<cacheFrameMatrix set="method" line="114">
			<f a=""><x path="Void"/></f>
			<meta>
				<m n=":allow"><e>flixel.graphics.frames.FlxFramesCollection</e></m>
				<m n=":allow"><e>flixel.graphics.frames.FlxBitmapFont</e></m>
			</meta>
		</cacheFrameMatrix>
		<prepareBlitMatrix get="inline" set="null" line="144">
			<f a="mat:?blit" v=":true">
				<c path="flixel.math.FlxMatrix"/>
				<x path="Bool"/>
				<c path="flixel.math.FlxMatrix"/>
			</f>
			<meta><m n=":value"><e>{ blit : true }</e></m></meta>
			<haxe_doc>* Applies frame rotation to the specified matrix, which should be used for tiling or blitting.
	 * Required for rotated frame support.
	 * 
	 * @param   mat    Matrix to transform / rotate
	 * @param   blit   Whether specified matrix will be used for blitting or for tile rendering.
	 * @return  Transformed matrix.</haxe_doc>
		</prepareBlitMatrix>
		<rotateAndFlip get="inline" set="null" line="176">
			<f a="mat:?rotation:?flipX:?flipY" v=":FlxFrameAngle.ANGLE_0:false:false">
				<c path="flixel.math.FlxMatrix"/>
				<x path="flixel.graphics.frames.FlxFrameAngle"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<c path="flixel.math.FlxMatrix"/>
			</f>
			<meta><m n=":value"><e>{ flipY : false, flipX : false, rotation : FlxFrameAngle.ANGLE_0 }</e></m></meta>
			<haxe_doc>* Rotates and flips matrix. This method expects matrix which was prepared by `prepareBlitMatrix()`.
	 * Internal use only.
	 * 
	 * @param   mat        Matrix to transform
	 * @param   rotation   Rotation to apply to specified matrix.
	 * @param   flipX      Do we need to flip frame horizontally
	 * @param   flipY      Do we need to flip frame vertically
	 * @return  Transformed matrix with applied rotation and flipping</haxe_doc>
		</rotateAndFlip>
		<prepareTransformedBlitMatrix set="method" line="226">
			<f a="mat:?rotation:?flipX:?flipY" v=":FlxFrameAngle.ANGLE_0:false:false">
				<c path="flixel.math.FlxMatrix"/>
				<x path="flixel.graphics.frames.FlxFrameAngle"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<c path="flixel.math.FlxMatrix"/>
			</f>
			<meta><m n=":value"><e>{ flipY : false, flipX : false, rotation : FlxFrameAngle.ANGLE_0 }</e></m></meta>
			<haxe_doc>* Prepares matrix for frame blitting (see `paint` methods).
	 * 
	 * @param   mat        Matrix to transform/prepare.
	 * @param   rotation   Rotation to apply to specified matrix.
	 * @param   flipX      Do we need to flip frame horizontally.
	 * @param   flipY      Do we need to flip frame vertically.
	 * @return  Transformed matrix which can be used for frame painting.</haxe_doc>
		</prepareTransformedBlitMatrix>
		<prepareMatrix public="1" set="method" line="242">
			<f a="mat:?rotation:?flipX:?flipY" v=":FlxFrameAngle.ANGLE_0:false:false">
				<c path="flixel.math.FlxMatrix"/>
				<x path="flixel.graphics.frames.FlxFrameAngle"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<c path="flixel.math.FlxMatrix"/>
			</f>
			<meta><m n=":value"><e>{ flipY : false, flipX : false, rotation : FlxFrameAngle.ANGLE_0 }</e></m></meta>
			<haxe_doc>* Prepares matrix for frame tile/triangles rendering.
	 * 
	 * @param   mat        Matrix to transform/prepare
	 * @param   rotation   Rotation to apply to specified matrix.
	 * @param   flipX      Do we need to flip frame horizontally
	 * @param   flipY      Do we need to flip frame vertically
	 * @return  Transformed matrix which can be used for frame drawing.</haxe_doc>
		</prepareMatrix>
		<fillBlitMatrix get="inline" set="null" line="267"><f a="mat">
	<c path="flixel.math.FlxMatrix"/>
	<c path="flixel.math.FlxMatrix"/>
</f></fillBlitMatrix>
		<paint public="1" set="method" line="290">
			<f a="?bmd:?point:?mergeAlpha:?disposeIfNotEqual" v="::false:false">
				<t path="flash.display.BitmapData"/>
				<t path="flash.geom.Point"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<t path="flash.display.BitmapData"/>
			</f>
			<meta><m n=":value"><e>{ disposeIfNotEqual : false, mergeAlpha : false }</e></m></meta>
			<haxe_doc>* Draws frame on specified `BitmapData` object.
	 * 
	 * @param   bmd                 `BitmapData` object to draw this frame on.
	 *                              If bmd is `null` then new a `BitmapData` is created.
	 * @param   point               Where to draw this frame on the specified `BitmapData` object.
	 * @param   mergeAlpha          Whether to merge alphas or not.
	 *                              (works like with `BitmapData`'s `copyPixels()` method).
	 * @param   disposeIfNotEqual   Whether dispose passed `bmd` or not if its size isn't
	 *                              equal to frame's original size (`sourceSize`)
	 * @return  Modified or newly created `BitmapData` with frame image on it.</haxe_doc>
		</paint>
		<paintRotatedAndFlipped public="1" set="method" line="337">
			<f a="?bmd:?point:?rotation:?flipX:?flipY:?mergeAlpha:?disposeIfNotEqual" v="::FlxFrameAngle.ANGLE_0:false:false:false:false">
				<t path="flash.display.BitmapData"/>
				<t path="flash.geom.Point"/>
				<x path="flixel.graphics.frames.FlxFrameAngle"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<t path="flash.display.BitmapData"/>
			</f>
			<meta><m n=":value"><e>{ disposeIfNotEqual : false, mergeAlpha : false, flipY : false, flipX : false, rotation : FlxFrameAngle.ANGLE_0 }</e></m></meta>
			<haxe_doc>* Draws rotated and flipped frame on specified BitmapData object.
	 * 
	 * @param   bmd                 BitmapData object to draw this frame on.
	 *                              If `bmd` is `null` then new `BitmapData` created.
	 * @param   point               Where to draw this frame on the specified `BitmapData` object
	 * @param   rotation            How much rotate the frame.
	 * @param   flipX               Do we need to flip frame horizontally.
	 * @param   flipY               Do we need to flip frame vertically.
	 * @param   mergeAlpha          Whether to merge alphas or not
	 *                              (works like with `BitmapData`'s `copyPixels()` method).
	 * @param   disposeIfNotEqual   Whether dispose passed `bmd` or not if its size isn't
	 *                              equal to frame's original size (`sourceSize`)
	 * @return  Modified or newly created `BitmapData` with frame image on it.</haxe_doc>
		</paintRotatedAndFlipped>
		<checkInputBitmap get="inline" set="null" line="378">
			<f a="?bmd:?point:?rotation:?mergeAlpha:?disposeIfNotEqual" v="::FlxFrameAngle.ANGLE_0:false:false">
				<t path="flash.display.BitmapData"/>
				<t path="flash.geom.Point"/>
				<x path="flixel.graphics.frames.FlxFrameAngle"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<t path="flash.display.BitmapData"/>
			</f>
			<meta><m n=":value"><e>{ disposeIfNotEqual : false, mergeAlpha : false, rotation : FlxFrameAngle.ANGLE_0 }</e></m></meta>
			<haxe_doc>* Internal method which runs few checks on specified `BitmapData` object.
	 * 
	 * @param   bmd                 `BitmapData` object to check against.
	 * @param   point               Optional point for mergeAlpha checks
	 * @param   rotation            How much we will rotate the frame when we will be
	 *                              drawing it on specified `BitmapData`.
	 * @param   mergeAlpha          Whether to merge alphas or not
	 *                              (works like with `BitmapData`'s `copyPixels()` method).
	 * @param   disposeIfNotEqual   Whether dispose passed bmd or not if its size isn't
	 *                              equal to frame's original size (`sourceSize`).
	 * @return  Prepared `BitmapData` for further frame blitting. Output `BitmapData` could be a different object.</haxe_doc>
		</checkInputBitmap>
		<getDrawFrameRect get="inline" set="null" line="415">
			<f a="mat">
				<c path="flixel.math.FlxMatrix"/>
				<t path="flash.geom.Rectangle"/>
			</f>
			<haxe_doc>* Internal method which prepares frame rect for blitting.
	 * Required for rotated frames support.
	 * 
	 * @param   mat   Frame transformation matrix (rotated / flipped / translated).
	 * @return  Clipping rectangle which will be used for frame blitting.</haxe_doc>
		</getDrawFrameRect>
		<subFrameTo public="1" set="method" line="436">
			<f a="rect:?frameToFill">
				<c path="flixel.math.FlxRect"/>
				<c path="flixel.graphics.frames.FlxFrame"/>
				<c path="flixel.graphics.frames.FlxFrame"/>
			</f>
			<haxe_doc>* Generates frame with specified subregion of this frame.
	 * 
	 * @param   rect          Frame region to generate frame for.
	 * @param   frameToFill   Frame to fill with data. If `null` then a new frame will be created.
	 * @return  Specified `frameToFill` object but filled with data.</haxe_doc>
		</subFrameTo>
		<setBorderTo public="1" set="method" line="524">
			<f a="border:?frameToFill">
				<c path="flixel.math.FlxPoint"/>
				<c path="flixel.graphics.frames.FlxFrame"/>
				<c path="flixel.graphics.frames.FlxFrame"/>
			</f>
			<haxe_doc>* Just a helper method for some frame adjusting.
	 * Try to not use it, since it may cause memory leaks.
	 * 
	 * @param   border   Amount to clip from frame
	 * @return  Clipped frame</haxe_doc>
		</setBorderTo>
		<clipTo public="1" set="method" line="541">
			<f a="clip:?clippedFrame">
				<c path="flixel.math.FlxRect"/>
				<c path="flixel.graphics.frames.FlxFrame"/>
				<c path="flixel.graphics.frames.FlxFrame"/>
			</f>
			<haxe_doc>* Frame clipping
	 *
	 * @param   clip           Clipping rectangle to apply on frame
	 * @param   clippedFrame   The frame which will contain result of original frame clipping.
	 *                         If `null`, a new frame will be created.
	 * @return  Result of applying frame clipping</haxe_doc>
		</clipTo>
		<copyTo public="1" set="method" line="626">
			<f a="?clone">
				<c path="flixel.graphics.frames.FlxFrame"/>
				<c path="flixel.graphics.frames.FlxFrame"/>
			</f>
			<haxe_doc>* Copies data from this frame into specified frame.
	 * 
	 * @param   clone   Frame to fill data with. If `null`, a new frame will be created.
	 * @return  Frame with data of this frame.</haxe_doc>
		</copyTo>
		<destroy public="1" set="method" line="650"><f a=""><x path="Void"/></f></destroy>
		<toString public="1" set="method" line="662"><f a=""><c path="String"/></f></toString>
		<set_frame set="method" line="668"><f a="value">
	<c path="flixel.math.FlxRect"/>
	<c path="flixel.math.FlxRect"/>
</f></set_frame>
		<new set="method" line="94">
			<f a="parent:?angle:?flipX:?flipY" v=":FlxFrameAngle.ANGLE_0:false:false">
				<c path="flixel.graphics.FlxGraphic"/>
				<x path="flixel.graphics.frames.FlxFrameAngle"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":value"><e>{ flipY : false, flipX : false, angle : FlxFrameAngle.ANGLE_0 }</e></m>
				<m n=":allow"><e>flixel.graphics.FlxGraphic</e></m>
				<m n=":allow"><e>flixel.graphics.frames.FlxFramesCollection</e></m>
			</meta>
		</new>
		<haxe_doc>* Base class for all frame types</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<abstract path="flixel.graphics.frames.FlxFrameType" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/graphics/frames/FlxFrame.hx" module="flixel.graphics.frames.FlxFrame">
		<this><x path="Int"/></this>
		<haxe_doc>* Just enumeration of all types of frames.
 * Added for faster type detection with less usage of casting.</haxe_doc>
		<meta><m n=":enum"/></meta>
		<impl><class path="flixel.graphics.frames._FlxFrame.FlxFrameType_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/graphics/frames/FlxFrame.hx" private="1" module="flixel.graphics.frames.FlxFrame" extern="1">
	<REGULAR public="1" get="inline" set="null" expr="cast 0" line="689" static="1">
		<x path="flixel.graphics.frames.FlxFrameType"/>
		<meta>
			<m n=":value"><e>cast 0</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</REGULAR>
	<EMPTY public="1" get="inline" set="null" expr="cast 2" line="690" static="1">
		<x path="flixel.graphics.frames.FlxFrameType"/>
		<meta>
			<m n=":value"><e>cast 2</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</EMPTY>
	<GLYPH public="1" get="inline" set="null" expr="cast 3" line="691" static="1">
		<x path="flixel.graphics.frames.FlxFrameType"/>
		<meta>
			<m n=":value"><e>cast 3</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</GLYPH>
	<meta>
		<m n=":final"/>
		<m n=":enum"/>
	</meta>
</class></impl>
	</abstract>
	<class path="flixel.graphics.frames._FlxFrame.FlxFrameType_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/graphics/frames/FlxFrame.hx" private="1" module="flixel.graphics.frames.FlxFrame" extern="1">
		<REGULAR public="1" get="inline" set="null" expr="cast 0" line="689" static="1">
			<x path="flixel.graphics.frames.FlxFrameType"/>
			<meta>
				<m n=":value"><e>cast 0</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</REGULAR>
		<EMPTY public="1" get="inline" set="null" expr="cast 2" line="690" static="1">
			<x path="flixel.graphics.frames.FlxFrameType"/>
			<meta>
				<m n=":value"><e>cast 2</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</EMPTY>
		<GLYPH public="1" get="inline" set="null" expr="cast 3" line="691" static="1">
			<x path="flixel.graphics.frames.FlxFrameType"/>
			<meta>
				<m n=":value"><e>cast 3</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</GLYPH>
		<meta>
			<m n=":final"/>
			<m n=":enum"/>
		</meta>
	</class>
	<abstract path="flixel.graphics.frames.FlxFrameAngle" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/graphics/frames/FlxFrame.hx" module="flixel.graphics.frames.FlxFrame">
		<from><icast><x path="Int"/></icast></from>
		<this><x path="Int"/></this>
		<to><icast><x path="Int"/></icast></to>
		<meta><m n=":enum"/></meta>
		<impl><class path="flixel.graphics.frames._FlxFrame.FlxFrameAngle_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/graphics/frames/FlxFrame.hx" private="1" module="flixel.graphics.frames.FlxFrame" extern="1">
	<ANGLE_0 public="1" get="inline" set="null" expr="cast 0" line="697" static="1">
		<x path="flixel.graphics.frames.FlxFrameAngle"/>
		<meta>
			<m n=":value"><e>cast 0</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</ANGLE_0>
	<ANGLE_90 public="1" get="inline" set="null" expr="cast 90" line="698" static="1">
		<x path="flixel.graphics.frames.FlxFrameAngle"/>
		<meta>
			<m n=":value"><e>cast 90</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</ANGLE_90>
	<ANGLE_NEG_90 public="1" get="inline" set="null" expr="cast -90" line="699" static="1">
		<x path="flixel.graphics.frames.FlxFrameAngle"/>
		<meta>
			<m n=":value"><e>cast -90</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</ANGLE_NEG_90>
	<ANGLE_270 public="1" get="inline" set="null" expr="cast -90" line="700" static="1">
		<x path="flixel.graphics.frames.FlxFrameAngle"/>
		<meta>
			<m n=":value"><e>cast -90</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</ANGLE_270>
	<meta>
		<m n=":final"/>
		<m n=":enum"/>
	</meta>
</class></impl>
	</abstract>
	<class path="flixel.graphics.frames._FlxFrame.FlxFrameAngle_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/graphics/frames/FlxFrame.hx" private="1" module="flixel.graphics.frames.FlxFrame" extern="1">
		<ANGLE_0 public="1" get="inline" set="null" expr="cast 0" line="697" static="1">
			<x path="flixel.graphics.frames.FlxFrameAngle"/>
			<meta>
				<m n=":value"><e>cast 0</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</ANGLE_0>
		<ANGLE_90 public="1" get="inline" set="null" expr="cast 90" line="698" static="1">
			<x path="flixel.graphics.frames.FlxFrameAngle"/>
			<meta>
				<m n=":value"><e>cast 90</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</ANGLE_90>
		<ANGLE_NEG_90 public="1" get="inline" set="null" expr="cast -90" line="699" static="1">
			<x path="flixel.graphics.frames.FlxFrameAngle"/>
			<meta>
				<m n=":value"><e>cast -90</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</ANGLE_NEG_90>
		<ANGLE_270 public="1" get="inline" set="null" expr="cast -90" line="700" static="1">
			<x path="flixel.graphics.frames.FlxFrameAngle"/>
			<meta>
				<m n=":value"><e>cast -90</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</ANGLE_270>
		<meta>
			<m n=":final"/>
			<m n=":enum"/>
		</meta>
	</class>
	<enum path="flixel.graphics.frames.FlxFrameCollectionType" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/graphics/frames/FlxFramesCollection.hx" module="flixel.graphics.frames.FlxFramesCollection">
		<IMAGE/>
		<TILES/>
		<ATLAS/>
		<FONT/>
		<USER a="type"><c path="String"/></USER>
		<FILTER/>
		<haxe_doc>* An enumeration of all types of frame collections.
 * Added for faster type detection with less usage of casting.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</enum>
	<class path="flixel.graphics.frames.FlxImageFrame" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/graphics/frames/FlxImageFrame.hx">
		<extends path="flixel.graphics.frames.FlxFramesCollection"/>
		<fromEmptyFrame public="1" set="method" line="38" static="1">
			<f a="graphic:frameRect">
				<c path="flixel.graphics.FlxGraphic"/>
				<c path="flixel.math.FlxRect"/>
				<c path="flixel.graphics.frames.FlxImageFrame"/>
			</f>
			<haxe_doc>* Generates a `FlxImageFrame` object with empty frame of specified size.
	 * 
	 * @param   graphic     Graphic for the `FlxImageFrame`.
	 * @param   frameRect   The size of the empty frame to generate
	 *                      (only `width` and `height` of the `frameRect` need to be set properly).
	 * @return  Newly created `FlxImageFrame` object with empty frame of specified size.</haxe_doc>
		</fromEmptyFrame>
		<fromFrame public="1" set="method" line="60" static="1">
			<f a="source">
				<c path="flixel.graphics.frames.FlxFrame"/>
				<c path="flixel.graphics.frames.FlxImageFrame"/>
			</f>
			<haxe_doc>* Generates a `FlxImageFrame` object from the specified `FlxFrame`.
	 * 
	 * @param   source   `FlxFrame` to generate `FlxImageFrame` from.
	 * @return  Created `FlxImageFrame` object.</haxe_doc>
		</fromFrame>
		<fromImage public="1" set="method" line="80" static="1">
			<f a="source">
				<t path="flixel.system.FlxGraphicAsset"/>
				<c path="flixel.graphics.frames.FlxImageFrame"/>
			</f>
			<haxe_doc>* Creates a `FlxImageFrame` object for the whole image.
	 * 
	 * @param   source   image graphic for the `FlxImageFrame`.
	 * @return  Newly created `FlxImageFrame` object for specified graphic.</haxe_doc>
		</fromImage>
		<fromGraphic public="1" set="method" line="92" static="1">
			<f a="graphic:?region">
				<c path="flixel.graphics.FlxGraphic"/>
				<c path="flixel.math.FlxRect"/>
				<c path="flixel.graphics.frames.FlxImageFrame"/>
			</f>
			<haxe_doc>* Creates `FlxImageFrame` for the specified region of `FlxGraphic`.
	 * 
	 * @param   graphic   Graphic for `FlxImageFrame`.
	 * @param   region    Region of image to create the `FlxImageFrame` for.
	 * @return  Newly created `FlxImageFrame` object for the specified region of `FlxGraphic` object.</haxe_doc>
		</fromGraphic>
		<fromRectangle public="1" set="method" line="134" static="1">
			<f a="source:?region">
				<t path="flixel.system.FlxGraphicAsset"/>
				<c path="flixel.math.FlxRect"/>
				<c path="flixel.graphics.frames.FlxImageFrame"/>
			</f>
			<haxe_doc>* Creates a `FlxImageFrame` object for specified region of the image.
	 * 
	 * @param   source   Image graphic for `FlxImageFrame`.
	 * @param   region   Region of the image to create the `FlxImageFrame` for.
	 * @return  Newly created `FlxImageFrame` object for specified region of image.</haxe_doc>
		</fromRectangle>
		<fromBitmapAddSpacesAndBorders public="1" set="method" line="150" static="1">
			<f a="source:border:?region">
				<t path="flixel.system.FlxGraphicAsset"/>
				<c path="flixel.math.FlxPoint"/>
				<c path="flixel.math.FlxRect"/>
				<c path="flixel.graphics.frames.FlxImageFrame"/>
			</f>
			<haxe_doc>* Gets source BitmapData, generates new BitmapData (if there is no such BitmapData in the cache already) 
	 * and creates FlxImageFrame collection.
	 * 
	 * @param   source   The source of graphic for frame collection.
	 * @param   border   Border to add around tiles (helps to avoid "tearing" problem).
	 * @param   region   Region of image to generate image frame from. Default value is `null`, which means that
	 *                   whole image will be used for it.
	 * @return  Newly created image frame collection.</haxe_doc>
		</fromBitmapAddSpacesAndBorders>
		<fromFrameAddSpacesAndBorders public="1" set="method" line="176" static="1">
			<f a="frame:border">
				<c path="flixel.graphics.frames.FlxFrame"/>
				<c path="flixel.math.FlxPoint"/>
				<c path="flixel.graphics.frames.FlxImageFrame"/>
			</f>
			<haxe_doc>* Gets `FlxFrame` object, generates new `BitmapData` with border pixels around
	 * (if there is no such BitmapData in the cache already) and creates image frame collection.
	 * 
	 * @param   frame    Frame to generate tiles from.
	 * @param   border   Border to add around frame image (helps to avoid "tearing" problem).
	 * @return  Newly created image frame collection.</haxe_doc>
		</fromFrameAddSpacesAndBorders>
		<findFrame public="1" set="method" line="191" static="1">
			<f a="graphic:frameRect:?frameBorder">
				<c path="flixel.graphics.FlxGraphic"/>
				<c path="flixel.math.FlxRect"/>
				<c path="flixel.math.FlxPoint"/>
				<c path="flixel.graphics.frames.FlxImageFrame"/>
			</f>
			<haxe_doc>* Searches `FlxImageFrame` object for specified `FlxGraphic` object which have the same frame rectangle.
	 * 
	 * @param    graphic     `FlxGraphic` object to search the `FlxImageFrame` for.
	 * @param    frameRect   `FlxImageFrame` object should have frame with
	 *                        the same position and dimensions as specified with this argument.
	 * @return   `FlxImageFrame` object which corresponds to specified rectangle.
	 *           Could be `null` if there is no such `FlxImageFrame`.</haxe_doc>
		</findFrame>
		<findEmptyFrame public="1" set="method" line="221" static="1">
			<f a="graphic:frameRect">
				<c path="flixel.graphics.FlxGraphic"/>
				<c path="flixel.math.FlxRect"/>
				<c path="flixel.graphics.frames.FlxImageFrame"/>
			</f>
			<haxe_doc>* Searches `FlxImageFrame` object with the empty frame which have specified size.
	 * 
	 * @param   graphic     `FlxGraphic` object to search `FlxImageFrame` for.
	 * @param   frameRect   The size of empty frame to search for.
	 * @return  `FlxImageFrame` with empty frame.</haxe_doc>
		</findEmptyFrame>
		<frame public="1" get="accessor" set="null">
			<c path="flixel.graphics.frames.FlxFrame"/>
			<haxe_doc>* Single frame of this frame collection.
	 * Added this var for faster access, so you don't need to type something like: `imageFrame.frames[0]`</haxe_doc>
		</frame>
		<equals get="inline" set="null" line="209">
			<f a="rect:border">
				<c path="flixel.math.FlxRect"/>
				<c path="flixel.math.FlxPoint"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* `FlxImageFrame` comparison method. For internal use.</haxe_doc>
		</equals>
		<addBorder public="1" set="method" line="236" override="1"><f a="border">
	<c path="flixel.math.FlxPoint"/>
	<c path="flixel.graphics.frames.FlxImageFrame"/>
</f></addBorder>
		<destroy public="1" set="method" line="249" override="1"><f a=""><x path="Void"/></f></destroy>
		<get_frame set="method" line="255"><f a=""><c path="flixel.graphics.frames.FlxFrame"/></f></get_frame>
		<new set="method" line="25"><f a="parent:?border">
	<c path="flixel.graphics.FlxGraphic"/>
	<c path="flixel.math.FlxPoint"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>* Single-frame collection.
 * Could be useful for non-animated sprites.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="flixel.graphics.frames.FlxTileFrames" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/graphics/frames/FlxTileFrames.hx">
		<extends path="flixel.graphics.frames.FlxFramesCollection"/>
		<fromBitmapAddSpacesAndBorders public="1" set="method" line="67" static="1">
			<f a="source:tileSize:?tileSpacing:?tileBorder:?region">
				<t path="flixel.system.FlxGraphicAsset"/>
				<c path="flixel.math.FlxPoint"/>
				<c path="flixel.math.FlxPoint"/>
				<c path="flixel.math.FlxPoint"/>
				<c path="flixel.math.FlxRect"/>
				<c path="flixel.graphics.frames.FlxTileFrames"/>
			</f>
			<haxe_doc>* Gets source `BitmapData`, generates new `BitmapData` with spaces between frames
	 * (if there is no such `BitmapData` in the cache already) and creates `FlxTileFrames` collection.
	 * 
	 * @param   source        The source of graphic for frame collection.
	 * @param   tileSize      The size of tiles in spritesheet.
	 * @param   tileSpacing   Desired offsets between frames in spritesheet
	 *                        (this method takes spritesheet bitmap without offsets between frames and adds them).
	 * @param   tileBorder    Border to add around tiles (helps to avoid "tearing" problem).
	 * @param   region        Region of image to generate spritesheet from. Default value is `null`, which means that
	 *                        the whole image will be used for spritesheet generation.
	 * @return   Newly created spritesheet.</haxe_doc>
		</fromBitmapAddSpacesAndBorders>
		<fromFrameAddSpacesAndBorders public="1" set="method" line="111" static="1">
			<f a="frame:tileSize:?tileSpacing:?tileBorder">
				<c path="flixel.graphics.frames.FlxFrame"/>
				<c path="flixel.math.FlxPoint"/>
				<c path="flixel.math.FlxPoint"/>
				<c path="flixel.math.FlxPoint"/>
				<c path="flixel.graphics.frames.FlxTileFrames"/>
			</f>
			<haxe_doc>* Gets `FlxFrame` object, generates new `BitmapData` with spaces between tiles in the frame
	 * (if there is no such `BitmapData` in the cache already) and creates a `FlxTileFrames` collection.
	 *  
	 * @param   frame         Frame to generate tiles from.
	 * @param   tileSize      the size of tiles in spritesheet.
	 * @param   tileSpacing   desired offsets between frames in spritesheet.
	 *                        (this method takes spritesheet bitmap without offsets between frames and adds them).
	 * @param   tileBorder    Border to add around tiles (helps to avoid "tearing" problem).
	 * @return  Newly created spritesheet.</haxe_doc>
		</fromFrameAddSpacesAndBorders>
		<fromFrame public="1" set="method" line="129" static="1">
			<f a="frame:tileSize:?tileSpacing">
				<c path="flixel.graphics.frames.FlxFrame"/>
				<c path="flixel.math.FlxPoint"/>
				<c path="flixel.math.FlxPoint"/>
				<c path="flixel.graphics.frames.FlxTileFrames"/>
			</f>
			<haxe_doc>* Generates spritesheet frame collection from provided frame. Can be useful for spritesheets packed into atlases.
	 * It can generate spritesheets from rotated and cropped frames also,
	 * which is important for devices with limited memory.
	 * 
	 * @param   frame         Frame, containing spritesheet image
	 * @param   tileSize      The size of tiles in spritesheet
	 * @param   tileSpacing   Offsets between frames in spritesheet.
	 *                        Default value is `null`, which means no offsets between tiles.
	 * @return  Newly created spritesheet frame collection.</haxe_doc>
		</fromFrame>
		<fromFrames public="1" set="method" line="182" static="1">
			<f a="Frames">
				<c path="Array"><c path="flixel.graphics.frames.FlxFrame"/></c>
				<c path="flixel.graphics.frames.FlxTileFrames"/>
			</f>
			<haxe_doc>* Just generates tile frames collection from specified array of frames.
	 * 
	 * @param   Frames   `Array` of frames to generate tile frames from.
	 *                   They all should have the same source size and parent graphic.
	 *                   If not then `null` will be returned.
	 * @return  Generated collection of frames.</haxe_doc>
		</fromFrames>
		<fromAtlasByPrefix public="1" set="method" line="225" static="1">
			<f a="Frames:Prefix">
				<c path="flixel.graphics.frames.FlxAtlasFrames"/>
				<c path="String"/>
				<c path="flixel.graphics.frames.FlxTileFrames"/>
			</f>
			<haxe_doc>* Creates new a `FlxTileFrames` collection from atlas frames which begin with
	 * a common name (e.g. `"tiles-"`) and differ in indices (e.g. `"001"`, `"002"`, etc.).
	 * This method is similar to `FlxAnimationController`'s `addByPrefix()`.
	 * 
	 * @param    Frames   Collection of atlas frames to generate tiles from.
	 * @param    Prefix   Common beginning of image names in atlas (e.g. `"tiles-"`).
	 * @return   Generated tile frames collection.</haxe_doc>
		</fromAtlasByPrefix>
		<fromGraphic public="1" set="method" line="259" static="1">
			<f a="graphic:tileSize:?region:?tileSpacing">
				<c path="flixel.graphics.FlxGraphic"/>
				<c path="flixel.math.FlxPoint"/>
				<c path="flixel.math.FlxRect"/>
				<c path="flixel.math.FlxPoint"/>
				<c path="flixel.graphics.frames.FlxTileFrames"/>
			</f>
			<haxe_doc>* Generates spritesheet frame collection from provided region of image.
	 * 
	 * @param   graphic       Source graphic for spritesheet.
	 * @param   tileSize      The size of tiles in spritesheet.
	 * @param   region        Region of image to use for spritesheet generation. Default value is `null`,
	 *                        which means that the whole image will be used for it.
	 * @param   tileSpacing   Offsets between frames in spritesheet.
	 *                        Default value is `null`, which means no offsets between tiles.
	 * @return  Newly created spritesheet frame collection.</haxe_doc>
		</fromGraphic>
		<fromRectangle public="1" set="method" line="326" static="1">
			<f a="source:tileSize:?region:?tileSpacing">
				<t path="flixel.system.FlxGraphicAsset"/>
				<c path="flixel.math.FlxPoint"/>
				<c path="flixel.math.FlxRect"/>
				<c path="flixel.math.FlxPoint"/>
				<c path="flixel.graphics.frames.FlxTileFrames"/>
			</f>
			<haxe_doc>* Generates a spritesheet frame collection from the provided image region.
	 * 
	 * @param   source        Source graphic for the spritesheet.
	 * @param   tileSize      The size of tiles in spritesheet.
	 * @param   region        Region of image to use for spritesheet generation. Default value is `null`,
	 *                        which means that whole image will be used for it.
	 * @param   tileSpacing   Offsets between frames in spritesheet.
	 *                        Default value is `null`, which means no offsets between tiles.
	 * @return  Newly created spritesheet frame collection.</haxe_doc>
		</fromRectangle>
		<combineTileSets public="1" set="method" line="355" static="1">
			<f a="bitmaps:tileSize:?spacing:?border">
				<c path="Array"><t path="flash.display.BitmapData"/></c>
				<c path="flixel.math.FlxPoint"/>
				<c path="flixel.math.FlxPoint"/>
				<c path="flixel.math.FlxPoint"/>
				<c path="flixel.graphics.frames.FlxTileFrames"/>
			</f>
			<haxe_doc>* This method takes array of tileset bitmaps and the size of
	 * tiles in them and then combine them in one big tileset.
	 * The order of bitmaps in the array is important.
	 * 
	 * @param   bitmaps    tilesets
	 * @param   tileSize   The size of tiles (tilesets should have tiles of the same size).
	 * @return  Atlas frames collection, which you can load in tilemaps or sprites:
	 * 
	 * ```haxe
	 * var combinedFrames = FlxTileFrames.combineTileSets(bitmaps, FlxPoint.get(16, 16));
	 * tilemap.loadMapFromCSV(mapData, combinedFrames);
	 *```
	 *
	 * or
	 * 
	 * ```haxe
	 * sprite.frames = combinedFrames;
	 * ```</haxe_doc>
		</combineTileSets>
		<combineTileFrames public="1" set="method" line="384" static="1">
			<f a="tileframes:?spacing:?border">
				<c path="Array"><c path="flixel.graphics.frames.FlxTileFrames"/></c>
				<c path="flixel.math.FlxPoint"/>
				<c path="flixel.math.FlxPoint"/>
				<c path="flixel.graphics.frames.FlxTileFrames"/>
			</f>
			<haxe_doc>* This method takes array of tile frames collections and then combine them in one big tileset.
	 * The order of bitmaps in array is important.
	 * 
	 * @param   tileframes   Tile frames collection to combine tiles from.
	 * @return  Atlas frames collection, which you can load in tilemaps or sprites:
	 * 
	 * ```haxe
	 * var combinedFrames = FlxTileFrames.combineTileFrames(tileframes);
	 * tilemap.loadMapFromCSV(mapData, combinedFrames);
	 * ```
	 *
	 * or
	 * 
	 * ```haxe
	 * sprite.frames = combinedFrames;
	 * ```</haxe_doc>
		</combineTileFrames>
		<findFrame public="1" set="method" line="474" static="1">
			<f a="graphic:tileSize:?region:?atlasFrame:?tileSpacing:?border">
				<c path="flixel.graphics.FlxGraphic"/>
				<c path="flixel.math.FlxPoint"/>
				<c path="flixel.math.FlxRect"/>
				<c path="flixel.graphics.frames.FlxFrame"/>
				<c path="flixel.math.FlxPoint"/>
				<c path="flixel.math.FlxPoint"/>
				<c path="flixel.graphics.frames.FlxTileFrames"/>
			</f>
			<haxe_doc>* Searches `FlxTileFrames` object for a specified `FlxGraphic` object
	 * which has the same parameters (frame size, frame spacings, region of image, etc.).
	 * 
	 * @param   graphic       `FlxGraphic` object to search `FlxTileFrames` for.
	 * @param   tileSize      The size of tiles in TileFrames.
	 * @param   region        The region of source image used for spritesheet generation.
	 * @param   atlasFrame    Optional `FlxFrame` object used for spritesheet generation.
	 * @param   tileSpacing   Spaces between tiles in spritesheet.
	 * @return  `FlxTileFrames` object which corresponds to specified arguments.
	 *          Could be null if there is no such `FlxTileFrames`.</haxe_doc>
		</findFrame>
		<atlasFrame>
			<c path="flixel.graphics.frames.FlxFrame"/>
			<haxe_doc>* Atlas frame from which this frame collection had been generated.
	 * Could be `null` if this collection generated from rectangle.</haxe_doc>
		</atlasFrame>
		<region>
			<c path="flixel.math.FlxRect"/>
			<haxe_doc>* Image region of the image from which this frame collection had been generated.</haxe_doc>
		</region>
		<tileSize public="1">
			<c path="flixel.math.FlxPoint"/>
			<haxe_doc>* The size of frame in this spritesheet.</haxe_doc>
		</tileSize>
		<tileSpacing>
			<c path="flixel.math.FlxPoint"/>
			<haxe_doc>* Offsets between frames in this spritesheet.</haxe_doc>
		</tileSpacing>
		<numRows public="1" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</numRows>
		<numCols public="1" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</numCols>
		<getByTilePosition public="1" get="inline" set="null" line="49">
			<f a="column:row">
				<x path="Int"/>
				<x path="Int"/>
				<c path="flixel.graphics.frames.FlxFrame"/>
			</f>
			<haxe_doc>* Gets frame by its "position" in spritesheet.</haxe_doc>
		</getByTilePosition>
		<equals public="1" set="method" line="491">
			<f a="tileSize:?region:?atlasFrame:?tileSpacing:?border">
				<c path="flixel.math.FlxPoint"/>
				<c path="flixel.math.FlxRect"/>
				<c path="flixel.graphics.frames.FlxFrame"/>
				<c path="flixel.math.FlxPoint"/>
				<c path="flixel.math.FlxPoint"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* TileFrames comparison method. For internal use.</haxe_doc>
		</equals>
		<addBorder public="1" set="method" line="517" override="1"><f a="border">
	<c path="flixel.math.FlxPoint"/>
	<c path="flixel.graphics.frames.FlxTileFrames"/>
</f></addBorder>
		<destroy public="1" set="method" line="542" override="1"><f a=""><x path="Void"/></f></destroy>
		<new set="method" line="41"><f a="parent:?border">
	<c path="flixel.graphics.FlxGraphic"/>
	<c path="flixel.math.FlxPoint"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>* Spritesheet frame collection. It is used for tilemaps and animated sprites.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="flixel.graphics.tile.FlxDrawBaseItem" params="T" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/graphics/tile/FlxDrawBaseItem.hx">
		<blendToInt public="1" set="method" line="16" static="1"><f a="blend">
	<x path="openfl.display.BlendMode"/>
	<x path="Int"/>
</f></blendToInt>
		<nextTyped public="1"><c path="flixel.graphics.tile.FlxDrawBaseItem.T"/></nextTyped>
		<next public="1"><c path="flixel.graphics.tile.FlxDrawBaseItem"><c path="flixel.graphics.tile.FlxDrawBaseItem.T"/></c></next>
		<graphics public="1"><c path="flixel.graphics.FlxGraphic"/></graphics>
		<antialiasing public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</antialiasing>
		<colored public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</colored>
		<hasColorOffsets public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</hasColorOffsets>
		<blending public="1" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</blending>
		<type public="1"><e path="flixel.graphics.tile.FlxDrawItemType"/></type>
		<numVertices public="1" get="accessor" set="null"><x path="Int"/></numVertices>
		<numTriangles public="1" get="accessor" set="null"><x path="Int"/></numTriangles>
		<reset public="1" set="method" line="70"><f a=""><x path="Void"/></f></reset>
		<dispose public="1" set="method" line="78"><f a=""><x path="Void"/></f></dispose>
		<render public="1" set="method" line="86"><f a="camera">
	<c path="flixel.FlxCamera"/>
	<x path="Void"/>
</f></render>
		<addQuad public="1" set="method" line="88"><f a="frame:matrix:?transform">
	<c path="flixel.graphics.frames.FlxFrame"/>
	<c path="flixel.math.FlxMatrix"/>
	<c path="openfl.geom.ColorTransform"/>
	<x path="Void"/>
</f></addQuad>
		<get_numVertices set="method" line="90"><f a=""><x path="Int"/></f></get_numVertices>
		<get_numTriangles set="method" line="95"><f a=""><x path="Int"/></f></get_numTriangles>
		<new public="1" set="method" line="68"><f a=""><x path="Void"/></f></new>
		<haxe_doc>* ...
 * @author Zaphod</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<enum path="flixel.graphics.tile.FlxDrawItemType" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/graphics/tile/FlxDrawBaseItem.hx" module="flixel.graphics.tile.FlxDrawBaseItem">
		<TILES/>
		<TRIANGLES/>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<class path="flixel.graphics.tile.FlxDrawTilesItem" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/graphics/tile/FlxDrawTilesItem.hx">
		<extends path="flixel.graphics.tile.FlxDrawBaseItem"><c path="flixel.graphics.tile.FlxDrawTilesItem"/></extends>
		<drawData public="1" expr="[]">
			<c path="Array"><x path="Float"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</drawData>
		<position public="1" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</position>
		<numTiles public="1" get="accessor" set="null"><x path="Int"/></numTiles>
		<shader public="1"><t path="flixel.system.FlxShader"/></shader>
		<reset public="1" set="method" line="25" override="1"><f a=""><x path="Void"/></f></reset>
		<dispose public="1" set="method" line="32" override="1"><f a=""><x path="Void"/></f></dispose>
		<addQuad public="1" set="method" line="39" override="1"><f a="frame:matrix:?transform">
	<c path="flixel.graphics.frames.FlxFrame"/>
	<c path="flixel.math.FlxMatrix"/>
	<c path="openfl.geom.ColorTransform"/>
	<x path="Void"/>
</f></addQuad>
		<setNext get="inline" set="null" line="76"><f a="f">
	<x path="Float"/>
	<x path="Void"/>
</f></setNext>
		<render public="1" set="method" line="81" override="1"><f a="camera">
	<c path="flixel.FlxCamera"/>
	<x path="Void"/>
</f></render>
		<get_numTiles set="method" line="108"><f a=""><x path="Int"/></f></get_numTiles>
		<get_numVertices set="method" line="121" override="1"><f a=""><x path="Int"/></f></get_numVertices>
		<get_numTriangles set="method" line="126" override="1"><f a=""><x path="Int"/></f></get_numTriangles>
		<new public="1" set="method" line="19"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<typedef path="flixel.graphics.tile.DrawData" params="T" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/graphics/tile/FlxDrawTrianglesItem.hx" module="flixel.graphics.tile.FlxDrawTrianglesItem"><c path="Array"><c path="flixel.graphics.tile.DrawData.T"/></c></typedef>
	<class path="flixel.graphics.tile.FlxDrawTrianglesItem" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/graphics/tile/FlxDrawTrianglesItem.hx">
		<extends path="flixel.graphics.tile.FlxDrawBaseItem"><c path="flixel.graphics.tile.FlxDrawTrianglesItem"/></extends>
		<point expr="FlxPoint.get()" line="26" static="1">
			<c path="flixel.math.FlxPoint"/>
			<meta><m n=":value"><e>FlxPoint.get()</e></m></meta>
		</point>
		<rect expr="FlxRect.get()" line="27" static="1">
			<c path="flixel.math.FlxRect"/>
			<meta><m n=":value"><e>FlxRect.get()</e></m></meta>
		</rect>
		<inflateBounds public="1" get="inline" set="null" line="174" static="1"><f a="bounds:x:y">
	<c path="flixel.math.FlxRect"/>
	<x path="Float"/>
	<x path="Float"/>
	<c path="flixel.math.FlxRect"/>
</f></inflateBounds>
		<vertices public="1" expr="new DrawData&lt;Float&gt;()">
			<t path="flixel.graphics.tile.DrawData"><x path="Float"/></t>
			<meta><m n=":value"><e><![CDATA[new DrawData<Float>()]]></e></m></meta>
		</vertices>
		<indices public="1" expr="new DrawData&lt;Int&gt;()">
			<t path="flixel.graphics.tile.DrawData"><x path="Int"/></t>
			<meta><m n=":value"><e><![CDATA[new DrawData<Int>()]]></e></m></meta>
		</indices>
		<uvtData public="1" expr="new DrawData&lt;Float&gt;()">
			<t path="flixel.graphics.tile.DrawData"><x path="Float"/></t>
			<meta><m n=":value"><e><![CDATA[new DrawData<Float>()]]></e></m></meta>
		</uvtData>
		<colors public="1" expr="new DrawData&lt;Int&gt;()">
			<t path="flixel.graphics.tile.DrawData"><x path="Int"/></t>
			<meta><m n=":value"><e><![CDATA[new DrawData<Int>()]]></e></m></meta>
		</colors>
		<verticesPosition public="1" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</verticesPosition>
		<indicesPosition public="1" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</indicesPosition>
		<colorsPosition public="1" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</colorsPosition>
		<bounds expr="FlxRect.get()">
			<c path="flixel.math.FlxRect"/>
			<meta><m n=":value"><e>FlxRect.get()</e></m></meta>
		</bounds>
		<render public="1" set="method" line="46" override="1"><f a="camera">
	<c path="flixel.FlxCamera"/>
	<x path="Void"/>
</f></render>
		<reset public="1" set="method" line="73" override="1"><f a=""><x path="Void"/></f></reset>
		<dispose public="1" set="method" line="86" override="1"><f a=""><x path="Void"/></f></dispose>
		<addTriangles public="1" set="method" line="97"><f a="vertices:indices:uvtData:?colors:?position:?cameraBounds">
	<t path="flixel.graphics.tile.DrawData"><x path="Float"/></t>
	<t path="flixel.graphics.tile.DrawData"><x path="Int"/></t>
	<t path="flixel.graphics.tile.DrawData"><x path="Float"/></t>
	<t path="flixel.graphics.tile.DrawData"><x path="Int"/></t>
	<c path="flixel.math.FlxPoint"/>
	<c path="flixel.math.FlxRect"/>
	<x path="Void"/>
</f></addTriangles>
		<addQuad public="1" set="method" line="201" override="1"><f a="frame:matrix:?transform">
	<c path="flixel.graphics.frames.FlxFrame"/>
	<c path="flixel.math.FlxMatrix"/>
	<c path="openfl.geom.ColorTransform"/>
	<x path="Void"/>
</f></addQuad>
		<get_numVertices set="method" line="285" override="1"><f a=""><x path="Int"/></f></get_numVertices>
		<get_numTriangles set="method" line="290" override="1"><f a=""><x path="Int"/></f></get_numTriangles>
		<new public="1" set="method" line="40"><f a=""><x path="Void"/></f></new>
		<haxe_doc>* ...
 * @author Zaphod</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="openfl.display.Tilesheet" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/display/Tilesheet.hx">
		<TILE_SCALE public="1" get="inline" set="null" expr="0x0001" line="16" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x0001</e></m></meta>
		</TILE_SCALE>
		<TILE_ROTATION public="1" get="inline" set="null" expr="0x0002" line="17" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x0002</e></m></meta>
		</TILE_ROTATION>
		<TILE_RGB public="1" get="inline" set="null" expr="0x0004" line="18" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x0004</e></m></meta>
		</TILE_RGB>
		<TILE_ALPHA public="1" get="inline" set="null" expr="0x0008" line="19" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x0008</e></m></meta>
		</TILE_ALPHA>
		<TILE_TRANS_2x2 public="1" get="inline" set="null" expr="0x0010" line="20" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x0010</e></m></meta>
		</TILE_TRANS_2x2>
		<TILE_RECT public="1" get="inline" set="null" expr="0x0020" line="21" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x0020</e></m></meta>
		</TILE_RECT>
		<TILE_ORIGIN public="1" get="inline" set="null" expr="0x0040" line="22" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x0040</e></m></meta>
		</TILE_ORIGIN>
		<TILE_TRANS_COLOR public="1" get="inline" set="null" expr="0x0080" line="23" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x0080</e></m></meta>
		</TILE_TRANS_COLOR>
		<TILE_BLEND_NORMAL public="1" get="inline" set="null" expr="0x00000000" line="25" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x00000000</e></m></meta>
		</TILE_BLEND_NORMAL>
		<TILE_BLEND_ADD public="1" get="inline" set="null" expr="0x00010000" line="26" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x00010000</e></m></meta>
		</TILE_BLEND_ADD>
		<TILE_BLEND_MULTIPLY public="1" get="inline" set="null" expr="0x00020000" line="27" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x00020000</e></m></meta>
		</TILE_BLEND_MULTIPLY>
		<TILE_BLEND_SCREEN public="1" get="inline" set="null" expr="0x00040000" line="28" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x00040000</e></m></meta>
		</TILE_BLEND_SCREEN>
		<TILE_BLEND_SUBTRACT public="1" get="inline" set="null" expr="0x00080000" line="29" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x00080000</e></m></meta>
		</TILE_BLEND_SUBTRACT>
		<TILE_BLEND_DARKEN public="1" get="inline" set="null" expr="0x00100000" line="30" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x00100000</e></m></meta>
		</TILE_BLEND_DARKEN>
		<TILE_BLEND_LIGHTEN public="1" get="inline" set="null" expr="0x00200000" line="31" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x00200000</e></m></meta>
		</TILE_BLEND_LIGHTEN>
		<TILE_BLEND_OVERLAY public="1" get="inline" set="null" expr="0x00400000" line="32" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x00400000</e></m></meta>
		</TILE_BLEND_OVERLAY>
		<TILE_BLEND_HARDLIGHT public="1" get="inline" set="null" expr="0x00800000" line="33" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x00800000</e></m></meta>
		</TILE_BLEND_HARDLIGHT>
		<TILE_BLEND_DIFFERENCE public="1" get="inline" set="null" expr="0x01000000" line="34" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x01000000</e></m></meta>
		</TILE_BLEND_DIFFERENCE>
		<TILE_BLEND_INVERT public="1" get="inline" set="null" expr="0x02000000" line="35" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x02000000</e></m></meta>
		</TILE_BLEND_INVERT>
		<__defaultPoint expr="new Point(0, 0)" line="37" static="1">
			<c path="openfl.geom.Point"/>
			<meta>
				<m n=":value"><e>new Point(0, 0)</e></m>
				<m n=":noCompletion"/>
			</meta>
		</__defaultPoint>
		<__bitmap>
			<c path="openfl.display.BitmapData"/>
			<meta><m n=":noCompletion"/></meta>
		</__bitmap>
		<__centerPoints>
			<c path="Array"><c path="openfl.geom.Point"/></c>
			<meta><m n=":noCompletion"/></meta>
		</__centerPoints>
		<__tileRects>
			<c path="Array"><c path="openfl.geom.Rectangle"/></c>
			<meta><m n=":noCompletion"/></meta>
		</__tileRects>
		<__tileUVs>
			<c path="Array"><c path="openfl.geom.Rectangle"/></c>
			<meta><m n=":noCompletion"/></meta>
		</__tileUVs>
		<__rectTile>
			<c path="openfl.geom.Rectangle"/>
			<meta><m n=":noCompletion"/></meta>
		</__rectTile>
		<__rectUV>
			<c path="openfl.geom.Rectangle"/>
			<meta><m n=":noCompletion"/></meta>
		</__rectUV>
		<__point>
			<c path="openfl.geom.Point"/>
			<meta><m n=":noCompletion"/></meta>
		</__point>
		<addTileRect public="1" set="method" line="89">
			<f a="rectangle:?centerPoint" v=":null">
				<c path="openfl.geom.Rectangle"/>
				<c path="openfl.geom.Point"/>
				<x path="Int"/>
			</f>
			<meta><m n=":value"><e>{ centerPoint : null }</e></m></meta>
			<haxe_doc>* Adds an single tile to this TileSheet
	 * @param	rectangle a rectangle defining the dimensions and positioning of a new tile
	 * @param	centerPoint if set, will act as the translation point of the tile, default: top-left corner
	 * @return an Int representing the id of a single tile rect</haxe_doc>
		</addTileRect>
		<drawTiles public="1" set="method" line="193">
			<f a="graphics:tileData:?smooth:?flags:?count" v="::false:0:-1">
				<c path="openfl.display.Graphics"/>
				<c path="Array"><x path="Float"/></c>
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ count : -1, flags : 0, smooth : false }</e></m></meta>
			<haxe_doc><![CDATA[* Draws tiles to a give Graphic Object
	 * @param	graphics the "Graphics" object to draw tiles to
	 * @param	tileData an Array<Float>(3) denoting the X position, Y position, and tile to render repsectively
	 * @param	smooth whether to smooth the tile or not
	 * @param	flags
	 * @param	count]]></haxe_doc>
		</drawTiles>
		<getTileCenter public="1" get="inline" set="null" line="199"><f a="index">
	<x path="Int"/>
	<c path="openfl.geom.Point"/>
</f></getTileCenter>
		<getTileRect public="1" get="inline" set="null" line="206"><f a="index">
	<x path="Int"/>
	<c path="openfl.geom.Rectangle"/>
</f></getTileRect>
		<getTileUVs public="1" get="inline" set="null" line="213"><f a="index">
	<x path="Int"/>
	<c path="openfl.geom.Rectangle"/>
</f></getTileUVs>
		<new public="1" set="method" line="61">
			<f a="image">
				<c path="openfl.display.BitmapData"/>
				<x path="Void"/>
			</f>
			<haxe_doc>*Creates new TileSheet Object
	 * @param	image a bitmap data to create tiles from</haxe_doc>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":allow"><e>openfl.display.Graphics</e></m>
		</meta>
	</class>
	<class path="flixel.graphics.tile.FlxTilesheet" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/graphics/tile/FlxTilesheet.hx">
		<extends path="openfl.display.Tilesheet"/>
		<_DRAWCALLS public="1" expr="0" line="10" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* Tracks total number of `drawTiles()` calls made each frame.</haxe_doc>
		</_DRAWCALLS>
		<new public="1" set="method" line="5"><f a="image">
	<c path="openfl.display.BitmapData"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<typedef path="flixel.group.FlxGroup" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/group/FlxGroup.hx"><c path="flixel.group.FlxTypedGroup"><c path="flixel.FlxBasic"/></c></typedef>
	<class path="flixel.group.FlxTypedGroupIterator" params="T" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/group/FlxGroup.hx" module="flixel.group.FlxGroup">
		<_groupMembers><c path="Array"><c path="flixel.group.FlxTypedGroupIterator.T"/></c></_groupMembers>
		<_filter><f a="">
	<c path="flixel.group.FlxTypedGroupIterator.T"/>
	<x path="Bool"/>
</f></_filter>
		<_cursor><x path="Int"/></_cursor>
		<_length><x path="Int"/></_length>
		<next public="1" set="method" line="841"><f a=""><t path="Null"><c path="flixel.group.FlxTypedGroupIterator.T"/></t></f></next>
		<hasNext public="1" set="method" line="846"><f a=""><x path="Bool"/></f></hasNext>
		<new public="1" set="method" line="833"><f a="GroupMembers:?filter">
	<c path="Array"><c path="flixel.group.FlxTypedGroupIterator.T"/></c>
	<f a="">
		<c path="flixel.group.FlxTypedGroupIterator.T"/>
		<x path="Bool"/>
	</f>
	<x path="Void"/>
</f></new>
		<haxe_doc>* Iterator implementation for groups
 * Support a filter method (used for iteratorAlive, iteratorDead and iteratorExists)
 * @author Masadow</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<typedef path="flixel.group.FlxSpriteGroup" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/group/FlxSpriteGroup.hx"><c path="flixel.group.FlxTypedSpriteGroup"><c path="flixel.FlxSprite"/></c></typedef>
	<class path="flixel.group.FlxTypedSpriteGroup" params="T" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/group/FlxSpriteGroup.hx" module="flixel.group.FlxSpriteGroup">
		<extends path="flixel.FlxSprite"/>
		<group public="1">
			<c path="flixel.group.FlxTypedGroup"><c path="flixel.group.FlxTypedSpriteGroup.T"/></c>
			<haxe_doc>* The actual group which holds all sprites.</haxe_doc>
		</group>
		<members public="1" get="accessor" set="null">
			<c path="Array"><c path="flixel.group.FlxTypedSpriteGroup.T"/></c>
			<haxe_doc>* The link to a group's `members` array.</haxe_doc>
		</members>
		<length public="1" get="accessor" set="null">
			<x path="Int"/>
			<haxe_doc>* The number of entries in the members array. For performance and safety you should check this
	 * variable instead of `members.length` unless you really know what you're doing!</haxe_doc>
		</length>
		<maxSize public="1" get="accessor" set="accessor">
			<x path="Int"/>
			<haxe_doc>* The maximum capacity of this group. Default is `0`, meaning no max capacity, and the group can just grow.</haxe_doc>
		</maxSize>
		<_skipTransformChildren expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
			<haxe_doc>* Optimization to allow setting position of group without transforming children twice.</haxe_doc>
		</_skipTransformChildren>
		<_sprites>
			<c path="Array"><c path="flixel.FlxSprite"/></c>
			<haxe_doc>* Array of all the `FlxSprite`s that exist in this group for
	 * optimization purposes / static typing on cpp targets.</haxe_doc>
		</_sprites>
		<initVars set="method" line="77" override="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* This method is used for initialization of variables of complex types.
	 * Don't forget to call `super.initVars()` if you'll override this method,
	 * or you'll get `null` object error and app will crash.</haxe_doc>
		</initVars>
		<destroy public="1" set="method" line="98" override="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Handy function for "killing" game objects. Use `reset()` to revive them.
	 * Default behavior is to flag them as nonexistent AND dead.
	 * However, if you want the "corpse" to remain in the game, like to animate an effect or whatever,
	 * you should `override` this, setting only `alive` to `false`, and leaving `exists` `true`.</haxe_doc>
		</destroy>
		<clone public="1" set="method" line="117" override="1">
			<f a=""><c path="flixel.group.FlxTypedSpriteGroup"><c path="flixel.group.FlxTypedSpriteGroup.T"/></c></f>
			<haxe_doc>* Recursive cloning method: it will create a copy of this group which will hold copies of all sprites
	 * 
	 * @return  copy of this sprite group</haxe_doc>
		</clone>
		<isOnScreen public="1" set="method" line="136" override="1">
			<f a="?Camera">
				<c path="flixel.FlxCamera"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Check and see if any sprite in this group is currently on screen.
	 * 
	 * @param   Camera   Specify which game camera you want. If `null`, it will just grab the first global camera.
	 * @return  Whether the object is on screen or not.</haxe_doc>
		</isOnScreen>
		<overlapsPoint public="1" set="method" line="155" override="1">
			<f a="point:?InScreenSpace:?Camera" v=":false:">
				<c path="flixel.math.FlxPoint"/>
				<x path="Bool"/>
				<c path="flixel.FlxCamera"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":value"><e>{ InScreenSpace : false }</e></m></meta>
			<haxe_doc>* Checks to see if a point in 2D world space overlaps any `FlxSprite` object from this group.
	 * 
	 * @param   Point           The point in world space you want to check.
	 * @param   InScreenSpace   Whether to take scroll factors into account when checking for overlap.
	 * @param   Camera          Specify which game camera you want. If `null`, it will just grab the first global camera.
	 * @return  Whether or not the point overlaps this group.</haxe_doc>
		</overlapsPoint>
		<pixelsOverlapPoint public="1" set="method" line="178" override="1">
			<f a="point:?Mask:?Camera" v=":0xFF:">
				<c path="flixel.math.FlxPoint"/>
				<x path="Int"/>
				<c path="flixel.FlxCamera"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":value"><e>{ Mask : 0xFF }</e></m></meta>
			<haxe_doc>* Checks to see if a point in 2D world space overlaps any of FlxSprite object's current displayed pixels.
	 * This check is ALWAYS made in screen space, and always takes scroll factors into account.
	 * 
	 * @param   Point    The point in world space you want to check.
	 * @param   Mask     Used in the pixel hit test to determine what counts as solid.
	 * @param   Camera   Specify which game camera you want.  If `null`, it will just grab the first global camera.
	 * @return  Whether or not the point overlaps this object.</haxe_doc>
		</pixelsOverlapPoint>
		<update public="1" set="method" line="192" override="1"><f a="elapsed">
	<x path="Float"/>
	<x path="Void"/>
</f></update>
		<draw public="1" set="method" line="200" override="1"><f a=""><x path="Void"/></f></draw>
		<replaceColor public="1" set="method" line="219" override="1">
			<f a="Color:NewColor:?FetchPositions" v="::false">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
				<c path="Array"><c path="flixel.math.FlxPoint"/></c>
			</f>
			<meta><m n=":value"><e>{ FetchPositions : false }</e></m></meta>
			<haxe_doc>* Replaces all pixels with specified `Color` with `NewColor` pixels.
	 * WARNING: very expensive (especially on big graphics) as it iterates over every single pixel.
	 * 
	 * @param   Color            Color to replace
	 * @param   NewColor         New color
	 * @param   FetchPositions   Whether we need to store positions of pixels which colors were replaced.
	 * @return  `Array` with replaced pixels positions</haxe_doc>
		</replaceColor>
		<add public="1" set="method" line="249">
			<f a="Sprite">
				<c path="flixel.group.FlxTypedSpriteGroup.T"/>
				<c path="flixel.group.FlxTypedSpriteGroup.T"/>
			</f>
			<haxe_doc>* Adds a new `FlxSprite` subclass to the group.
	 * 
	 * @param   Sprite   The sprite or sprite group you want to add to the group.
	 * @return  The same object that was passed in.</haxe_doc>
		</add>
		<insert public="1" set="method" line="264">
			<f a="Position:Sprite">
				<x path="Int"/>
				<c path="flixel.group.FlxTypedSpriteGroup.T"/>
				<c path="flixel.group.FlxTypedSpriteGroup.T"/>
			</f>
			<haxe_doc>* Inserts a new `FlxSprite` subclass to the group at the specified position.
	 * 
	 * @param   Position The position that the new sprite or sprite group should be inserted at.
	 * @param   Sprite   The sprite or sprite group you want to insert into the group.
	 * @return  The same object that was passed in.
	 *
	 * @since 4.3.0</haxe_doc>
		</insert>
		<preAdd set="method" line="276">
			<f a="Sprite">
				<c path="flixel.group.FlxTypedSpriteGroup.T"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Adjusts the position and other properties of the soon-to-be child of this sprite group.
	 * Private helper to avoid duplicate code in `add()` and `insert()`.
	 * 
	 * @param	Sprite	The sprite or sprite group that is about to be added or inserted into the group.</haxe_doc>
		</preAdd>
		<recycle public="1" get="inline" set="null" line="313">
			<f a="?ObjectClass:?ObjectFactory:?Force" v="::false">
				<x path="Class"><c path="flixel.group.FlxTypedSpriteGroup.T"/></x>
				<f a=""><c path="flixel.group.FlxTypedSpriteGroup.T"/></f>
				<x path="Bool"/>
				<c path="flixel.group.FlxTypedSpriteGroup.T"/>
			</f>
			<meta><m n=":value"><e>{ Force : false }</e></m></meta>
			<haxe_doc><![CDATA[* Recycling is designed to help you reuse game objects without always re-allocating or "newing" them.
	 * It behaves differently depending on whether `maxSize` equals `0` or is bigger than `0`.
	 * 
	 * `maxSize > 0` / "rotating-recycling" (used by `FlxEmitter`):
	 *   - at capacity:  returns the next object in line, no matter its properties like `alive`, `exists` etc.
	 *   - otherwise:    returns a new object.
	 * 
	 * `maxSize == 0` / "grow-style-recycling"
	 *   - tries to find the first object with `exists == false`
	 *   - otherwise: adds a new object to the `members` array
	 *
	 * WARNING: If this function needs to create a new object, and no object class was provided,
	 * it will return `null` instead of a valid object!
	 * 
	 * @param   ObjectClass     The class type you want to recycle (e.g. `FlxSprite`, `EvilRobot`, etc).
	 * @param   ObjectFactory   Optional factory function to create a new object
	 *                          if there aren't any dead members to recycle.
	 *                          If `null`, `Type.createInstance()` is used,
	 *                          which requires the class to have no constructor parameters.
	 * @param   Force           Force the object to be an `ObjectClass` and not a super class of `ObjectClass`.
	 * @param   Revive          Whether recycled members should automatically be revived
	 *                          (by calling `revive()` on them).
	 * @return  A reference to the object that was created.]]></haxe_doc>
		</recycle>
		<remove public="1" set="method" line="325">
			<f a="Sprite:?Splice" v=":false">
				<c path="flixel.group.FlxTypedSpriteGroup.T"/>
				<x path="Bool"/>
				<c path="flixel.group.FlxTypedSpriteGroup.T"/>
			</f>
			<meta><m n=":value"><e>{ Splice : false }</e></m></meta>
			<haxe_doc>* Removes the specified sprite from the group.
	 * 
	 * @param   Sprite   The `FlxSprite` you want to remove.
	 * @param   Splice   Whether the object should be cut from the array entirely or not.
	 * @return  The removed sprite.</haxe_doc>
		</remove>
		<replace public="1" get="inline" set="null" line="342">
			<f a="OldObject:NewObject">
				<c path="flixel.group.FlxTypedSpriteGroup.T"/>
				<c path="flixel.group.FlxTypedSpriteGroup.T"/>
				<c path="flixel.group.FlxTypedSpriteGroup.T"/>
			</f>
			<haxe_doc>* Replaces an existing `FlxSprite` with a new one.
	 * 
	 * @param   OldObject   The sprite you want to replace.
	 * @param   NewObject   The new object you want to use instead.
	 * @return  The new sprite.</haxe_doc>
		</replace>
		<sort public="1" get="inline" set="null" line="357">
			<f a="Function:?Order" v=":FlxSort.ASCENDING">
				<f a="::">
					<x path="Int"/>
					<c path="flixel.group.FlxTypedSpriteGroup.T"/>
					<c path="flixel.group.FlxTypedSpriteGroup.T"/>
					<x path="Int"/>
				</f>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ Order : FlxSort.ASCENDING }</e></m></meta>
			<haxe_doc>* Call this function to sort the group according to a particular value and order.
	 * For example, to sort game objects for Zelda-style overlaps you might call
	 * `group.sort(FlxSort.byY, FlxSort.ASCENDING)` at the bottom of your `FlxState#update()` override.
	 * 
	 * @param   Function   The sorting function to use - you can use one of the premade ones in
	 *                     `FlxSort` or write your own using `FlxSort.byValues()` as a "backend".
	 * @param   Order      A constant that defines the sort order.
	 *                     Possible values are `FlxSort.ASCENDING` (default) and `FlxSort.DESCENDING`.</haxe_doc>
		</sort>
		<getFirstAvailable public="1" get="inline" set="null" line="371">
			<f a="?ObjectClass:?Force" v=":false">
				<x path="Class"><c path="flixel.group.FlxTypedSpriteGroup.T"/></x>
				<x path="Bool"/>
				<c path="flixel.group.FlxTypedSpriteGroup.T"/>
			</f>
			<meta><m n=":value"><e>{ Force : false }</e></m></meta>
			<haxe_doc>* Call this function to retrieve the first object with `exists == false` in the group.
	 * This is handy for recycling in general, e.g. respawning enemies.
	 * 
	 * @param   ObjectClass   An optional parameter that lets you narrow the
	 *                        results to instances of this particular class.
	 * @param   Force         Force the object to be an `ObjectClass` and not a super class of `ObjectClass`.
	 * @return  A `FlxSprite` currently flagged as not existing.</haxe_doc>
		</getFirstAvailable>
		<getFirstNull public="1" get="inline" set="null" line="382">
			<f a=""><x path="Int"/></f>
			<haxe_doc>* Call this function to retrieve the first index set to `null`.
	 * Returns `-1` if no index stores a `null` object.
	 * 
	 * @return  An `Int` indicating the first `null` slot in the group.</haxe_doc>
		</getFirstNull>
		<getFirstExisting public="1" get="inline" set="null" line="393">
			<f a=""><c path="flixel.group.FlxTypedSpriteGroup.T"/></f>
			<haxe_doc>* Call this function to retrieve the first object with `exists == true` in the group.
	 * This is handy for checking if everything's wiped out, or choosing a squad leader, etc.
	 * 
	 * @return  A `FlxSprite` currently flagged as existing.</haxe_doc>
		</getFirstExisting>
		<getFirstAlive public="1" get="inline" set="null" line="404">
			<f a=""><c path="flixel.group.FlxTypedSpriteGroup.T"/></f>
			<haxe_doc>* Call this function to retrieve the first object with `dead == false` in the group.
	 * This is handy for checking if everything's wiped out, or choosing a squad leader, etc.
	 * 
	 * @return  A `FlxSprite` currently flagged as not dead.</haxe_doc>
		</getFirstAlive>
		<getFirstDead public="1" get="inline" set="null" line="415">
			<f a=""><c path="flixel.group.FlxTypedSpriteGroup.T"/></f>
			<haxe_doc>* Call this function to retrieve the first object with `dead == true` in the group.
	 * This is handy for checking if everything's wiped out, or choosing a squad leader, etc.
	 * 
	 * @return  A `FlxSprite` currently flagged as dead.</haxe_doc>
		</getFirstDead>
		<countLiving public="1" get="inline" set="null" line="425">
			<f a=""><x path="Int"/></f>
			<haxe_doc>* Call this function to find out how many members of the group are not dead.
	 * 
	 * @return  The number of `FlxSprite`s flagged as not dead. Returns `-1` if group is empty.</haxe_doc>
		</countLiving>
		<countDead public="1" get="inline" set="null" line="435">
			<f a=""><x path="Int"/></f>
			<haxe_doc>* Call this function to find out how many members of the group are dead.
	 * 
	 * @return  The number of `FlxSprite`s flagged as dead. Returns `-1` if group is empty.</haxe_doc>
		</countDead>
		<getRandom public="1" get="inline" set="null" line="448">
			<f a="?StartIndex:?Length" v="0:0">
				<x path="Int"/>
				<x path="Int"/>
				<c path="flixel.group.FlxTypedSpriteGroup.T"/>
			</f>
			<meta><m n=":value"><e>{ Length : 0, StartIndex : 0 }</e></m></meta>
			<haxe_doc>* Returns a member at random from the group.
	 * 
	 * @param   StartIndex  Optional offset off the front of the array.
	 *                      Default value is `0`, or the beginning of the array.
	 * @param   Length      Optional restriction on the number of values you want to randomly select from.
	 * @return  A `FlxSprite` from the `members` list.</haxe_doc>
		</getRandom>
		<iterator public="1" get="inline" set="null" line="458">
			<f a="?filter">
				<f a="">
					<c path="flixel.group.FlxTypedSpriteGroup.T"/>
					<x path="Bool"/>
				</f>
				<c path="flixel.group.FlxTypedGroupIterator"><c path="flixel.group.FlxTypedSpriteGroup.T"/></c>
			</f>
			<haxe_doc>* Iterate through every member
	 * 
	 * @return An iterator</haxe_doc>
		</iterator>
		<forEach public="1" get="inline" set="null" line="469">
			<f a="Function:?Recurse" v=":false">
				<f a="">
					<c path="flixel.group.FlxTypedSpriteGroup.T"/>
					<x path="Void"/>
				</f>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ Recurse : false }</e></m></meta>
			<haxe_doc>* Applies a function to all members.
	 * 
	 * @param   Function   A function that modifies one element at a time.
	 * @param   Recurse    Whether or not to apply the function to members of subgroups as well.</haxe_doc>
		</forEach>
		<forEachAlive public="1" get="inline" set="null" line="480">
			<f a="Function:?Recurse" v=":false">
				<f a="">
					<c path="flixel.group.FlxTypedSpriteGroup.T"/>
					<x path="Void"/>
				</f>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ Recurse : false }</e></m></meta>
			<haxe_doc>* Applies a function to all `alive` members.
	 * 
	 * @param   Function   A function that modifies one element at a time.
	 * @param   Recurse    Whether or not to apply the function to members of subgroups as well.</haxe_doc>
		</forEachAlive>
		<forEachDead public="1" get="inline" set="null" line="491">
			<f a="Function:?Recurse" v=":false">
				<f a="">
					<c path="flixel.group.FlxTypedSpriteGroup.T"/>
					<x path="Void"/>
				</f>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ Recurse : false }</e></m></meta>
			<haxe_doc>* Applies a function to all dead members.
	 * 
	 * @param   Function   A function that modifies one element at a time.
	 * @param   Recurse    Whether or not to apply the function to members of subgroups as well.</haxe_doc>
		</forEachDead>
		<forEachExists public="1" get="inline" set="null" line="502">
			<f a="Function:?Recurse" v=":false">
				<f a="">
					<c path="flixel.group.FlxTypedSpriteGroup.T"/>
					<x path="Void"/>
				</f>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ Recurse : false }</e></m></meta>
			<haxe_doc>* Applies a function to all existing members.
	 * 
	 * @param   Function   A function that modifies one element at a time.
	 * @param   Recurse    Whether or not to apply the function to members of subgroups as well.</haxe_doc>
		</forEachExists>
		<forEachOfType public="1" params="K" get="inline" set="null" line="514">
			<f a="ObjectClass:Function:?Recurse" v="::false">
				<x path="Class"><c path="forEachOfType.K"/></x>
				<f a="">
					<c path="forEachOfType.K"/>
					<x path="Void"/>
				</f>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ Recurse : false }</e></m></meta>
			<haxe_doc><![CDATA[* Applies a function to all members of type `Class<K>`.
	 * 
	 * @param   ObjectClass   A class that objects will be checked against before Function is applied, ex: `FlxSprite`.
	 * @param   Function      A function that modifies one element at a time.
	 * @param   Recurse       Whether or not to apply the function to members of subgroups as well.]]></haxe_doc>
		</forEachOfType>
		<clear public="1" get="inline" set="null" line="523">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Remove all instances of `FlxSprite` from the list.
	 * WARNING: does not `destroy()` or `kill()` any of these objects!</haxe_doc>
		</clear>
		<kill public="1" set="method" line="532" override="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Calls `kill()` on the group's members and then on the group itself.
	 * You can revive this group later via `revive()` after this.</haxe_doc>
		</kill>
		<revive public="1" set="method" line="541" override="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Revives the group.</haxe_doc>
		</revive>
		<reset public="1" set="method" line="547" override="1"><f a="X:Y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></reset>
		<setPosition public="1" set="method" line="568" override="1">
			<f a="?X:?Y" v="0:0">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ Y : 0, X : 0 }</e></m></meta>
			<haxe_doc>* Helper function to set the coordinates of this object.
	 * Handy since it only requires one line of code.
	 * 
	 * @param   X   The new x position
	 * @param   Y   The new y position</haxe_doc>
		</setPosition>
		<transformChildren public="1" params="V" set="method" line="590">
			<f a="Function:Value">
				<f a=":">
					<c path="flixel.group.FlxTypedSpriteGroup.T"/>
					<c path="transformChildren.V"/>
					<x path="Void"/>
				</f>
				<c path="transformChildren.V"/>
				<x path="Void"/>
			</f>
			<meta><m n=":generic"/></meta>
			<haxe_doc>* Handy function that allows you to quickly transform one property of sprites in this group at a time.
	 * 
	 * @param   Function   Function to transform the sprites. Example:
	 *                     `function(sprite, v:Dynamic) { s.acceleration.x = v; s.makeGraphic(10,10,0xFF000000); }`
	 * @param   Value      Value which will passed to lambda function.</haxe_doc>
		</transformChildren>
		<multiTransformChildren public="1" params="V" set="method" line="609">
			<f a="FunctionArray:ValueArray">
				<c path="Array"><f a=":">
	<c path="flixel.group.FlxTypedSpriteGroup.T"/>
	<c path="multiTransformChildren.V"/>
	<x path="Void"/>
</f></c>
				<c path="Array"><c path="multiTransformChildren.V"/></c>
				<x path="Void"/>
			</f>
			<meta><m n=":generic"/></meta>
			<haxe_doc>* Handy function that allows you to quickly transform multiple properties of sprites in this group at a time.
	 * 
	 * @param   FunctionArray   `Array` of functions to transform sprites in this group.
	 * @param   ValueArray      `Array` of values which will be passed to lambda functions</haxe_doc>
		</multiTransformChildren>
		<set_cameras set="method" line="634" override="1"><f a="Value">
	<c path="Array"><c path="flixel.FlxCamera"/></c>
	<c path="Array"><c path="flixel.FlxCamera"/></c>
</f></set_cameras>
		<set_exists set="method" line="641" override="1"><f a="Value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_exists>
		<set_visible set="method" line="648" override="1"><f a="Value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_visible>
		<set_active set="method" line="655" override="1"><f a="Value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_active>
		<set_alive set="method" line="662" override="1"><f a="Value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_alive>
		<set_x set="method" line="669" override="1"><f a="Value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_x>
		<set_y set="method" line="680" override="1"><f a="Value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_y>
		<set_angle set="method" line="691" override="1"><f a="Value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_angle>
		<set_alpha set="method" line="701" override="1"><f a="Value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_alpha>
		<set_facing set="method" line="713" override="1"><f a="Value">
	<x path="Int"/>
	<x path="Int"/>
</f></set_facing>
		<set_flipX set="method" line="720" override="1"><f a="Value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_flipX>
		<set_flipY set="method" line="727" override="1"><f a="Value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_flipY>
		<set_moves set="method" line="734" override="1"><f a="Value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_moves>
		<set_immovable set="method" line="741" override="1"><f a="Value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_immovable>
		<set_solid set="method" line="748" override="1"><f a="Value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_solid>
		<set_color set="method" line="755" override="1"><f a="Value">
	<x path="Int"/>
	<x path="Int"/>
</f></set_color>
		<set_blend set="method" line="762" override="1"><f a="Value">
	<t path="flash.display.BlendMode"/>
	<t path="flash.display.BlendMode"/>
</f></set_blend>
		<set_clipRect set="method" line="769" override="1"><f a="rect">
	<c path="flixel.math.FlxRect"/>
	<c path="flixel.math.FlxRect"/>
</f></set_clipRect>
		<set_pixelPerfectRender set="method" line="776" override="1"><f a="Value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_pixelPerfectRender>
		<set_width set="method" line="786" override="1">
			<f a="Value">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>* This functionality isn't supported in SpriteGroup</haxe_doc>
		</set_width>
		<get_width set="method" line="791" override="1"><f a=""><x path="Float"/></f></get_width>
		<set_height set="method" line="816" override="1">
			<f a="Value">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>* This functionality isn't supported in SpriteGroup</haxe_doc>
		</set_height>
		<get_height set="method" line="821" override="1"><f a=""><x path="Float"/></f></get_height>
		<get_length get="inline" set="null" line="847"><f a=""><x path="Int"/></f></get_length>
		<get_maxSize get="inline" set="null" line="852"><f a=""><x path="Int"/></f></get_maxSize>
		<set_maxSize get="inline" set="null" line="857"><f a="Size">
	<x path="Int"/>
	<x path="Int"/>
</f></set_maxSize>
		<get_members get="inline" set="null" line="862"><f a=""><c path="Array"><c path="flixel.group.FlxTypedSpriteGroup.T"/></c></f></get_members>
		<xTransform get="inline" set="null" line="869"><f a="Sprite:X">
	<c path="flixel.FlxSprite"/>
	<x path="Float"/>
	<x path="Void"/>
</f></xTransform>
		<yTransform get="inline" set="null" line="870"><f a="Sprite:Y">
	<c path="flixel.FlxSprite"/>
	<x path="Float"/>
	<x path="Void"/>
</f></yTransform>
		<angleTransform get="inline" set="null" line="871"><f a="Sprite:Angle">
	<c path="flixel.FlxSprite"/>
	<x path="Float"/>
	<x path="Void"/>
</f></angleTransform>
		<alphaTransform get="inline" set="null" line="872"><f a="Sprite:Alpha">
	<c path="flixel.FlxSprite"/>
	<x path="Float"/>
	<x path="Void"/>
</f></alphaTransform>
		<facingTransform get="inline" set="null" line="873"><f a="Sprite:Facing">
	<c path="flixel.FlxSprite"/>
	<x path="Int"/>
	<x path="Void"/>
</f></facingTransform>
		<flipXTransform get="inline" set="null" line="874"><f a="Sprite:FlipX">
	<c path="flixel.FlxSprite"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></flipXTransform>
		<flipYTransform get="inline" set="null" line="875"><f a="Sprite:FlipY">
	<c path="flixel.FlxSprite"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></flipYTransform>
		<movesTransform get="inline" set="null" line="876"><f a="Sprite:Moves">
	<c path="flixel.FlxSprite"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></movesTransform>
		<pixelPerfectTransform get="inline" set="null" line="877"><f a="Sprite:PixelPerfect">
	<c path="flixel.FlxSprite"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></pixelPerfectTransform>
		<gColorTransform get="inline" set="null" line="878"><f a="Sprite:Color">
	<c path="flixel.FlxSprite"/>
	<x path="Int"/>
	<x path="Void"/>
</f></gColorTransform>
		<blendTransform get="inline" set="null" line="879"><f a="Sprite:Blend">
	<c path="flixel.FlxSprite"/>
	<t path="flash.display.BlendMode"/>
	<x path="Void"/>
</f></blendTransform>
		<immovableTransform get="inline" set="null" line="880"><f a="Sprite:Immovable">
	<c path="flixel.FlxSprite"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></immovableTransform>
		<visibleTransform get="inline" set="null" line="881"><f a="Sprite:Visible">
	<c path="flixel.FlxSprite"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></visibleTransform>
		<activeTransform get="inline" set="null" line="882"><f a="Sprite:Active">
	<c path="flixel.FlxSprite"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></activeTransform>
		<solidTransform get="inline" set="null" line="883"><f a="Sprite:Solid">
	<c path="flixel.FlxSprite"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></solidTransform>
		<aliveTransform get="inline" set="null" line="884"><f a="Sprite:Alive">
	<c path="flixel.FlxSprite"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></aliveTransform>
		<existsTransform get="inline" set="null" line="885"><f a="Sprite:Exists">
	<c path="flixel.FlxSprite"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></existsTransform>
		<camerasTransform get="inline" set="null" line="886"><f a="Sprite:Cameras">
	<c path="flixel.FlxSprite"/>
	<c path="Array"><c path="flixel.FlxCamera"/></c>
	<x path="Void"/>
</f></camerasTransform>
		<offsetTransform get="inline" set="null" line="888"><f a="Sprite:Offset">
	<c path="flixel.FlxSprite"/>
	<c path="flixel.math.FlxPoint"/>
	<x path="Void"/>
</f></offsetTransform>
		<originTransform get="inline" set="null" line="889"><f a="Sprite:Origin">
	<c path="flixel.FlxSprite"/>
	<c path="flixel.math.FlxPoint"/>
	<x path="Void"/>
</f></originTransform>
		<scaleTransform get="inline" set="null" line="890"><f a="Sprite:Scale">
	<c path="flixel.FlxSprite"/>
	<c path="flixel.math.FlxPoint"/>
	<x path="Void"/>
</f></scaleTransform>
		<scrollFactorTransform get="inline" set="null" line="891"><f a="Sprite:ScrollFactor">
	<c path="flixel.FlxSprite"/>
	<c path="flixel.math.FlxPoint"/>
	<x path="Void"/>
</f></scrollFactorTransform>
		<clipRectTransform get="inline" set="null" line="893"><f a="Sprite:ClipRect">
	<c path="flixel.FlxSprite"/>
	<c path="flixel.math.FlxRect"/>
	<x path="Void"/>
</f></clipRectTransform>
		<offsetCallback get="inline" set="null" line="900"><f a="Offset">
	<c path="flixel.math.FlxPoint"/>
	<x path="Void"/>
</f></offsetCallback>
		<originCallback get="inline" set="null" line="901"><f a="Origin">
	<c path="flixel.math.FlxPoint"/>
	<x path="Void"/>
</f></originCallback>
		<scaleCallback get="inline" set="null" line="902"><f a="Scale">
	<c path="flixel.math.FlxPoint"/>
	<x path="Void"/>
</f></scaleCallback>
		<scrollFactorCallback get="inline" set="null" line="903"><f a="ScrollFactor">
	<c path="flixel.math.FlxPoint"/>
	<x path="Void"/>
</f></scrollFactorCallback>
		<loadGraphicFromSprite public="1" set="method" line="912" override="1">
			<f a="Sprite">
				<c path="flixel.FlxSprite"/>
				<c path="flixel.FlxSprite"/>
			</f>
			<haxe_doc>* This functionality isn't supported in SpriteGroup
	 * @return this sprite group</haxe_doc>
		</loadGraphicFromSprite>
		<loadGraphic public="1" set="method" line="924" override="1">
			<f a="Graphic:?Animated:?Width:?Height:?Unique:?Key" v=":false:0:0:false:">
				<t path="flixel.system.FlxGraphicAsset"/>
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
				<c path="String"/>
				<c path="flixel.FlxSprite"/>
			</f>
			<meta><m n=":value"><e>{ Unique : false, Height : 0, Width : 0, Animated : false }</e></m></meta>
			<haxe_doc>* This functionality isn't supported in SpriteGroup
	 * @return this sprite group</haxe_doc>
		</loadGraphic>
		<loadRotatedGraphic public="1" set="method" line="934" override="1">
			<f a="Graphic:?Rotations:?Frame:?AntiAliasing:?AutoBuffer:?Key" v=":16:-1:false:false:">
				<t path="flixel.system.FlxGraphicAsset"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<c path="String"/>
				<c path="flixel.FlxSprite"/>
			</f>
			<meta><m n=":value"><e>{ AutoBuffer : false, AntiAliasing : false, Frame : -1, Rotations : 16 }</e></m></meta>
			<haxe_doc>* This functionality isn't supported in SpriteGroup
	 * @return this sprite group</haxe_doc>
		</loadRotatedGraphic>
		<makeGraphic public="1" set="method" line="947" override="1">
			<f a="Width:Height:?Color:?Unique:?Key" v="::FlxColor.WHITE:false:">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
				<c path="String"/>
				<c path="flixel.FlxSprite"/>
			</f>
			<meta><m n=":value"><e>{ Unique : false, Color : FlxColor.WHITE }</e></m></meta>
			<haxe_doc>* This functionality isn't supported in SpriteGroup
	 * @return this sprite group</haxe_doc>
		</makeGraphic>
		<set_pixels set="method" line="956" override="1"><f a="Value">
	<t path="flash.display.BitmapData"/>
	<t path="flash.display.BitmapData"/>
</f></set_pixels>
		<set_frame set="method" line="961" override="1"><f a="Value">
	<c path="flixel.graphics.frames.FlxFrame"/>
	<c path="flixel.graphics.frames.FlxFrame"/>
</f></set_frame>
		<get_pixels set="method" line="966" override="1"><f a=""><t path="flash.display.BitmapData"/></f></get_pixels>
		<calcFrame get="inline" set="null" line="976" override="1">
			<f a="?RunOnCpp" v="false">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ RunOnCpp : false }</e></m></meta>
			<haxe_doc>* Internal function to update the current animation frame.
	 * 
	 * @param	RunOnCpp	Whether the frame should also be recalculated if we're on a non-flash target</haxe_doc>
		</calcFrame>
		<resetHelpers get="inline" set="null" line="984" override="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* This functionality isn't supported in SpriteGroup</haxe_doc>
		</resetHelpers>
		<stamp public="1" get="inline" set="null" line="989" override="1">
			<f a="Brush:?X:?Y" v=":0:0">
				<c path="flixel.FlxSprite"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ Y : 0, X : 0 }</e></m></meta>
			<haxe_doc>* This functionality isn't supported in SpriteGroup</haxe_doc>
		</stamp>
		<set_frames set="method" line="991" override="1"><f a="Frames">
	<c path="flixel.graphics.frames.FlxFramesCollection"/>
	<c path="flixel.graphics.frames.FlxFramesCollection"/>
</f></set_frames>
		<updateColorTransform get="inline" set="null" line="999" override="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* This functionality isn't supported in SpriteGroup</haxe_doc>
		</updateColorTransform>
		<new public="1" set="method" line="65">
			<f a="?X:?Y:?MaxSize" v="0:0:0">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ MaxSize : 0, Y : 0, X : 0 }</e></m></meta>
			<haxe_doc>* @param   X         The initial X position of the group.
	 * @param   Y         The initial Y position of the group.
	 * @param   MaxSize   Maximum amount of members allowed.</haxe_doc>
		</new>
		<haxe_doc>* `FlxSpriteGroup` is a special `FlxSprite` that can be treated like
 * a single sprite even if it's made up of several member sprites.
 * It shares the `FlxTypedGroup` API, but it doesn't inherit from it.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="flixel.input.FlxBaseKeyList" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/input/FlxBaseKeyList.hx">
		<status><x path="flixel.input.FlxInputState"/></status>
		<keyManager><c path="flixel.input.FlxKeyManager">
	<d/>
	<d/>
</c></keyManager>
		<check get="inline" set="null" line="16"><f a="keyCode">
	<x path="Int"/>
	<x path="Bool"/>
</f></check>
		<ANY public="1" get="accessor" set="null"><x path="Bool"/></ANY>
		<get_ANY set="method" line="23"><f a=""><x path="Bool"/></f></get_ANY>
		<new public="1" set="method" line="10"><f a="status:keyManager">
	<x path="flixel.input.FlxInputState"/>
	<c path="flixel.input.FlxKeyManager">
		<d/>
		<d/>
	</c>
	<x path="Void"/>
</f></new>
	</class>
	<class path="flixel.input.IFlxInput" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/input/IFlxInput.hx" interface="1">
		<get_justReleased public="1" set="method">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":compilerGenerated"/></meta>
		</get_justReleased>
		<get_released public="1" set="method">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":compilerGenerated"/></meta>
		</get_released>
		<get_pressed public="1" set="method">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":compilerGenerated"/></meta>
		</get_pressed>
		<get_justPressed public="1" set="method">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":compilerGenerated"/></meta>
		</get_justPressed>
		<justReleased public="1" get="accessor" set="null"><x path="Bool"/></justReleased>
		<released public="1" get="accessor" set="null"><x path="Bool"/></released>
		<pressed public="1" get="accessor" set="null"><x path="Bool"/></pressed>
		<justPressed public="1" get="accessor" set="null"><x path="Bool"/></justPressed>
	</class>
	<class path="flixel.input.FlxInput" params="T" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/input/FlxInput.hx">
		<implements path="flixel.input.IFlxInput"/>
		<ID public="1"><c path="flixel.input.FlxInput.T"/></ID>
		<justReleased public="1" get="accessor" set="null"><x path="Bool"/></justReleased>
		<released public="1" get="accessor" set="null"><x path="Bool"/></released>
		<pressed public="1" get="accessor" set="null"><x path="Bool"/></pressed>
		<justPressed public="1" get="accessor" set="null"><x path="Bool"/></justPressed>
		<current public="1" expr="RELEASED">
			<x path="flixel.input.FlxInputState"/>
			<meta><m n=":value"><e>RELEASED</e></m></meta>
		</current>
		<last public="1" expr="RELEASED">
			<x path="flixel.input.FlxInputState"/>
			<meta><m n=":value"><e>RELEASED</e></m></meta>
		</last>
		<press public="1" set="method" line="20"><f a=""><x path="Void"/></f></press>
		<release public="1" set="method" line="26"><f a=""><x path="Void"/></f></release>
		<update public="1" set="method" line="32"><f a=""><x path="Void"/></f></update>
		<reset public="1" set="method" line="46"><f a=""><x path="Void"/></f></reset>
		<hasState public="1" set="method" line="52"><f a="state">
	<x path="flixel.input.FlxInputState"/>
	<x path="Bool"/>
</f></hasState>
		<get_justReleased get="inline" set="null" line="63"><f a=""><x path="Bool"/></f></get_justReleased>
		<get_released get="inline" set="null" line="68"><f a=""><x path="Bool"/></f></get_released>
		<get_pressed get="inline" set="null" line="73"><f a=""><x path="Bool"/></f></get_pressed>
		<get_justPressed get="inline" set="null" line="78"><f a=""><x path="Bool"/></f></get_justPressed>
		<new public="1" set="method" line="15"><f a="ID">
	<c path="flixel.input.FlxInput.T"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<abstract path="flixel.input.FlxInputState" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/input/FlxInput.hx" module="flixel.input.FlxInput">
		<from><icast><x path="Int"/></icast></from>
		<this><x path="Int"/></this>
		<meta><m n=":enum"/></meta>
		<impl><class path="flixel.input._FlxInput.FlxInputState_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/input/FlxInput.hx" private="1" module="flixel.input.FlxInput" extern="1">
	<JUST_RELEASED public="1" get="inline" set="null" expr="cast -1" line="87" static="1">
		<x path="flixel.input.FlxInputState"/>
		<meta>
			<m n=":value"><e>cast -1</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</JUST_RELEASED>
	<RELEASED public="1" get="inline" set="null" expr="cast 0" line="88" static="1">
		<x path="flixel.input.FlxInputState"/>
		<meta>
			<m n=":value"><e>cast 0</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</RELEASED>
	<PRESSED public="1" get="inline" set="null" expr="cast 1" line="89" static="1">
		<x path="flixel.input.FlxInputState"/>
		<meta>
			<m n=":value"><e>cast 1</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</PRESSED>
	<JUST_PRESSED public="1" get="inline" set="null" expr="cast 2" line="90" static="1">
		<x path="flixel.input.FlxInputState"/>
		<meta>
			<m n=":value"><e>cast 2</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</JUST_PRESSED>
	<meta>
		<m n=":final"/>
		<m n=":enum"/>
	</meta>
</class></impl>
	</abstract>
	<class path="flixel.input._FlxInput.FlxInputState_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/input/FlxInput.hx" private="1" module="flixel.input.FlxInput" extern="1">
		<JUST_RELEASED public="1" get="inline" set="null" expr="cast -1" line="87" static="1">
			<x path="flixel.input.FlxInputState"/>
			<meta>
				<m n=":value"><e>cast -1</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</JUST_RELEASED>
		<RELEASED public="1" get="inline" set="null" expr="cast 0" line="88" static="1">
			<x path="flixel.input.FlxInputState"/>
			<meta>
				<m n=":value"><e>cast 0</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</RELEASED>
		<PRESSED public="1" get="inline" set="null" expr="cast 1" line="89" static="1">
			<x path="flixel.input.FlxInputState"/>
			<meta>
				<m n=":value"><e>cast 1</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</PRESSED>
		<JUST_PRESSED public="1" get="inline" set="null" expr="cast 2" line="90" static="1">
			<x path="flixel.input.FlxInputState"/>
			<meta>
				<m n=":value"><e>cast 2</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</JUST_PRESSED>
		<meta>
			<m n=":final"/>
			<m n=":enum"/>
		</meta>
	</class>
	<class path="flixel.input.IFlxInputManager" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/input/IFlxInputManager.hx" interface="1">
		<extends path="flixel.util.IFlxDestroyable"/>
		<reset public="1" set="method"><f a=""><x path="Void"/></f></reset>
		<update set="method"><f a=""><x path="Void"/></f></update>
		<onFocus set="method"><f a=""><x path="Void"/></f></onFocus>
		<onFocusLost set="method"><f a=""><x path="Void"/></f></onFocusLost>
		<meta><m n=":allow"><e>flixel.system.frontEnds.InputFrontEnd</e></m></meta>
	</class>
	<class path="flixel.input.FlxKeyManager" params="Key:KeyList" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/input/FlxKeyManager.hx">
		<implements path="flixel.input.IFlxInputManager"/>
		<enabled public="1" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
			<haxe_doc>* Whether or not keyboard input is currently enabled.</haxe_doc>
		</enabled>
		<preventDefaultKeys public="1" expr="[]">
			<c path="Array"><c path="flixel.input.FlxKeyManager.Key"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
			<haxe_doc>* List of keys on which preventDefault() is called, useful on HTML5 to stop 
	 * the browser from scrolling when pressing the up or down key for example, or
	 * on android to prevent the default back key action.</haxe_doc>
		</preventDefaultKeys>
		<pressed public="1" set="null">
			<c path="flixel.input.FlxKeyManager.KeyList"/>
			<haxe_doc>* Helper class to check if a key is pressed.</haxe_doc>
		</pressed>
		<justPressed public="1" set="null">
			<c path="flixel.input.FlxKeyManager.KeyList"/>
			<haxe_doc>* Helper class to check if a key was just pressed.</haxe_doc>
		</justPressed>
		<justReleased public="1" set="null">
			<c path="flixel.input.FlxKeyManager.KeyList"/>
			<haxe_doc>* Helper class to check if a key was just released.</haxe_doc>
		</justReleased>
		<_keyListArray expr="[]">
			<c path="Array"><c path="flixel.input.FlxInput"><c path="flixel.input.FlxKeyManager.Key"/></c></c>
			<meta>
				<m n=":value"><e>[]</e></m>
				<m n=":allow"><e>flixel.input.FlxBaseKeyList</e></m>
			</meta>
			<haxe_doc>* Internal storage of input keys as an array, for efficient iteration.</haxe_doc>
		</_keyListArray>
		<_keyListMap expr="new Map&lt;Int,FlxInput&lt;Key&gt;&gt;()">
			<x path="Map">
				<x path="Int"/>
				<c path="flixel.input.FlxInput"><c path="flixel.input.FlxKeyManager.Key"/></c>
			</x>
			<meta><m n=":value"><e><![CDATA[new Map<Int,FlxInput<Key>>()]]></e></m></meta>
			<haxe_doc>* Internal storage of input keys as a map, for efficient indexing.</haxe_doc>
		</_keyListMap>
		<anyPressed public="1" get="inline" set="null" line="48">
			<f a="KeyArray">
				<c path="Array"><c path="flixel.input.FlxKeyManager.Key"/></c>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Check to see if at least one key from an array of keys is pressed.
	 * 
	 * @param	KeyArray 	An array of key names
	 * @return	Whether at least one of the keys passed in is pressed.</haxe_doc>
		</anyPressed>
		<anyJustPressed public="1" get="inline" set="null" line="59">
			<f a="KeyArray">
				<c path="Array"><c path="flixel.input.FlxKeyManager.Key"/></c>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Check to see if at least one key from an array of keys was just pressed.
	 * 
	 * @param	KeyArray 	An array of key names
	 * @return	Whether at least one of the keys passed was just pressed.</haxe_doc>
		</anyJustPressed>
		<anyJustReleased public="1" get="inline" set="null" line="70">
			<f a="KeyArray">
				<c path="Array"><c path="flixel.input.FlxKeyManager.Key"/></c>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Check to see if at least one key from an array of keys was just released.
	 * 
	 * @param	KeyArray 	An array of key names
	 * @return	Whether at least one of the keys passed was just released.</haxe_doc>
		</anyJustReleased>
		<firstPressed public="1" set="method" line="80">
			<f a=""><x path="Int"/></f>
			<haxe_doc>* Get the ID of the first key which is currently pressed.
	 * 
	 * @return	The ID of the first pressed key or -1 if none are pressed.</haxe_doc>
		</firstPressed>
		<firstJustPressed public="1" set="method" line="97">
			<f a=""><x path="Int"/></f>
			<haxe_doc>* Get the ID of the first key which has just been pressed.
	 * 
	 * @return	The ID of the key or -1 if none were just pressed.</haxe_doc>
		</firstJustPressed>
		<firstJustReleased public="1" set="method" line="114">
			<f a=""><x path="Int"/></f>
			<haxe_doc>* Get the ID of the first key which has just been released.
	 * 
	 * @return	The ID of the key or -1 if none were just released.</haxe_doc>
		</firstJustReleased>
		<checkStatus public="1" set="method" line="133">
			<f a="KeyCode:Status">
				<c path="flixel.input.FlxKeyManager.Key"/>
				<x path="flixel.input.FlxInputState"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Check the status of a single of key
	 * 
	 * @param	KeyCode		KeyCode to be checked.
	 * @param	Status		The key state to check for.
	 * @return	Whether the provided key has the specified status.</haxe_doc>
		</checkStatus>
		<getIsDown public="1" set="method" line="159">
			<f a=""><c path="Array"><c path="flixel.input.FlxInput"><c path="flixel.input.FlxKeyManager.Key"/></c></c></f>
			<haxe_doc>* Get an Array of Key that are in a pressed state
	 * 
	 * @return	Array of keys that are currently pressed.</haxe_doc>
		</getIsDown>
		<destroy public="1" set="method" line="176">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Clean up memory.</haxe_doc>
		</destroy>
		<reset public="1" set="method" line="185">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Resets all the keys.</haxe_doc>
		</reset>
		<update set="method" line="209">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Updates the key states (for tracking just pressed, just released, etc).</haxe_doc>
		</update>
		<checkKeyArrayState set="method" line="227">
			<f a="KeyArray:State">
				<c path="Array"><c path="flixel.input.FlxKeyManager.Key"/></c>
				<x path="flixel.input.FlxInputState"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Helper function to check the status of an array of keys
	 * 
	 * @param	KeyArray	An array of keys as Strings
	 * @param	State		The key state to check for
	 * @return	Whether at least one of the keys has the specified status</haxe_doc>
		</checkKeyArrayState>
		<onKeyUp set="method" line="253">
			<f a="event">
				<t path="flash.events.KeyboardEvent"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Event handler so FlxGame can toggle keys.</haxe_doc>
		</onKeyUp>
		<onKeyDown set="method" line="267">
			<f a="event">
				<t path="flash.events.KeyboardEvent"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Internal event handler for input and focus.</haxe_doc>
		</onKeyDown>
		<handlePreventDefaultKeys set="method" line="278"><f a="keyCode:event">
	<x path="Int"/>
	<t path="flash.events.KeyboardEvent"/>
	<x path="Void"/>
</f></handlePreventDefaultKeys>
		<inKeyArray set="method" line="292">
			<f a="KeyArray:Event">
				<c path="Array"><c path="flixel.input.FlxKeyManager.Key"/></c>
				<t path="flash.events.KeyboardEvent"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* A Helper function to check whether an array of keycodes contains 
	 * a certain key safely (returns false if the array is null).</haxe_doc>
		</inKeyArray>
		<resolveKeyCode set="method" line="312"><f a="e">
	<t path="flash.events.KeyboardEvent"/>
	<x path="Int"/>
</f></resolveKeyCode>
		<updateKeyStates get="inline" set="null" line="320">
			<f a="KeyCode:Down">
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* A helper function to update the key states based on a keycode provided.</haxe_doc>
		</updateKeyStates>
		<onFocus get="inline" set="null" line="337"><f a=""><x path="Void"/></f></onFocus>
		<onFocusLost get="inline" set="null" line="339"><f a=""><x path="Void"/></f></onFocusLost>
		<getKey get="inline" set="null" line="347">
			<f a="KeyCode">
				<x path="Int"/>
				<c path="flixel.input.FlxInput"><c path="flixel.input.FlxKeyManager.Key"/></c>
			</f>
			<haxe_doc>* Return a key from the key list, if found. Will return null if not found.</haxe_doc>
		</getKey>
		<new set="method" line="196"><f a="keyListClass">
	<x path="Class"><c path="flixel.input.FlxBaseKeyList"/></x>
	<x path="Void"/>
</f></new>
	</class>
	<class path="flixel.input.FlxPointer" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/input/FlxPointer.hx">
		<_cachedPoint expr="new FlxPoint()" line="18" static="1">
			<c path="flixel.math.FlxPoint"/>
			<meta><m n=":value"><e>new FlxPoint()</e></m></meta>
		</_cachedPoint>
		<x public="1" set="null" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</x>
		<y public="1" set="null" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</y>
		<screenX public="1" set="null" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</screenX>
		<screenY public="1" set="null" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</screenY>
		<_globalScreenX expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</_globalScreenX>
		<_globalScreenY expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</_globalScreenY>
		<getWorldPosition public="1" set="method" line="30">
			<f a="?Camera:?point">
				<c path="flixel.FlxCamera"/>
				<c path="flixel.math.FlxPoint"/>
				<c path="flixel.math.FlxPoint"/>
			</f>
			<haxe_doc>* Fetch the world position of the pointer on any given camera.
	 * NOTE: x and y also store the world position of the pointer on the main camera.
	 * 
	 * @param 	Camera	If unspecified, first/main global camera is used instead.
	 * @param 	point	An existing point object to store the results (if you don't want a new one created). 
	 * @return 	The touch point's location in world space.</haxe_doc>
		</getWorldPosition>
		<getScreenPosition public="1" set="method" line="54">
			<f a="?Camera:?point">
				<c path="flixel.FlxCamera"/>
				<c path="flixel.math.FlxPoint"/>
				<c path="flixel.math.FlxPoint"/>
			</f>
			<haxe_doc>* Fetch the screen position of the pointer on any given camera.
	 * NOTE: screenX and screenY also store the screen position of the pointer on the main camera.
	 * 
	 * @param 	Camera	If unspecified, first/main global camera is used instead.
	 * @param 	point		An existing point object to store the results (if you don't want a new one created). 
	 * @return 	The touch point's location in screen space.</haxe_doc>
		</getScreenPosition>
		<getPositionInCameraView public="1" set="method" line="79">
			<f a="?Camera:?point">
				<c path="flixel.FlxCamera"/>
				<c path="flixel.math.FlxPoint"/>
				<c path="flixel.math.FlxPoint"/>
			</f>
			<meta><m n=":access"><e>flixel.FlxCamera</e></m></meta>
			<haxe_doc>* Fetch the screen position of the pointer relative to given camera's viewport.
	 * 
	 * @param 	Camera		If unspecified, first/main global camera is used instead.
	 * @param 	point		An existing point object to store the results (if you don't want a new one created). 
	 * @return 	The touch point's location relative to camera's viewport.</haxe_doc>
		</getPositionInCameraView>
		<getPosition public="1" set="method" line="96">
			<f a="?point">
				<c path="flixel.math.FlxPoint"/>
				<c path="flixel.math.FlxPoint"/>
			</f>
			<haxe_doc>* Returns a FlxPoint with this input's x and y.</haxe_doc>
		</getPosition>
		<overlaps public="1" set="method" line="113">
			<f a="ObjectOrGroup:?Camera">
				<c path="flixel.FlxBasic"/>
				<c path="flixel.FlxCamera"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":access"><e>flixel.group.FlxTypedGroup.resolveGroup</e></m></meta>
			<haxe_doc>* Checks to see if some FlxObject overlaps this FlxObject or FlxGroup.
	 * If the group has a LOT of things in it, it might be faster to use FlxG.overlaps().
	 * WARNING: Currently tilemaps do NOT support screen space overlap checks!
	 * 
	 * @param 	ObjectOrGroup The object or group being tested.
	 * @param 	Camera Specify which game camera you want. If null getScreenPosition() will just grab the first global camera.
	 * @return 	Whether or not the two objects overlap.</haxe_doc>
		</overlaps>
		<setGlobalScreenPositionUnsafe public="1" get="inline" set="null" line="143">
			<f a="newX:newY">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Directly set the underyling screen position variable. WARNING! You should never use
	 * this unless you are trying to manually dispatch low-level mouse / touch events to the stage.</haxe_doc>
		</setGlobalScreenPositionUnsafe>
		<toString public="1" set="method" line="151"><f a=""><c path="String"/></f></toString>
		<updatePositions set="method" line="162">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Helper function to update the cursor used by update() and playback().
	 * Updates the x, y, screenX, and screenY variables based on the default camera.</haxe_doc>
		</updatePositions>
		<new public="1" set="method" line="20"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="flixel.input.FlxSwipe" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/input/FlxSwipe.hx">
		<ID public="1" set="null">
			<x path="Int"/>
			<haxe_doc>* Either LEFT_MOUSE, MIDDLE_MOUSE or RIGHT_MOUSE, 
	 * or the touchPointID of a FlxTouch.</haxe_doc>
		</ID>
		<startPosition public="1" set="null"><c path="flixel.math.FlxPoint"/></startPosition>
		<endPosition public="1" set="null"><c path="flixel.math.FlxPoint"/></endPosition>
		<distance public="1" get="accessor" set="null"><x path="Float"/></distance>
		<angle public="1" get="accessor" set="null"><x path="Float"/></angle>
		<duration public="1" get="accessor" set="null"><x path="Float"/></duration>
		<_startTimeInTicks><x path="Int"/></_startTimeInTicks>
		<_endTimeInTicks><x path="Int"/></_endTimeInTicks>
		<toString get="inline" set="null" line="37"><f a=""><c path="String"/></f></toString>
		<get_distance get="inline" set="null" line="48"><f a=""><x path="Float"/></f></get_distance>
		<get_angle get="inline" set="null" line="53"><f a=""><x path="Float"/></f></get_angle>
		<get_duration get="inline" set="null" line="58"><f a=""><x path="Float"/></f></get_duration>
		<new set="method" line="28"><f a="ID:StartPosition:EndPosition:StartTimeInTicks">
	<x path="Int"/>
	<c path="flixel.math.FlxPoint"/>
	<c path="flixel.math.FlxPoint"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":allow"><e>flixel.input.mouse.FlxMouseButton</e></m>
			<m n=":allow"><e>flixel.input.touch.FlxTouch</e></m>
		</meta>
	</class>
	<class path="flixel.input.gamepad.FlxGamepad" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/input/gamepad/FlxGamepad.hx">
		<implements path="flixel.util.IFlxDestroyable"/>
		<id public="1" set="null"><x path="Int"/></id>
		<name public="1" get="accessor" set="null">
			<c path="String"/>
			<haxe_doc>* The device name. Used to determine the `model`.</haxe_doc>
		</name>
		<model public="1" set="accessor">
			<e path="flixel.input.gamepad.FlxGamepadModel"/>
			<haxe_doc>* The gamepad model used for the mapping of the IDs.
	 * Defaults to `detectedModel`, but can be changed manually.</haxe_doc>
		</model>
		<detectedModel public="1" set="null">
			<e path="flixel.input.gamepad.FlxGamepadModel"/>
			<haxe_doc>* The gamepad model this gamepad has been identified as.</haxe_doc>
		</detectedModel>
		<mapping public="1">
			<c path="flixel.input.gamepad.mappings.FlxGamepadMapping"/>
			<haxe_doc>* The mapping that is used to map the raw hardware IDs to the values in `FlxGamepadInputID`.
	 * Determined by the current `model`.
	 * It's also possible to create a custom mapping and assign it here.</haxe_doc>
		</mapping>
		<connected public="1" set="null" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</connected>
		<attachment public="1" set="accessor">
			<e path="flixel.input.gamepad.FlxGamepadAttachment"/>
			<haxe_doc>* For gamepads that can have things plugged into them (the Wii Remote, basically).
	 * Making the user set this helps Flixel properly interpret inputs properly. 
	 * EX: if you plug a nunchuk into the Wii Remote, you will get different values for 
	 * certain buttons than with the Wii Remote alone.
	 * (This is probably why Wii games ask the player what control scheme they are using.)
	 * 
	 * In the future, this could also be used for any attachment that exposes new API features
	 * to the controller, e.g. a microphone or headset</haxe_doc>
		</attachment>
		<deadZone public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<haxe_doc>* Gamepad deadzone. The lower, the more sensitive the gamepad.
	 * Should be between 0.0 and 1.0. Defaults to 0.15.</haxe_doc>
		</deadZone>
		<deadZoneMode public="1" expr="INDEPENDENT_AXES">
			<e path="flixel.input.gamepad.FlxGamepadDeadZoneMode"/>
			<meta><m n=":value"><e>INDEPENDENT_AXES</e></m></meta>
			<haxe_doc>* Which dead zone mode to use for analog sticks.</haxe_doc>
		</deadZoneMode>
		<pressed public="1" set="null">
			<c path="flixel.input.gamepad.lists.FlxGamepadButtonList"/>
			<haxe_doc>* Helper class to check if a button is pressed.</haxe_doc>
		</pressed>
		<justPressed public="1" set="null">
			<c path="flixel.input.gamepad.lists.FlxGamepadButtonList"/>
			<haxe_doc>* Helper class to check if a button was just pressed.</haxe_doc>
		</justPressed>
		<justReleased public="1" set="null">
			<c path="flixel.input.gamepad.lists.FlxGamepadButtonList"/>
			<haxe_doc>* Helper class to check if a button was just released.</haxe_doc>
		</justReleased>
		<analog public="1" set="null">
			<c path="flixel.input.gamepad.lists.FlxGamepadAnalogList"/>
			<haxe_doc>* Helper class to get the justMoved, justReleased, and float values of analog input.</haxe_doc>
		</analog>
		<motion public="1" set="null">
			<c path="flixel.input.gamepad.lists.FlxGamepadMotionValueList"/>
			<haxe_doc>* Helper class to get the float values of motion-sensing input, if it is supported</haxe_doc>
		</motion>
		<pointer public="1" set="null">
			<c path="flixel.input.gamepad.lists.FlxGamepadPointerValueList"/>
			<haxe_doc>* Helper class to get the float values of mouse-like pointer input, if it is supported.
	 * (contains continously updated X and Y coordinates, each between 0.0 and 1.0)</haxe_doc>
		</pointer>
		<axis expr="[for (i in 0 ... 6) 0]">
			<c path="Array"><x path="Float"/></c>
			<meta><m n=":value"><e>[for (i in 0 ... 6) 0]</e></m></meta>
		</axis>
		<axisActive expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</axisActive>
		<manager><c path="flixel.input.gamepad.FlxGamepadManager"/></manager>
		<_deadZone expr="0.15">
			<x path="Float"/>
			<meta><m n=":value"><e>0.15</e></m></meta>
		</_deadZone>
		<_device><t path="flash.ui.GameInputDevice"/></_device>
		<buttons expr="[]">
			<c path="Array"><c path="flixel.input.gamepad.FlxGamepadButton"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</buttons>
		<getButton set="method" line="149"><f a="RawID">
	<x path="Int"/>
	<c path="flixel.input.gamepad.FlxGamepadButton"/>
</f></getButton>
		<applyAxisFlip get="inline" set="null" line="164"><f a="axisValue:axisID">
	<x path="Float"/>
	<x path="Int"/>
	<x path="Float"/>
</f></applyAxisFlip>
		<update public="1" set="method" line="174">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Updates the key states (for tracking just pressed, just released, etc).</haxe_doc>
		</update>
		<reset public="1" set="method" line="241"><f a=""><x path="Void"/></f></reset>
		<destroy public="1" set="method" line="264"><f a=""><x path="Void"/></f></destroy>
		<checkStatus public="1" get="inline" set="null" line="288">
			<f a="ID:Status">
				<x path="flixel.input.gamepad.FlxGamepadInputID"/>
				<x path="flixel.input.FlxInputState"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Check the status of a "universal" button ID, auto-mapped to this gamepad (something like FlxGamepadInputID.A).
	 * 
	 * @param	ID			"universal" gamepad input ID
	 * @param	Status		The key state to check for
	 * @return	Whether the provided button has the specified status</haxe_doc>
		</checkStatus>
		<checkStatusRaw public="1" set="method" line="300">
			<f a="RawID:Status">
				<x path="Int"/>
				<x path="flixel.input.FlxInputState"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Check the status of a raw button ID (like XInputID.A).
	 * 
	 * @param	RawID	Index into buttons array.
	 * @param	Status	The key state to check for
	 * @return	Whether the provided button has the specified status</haxe_doc>
		</checkStatusRaw>
		<anyPressed public="1" set="method" line="315">
			<f a="IDArray">
				<c path="Array"><x path="flixel.input.gamepad.FlxGamepadInputID"/></c>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Check if at least one button from an array of button IDs is pressed.
	 * 
	 * @param	IDArray	An array of "universal" gamepad input IDs
	 * @return	Whether at least one of the buttons is pressed</haxe_doc>
		</anyPressed>
		<anyPressedRaw public="1" set="method" line="337">
			<f a="RawIDArray">
				<c path="Array"><x path="Int"/></c>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Check if at least one button from an array of raw button IDs is pressed.
	 * 
	 * @param	RawIDArray	An array of raw button IDs
	 * @return	Whether at least one of the buttons is pressed</haxe_doc>
		</anyPressedRaw>
		<anyJustPressed public="1" set="method" line="357">
			<f a="IDArray">
				<c path="Array"><x path="flixel.input.gamepad.FlxGamepadInputID"/></c>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Check if at least one button from an array of universal button IDs was just pressed.
	 * 
	 * @param	IDArray	An array of "universal" gamepad input IDs
	 * @return	Whether at least one of the buttons was just pressed</haxe_doc>
		</anyJustPressed>
		<anyJustPressedRaw public="1" set="method" line="378">
			<f a="RawIDArray">
				<c path="Array"><x path="Int"/></c>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Check if at least one button from an array of raw button IDs was just pressed.
	 * 
	 * @param	RawIDArray	An array of raw button IDs
	 * @return	Whether at least one of the buttons was just pressed</haxe_doc>
		</anyJustPressedRaw>
		<anyJustReleased public="1" set="method" line="398">
			<f a="IDArray">
				<c path="Array"><x path="flixel.input.gamepad.FlxGamepadInputID"/></c>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Check if at least one button from an array of gamepad input IDs was just released.
	 * 
	 * @param	IDArray	An array of "universal" gamepad input IDs
	 * @return	Whether at least one of the buttons was just released</haxe_doc>
		</anyJustReleased>
		<anyJustReleasedRaw public="1" set="method" line="419">
			<f a="RawIDArray">
				<c path="Array"><x path="Int"/></c>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Check if at least one button from an array of raw button IDs was just released.
	 * 
	 * @param	RawArray	An array of raw button IDs
	 * @return	Whether at least one of the buttons was just released</haxe_doc>
		</anyJustReleasedRaw>
		<firstPressedID public="1" get="inline" set="null" line="437">
			<f a=""><x path="flixel.input.gamepad.FlxGamepadInputID"/></f>
			<haxe_doc>* Get the first found "universal" ID of the button which is currently pressed.
	 * Returns NONE if no button is pressed.</haxe_doc>
		</firstPressedID>
		<firstPressedRawID public="1" set="method" line="446">
			<f a=""><x path="Int"/></f>
			<haxe_doc>* Get the first found raw ID of the button which is currently pressed.
	 * Returns -1 if no button is pressed.</haxe_doc>
		</firstPressedRawID>
		<firstJustPressedID public="1" get="inline" set="null" line="462">
			<f a=""><x path="flixel.input.gamepad.FlxGamepadInputID"/></f>
			<haxe_doc>* Get the first found "universal" ButtonID of the button which has been just pressed.
	 * Returns NONE if no button was just pressed.</haxe_doc>
		</firstJustPressedID>
		<firstJustPressedRawID public="1" set="method" line="471">
			<f a=""><x path="Int"/></f>
			<haxe_doc>* Get the first found raw ID of the button which has been just pressed.
	 * Returns -1 if no button was just pressed.</haxe_doc>
		</firstJustPressedRawID>
		<firstJustReleasedID public="1" get="inline" set="null" line="487">
			<f a=""><x path="flixel.input.gamepad.FlxGamepadInputID"/></f>
			<haxe_doc>* Get the first found "universal" ButtonID of the button which has been just released.
	 * Returns NONE if no button was just released.</haxe_doc>
		</firstJustReleasedID>
		<firstJustReleasedRawID public="1" set="method" line="496">
			<f a=""><x path="Int"/></f>
			<haxe_doc>* Get the first found raw ID of the button which has been just released.
	 * Returns -1 if no button was just released.</haxe_doc>
		</firstJustReleasedRawID>
		<getAxis public="1" set="method" line="513">
			<f a="AxisButtonID">
				<x path="flixel.input.gamepad.FlxGamepadInputID"/>
				<x path="Float"/>
			</f>
			<haxe_doc>* Gets the value of the specified axis using the "universal" ButtonID - 
	 * use this only for things like FlxGamepadButtonID.LEFT_TRIGGER, 
	 * use getXAxis() / getYAxis() for analog sticks!</haxe_doc>
		</getAxis>
		<getAxisRaw public="1" get="inline" set="null" line="543">
			<f a="RawAxisID">
				<x path="Int"/>
				<x path="Float"/>
			</f>
			<haxe_doc>* Gets the value of the specified axis using the raw ID - 
	 * use this only for things like XInputID.LEFT_TRIGGER,
	 * use getXAxis() / getYAxis() for analog sticks!</haxe_doc>
		</getAxisRaw>
		<isAxisForAnalogStick set="method" line="553"><f a="AxisIndex">
	<x path="Int"/>
	<x path="Bool"/>
</f></isAxisForAnalogStick>
		<getAnalogStickByAxis get="inline" set="null" line="571"><f a="AxisIndex">
	<x path="Int"/>
	<c path="flixel.input.gamepad.FlxGamepadAnalogStick"/>
</f></getAnalogStickByAxis>
		<getXAxis public="1" get="inline" set="null" line="587">
			<f a="AxesButtonID">
				<x path="flixel.input.gamepad.FlxGamepadInputID"/>
				<x path="Float"/>
			</f>
			<haxe_doc>* Given a ButtonID for an analog stick, gets the value of its x axis
	 * @param	AxesButtonID an analog stick like FlxGamepadButtonID.LEFT_STICK</haxe_doc>
		</getXAxis>
		<getXAxisRaw public="1" get="inline" set="null" line="595">
			<f a="Stick">
				<c path="flixel.input.gamepad.FlxGamepadAnalogStick"/>
				<x path="Float"/>
			</f>
			<haxe_doc>* Given both raw IDs for the axes of an analog stick, gets the value of its x axis</haxe_doc>
		</getXAxisRaw>
		<getYAxis public="1" get="inline" set="null" line="604">
			<f a="AxesButtonID">
				<x path="flixel.input.gamepad.FlxGamepadInputID"/>
				<x path="Float"/>
			</f>
			<haxe_doc>* Given a ButtonID for an analog stick, gets the value of its y axis
	 * @param	AxesButtonID an analog stick like FlxGamepadButtonID.LEFT_STICK</haxe_doc>
		</getYAxis>
		<getYAxisRaw public="1" set="method" line="613">
			<f a="Stick">
				<c path="flixel.input.gamepad.FlxGamepadAnalogStick"/>
				<x path="Float"/>
			</f>
			<haxe_doc>* Given both raw ID's for the axes of an analog stick, gets the value of its Y axis
	 * (should be used in flash to correct the inverted y axis)</haxe_doc>
		</getYAxisRaw>
		<getAnalogAxes public="1" set="method" line="624">
			<f a="AxesButtonID">
				<x path="flixel.input.gamepad.FlxGamepadInputID"/>
				<c path="flixel.math.FlxVector"/>
			</f>
			<haxe_doc>* Convenience method that wraps `getXAxis()` and `getYAxis()` into a `FlxVector`.
	 *
	 * @param	AxesButtonID an analog stick like `FlxGamepadButtonID.LEFT_STICK`
	 * @since	4.3.0</haxe_doc>
		</getAnalogAxes>
		<anyButton public="1" set="method" line="632">
			<f a="?state" v="PRESSED">
				<x path="flixel.input.FlxInputState"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":value"><e>{ state : PRESSED }</e></m></meta>
			<haxe_doc>* Whether any buttons have the specified input state.</haxe_doc>
		</anyButton>
		<anyInput public="1" set="method" line="647">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>* Check to see if any buttons are pressed right or Axis, Ball and Hat moved now.</haxe_doc>
		</anyInput>
		<getAxisValue set="method" line="677"><f a="AxisID">
	<x path="Int"/>
	<x path="Float"/>
</f></getAxisValue>
		<getAnalogXAxisValue set="method" line="707"><f a="stick">
	<c path="flixel.input.gamepad.FlxGamepadAnalogStick"/>
	<x path="Float"/>
</f></getAnalogXAxisValue>
		<getAnalogYAxisValue set="method" line="717"><f a="stick">
	<c path="flixel.input.gamepad.FlxGamepadAnalogStick"/>
	<x path="Float"/>
</f></getAnalogYAxisValue>
		<getAnalogAxisValueCircular set="method" line="727"><f a="stick:axisID">
	<c path="flixel.input.gamepad.FlxGamepadAnalogStick"/>
	<x path="Int"/>
	<x path="Float"/>
</f></getAnalogAxisValueCircular>
		<getAnalogAxisValueIndependent set="method" line="745"><f a="axisID">
	<x path="Int"/>
	<x path="Float"/>
</f></getAnalogAxisValueIndependent>
		<handleAxisMove set="method" line="753"><f a="axis:newValue:oldValue">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></handleAxisMove>
		<handleAxisMoveSub set="method" line="772">
			<f a="stick:axis:value:oldValue:?sign" v="::::1.0">
				<c path="flixel.input.gamepad.FlxGamepadAnalogStick"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ sign : 1.0 }</e></m></meta>
		</handleAxisMoveSub>
		<createMappingForModel set="method" line="800"><f a="model">
	<e path="flixel.input.gamepad.FlxGamepadModel"/>
	<c path="flixel.input.gamepad.mappings.FlxGamepadMapping"/>
</f></createMappingForModel>
		<get_name set="method" line="818"><f a=""><c path="String"/></f></get_name>
		<set_model set="method" line="826"><f a="Model">
	<e path="flixel.input.gamepad.FlxGamepadModel"/>
	<e path="flixel.input.gamepad.FlxGamepadModel"/>
</f></set_model>
		<set_attachment set="method" line="834"><f a="Attachment">
	<e path="flixel.input.gamepad.FlxGamepadAttachment"/>
	<e path="flixel.input.gamepad.FlxGamepadAttachment"/>
</f></set_attachment>
		<get_deadZone set="method" line="841"><f a=""><x path="Float"/></f></get_deadZone>
		<set_deadZone get="inline" set="null" line="846"><f a="deadZone">
	<x path="Float"/>
	<x path="Float"/>
</f></set_deadZone>
		<toString public="1" set="method" line="851"><f a=""><c path="String"/></f></toString>
		<new public="1" set="method" line="126"><f a="ID:Manager:?Model:?Attachment">
	<x path="Int"/>
	<c path="flixel.input.gamepad.FlxGamepadManager"/>
	<e path="flixel.input.gamepad.FlxGamepadModel"/>
	<e path="flixel.input.gamepad.FlxGamepadAttachment"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":allow"><e>flixel.input.gamepad</e></m>
		</meta>
	</class>
	<enum path="flixel.input.gamepad.FlxGamepadDeadZoneMode" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/input/gamepad/FlxGamepad.hx" module="flixel.input.gamepad.FlxGamepad">
		<INDEPENDENT_AXES><haxe_doc>* The value of each axis is compared to the deadzone individually.
	 * Works better when an analog stick is used like arrow keys for 4-directional-input.</haxe_doc></INDEPENDENT_AXES>
		<CIRCULAR><haxe_doc>* X and y are combined against the deadzone combined.
	 * Works better when an analog stick is used as a two-dimensional control surface.</haxe_doc></CIRCULAR>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<enum path="flixel.input.gamepad.FlxGamepadModel" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/input/gamepad/FlxGamepad.hx" module="flixel.input.gamepad.FlxGamepad">
		<LOGITECH/>
		<OUYA/>
		<PS4/>
		<PSVITA/>
		<XINPUT/>
		<MAYFLASH_WII_REMOTE/>
		<WII_REMOTE/>
		<MFI/>
		<UNKNOWN/>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<enum path="flixel.input.gamepad.FlxGamepadAttachment" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/input/gamepad/FlxGamepad.hx" module="flixel.input.gamepad.FlxGamepad">
		<WII_NUNCHUCK/>
		<WII_CLASSIC_CONTROLLER/>
		<NONE/>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<class path="flixel.input.gamepad.FlxGamepadAnalogStick" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/input/gamepad/FlxGamepadAnalogStick.hx">
		<x public="1" set="null"><x path="Int"/></x>
		<y public="1" set="null"><x path="Int"/></y>
		<rawUp public="1" set="null" expr="-1">
			<x path="Int"/>
			<meta><m n=":value"><e>-1</e></m></meta>
			<haxe_doc>* a raw button input ID, for sending a digital event for "up" alongside the analog event</haxe_doc>
		</rawUp>
		<rawDown public="1" set="null" expr="-1">
			<x path="Int"/>
			<meta><m n=":value"><e>-1</e></m></meta>
			<haxe_doc>* a raw button input ID, for sending a digital event for "down" alongside the analog event</haxe_doc>
		</rawDown>
		<rawLeft public="1" set="null" expr="-1">
			<x path="Int"/>
			<meta><m n=":value"><e>-1</e></m></meta>
			<haxe_doc>* a raw button input ID, for sending a digital event for "left" alongside the analog event</haxe_doc>
		</rawLeft>
		<rawRight public="1" set="null" expr="-1">
			<x path="Int"/>
			<meta><m n=":value"><e>-1</e></m></meta>
			<haxe_doc>* a raw button input ID, for sending a digital event for "right" alongside the analog event</haxe_doc>
		</rawRight>
		<digitalThreshold public="1" set="null" expr="0.5">
			<x path="Float"/>
			<meta><m n=":value"><e>0.5</e></m></meta>
			<haxe_doc>* the absolute value the dpad must be greater than before digital inputs are sent</haxe_doc>
		</digitalThreshold>
		<mode public="1" set="null" expr="BOTH">
			<e path="flixel.input.gamepad.FlxAnalogToDigitalMode"/>
			<meta><m n=":value"><e>BOTH</e></m></meta>
			<haxe_doc>* when analog inputs are received, how to process them digitally</haxe_doc>
		</mode>
		<toString public="1" set="method" line="53"><f a=""><c path="String"/></f></toString>
		<new public="1" set="method" line="37"><f a="x:y:?settings">
	<x path="Int"/>
	<x path="Int"/>
	<t path="flixel.input.gamepad.FlxGamepadAnalogStickSettings"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<typedef path="flixel.input.gamepad.FlxGamepadAnalogStickSettings" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/input/gamepad/FlxGamepadAnalogStick.hx" module="flixel.input.gamepad.FlxGamepadAnalogStick"><a>
	<up>
		<t path="Null"><x path="Int"/></t>
		<meta><m n=":optional"/></meta>
	</up>
	<threshold>
		<t path="Null"><x path="Float"/></t>
		<meta><m n=":optional"/></meta>
	</threshold>
	<right>
		<t path="Null"><x path="Int"/></t>
		<meta><m n=":optional"/></meta>
	</right>
	<mode>
		<t path="Null"><e path="flixel.input.gamepad.FlxAnalogToDigitalMode"/></t>
		<meta><m n=":optional"/></meta>
	</mode>
	<left>
		<t path="Null"><x path="Int"/></t>
		<meta><m n=":optional"/></meta>
	</left>
	<down>
		<t path="Null"><x path="Int"/></t>
		<meta><m n=":optional"/></meta>
	</down>
</a></typedef>
	<enum path="flixel.input.gamepad.FlxAnalogToDigitalMode" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/input/gamepad/FlxGamepadAnalogStick.hx" module="flixel.input.gamepad.FlxGamepadAnalogStick">
		<BOTH><haxe_doc>* Send both digital and analog events when the analog stick is moved</haxe_doc></BOTH>
		<ONLY_DIGITAL><haxe_doc>* Send only digital events when the analog stick is moved</haxe_doc></ONLY_DIGITAL>
		<ONLY_ANALOG><haxe_doc>* Send only analog events when the analog stick is moved</haxe_doc></ONLY_ANALOG>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<class path="flixel.input.gamepad.FlxGamepadButton" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/input/gamepad/FlxGamepadButton.hx">
		<extends path="flixel.input.FlxInput"><x path="Int"/></extends>
		<value public="1" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* Optional analog value, so we can check when the value has changed from the last frame</haxe_doc>
		</value>
		<new public="1" set="method" line="5"><f a="ID">
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<abstract path="flixel.input.gamepad.FlxGamepadInputID" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/input/gamepad/FlxGamepadInputID.hx">
		<from>
			<icast><x path="Int"/></icast>
			<icast field="fromString"><c path="String"/></icast>
		</from>
		<this><x path="Int"/></this>
		<to>
			<icast><x path="Int"/></icast>
			<icast field="toString"><c path="String"/></icast>
		</to>
		<haxe_doc>* A high-level list of unique values for gamepad inputs.
 * These do NOT correspond to any actual hardware values but
 * are the basis for all hardware-specific lookups.
 * 
 * Maps enum values and strings to unique integer codes</haxe_doc>
		<meta><m n=":enum"/></meta>
		<impl><class path="flixel.input.gamepad._FlxGamepadInputID.FlxGamepadInputID_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/input/gamepad/FlxGamepadInputID.hx" private="1" module="flixel.input.gamepad.FlxGamepadInputID">
	<fromStringMap public="1" set="null" expr="FlxMacroUtil.buildMap(&quot;flixel.input.gamepad.FlxGamepadInputID&quot;)" line="53" static="1">
		<x path="Map">
			<c path="String"/>
			<x path="flixel.input.gamepad.FlxGamepadInputID"/>
		</x>
		<meta><m n=":value"><e>FlxMacroUtil.buildMap("flixel.input.gamepad.FlxGamepadInputID")</e></m></meta>
	</fromStringMap>
	<toStringMap public="1" set="null" expr="FlxMacroUtil.buildMap(&quot;flixel.input.gamepad.FlxGamepadInputID&quot;, true)" line="53" static="1">
		<x path="Map">
			<x path="flixel.input.gamepad.FlxGamepadInputID"/>
			<c path="String"/>
		</x>
		<meta><m n=":value"><e>FlxMacroUtil.buildMap("flixel.input.gamepad.FlxGamepadInputID", true)</e></m></meta>
	</toStringMap>
	<ANY public="1" get="inline" set="null" expr="cast -2" line="22" static="1">
		<x path="flixel.input.gamepad.FlxGamepadInputID"/>
		<meta>
			<m n=":value"><e>cast -2</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</ANY>
	<NONE public="1" get="inline" set="null" expr="cast -1" line="23" static="1">
		<x path="flixel.input.gamepad.FlxGamepadInputID"/>
		<meta>
			<m n=":value"><e>cast -1</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NONE>
	<A public="1" get="inline" set="null" expr="cast 0" line="26" static="1">
		<x path="flixel.input.gamepad.FlxGamepadInputID"/>
		<meta>
			<m n=":value"><e>cast 0</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
		<haxe_doc>BOTTOM face button</haxe_doc>
	</A>
	<B public="1" get="inline" set="null" expr="cast 1" line="28" static="1">
		<x path="flixel.input.gamepad.FlxGamepadInputID"/>
		<meta>
			<m n=":value"><e>cast 1</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
		<haxe_doc>RIGHT face button</haxe_doc>
	</B>
	<X public="1" get="inline" set="null" expr="cast 2" line="30" static="1">
		<x path="flixel.input.gamepad.FlxGamepadInputID"/>
		<meta>
			<m n=":value"><e>cast 2</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
		<haxe_doc>LEFT face button</haxe_doc>
	</X>
	<Y public="1" get="inline" set="null" expr="cast 3" line="32" static="1">
		<x path="flixel.input.gamepad.FlxGamepadInputID"/>
		<meta>
			<m n=":value"><e>cast 3</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
		<haxe_doc>TOP face button</haxe_doc>
	</Y>
	<LEFT_SHOULDER public="1" get="inline" set="null" expr="cast 4" line="34" static="1">
		<x path="flixel.input.gamepad.FlxGamepadInputID"/>
		<meta>
			<m n=":value"><e>cast 4</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
		<haxe_doc>left digital "bumper"</haxe_doc>
	</LEFT_SHOULDER>
	<RIGHT_SHOULDER public="1" get="inline" set="null" expr="cast 5" line="36" static="1">
		<x path="flixel.input.gamepad.FlxGamepadInputID"/>
		<meta>
			<m n=":value"><e>cast 5</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
		<haxe_doc>right digital "bumper"</haxe_doc>
	</RIGHT_SHOULDER>
	<BACK public="1" get="inline" set="null" expr="cast 6" line="38" static="1">
		<x path="flixel.input.gamepad.FlxGamepadInputID"/>
		<meta>
			<m n=":value"><e>cast 6</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
		<haxe_doc>also known as "select", the leftmost center button</haxe_doc>
	</BACK>
	<START public="1" get="inline" set="null" expr="cast 7" line="40" static="1">
		<x path="flixel.input.gamepad.FlxGamepadInputID"/>
		<meta>
			<m n=":value"><e>cast 7</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
		<haxe_doc>the rightmost center button</haxe_doc>
	</START>
	<LEFT_STICK_CLICK public="1" get="inline" set="null" expr="cast 8" line="42" static="1">
		<x path="flixel.input.gamepad.FlxGamepadInputID"/>
		<meta>
			<m n=":value"><e>cast 8</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
		<haxe_doc>digital click of the left analog stick</haxe_doc>
	</LEFT_STICK_CLICK>
	<RIGHT_STICK_CLICK public="1" get="inline" set="null" expr="cast 9" line="44" static="1">
		<x path="flixel.input.gamepad.FlxGamepadInputID"/>
		<meta>
			<m n=":value"><e>cast 9</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
		<haxe_doc>digital click of the right analog stick</haxe_doc>
	</RIGHT_STICK_CLICK>
	<GUIDE public="1" get="inline" set="null" expr="cast 10" line="46" static="1">
		<x path="flixel.input.gamepad.FlxGamepadInputID"/>
		<meta>
			<m n=":value"><e>cast 10</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
		<haxe_doc>this is the "XBox" or "PS" or "home" button in the center</haxe_doc>
	</GUIDE>
	<DPAD_UP public="1" get="inline" set="null" expr="cast 11" line="47" static="1">
		<x path="flixel.input.gamepad.FlxGamepadInputID"/>
		<meta>
			<m n=":value"><e>cast 11</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</DPAD_UP>
	<DPAD_DOWN public="1" get="inline" set="null" expr="cast 12" line="48" static="1">
		<x path="flixel.input.gamepad.FlxGamepadInputID"/>
		<meta>
			<m n=":value"><e>cast 12</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</DPAD_DOWN>
	<DPAD_LEFT public="1" get="inline" set="null" expr="cast 13" line="49" static="1">
		<x path="flixel.input.gamepad.FlxGamepadInputID"/>
		<meta>
			<m n=":value"><e>cast 13</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</DPAD_LEFT>
	<DPAD_RIGHT public="1" get="inline" set="null" expr="cast 14" line="50" static="1">
		<x path="flixel.input.gamepad.FlxGamepadInputID"/>
		<meta>
			<m n=":value"><e>cast 14</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</DPAD_RIGHT>
	<LEFT_TRIGGER_BUTTON public="1" get="inline" set="null" expr="cast 15" line="52" static="1">
		<x path="flixel.input.gamepad.FlxGamepadInputID"/>
		<meta>
			<m n=":value"><e>cast 15</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
		<haxe_doc>digital click at end of left analog trigger's squeeze (if available)</haxe_doc>
	</LEFT_TRIGGER_BUTTON>
	<RIGHT_TRIGGER_BUTTON public="1" get="inline" set="null" expr="cast 16" line="54" static="1">
		<x path="flixel.input.gamepad.FlxGamepadInputID"/>
		<meta>
			<m n=":value"><e>cast 16</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
		<haxe_doc>digital click at end of right analog trigger's squeeze (if available)</haxe_doc>
	</RIGHT_TRIGGER_BUTTON>
	<LEFT_TRIGGER public="1" get="inline" set="null" expr="cast 17" line="56" static="1">
		<x path="flixel.input.gamepad.FlxGamepadInputID"/>
		<meta>
			<m n=":value"><e>cast 17</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</LEFT_TRIGGER>
	<RIGHT_TRIGGER public="1" get="inline" set="null" expr="cast 18" line="57" static="1">
		<x path="flixel.input.gamepad.FlxGamepadInputID"/>
		<meta>
			<m n=":value"><e>cast 18</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</RIGHT_TRIGGER>
	<LEFT_ANALOG_STICK public="1" get="inline" set="null" expr="cast 19" line="60" static="1">
		<x path="flixel.input.gamepad.FlxGamepadInputID"/>
		<meta>
			<m n=":value"><e>cast 19</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
		<haxe_doc>identifier for the entire LEFT_ANALOG_STICK itself, not just any particular direction</haxe_doc>
	</LEFT_ANALOG_STICK>
	<RIGHT_ANALOG_STICK public="1" get="inline" set="null" expr="cast 20" line="62" static="1">
		<x path="flixel.input.gamepad.FlxGamepadInputID"/>
		<meta>
			<m n=":value"><e>cast 20</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
		<haxe_doc>identifier for the entire RIGHT_ANALOG_STICK itself, not just any particular direction</haxe_doc>
	</RIGHT_ANALOG_STICK>
	<DPAD public="1" get="inline" set="null" expr="cast 21" line="65" static="1">
		<x path="flixel.input.gamepad.FlxGamepadInputID"/>
		<meta>
			<m n=":value"><e>cast 21</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
		<haxe_doc>identifier for the entire DPAD itself, not just any particular button</haxe_doc>
	</DPAD>
	<TILT_PITCH public="1" get="inline" set="null" expr="cast 26" line="75" static="1">
		<x path="flixel.input.gamepad.FlxGamepadInputID"/>
		<meta>
			<m n=":value"><e>cast 26</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
		<haxe_doc>tilting towards or away from the ceiling (think "look up", "look down")</haxe_doc>
	</TILT_PITCH>
	<TILT_ROLL public="1" get="inline" set="null" expr="cast 27" line="77" static="1">
		<x path="flixel.input.gamepad.FlxGamepadInputID"/>
		<meta>
			<m n=":value"><e>cast 27</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
		<haxe_doc>tilting side-to-side (think "twisting", or "do a barrel roll!")</haxe_doc>
	</TILT_ROLL>
	<POINTER_X public="1" get="inline" set="null" expr="cast 28" line="80" static="1">
		<x path="flixel.input.gamepad.FlxGamepadInputID"/>
		<meta>
			<m n=":value"><e>cast 28</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
		<haxe_doc>for a mouse-like input such as touch or IR camera. Horizontal axis.</haxe_doc>
	</POINTER_X>
	<POINTER_Y public="1" get="inline" set="null" expr="cast 29" line="82" static="1">
		<x path="flixel.input.gamepad.FlxGamepadInputID"/>
		<meta>
			<m n=":value"><e>cast 29</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
		<haxe_doc>for a mouse-like input such as touch or IR camera. Vertical axis.</haxe_doc>
	</POINTER_Y>
	<EXTRA_0 public="1" get="inline" set="null" expr="cast 30" line="85" static="1">
		<x path="flixel.input.gamepad.FlxGamepadInputID"/>
		<meta>
			<m n=":value"><e>cast 30</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
		<haxe_doc>an extra digital button that doesn't fit cleanly into the universal template</haxe_doc>
	</EXTRA_0>
	<EXTRA_1 public="1" get="inline" set="null" expr="cast 31" line="87" static="1">
		<x path="flixel.input.gamepad.FlxGamepadInputID"/>
		<meta>
			<m n=":value"><e>cast 31</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
		<haxe_doc>an extra digital button that doesn't fit cleanly into the universal template</haxe_doc>
	</EXTRA_1>
	<EXTRA_2 public="1" get="inline" set="null" expr="cast 32" line="89" static="1">
		<x path="flixel.input.gamepad.FlxGamepadInputID"/>
		<meta>
			<m n=":value"><e>cast 32</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
		<haxe_doc>an extra digital button that doesn't fit cleanly into the universal template</haxe_doc>
	</EXTRA_2>
	<EXTRA_3 public="1" get="inline" set="null" expr="cast 33" line="91" static="1">
		<x path="flixel.input.gamepad.FlxGamepadInputID"/>
		<meta>
			<m n=":value"><e>cast 33</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
		<haxe_doc>an extra digital button that doesn't fit cleanly into the universal template</haxe_doc>
	</EXTRA_3>
	<LEFT_STICK_DIGITAL_UP public="1" get="inline" set="null" expr="cast 34" line="94" static="1">
		<x path="flixel.input.gamepad.FlxGamepadInputID"/>
		<meta>
			<m n=":value"><e>cast 34</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
		<haxe_doc>left analog stick as a dpad, pushed up</haxe_doc>
	</LEFT_STICK_DIGITAL_UP>
	<LEFT_STICK_DIGITAL_RIGHT public="1" get="inline" set="null" expr="cast 35" line="96" static="1">
		<x path="flixel.input.gamepad.FlxGamepadInputID"/>
		<meta>
			<m n=":value"><e>cast 35</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
		<haxe_doc>left analog stick as a dpad, pushed right</haxe_doc>
	</LEFT_STICK_DIGITAL_RIGHT>
	<LEFT_STICK_DIGITAL_DOWN public="1" get="inline" set="null" expr="cast 36" line="98" static="1">
		<x path="flixel.input.gamepad.FlxGamepadInputID"/>
		<meta>
			<m n=":value"><e>cast 36</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
		<haxe_doc>left analog stick as a dpad, pushed down</haxe_doc>
	</LEFT_STICK_DIGITAL_DOWN>
	<LEFT_STICK_DIGITAL_LEFT public="1" get="inline" set="null" expr="cast 37" line="100" static="1">
		<x path="flixel.input.gamepad.FlxGamepadInputID"/>
		<meta>
			<m n=":value"><e>cast 37</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
		<haxe_doc>left analog stick as a dpad, pushed left</haxe_doc>
	</LEFT_STICK_DIGITAL_LEFT>
	<RIGHT_STICK_DIGITAL_UP public="1" get="inline" set="null" expr="cast 38" line="103" static="1">
		<x path="flixel.input.gamepad.FlxGamepadInputID"/>
		<meta>
			<m n=":value"><e>cast 38</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
		<haxe_doc>left analog stick as a dpad, pushed up</haxe_doc>
	</RIGHT_STICK_DIGITAL_UP>
	<RIGHT_STICK_DIGITAL_RIGHT public="1" get="inline" set="null" expr="cast 39" line="105" static="1">
		<x path="flixel.input.gamepad.FlxGamepadInputID"/>
		<meta>
			<m n=":value"><e>cast 39</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
		<haxe_doc>left analog stick as a dpad, pushed right</haxe_doc>
	</RIGHT_STICK_DIGITAL_RIGHT>
	<RIGHT_STICK_DIGITAL_DOWN public="1" get="inline" set="null" expr="cast 40" line="107" static="1">
		<x path="flixel.input.gamepad.FlxGamepadInputID"/>
		<meta>
			<m n=":value"><e>cast 40</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
		<haxe_doc>left analog stick as a dpad, pushed down</haxe_doc>
	</RIGHT_STICK_DIGITAL_DOWN>
	<RIGHT_STICK_DIGITAL_LEFT public="1" get="inline" set="null" expr="cast 41" line="109" static="1">
		<x path="flixel.input.gamepad.FlxGamepadInputID"/>
		<meta>
			<m n=":value"><e>cast 41</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
		<haxe_doc>left analog stick as a dpad, pushed left</haxe_doc>
	</RIGHT_STICK_DIGITAL_LEFT>
	<fromString public="1" get="inline" set="null" line="112" static="1">
		<f a="s">
			<c path="String"/>
			<x path="flixel.input.gamepad.FlxGamepadInputID"/>
		</f>
		<meta><m n=":from"/></meta>
	</fromString>
	<toString public="1" get="inline" set="null" line="119" static="1">
		<f a="this">
			<x path="Int"/>
			<c path="String"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":to"/>
		</meta>
	</toString>
	<meta>
		<m n=":directlyUsed"/>
		<m n=":final"/>
		<m n=":enum"/>
	</meta>
</class></impl>
	</abstract>
	<class path="flixel.input.gamepad._FlxGamepadInputID.FlxGamepadInputID_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/input/gamepad/FlxGamepadInputID.hx" private="1" module="flixel.input.gamepad.FlxGamepadInputID">
		<fromStringMap public="1" set="null" expr="FlxMacroUtil.buildMap(&quot;flixel.input.gamepad.FlxGamepadInputID&quot;)" line="53" static="1">
			<x path="Map">
				<c path="String"/>
				<x path="flixel.input.gamepad.FlxGamepadInputID"/>
			</x>
			<meta><m n=":value"><e>FlxMacroUtil.buildMap("flixel.input.gamepad.FlxGamepadInputID")</e></m></meta>
		</fromStringMap>
		<toStringMap public="1" set="null" expr="FlxMacroUtil.buildMap(&quot;flixel.input.gamepad.FlxGamepadInputID&quot;, true)" line="53" static="1">
			<x path="Map">
				<x path="flixel.input.gamepad.FlxGamepadInputID"/>
				<c path="String"/>
			</x>
			<meta><m n=":value"><e>FlxMacroUtil.buildMap("flixel.input.gamepad.FlxGamepadInputID", true)</e></m></meta>
		</toStringMap>
		<ANY public="1" get="inline" set="null" expr="cast -2" line="22" static="1">
			<x path="flixel.input.gamepad.FlxGamepadInputID"/>
			<meta>
				<m n=":value"><e>cast -2</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</ANY>
		<NONE public="1" get="inline" set="null" expr="cast -1" line="23" static="1">
			<x path="flixel.input.gamepad.FlxGamepadInputID"/>
			<meta>
				<m n=":value"><e>cast -1</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NONE>
		<A public="1" get="inline" set="null" expr="cast 0" line="26" static="1">
			<x path="flixel.input.gamepad.FlxGamepadInputID"/>
			<meta>
				<m n=":value"><e>cast 0</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
			<haxe_doc>BOTTOM face button</haxe_doc>
		</A>
		<B public="1" get="inline" set="null" expr="cast 1" line="28" static="1">
			<x path="flixel.input.gamepad.FlxGamepadInputID"/>
			<meta>
				<m n=":value"><e>cast 1</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
			<haxe_doc>RIGHT face button</haxe_doc>
		</B>
		<X public="1" get="inline" set="null" expr="cast 2" line="30" static="1">
			<x path="flixel.input.gamepad.FlxGamepadInputID"/>
			<meta>
				<m n=":value"><e>cast 2</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
			<haxe_doc>LEFT face button</haxe_doc>
		</X>
		<Y public="1" get="inline" set="null" expr="cast 3" line="32" static="1">
			<x path="flixel.input.gamepad.FlxGamepadInputID"/>
			<meta>
				<m n=":value"><e>cast 3</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
			<haxe_doc>TOP face button</haxe_doc>
		</Y>
		<LEFT_SHOULDER public="1" get="inline" set="null" expr="cast 4" line="34" static="1">
			<x path="flixel.input.gamepad.FlxGamepadInputID"/>
			<meta>
				<m n=":value"><e>cast 4</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
			<haxe_doc>left digital "bumper"</haxe_doc>
		</LEFT_SHOULDER>
		<RIGHT_SHOULDER public="1" get="inline" set="null" expr="cast 5" line="36" static="1">
			<x path="flixel.input.gamepad.FlxGamepadInputID"/>
			<meta>
				<m n=":value"><e>cast 5</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
			<haxe_doc>right digital "bumper"</haxe_doc>
		</RIGHT_SHOULDER>
		<BACK public="1" get="inline" set="null" expr="cast 6" line="38" static="1">
			<x path="flixel.input.gamepad.FlxGamepadInputID"/>
			<meta>
				<m n=":value"><e>cast 6</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
			<haxe_doc>also known as "select", the leftmost center button</haxe_doc>
		</BACK>
		<START public="1" get="inline" set="null" expr="cast 7" line="40" static="1">
			<x path="flixel.input.gamepad.FlxGamepadInputID"/>
			<meta>
				<m n=":value"><e>cast 7</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
			<haxe_doc>the rightmost center button</haxe_doc>
		</START>
		<LEFT_STICK_CLICK public="1" get="inline" set="null" expr="cast 8" line="42" static="1">
			<x path="flixel.input.gamepad.FlxGamepadInputID"/>
			<meta>
				<m n=":value"><e>cast 8</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
			<haxe_doc>digital click of the left analog stick</haxe_doc>
		</LEFT_STICK_CLICK>
		<RIGHT_STICK_CLICK public="1" get="inline" set="null" expr="cast 9" line="44" static="1">
			<x path="flixel.input.gamepad.FlxGamepadInputID"/>
			<meta>
				<m n=":value"><e>cast 9</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
			<haxe_doc>digital click of the right analog stick</haxe_doc>
		</RIGHT_STICK_CLICK>
		<GUIDE public="1" get="inline" set="null" expr="cast 10" line="46" static="1">
			<x path="flixel.input.gamepad.FlxGamepadInputID"/>
			<meta>
				<m n=":value"><e>cast 10</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
			<haxe_doc>this is the "XBox" or "PS" or "home" button in the center</haxe_doc>
		</GUIDE>
		<DPAD_UP public="1" get="inline" set="null" expr="cast 11" line="47" static="1">
			<x path="flixel.input.gamepad.FlxGamepadInputID"/>
			<meta>
				<m n=":value"><e>cast 11</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</DPAD_UP>
		<DPAD_DOWN public="1" get="inline" set="null" expr="cast 12" line="48" static="1">
			<x path="flixel.input.gamepad.FlxGamepadInputID"/>
			<meta>
				<m n=":value"><e>cast 12</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</DPAD_DOWN>
		<DPAD_LEFT public="1" get="inline" set="null" expr="cast 13" line="49" static="1">
			<x path="flixel.input.gamepad.FlxGamepadInputID"/>
			<meta>
				<m n=":value"><e>cast 13</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</DPAD_LEFT>
		<DPAD_RIGHT public="1" get="inline" set="null" expr="cast 14" line="50" static="1">
			<x path="flixel.input.gamepad.FlxGamepadInputID"/>
			<meta>
				<m n=":value"><e>cast 14</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</DPAD_RIGHT>
		<LEFT_TRIGGER_BUTTON public="1" get="inline" set="null" expr="cast 15" line="52" static="1">
			<x path="flixel.input.gamepad.FlxGamepadInputID"/>
			<meta>
				<m n=":value"><e>cast 15</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
			<haxe_doc>digital click at end of left analog trigger's squeeze (if available)</haxe_doc>
		</LEFT_TRIGGER_BUTTON>
		<RIGHT_TRIGGER_BUTTON public="1" get="inline" set="null" expr="cast 16" line="54" static="1">
			<x path="flixel.input.gamepad.FlxGamepadInputID"/>
			<meta>
				<m n=":value"><e>cast 16</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
			<haxe_doc>digital click at end of right analog trigger's squeeze (if available)</haxe_doc>
		</RIGHT_TRIGGER_BUTTON>
		<LEFT_TRIGGER public="1" get="inline" set="null" expr="cast 17" line="56" static="1">
			<x path="flixel.input.gamepad.FlxGamepadInputID"/>
			<meta>
				<m n=":value"><e>cast 17</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</LEFT_TRIGGER>
		<RIGHT_TRIGGER public="1" get="inline" set="null" expr="cast 18" line="57" static="1">
			<x path="flixel.input.gamepad.FlxGamepadInputID"/>
			<meta>
				<m n=":value"><e>cast 18</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</RIGHT_TRIGGER>
		<LEFT_ANALOG_STICK public="1" get="inline" set="null" expr="cast 19" line="60" static="1">
			<x path="flixel.input.gamepad.FlxGamepadInputID"/>
			<meta>
				<m n=":value"><e>cast 19</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
			<haxe_doc>identifier for the entire LEFT_ANALOG_STICK itself, not just any particular direction</haxe_doc>
		</LEFT_ANALOG_STICK>
		<RIGHT_ANALOG_STICK public="1" get="inline" set="null" expr="cast 20" line="62" static="1">
			<x path="flixel.input.gamepad.FlxGamepadInputID"/>
			<meta>
				<m n=":value"><e>cast 20</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
			<haxe_doc>identifier for the entire RIGHT_ANALOG_STICK itself, not just any particular direction</haxe_doc>
		</RIGHT_ANALOG_STICK>
		<DPAD public="1" get="inline" set="null" expr="cast 21" line="65" static="1">
			<x path="flixel.input.gamepad.FlxGamepadInputID"/>
			<meta>
				<m n=":value"><e>cast 21</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
			<haxe_doc>identifier for the entire DPAD itself, not just any particular button</haxe_doc>
		</DPAD>
		<TILT_PITCH public="1" get="inline" set="null" expr="cast 26" line="75" static="1">
			<x path="flixel.input.gamepad.FlxGamepadInputID"/>
			<meta>
				<m n=":value"><e>cast 26</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
			<haxe_doc>tilting towards or away from the ceiling (think "look up", "look down")</haxe_doc>
		</TILT_PITCH>
		<TILT_ROLL public="1" get="inline" set="null" expr="cast 27" line="77" static="1">
			<x path="flixel.input.gamepad.FlxGamepadInputID"/>
			<meta>
				<m n=":value"><e>cast 27</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
			<haxe_doc>tilting side-to-side (think "twisting", or "do a barrel roll!")</haxe_doc>
		</TILT_ROLL>
		<POINTER_X public="1" get="inline" set="null" expr="cast 28" line="80" static="1">
			<x path="flixel.input.gamepad.FlxGamepadInputID"/>
			<meta>
				<m n=":value"><e>cast 28</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
			<haxe_doc>for a mouse-like input such as touch or IR camera. Horizontal axis.</haxe_doc>
		</POINTER_X>
		<POINTER_Y public="1" get="inline" set="null" expr="cast 29" line="82" static="1">
			<x path="flixel.input.gamepad.FlxGamepadInputID"/>
			<meta>
				<m n=":value"><e>cast 29</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
			<haxe_doc>for a mouse-like input such as touch or IR camera. Vertical axis.</haxe_doc>
		</POINTER_Y>
		<EXTRA_0 public="1" get="inline" set="null" expr="cast 30" line="85" static="1">
			<x path="flixel.input.gamepad.FlxGamepadInputID"/>
			<meta>
				<m n=":value"><e>cast 30</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
			<haxe_doc>an extra digital button that doesn't fit cleanly into the universal template</haxe_doc>
		</EXTRA_0>
		<EXTRA_1 public="1" get="inline" set="null" expr="cast 31" line="87" static="1">
			<x path="flixel.input.gamepad.FlxGamepadInputID"/>
			<meta>
				<m n=":value"><e>cast 31</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
			<haxe_doc>an extra digital button that doesn't fit cleanly into the universal template</haxe_doc>
		</EXTRA_1>
		<EXTRA_2 public="1" get="inline" set="null" expr="cast 32" line="89" static="1">
			<x path="flixel.input.gamepad.FlxGamepadInputID"/>
			<meta>
				<m n=":value"><e>cast 32</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
			<haxe_doc>an extra digital button that doesn't fit cleanly into the universal template</haxe_doc>
		</EXTRA_2>
		<EXTRA_3 public="1" get="inline" set="null" expr="cast 33" line="91" static="1">
			<x path="flixel.input.gamepad.FlxGamepadInputID"/>
			<meta>
				<m n=":value"><e>cast 33</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
			<haxe_doc>an extra digital button that doesn't fit cleanly into the universal template</haxe_doc>
		</EXTRA_3>
		<LEFT_STICK_DIGITAL_UP public="1" get="inline" set="null" expr="cast 34" line="94" static="1">
			<x path="flixel.input.gamepad.FlxGamepadInputID"/>
			<meta>
				<m n=":value"><e>cast 34</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
			<haxe_doc>left analog stick as a dpad, pushed up</haxe_doc>
		</LEFT_STICK_DIGITAL_UP>
		<LEFT_STICK_DIGITAL_RIGHT public="1" get="inline" set="null" expr="cast 35" line="96" static="1">
			<x path="flixel.input.gamepad.FlxGamepadInputID"/>
			<meta>
				<m n=":value"><e>cast 35</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
			<haxe_doc>left analog stick as a dpad, pushed right</haxe_doc>
		</LEFT_STICK_DIGITAL_RIGHT>
		<LEFT_STICK_DIGITAL_DOWN public="1" get="inline" set="null" expr="cast 36" line="98" static="1">
			<x path="flixel.input.gamepad.FlxGamepadInputID"/>
			<meta>
				<m n=":value"><e>cast 36</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
			<haxe_doc>left analog stick as a dpad, pushed down</haxe_doc>
		</LEFT_STICK_DIGITAL_DOWN>
		<LEFT_STICK_DIGITAL_LEFT public="1" get="inline" set="null" expr="cast 37" line="100" static="1">
			<x path="flixel.input.gamepad.FlxGamepadInputID"/>
			<meta>
				<m n=":value"><e>cast 37</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
			<haxe_doc>left analog stick as a dpad, pushed left</haxe_doc>
		</LEFT_STICK_DIGITAL_LEFT>
		<RIGHT_STICK_DIGITAL_UP public="1" get="inline" set="null" expr="cast 38" line="103" static="1">
			<x path="flixel.input.gamepad.FlxGamepadInputID"/>
			<meta>
				<m n=":value"><e>cast 38</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
			<haxe_doc>left analog stick as a dpad, pushed up</haxe_doc>
		</RIGHT_STICK_DIGITAL_UP>
		<RIGHT_STICK_DIGITAL_RIGHT public="1" get="inline" set="null" expr="cast 39" line="105" static="1">
			<x path="flixel.input.gamepad.FlxGamepadInputID"/>
			<meta>
				<m n=":value"><e>cast 39</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
			<haxe_doc>left analog stick as a dpad, pushed right</haxe_doc>
		</RIGHT_STICK_DIGITAL_RIGHT>
		<RIGHT_STICK_DIGITAL_DOWN public="1" get="inline" set="null" expr="cast 40" line="107" static="1">
			<x path="flixel.input.gamepad.FlxGamepadInputID"/>
			<meta>
				<m n=":value"><e>cast 40</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
			<haxe_doc>left analog stick as a dpad, pushed down</haxe_doc>
		</RIGHT_STICK_DIGITAL_DOWN>
		<RIGHT_STICK_DIGITAL_LEFT public="1" get="inline" set="null" expr="cast 41" line="109" static="1">
			<x path="flixel.input.gamepad.FlxGamepadInputID"/>
			<meta>
				<m n=":value"><e>cast 41</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
			<haxe_doc>left analog stick as a dpad, pushed left</haxe_doc>
		</RIGHT_STICK_DIGITAL_LEFT>
		<fromString public="1" get="inline" set="null" line="112" static="1">
			<f a="s">
				<c path="String"/>
				<x path="flixel.input.gamepad.FlxGamepadInputID"/>
			</f>
			<meta><m n=":from"/></meta>
		</fromString>
		<toString public="1" get="inline" set="null" line="119" static="1">
			<f a="this">
				<x path="Int"/>
				<c path="String"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":to"/>
			</meta>
		</toString>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":final"/>
			<m n=":enum"/>
		</meta>
	</class>
	<class path="openfl.ui.GameInput" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/ui/GameInput.hx">
		<extends path="openfl.events.EventDispatcher"/>
		<isSupported public="1" set="null" expr="true" line="18" static="1">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</isSupported>
		<numDevices public="1" set="null" expr="0" line="19" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</numDevices>
		<__deviceList expr="new Array&lt;GameInputDevice&gt;()" line="21" static="1">
			<c path="Array"><c path="openfl.ui.GameInputDevice"/></c>
			<meta><m n=":value"><e><![CDATA[new Array<GameInputDevice>()]]></e></m></meta>
		</__deviceList>
		<__devices expr="new Map&lt;Gamepad,GameInputDevice&gt;()" line="22" static="1">
			<x path="Map">
				<c path="lime.ui.Gamepad"/>
				<c path="openfl.ui.GameInputDevice"/>
			</x>
			<meta><m n=":value"><e><![CDATA[new Map<Gamepad,GameInputDevice>()]]></e></m></meta>
		</__devices>
		<__instances expr="[]" line="23" static="1">
			<c path="Array"><c path="openfl.ui.GameInput"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</__instances>
		<getDeviceAt public="1" set="method" line="35" static="1"><f a="index">
	<x path="Int"/>
	<c path="openfl.ui.GameInputDevice"/>
</f></getDeviceAt>
		<__getDevice set="method" line="48" static="1"><f a="gamepad">
	<c path="lime.ui.Gamepad"/>
	<c path="openfl.ui.GameInputDevice"/>
</f></__getDevice>
		<__onGamepadAxisMove set="method" line="66" static="1"><f a="gamepad:axis:value">
	<c path="lime.ui.Gamepad"/>
	<x path="lime.ui.GamepadAxis"/>
	<x path="Float"/>
	<x path="Void"/>
</f></__onGamepadAxisMove>
		<__onGamepadButtonDown set="method" line="90" static="1"><f a="gamepad:button">
	<c path="lime.ui.Gamepad"/>
	<x path="lime.ui.GamepadButton"/>
	<x path="Void"/>
</f></__onGamepadButtonDown>
		<__onGamepadButtonUp set="method" line="114" static="1"><f a="gamepad:button">
	<c path="lime.ui.Gamepad"/>
	<x path="lime.ui.GamepadButton"/>
	<x path="Void"/>
</f></__onGamepadButtonUp>
		<__onGamepadConnect set="method" line="138" static="1"><f a="gamepad">
	<c path="lime.ui.Gamepad"/>
	<x path="Void"/>
</f></__onGamepadConnect>
		<__onGamepadDisconnect set="method" line="152" static="1"><f a="gamepad">
	<c path="lime.ui.Gamepad"/>
	<x path="Void"/>
</f></__onGamepadDisconnect>
		<new public="1" set="method" line="26"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":access"><e>openfl.ui.GameInputControl</e></m>
			<m n=":access"><e>openfl.ui.GameInputDevice</e></m>
			<m n=":final"/>
		</meta>
	</class>
	<class path="flixel.input.gamepad.FlxGamepadManager" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/input/gamepad/FlxGamepadManager.hx">
		<implements path="flixel.input.IFlxInputManager"/>
		<_gameInput expr="new GameInput()" line="53" static="1">
			<t path="flash.ui.GameInput"/>
			<meta><m n=":value"><e>new GameInput()</e></m></meta>
			<haxe_doc>* GameInput needs to be statically created, otherwise GameInput.numDevices will be zero during construction.</haxe_doc>
		</_gameInput>
		<firstActive public="1">
			<c path="flixel.input.gamepad.FlxGamepad"/>
			<haxe_doc>* The first accessed gamepad - can be `null`!</haxe_doc>
		</firstActive>
		<lastActive public="1">
			<c path="flixel.input.gamepad.FlxGamepad"/>
			<haxe_doc>* The last accessed gamepad - can be `null`!</haxe_doc>
		</lastActive>
		<numActiveGamepads public="1" get="accessor" set="null">
			<x path="Int"/>
			<haxe_doc>* A counter for the number of active gamepads</haxe_doc>
		</numActiveGamepads>
		<globalDeadZone public="1">
			<t path="Null"><x path="Float"/></t>
			<haxe_doc>* Global Gamepad deadzone. The lower, the more sensitive the gamepad. Should be
	 * between 0.0 and 1.0. Null by default, overrides the deadzone of gamepads if non-null.</haxe_doc>
		</globalDeadZone>
		<_gamepads expr="[]">
			<c path="Array"><c path="flixel.input.gamepad.FlxGamepad"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
			<haxe_doc>* Stores all gamepads - can have null entries, but index matches event.device</haxe_doc>
		</_gamepads>
		<_activeGamepads expr="[]">
			<c path="Array"><c path="flixel.input.gamepad.FlxGamepad"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
			<haxe_doc>* Stores all gamepads - no null entries, but index does *not* match event.device</haxe_doc>
		</_activeGamepads>
		<getByID public="1" get="inline" set="null" line="60">
			<f a="GamepadID">
				<x path="Int"/>
				<c path="flixel.input.gamepad.FlxGamepad"/>
			</f>
			<haxe_doc>* Returns a FlxGamepad with the specified ID or null if none was found.
	 * For example, if there are 4 gamepads connected, they will have the IDs 0-3.</haxe_doc>
		</getByID>
		<removeByID set="method" line="65"><f a="GamepadID">
	<x path="Int"/>
	<x path="Void"/>
</f></removeByID>
		<createByID set="method" line="85"><f a="GamepadID:?Model">
	<x path="Int"/>
	<e path="flixel.input.gamepad.FlxGamepadModel"/>
	<c path="flixel.input.gamepad.FlxGamepad"/>
</f></createByID>
		<getActiveGamepadIDs public="1" set="method" line="122">
			<f a="?IDsArray">
				<c path="Array"><x path="Int"/></c>
				<c path="Array"><x path="Int"/></c>
			</f>
			<haxe_doc>* Get array of ids for gamepads with any pressed buttons or moved Axis, Ball and Hat.
	 * 
	 * @param	IDsArray	optional array to fill with ids
	 * @return	array filled with active gamepad ids</haxe_doc>
		</getActiveGamepadIDs>
		<getActiveGamepads public="1" set="method" line="140">
			<f a="?GamepadArray">
				<c path="Array"><c path="flixel.input.gamepad.FlxGamepad"/></c>
				<c path="Array"><c path="flixel.input.gamepad.FlxGamepad"/></c>
			</f>
			<haxe_doc>* Get array of gamepads with any pressed buttons or moved Axis, Ball and Hat.
	 * 
	 * @param	GamepadArray	optional array to fill with active gamepads
	 * @return	array filled with active gamepads</haxe_doc>
		</getActiveGamepads>
		<getFirstActiveGamepadID public="1" set="method" line="156">
			<f a=""><x path="Int"/></f>
			<haxe_doc>* Get first found active gamepad id (with any pressed buttons or moved Axis, Ball and Hat).
	 * Returns "-1" if no active gamepad has been found.</haxe_doc>
		</getFirstActiveGamepadID>
		<getFirstActiveGamepad public="1" set="method" line="166">
			<f a=""><c path="flixel.input.gamepad.FlxGamepad"/></f>
			<haxe_doc>* Get first found active gamepad (with any pressed buttons or moved Axis, Ball and Hat).
	 * Returns null if no active gamepad has been found.</haxe_doc>
		</getFirstActiveGamepad>
		<anyButton public="1" set="method" line="178">
			<f a="?state" v="PRESSED">
				<x path="flixel.input.FlxInputState"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":value"><e>{ state : PRESSED }</e></m></meta>
			<haxe_doc>* Whether any buttons have the specified input state on any gamepad.</haxe_doc>
		</anyButton>
		<anyInput public="1" set="method" line="190">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>* Whether there's any input at all on any gamepad.</haxe_doc>
		</anyInput>
		<anyPressed public="1" get="inline" set="null" line="202">
			<f a="buttonID">
				<x path="flixel.input.gamepad.FlxGamepadInputID"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Whether this button is pressed on any gamepad.</haxe_doc>
		</anyPressed>
		<anyJustPressed public="1" get="inline" set="null" line="210">
			<f a="buttonID">
				<x path="flixel.input.gamepad.FlxGamepadInputID"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Whether this button was just pressed on any gamepad.</haxe_doc>
		</anyJustPressed>
		<anyJustReleased public="1" get="inline" set="null" line="218">
			<f a="buttonID">
				<x path="flixel.input.gamepad.FlxGamepadInputID"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Whether this button was just released on any gamepad.</haxe_doc>
		</anyJustReleased>
		<anyHasState set="method" line="223"><f a="buttonID:state">
	<x path="flixel.input.gamepad.FlxGamepadInputID"/>
	<x path="flixel.input.FlxInputState"/>
	<x path="Bool"/>
</f></anyHasState>
		<anyMovedXAxis public="1" set="method" line="238">
			<f a="RawAxisID">
				<c path="flixel.input.gamepad.FlxGamepadAnalogStick"/>
				<x path="Float"/>
			</f>
			<haxe_doc>* Check to see if the X axis is moved on any Gamepad.
	 * 
	 * @param AxisID The axis id
	 * @return Float Value from -1 to 1 or 0 if no X axes were moved</haxe_doc>
		</anyMovedXAxis>
		<anyMovedYAxis public="1" set="method" line="259">
			<f a="RawAxisID">
				<c path="flixel.input.gamepad.FlxGamepadAnalogStick"/>
				<x path="Float"/>
			</f>
			<haxe_doc>* Check to see if the Y axis is moved on any Gamepad.
	 * 
	 * @param AxisID The axis id
	 * @return Float Value from -1 to 1 or 0 if no Y axes were moved</haxe_doc>
		</anyMovedYAxis>
		<destroy public="1" set="method" line="278">
			<f a=""><x path="Void"/></f>
			<meta><m n=":noCompletion"/></meta>
			<haxe_doc>* Clean up memory. Internal use only.</haxe_doc>
		</destroy>
		<reset public="1" set="method" line="296">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Resets all the keys on all joys.</haxe_doc>
		</reset>
		<onDeviceAdded set="method" line="324"><f a="Event">
	<t path="flash.events.GameInputEvent"/>
	<x path="Void"/>
</f></onDeviceAdded>
		<onDeviceRemoved set="method" line="329"><f a="Event">
	<t path="flash.events.GameInputEvent"/>
	<x path="Void"/>
</f></onDeviceRemoved>
		<findGamepadIndex set="method" line="334"><f a="Device">
	<t path="flash.ui.GameInputDevice"/>
	<x path="Int"/>
</f></findGamepadIndex>
		<addGamepad set="method" line="346"><f a="Device">
	<t path="flash.ui.GameInputDevice"/>
	<x path="Void"/>
</f></addGamepad>
		<getModelFromDeviceName set="method" line="360"><f a="name">
	<c path="String"/>
	<e path="flixel.input.gamepad.FlxGamepadModel"/>
</f></getModelFromDeviceName>
		<removeGamepad set="method" line="389"><f a="Device">
	<t path="flash.ui.GameInputDevice"/>
	<x path="Void"/>
</f></removeGamepad>
		<update set="method" line="534">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Updates the key states (for tracking just pressed, just released, etc).</haxe_doc>
		</update>
		<onFocus get="inline" set="null" line="541"><f a=""><x path="Void"/></f></onFocus>
		<onFocusLost get="inline" set="null" line="543"><f a=""><x path="Void"/></f></onFocusLost>
		<get_numActiveGamepads set="method" line="548"><f a=""><x path="Int"/></f></get_numActiveGamepads>
		<new set="method" line="304">
			<f a=""><x path="Void"/></f>
			<meta><m n=":allow"><e>flixel.FlxG</e></m></meta>
		</new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="flixel.input.gamepad.id.LogitechID" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/input/gamepad/id/LogitechID.hx">
		<ONE public="1" get="inline" set="null" expr="0" line="33" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</ONE>
		<TWO public="1" get="inline" set="null" expr="1" line="34" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</TWO>
		<THREE public="1" get="inline" set="null" expr="2" line="35" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>2</e></m></meta>
		</THREE>
		<FOUR public="1" get="inline" set="null" expr="3" line="36" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>3</e></m></meta>
		</FOUR>
		<FIVE public="1" get="inline" set="null" expr="4" line="37" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>4</e></m></meta>
		</FIVE>
		<SIX public="1" get="inline" set="null" expr="5" line="38" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>5</e></m></meta>
		</SIX>
		<SEVEN public="1" get="inline" set="null" expr="6" line="39" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>6</e></m></meta>
		</SEVEN>
		<EIGHT public="1" get="inline" set="null" expr="7" line="40" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>7</e></m></meta>
		</EIGHT>
		<NINE public="1" get="inline" set="null" expr="8" line="41" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>8</e></m></meta>
		</NINE>
		<TEN public="1" get="inline" set="null" expr="9" line="42" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>9</e></m></meta>
		</TEN>
		<LEFT_STICK_CLICK public="1" get="inline" set="null" expr="10" line="43" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>10</e></m></meta>
		</LEFT_STICK_CLICK>
		<RIGHT_STICK_CLICK public="1" get="inline" set="null" expr="11" line="44" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>11</e></m></meta>
		</RIGHT_STICK_CLICK>
		<DPAD_UP public="1" get="inline" set="null" expr="16" line="47" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>16</e></m></meta>
		</DPAD_UP>
		<DPAD_DOWN public="1" get="inline" set="null" expr="17" line="48" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>17</e></m></meta>
		</DPAD_DOWN>
		<DPAD_LEFT public="1" get="inline" set="null" expr="18" line="49" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>18</e></m></meta>
		</DPAD_LEFT>
		<DPAD_RIGHT public="1" get="inline" set="null" expr="19" line="50" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>19</e></m></meta>
		</DPAD_RIGHT>
		<LOGITECH public="1" get="inline" set="null" expr="-5" line="53" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>-5</e></m></meta>
		</LOGITECH>
		<LEFT_ANALOG_STICK public="1" set="null" expr="new FlxGamepadAnalogStick(0, 1, { up : 24, down : 25, left : 26, right : 27 })" line="57" static="1">
			<c path="flixel.input.gamepad.FlxGamepadAnalogStick"/>
			<meta><m n=":value"><e>new FlxGamepadAnalogStick(0, 1, { up : 24, down : 25, left : 26, right : 27 })</e></m></meta>
		</LEFT_ANALOG_STICK>
		<RIGHT_ANALOG_STICK public="1" set="null" expr="new FlxGamepadAnalogStick(2, 3, { up : 28, down : 29, left : 30, right : 31 })" line="58" static="1">
			<c path="flixel.input.gamepad.FlxGamepadAnalogStick"/>
			<meta><m n=":value"><e>new FlxGamepadAnalogStick(2, 3, { up : 28, down : 29, left : 30, right : 31 })</e></m></meta>
		</RIGHT_ANALOG_STICK>
		<haxe_doc>* IDs for Logitech controllers (key codes based on Cordless Rumblepad 2)</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="flixel.input.gamepad.id.MFiID" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/input/gamepad/id/MFiID.hx">
		<A public="1" get="inline" set="null" expr="6" line="8" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>6</e></m></meta>
		</A>
		<B public="1" get="inline" set="null" expr="7" line="9" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>7</e></m></meta>
		</B>
		<X public="1" get="inline" set="null" expr="8" line="10" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>8</e></m></meta>
		</X>
		<Y public="1" get="inline" set="null" expr="9" line="11" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>9</e></m></meta>
		</Y>
		<LB public="1" get="inline" set="null" expr="15" line="12" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>15</e></m></meta>
		</LB>
		<RB public="1" get="inline" set="null" expr="16" line="13" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>16</e></m></meta>
		</RB>
		<BACK public="1" get="inline" set="null" expr="10" line="14" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>10</e></m></meta>
		</BACK>
		<START public="1" get="inline" set="null" expr="12" line="15" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>12</e></m></meta>
		</START>
		<LEFT_STICK_CLICK public="1" get="inline" set="null" expr="13" line="16" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>13</e></m></meta>
		</LEFT_STICK_CLICK>
		<RIGHT_STICK_CLICK public="1" get="inline" set="null" expr="14" line="17" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>14</e></m></meta>
		</RIGHT_STICK_CLICK>
		<GUIDE public="1" get="inline" set="null" expr="11" line="19" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>11</e></m></meta>
		</GUIDE>
		<DPAD_UP public="1" get="inline" set="null" expr="17" line="21" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>17</e></m></meta>
		</DPAD_UP>
		<DPAD_DOWN public="1" get="inline" set="null" expr="18" line="22" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>18</e></m></meta>
		</DPAD_DOWN>
		<DPAD_LEFT public="1" get="inline" set="null" expr="19" line="23" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>19</e></m></meta>
		</DPAD_LEFT>
		<DPAD_RIGHT public="1" get="inline" set="null" expr="20" line="24" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>20</e></m></meta>
		</DPAD_RIGHT>
		<LEFT_ANALOG_STICK public="1" set="null" expr="new FlxGamepadAnalogStick(0, 1, { up : 21, down : 22, left : 23, right : 24 })" line="26" static="1">
			<c path="flixel.input.gamepad.FlxGamepadAnalogStick"/>
			<meta><m n=":value"><e>new FlxGamepadAnalogStick(0, 1, { up : 21, down : 22, left : 23, right : 24 })</e></m></meta>
		</LEFT_ANALOG_STICK>
		<RIGHT_ANALOG_STICK public="1" set="null" expr="new FlxGamepadAnalogStick(2, 3, { up : 25, down : 26, left : 27, right : 28 })" line="27" static="1">
			<c path="flixel.input.gamepad.FlxGamepadAnalogStick"/>
			<meta><m n=":value"><e>new FlxGamepadAnalogStick(2, 3, { up : 25, down : 26, left : 27, right : 28 })</e></m></meta>
		</RIGHT_ANALOG_STICK>
		<LEFT_TRIGGER public="1" get="inline" set="null" expr="4" line="29" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>4</e></m></meta>
		</LEFT_TRIGGER>
		<RIGHT_TRIGGER public="1" get="inline" set="null" expr="5" line="30" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>5</e></m></meta>
		</RIGHT_TRIGGER>
		<haxe_doc>* IDs for MFi controllers</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="flixel.input.gamepad.id.MayflashWiiRemoteID" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/input/gamepad/id/MayflashWiiRemoteID.hx">
		<REMOTE_ONE public="1" get="inline" set="null" expr="8" line="106" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>8</e></m></meta>
			<haxe_doc>* Things to add:
	 * - Accelerometer (in both remote and nunchuk)
	 * - Gyroscope (in Motion-Plus version only)
	 * - IR camera (position tracking)
	 * - Rumble
	 * - Speaker</haxe_doc>
		</REMOTE_ONE>
		<REMOTE_TWO public="1" get="inline" set="null" expr="9" line="107" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>9</e></m></meta>
		</REMOTE_TWO>
		<REMOTE_A public="1" get="inline" set="null" expr="10" line="108" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>10</e></m></meta>
		</REMOTE_A>
		<REMOTE_B public="1" get="inline" set="null" expr="11" line="109" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>11</e></m></meta>
		</REMOTE_B>
		<REMOTE_MINUS public="1" get="inline" set="null" expr="12" line="111" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>12</e></m></meta>
		</REMOTE_MINUS>
		<REMOTE_PLUS public="1" get="inline" set="null" expr="13" line="112" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>13</e></m></meta>
		</REMOTE_PLUS>
		<REMOTE_HOME public="1" get="inline" set="null" expr="19" line="114" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>19</e></m></meta>
		</REMOTE_HOME>
		<NUNCHUK_Z public="1" get="inline" set="null" expr="14" line="117" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>14</e></m></meta>
		</NUNCHUK_Z>
		<NUNCHUK_C public="1" get="inline" set="null" expr="15" line="118" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>15</e></m></meta>
		</NUNCHUK_C>
		<NUNCHUK_DPAD_UP public="1" get="inline" set="null" expr="4" line="120" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>4</e></m></meta>
		</NUNCHUK_DPAD_UP>
		<NUNCHUK_DPAD_DOWN public="1" get="inline" set="null" expr="5" line="121" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>5</e></m></meta>
		</NUNCHUK_DPAD_DOWN>
		<NUNCHUK_DPAD_LEFT public="1" get="inline" set="null" expr="6" line="122" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>6</e></m></meta>
		</NUNCHUK_DPAD_LEFT>
		<NUNCHUK_DPAD_RIGHT public="1" get="inline" set="null" expr="7" line="123" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>7</e></m></meta>
		</NUNCHUK_DPAD_RIGHT>
		<NUNCHUK_MINUS public="1" get="inline" set="null" expr="12" line="125" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>12</e></m></meta>
		</NUNCHUK_MINUS>
		<NUNCHUK_PLUS public="1" get="inline" set="null" expr="13" line="126" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>13</e></m></meta>
		</NUNCHUK_PLUS>
		<NUNCHUK_HOME public="1" get="inline" set="null" expr="19" line="128" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>19</e></m></meta>
		</NUNCHUK_HOME>
		<NUNCHUK_A public="1" get="inline" set="null" expr="10" line="130" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>10</e></m></meta>
		</NUNCHUK_A>
		<NUNCHUK_B public="1" get="inline" set="null" expr="11" line="131" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>11</e></m></meta>
		</NUNCHUK_B>
		<NUNCHUK_ONE public="1" get="inline" set="null" expr="8" line="133" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>8</e></m></meta>
		</NUNCHUK_ONE>
		<NUNCHUK_TWO public="1" get="inline" set="null" expr="9" line="134" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>9</e></m></meta>
		</NUNCHUK_TWO>
		<CLASSIC_Y public="1" get="inline" set="null" expr="8" line="137" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>8</e></m></meta>
		</CLASSIC_Y>
		<CLASSIC_X public="1" get="inline" set="null" expr="9" line="138" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>9</e></m></meta>
		</CLASSIC_X>
		<CLASSIC_B public="1" get="inline" set="null" expr="10" line="139" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>10</e></m></meta>
		</CLASSIC_B>
		<CLASSIC_A public="1" get="inline" set="null" expr="11" line="140" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>11</e></m></meta>
		</CLASSIC_A>
		<CLASSIC_L public="1" get="inline" set="null" expr="12" line="142" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>12</e></m></meta>
		</CLASSIC_L>
		<CLASSIC_R public="1" get="inline" set="null" expr="13" line="143" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>13</e></m></meta>
		</CLASSIC_R>
		<CLASSIC_ZL public="1" get="inline" set="null" expr="14" line="144" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>14</e></m></meta>
		</CLASSIC_ZL>
		<CLASSIC_ZR public="1" get="inline" set="null" expr="15" line="145" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>15</e></m></meta>
		</CLASSIC_ZR>
		<CLASSIC_SELECT public="1" get="inline" set="null" expr="16" line="147" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>16</e></m></meta>
		</CLASSIC_SELECT>
		<CLASSIC_START public="1" get="inline" set="null" expr="17" line="148" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>17</e></m></meta>
		</CLASSIC_START>
		<CLASSIC_HOME public="1" get="inline" set="null" expr="19" line="150" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>19</e></m></meta>
		</CLASSIC_HOME>
		<CLASSIC_ONE public="1" get="inline" set="null" expr="-1" line="152" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>-1</e></m></meta>
		</CLASSIC_ONE>
		<CLASSIC_TWO public="1" get="inline" set="null" expr="-1" line="153" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>-1</e></m></meta>
		</CLASSIC_TWO>
		<CLASSIC_DPAD_UP public="1" get="inline" set="null" expr="4" line="156" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>4</e></m></meta>
		</CLASSIC_DPAD_UP>
		<CLASSIC_DPAD_DOWN public="1" get="inline" set="null" expr="5" line="157" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>5</e></m></meta>
		</CLASSIC_DPAD_DOWN>
		<CLASSIC_DPAD_LEFT public="1" get="inline" set="null" expr="6" line="158" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>6</e></m></meta>
		</CLASSIC_DPAD_LEFT>
		<CLASSIC_DPAD_RIGHT public="1" get="inline" set="null" expr="7" line="159" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>7</e></m></meta>
		</CLASSIC_DPAD_RIGHT>
		<NUNCHUK_POINTER_X public="1" get="inline" set="null" expr="2" line="162" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>2</e></m></meta>
		</NUNCHUK_POINTER_X>
		<NUNCHUK_POINTER_Y public="1" get="inline" set="null" expr="3" line="163" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>3</e></m></meta>
		</NUNCHUK_POINTER_Y>
		<REMOTE_DPAD public="1" set="null" expr="new FlxGamepadAnalogStick(0, 1, { up : REMOTE_DPAD_UP, down : REMOTE_DPAD_DOWN, left : REMOTE_DPAD_LEFT, right : REMOTE_DPAD_RIGHT, threshold : 0.5, mode : ONLY_DIGITAL })" line="166" static="1">
			<c path="flixel.input.gamepad.FlxGamepadAnalogStick"/>
			<meta><m n=":value"><e>new FlxGamepadAnalogStick(0, 1, { up : REMOTE_DPAD_UP, down : REMOTE_DPAD_DOWN, left : REMOTE_DPAD_LEFT, right : REMOTE_DPAD_RIGHT, threshold : 0.5, mode : ONLY_DIGITAL })</e></m></meta>
		</REMOTE_DPAD>
		<LEFT_ANALOG_STICK public="1" set="null" expr="new FlxGamepadAnalogStick(0, 1, { up : 26, down : 27, left : 28, right : 29 })" line="175" static="1">
			<c path="flixel.input.gamepad.FlxGamepadAnalogStick"/>
			<meta><m n=":value"><e>new FlxGamepadAnalogStick(0, 1, { up : 26, down : 27, left : 28, right : 29 })</e></m></meta>
		</LEFT_ANALOG_STICK>
		<RIGHT_ANALOG_STICK public="1" set="null" expr="new FlxGamepadAnalogStick(2, 3, { up : 26, down : 27, left : 28, right : 29 })" line="176" static="1">
			<c path="flixel.input.gamepad.FlxGamepadAnalogStick"/>
			<meta><m n=":value"><e>new FlxGamepadAnalogStick(2, 3, { up : 26, down : 27, left : 28, right : 29 })</e></m></meta>
		</RIGHT_ANALOG_STICK>
		<LEFT_TRIGGER_FAKE public="1" get="inline" set="null" expr="4" line="179" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>4</e></m></meta>
		</LEFT_TRIGGER_FAKE>
		<RIGHT_TRIGGER_FAKE public="1" get="inline" set="null" expr="5" line="180" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>5</e></m></meta>
		</RIGHT_TRIGGER_FAKE>
		<REMOTE_DPAD_UP public="1" get="inline" set="null" expr="22" line="183" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>22</e></m></meta>
		</REMOTE_DPAD_UP>
		<REMOTE_DPAD_DOWN public="1" get="inline" set="null" expr="23" line="184" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>23</e></m></meta>
		</REMOTE_DPAD_DOWN>
		<REMOTE_DPAD_LEFT public="1" get="inline" set="null" expr="24" line="185" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>24</e></m></meta>
		</REMOTE_DPAD_LEFT>
		<REMOTE_DPAD_RIGHT public="1" get="inline" set="null" expr="25" line="186" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>25</e></m></meta>
		</REMOTE_DPAD_RIGHT>
		<haxe_doc>* WiiRemote hardware input ID's when using "Mode 3" of the MayFlash DolphinBar accessory
 * 
 * @author larsiusprime</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="flixel.input.gamepad.id.OUYAID" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/input/gamepad/id/OUYAID.hx">
		<O public="1" get="inline" set="null" expr="0" line="10" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</O>
		<U public="1" get="inline" set="null" expr="3" line="11" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>3</e></m></meta>
		</U>
		<Y public="1" get="inline" set="null" expr="4" line="12" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>4</e></m></meta>
		</Y>
		<A public="1" get="inline" set="null" expr="1" line="13" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</A>
		<LB public="1" get="inline" set="null" expr="6" line="14" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>6</e></m></meta>
		</LB>
		<RB public="1" get="inline" set="null" expr="7" line="15" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>7</e></m></meta>
		</RB>
		<LEFT_STICK_CLICK public="1" get="inline" set="null" expr="10" line="16" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>10</e></m></meta>
		</LEFT_STICK_CLICK>
		<RIGHT_STICK_CLICK public="1" get="inline" set="null" expr="11" line="17" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>11</e></m></meta>
		</RIGHT_STICK_CLICK>
		<HOME public="1" get="inline" set="null" expr="2" line="18" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>2</e></m></meta>
		</HOME>
		<LEFT_TRIGGER public="1" get="inline" set="null" expr="8" line="19" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>8</e></m></meta>
		</LEFT_TRIGGER>
		<RIGHT_TRIGGER public="1" get="inline" set="null" expr="9" line="20" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>9</e></m></meta>
		</RIGHT_TRIGGER>
		<DPAD_LEFT public="1" get="inline" set="null" expr="13" line="23" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>13</e></m></meta>
		</DPAD_LEFT>
		<DPAD_RIGHT public="1" get="inline" set="null" expr="14" line="24" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>14</e></m></meta>
		</DPAD_RIGHT>
		<DPAD_DOWN public="1" get="inline" set="null" expr="15" line="25" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>15</e></m></meta>
		</DPAD_DOWN>
		<DPAD_UP public="1" get="inline" set="null" expr="16" line="26" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>16</e></m></meta>
		</DPAD_UP>
		<LEFT_ANALOG_STICK public="1" set="null" expr="new FlxGamepadAnalogStick(0, 1, { up : 23, down : 24, left : 25, right : 26 })" line="29" static="1">
			<c path="flixel.input.gamepad.FlxGamepadAnalogStick"/>
			<meta><m n=":value"><e>new FlxGamepadAnalogStick(0, 1, { up : 23, down : 24, left : 25, right : 26 })</e></m></meta>
		</LEFT_ANALOG_STICK>
		<RIGHT_ANALOG_STICK public="1" set="null" expr="new FlxGamepadAnalogStick(11, 14, { up : 27, down : 28, left : 29, right : 30 })" line="30" static="1">
			<c path="flixel.input.gamepad.FlxGamepadAnalogStick"/>
			<meta><m n=":value"><e>new FlxGamepadAnalogStick(11, 14, { up : 27, down : 28, left : 29, right : 30 })</e></m></meta>
		</RIGHT_ANALOG_STICK>
		<LEFT_TRIGGER_ANALOG public="1" get="inline" set="null" expr="17" line="32" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>17</e></m></meta>
		</LEFT_TRIGGER_ANALOG>
		<RIGHT_TRIGGER_ANALOG public="1" get="inline" set="null" expr="18" line="33" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>18</e></m></meta>
		</RIGHT_TRIGGER_ANALOG>
		<haxe_doc>* IDs for OUYA controllers</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="flixel.input.gamepad.id.PS4ID" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/input/gamepad/id/PS4ID.hx">
		<X public="1" get="inline" set="null" expr="6" line="52" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>6</e></m></meta>
		</X>
		<CIRCLE public="1" get="inline" set="null" expr="7" line="53" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>7</e></m></meta>
		</CIRCLE>
		<SQUARE public="1" get="inline" set="null" expr="8" line="54" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>8</e></m></meta>
		</SQUARE>
		<TRIANGLE public="1" get="inline" set="null" expr="9" line="55" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>9</e></m></meta>
		</TRIANGLE>
		<SHARE public="1" get="inline" set="null" expr="10" line="56" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>10</e></m></meta>
		</SHARE>
		<PS public="1" get="inline" set="null" expr="11" line="57" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>11</e></m></meta>
		</PS>
		<OPTIONS public="1" get="inline" set="null" expr="12" line="58" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>12</e></m></meta>
		</OPTIONS>
		<LEFT_STICK_CLICK public="1" get="inline" set="null" expr="13" line="59" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>13</e></m></meta>
		</LEFT_STICK_CLICK>
		<RIGHT_STICK_CLICK public="1" get="inline" set="null" expr="14" line="60" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>14</e></m></meta>
		</RIGHT_STICK_CLICK>
		<L1 public="1" get="inline" set="null" expr="15" line="61" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>15</e></m></meta>
		</L1>
		<R1 public="1" get="inline" set="null" expr="16" line="62" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>16</e></m></meta>
		</R1>
		<TOUCHPAD_CLICK public="1" get="inline" set="null" expr="21" line="64" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>21</e></m></meta>
		</TOUCHPAD_CLICK>
		<LEFT_ANALOG_STICK public="1" set="null" expr="new FlxGamepadAnalogStick(0, 1, { up : 22, down : 23, left : 24, right : 25 })" line="66" static="1">
			<c path="flixel.input.gamepad.FlxGamepadAnalogStick"/>
			<meta><m n=":value"><e>new FlxGamepadAnalogStick(0, 1, { up : 22, down : 23, left : 24, right : 25 })</e></m></meta>
		</LEFT_ANALOG_STICK>
		<RIGHT_ANALOG_STICK public="1" set="null" expr="new FlxGamepadAnalogStick(2, 3, { up : 26, down : 27, left : 28, right : 29 })" line="67" static="1">
			<c path="flixel.input.gamepad.FlxGamepadAnalogStick"/>
			<meta><m n=":value"><e>new FlxGamepadAnalogStick(2, 3, { up : 26, down : 27, left : 28, right : 29 })</e></m></meta>
		</RIGHT_ANALOG_STICK>
		<L2 public="1" get="inline" set="null" expr="4" line="69" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>4</e></m></meta>
		</L2>
		<R2 public="1" get="inline" set="null" expr="5" line="70" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>5</e></m></meta>
		</R2>
		<DPAD_UP public="1" get="inline" set="null" expr="17" line="72" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>17</e></m></meta>
		</DPAD_UP>
		<DPAD_DOWN public="1" get="inline" set="null" expr="18" line="73" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>18</e></m></meta>
		</DPAD_DOWN>
		<DPAD_LEFT public="1" get="inline" set="null" expr="19" line="74" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>19</e></m></meta>
		</DPAD_LEFT>
		<DPAD_RIGHT public="1" get="inline" set="null" expr="20" line="75" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>20</e></m></meta>
		</DPAD_RIGHT>
		<haxe_doc>* IDs for PlayStation 4 controllers
 * 
 *-------
 * NOTES
 *-------
 *
 * WINDOWS: seems to work fine without any special drivers on Windows 10 (and I seem to recall the same on Windows 7).
 * DS4Windows is the popular 3rd-party utility here, but it will make the PS4 controller look like a 360 controller, which
 * means that it will be indistinguishable from an XInput device to flixel (DS4Windows: http://ds4windows.com).
 *
 * LINUX: the PS4 controller will be detected as an XInput device when using xpad (see notes in XInputID.hx)
 * 
 * MAC: the PS4 controller seemed to work perfectly without anything special installed, and was not detected in the 360Controller
 * control panel, so it might just work right out of the box!</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="flixel.input.gamepad.id.PSVitaID" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/input/gamepad/id/PSVitaID.hx">
		<X public="1" get="inline" set="null" expr="6" line="13" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>6</e></m></meta>
		</X>
		<CIRCLE public="1" get="inline" set="null" expr="7" line="14" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>7</e></m></meta>
		</CIRCLE>
		<SQUARE public="1" get="inline" set="null" expr="8" line="15" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>8</e></m></meta>
		</SQUARE>
		<TRIANGLE public="1" get="inline" set="null" expr="9" line="16" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>9</e></m></meta>
		</TRIANGLE>
		<SELECT public="1" get="inline" set="null" expr="10" line="17" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>10</e></m></meta>
		</SELECT>
		<START public="1" get="inline" set="null" expr="12" line="18" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>12</e></m></meta>
		</START>
		<L public="1" get="inline" set="null" expr="15" line="19" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>15</e></m></meta>
		</L>
		<R public="1" get="inline" set="null" expr="16" line="20" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>16</e></m></meta>
		</R>
		<DPAD_UP public="1" get="inline" set="null" expr="17" line="22" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>17</e></m></meta>
		</DPAD_UP>
		<DPAD_DOWN public="1" get="inline" set="null" expr="18" line="23" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>18</e></m></meta>
		</DPAD_DOWN>
		<DPAD_LEFT public="1" get="inline" set="null" expr="19" line="24" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>19</e></m></meta>
		</DPAD_LEFT>
		<DPAD_RIGHT public="1" get="inline" set="null" expr="20" line="25" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>20</e></m></meta>
		</DPAD_RIGHT>
		<LEFT_ANALOG_STICK public="1" set="null" expr="new FlxGamepadAnalogStick(0, 1, { up : 21, down : 22, left : 23, right : 24 })" line="27" static="1">
			<c path="flixel.input.gamepad.FlxGamepadAnalogStick"/>
			<meta><m n=":value"><e>new FlxGamepadAnalogStick(0, 1, { up : 21, down : 22, left : 23, right : 24 })</e></m></meta>
		</LEFT_ANALOG_STICK>
		<RIGHT_ANALOG_STICK public="1" set="null" expr="new FlxGamepadAnalogStick(2, 3, { up : 21, down : 22, left : 23, right : 24 })" line="28" static="1">
			<c path="flixel.input.gamepad.FlxGamepadAnalogStick"/>
			<meta><m n=":value"><e>new FlxGamepadAnalogStick(2, 3, { up : 21, down : 22, left : 23, right : 24 })</e></m></meta>
		</RIGHT_ANALOG_STICK>
		<haxe_doc>* Native PSVita input values.
 * (The only way to use these is to actually be using a PSVita with the upcoming openfl vita target!)
 * 
 * This will ONLY work with the gamepad API (available only in OpenFL "next", not "legacy") and will NOT work with the joystick API</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="flixel.input.gamepad.id.WiiRemoteID" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/input/gamepad/id/WiiRemoteID.hx">
		<REMOTE_ONE public="1" get="inline" set="null" expr="9" line="112" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>9</e></m></meta>
			<haxe_doc>* Things to add:
	 * - Accelerometer (in both remote and nunchuk)
	 * - Gyroscope (in Motion-Plus version only)
	 * - IR camera (position tracking)
	 * - Rumble
	 * - Speaker</haxe_doc>
		</REMOTE_ONE>
		<REMOTE_TWO public="1" get="inline" set="null" expr="10" line="113" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>10</e></m></meta>
		</REMOTE_TWO>
		<REMOTE_A public="1" get="inline" set="null" expr="11" line="114" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>11</e></m></meta>
		</REMOTE_A>
		<REMOTE_B public="1" get="inline" set="null" expr="12" line="115" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>12</e></m></meta>
		</REMOTE_B>
		<REMOTE_PLUS public="1" get="inline" set="null" expr="13" line="116" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>13</e></m></meta>
		</REMOTE_PLUS>
		<REMOTE_MINUS public="1" get="inline" set="null" expr="14" line="117" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>14</e></m></meta>
		</REMOTE_MINUS>
		<REMOTE_HOME public="1" get="inline" set="null" expr="15" line="118" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>15</e></m></meta>
		</REMOTE_HOME>
		<NUNCHUK_A public="1" get="inline" set="null" expr="9" line="121" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>9</e></m></meta>
		</NUNCHUK_A>
		<NUNCHUK_B public="1" get="inline" set="null" expr="10" line="122" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>10</e></m></meta>
		</NUNCHUK_B>
		<NUNCHUK_C public="1" get="inline" set="null" expr="11" line="123" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>11</e></m></meta>
		</NUNCHUK_C>
		<NUNCHUK_Z public="1" get="inline" set="null" expr="12" line="124" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>12</e></m></meta>
		</NUNCHUK_Z>
		<NUNCHUK_ONE public="1" get="inline" set="null" expr="13" line="125" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>13</e></m></meta>
		</NUNCHUK_ONE>
		<NUNCHUK_TWO public="1" get="inline" set="null" expr="14" line="126" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>14</e></m></meta>
		</NUNCHUK_TWO>
		<NUNCHUK_PLUS public="1" get="inline" set="null" expr="15" line="127" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>15</e></m></meta>
		</NUNCHUK_PLUS>
		<NUNCHUK_MINUS public="1" get="inline" set="null" expr="16" line="128" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>16</e></m></meta>
		</NUNCHUK_MINUS>
		<NUNCHUK_HOME public="1" get="inline" set="null" expr="17" line="129" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>17</e></m></meta>
		</NUNCHUK_HOME>
		<NUNCHUK_DPAD_UP public="1" get="inline" set="null" expr="5" line="131" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>5</e></m></meta>
		</NUNCHUK_DPAD_UP>
		<NUNCHUK_DPAD_DOWN public="1" get="inline" set="null" expr="6" line="132" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>6</e></m></meta>
		</NUNCHUK_DPAD_DOWN>
		<NUNCHUK_DPAD_LEFT public="1" get="inline" set="null" expr="7" line="133" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>7</e></m></meta>
		</NUNCHUK_DPAD_LEFT>
		<NUNCHUK_DPAD_RIGHT public="1" get="inline" set="null" expr="8" line="134" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>8</e></m></meta>
		</NUNCHUK_DPAD_RIGHT>
		<CLASSIC_A public="1" get="inline" set="null" expr="9" line="137" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>9</e></m></meta>
		</CLASSIC_A>
		<CLASSIC_B public="1" get="inline" set="null" expr="10" line="138" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>10</e></m></meta>
		</CLASSIC_B>
		<CLASSIC_Y public="1" get="inline" set="null" expr="11" line="139" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>11</e></m></meta>
		</CLASSIC_Y>
		<CLASSIC_X public="1" get="inline" set="null" expr="12" line="140" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>12</e></m></meta>
		</CLASSIC_X>
		<CLASSIC_L public="1" get="inline" set="null" expr="13" line="141" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>13</e></m></meta>
		</CLASSIC_L>
		<CLASSIC_R public="1" get="inline" set="null" expr="14" line="142" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>14</e></m></meta>
		</CLASSIC_R>
		<CLASSIC_ZL public="1" get="inline" set="null" expr="15" line="143" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>15</e></m></meta>
		</CLASSIC_ZL>
		<CLASSIC_ZR public="1" get="inline" set="null" expr="16" line="144" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>16</e></m></meta>
		</CLASSIC_ZR>
		<CLASSIC_START public="1" get="inline" set="null" expr="17" line="145" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>17</e></m></meta>
		</CLASSIC_START>
		<CLASSIC_SELECT public="1" get="inline" set="null" expr="18" line="146" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>18</e></m></meta>
		</CLASSIC_SELECT>
		<CLASSIC_HOME public="1" get="inline" set="null" expr="19" line="147" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>19</e></m></meta>
		</CLASSIC_HOME>
		<CLASSIC_ONE public="1" get="inline" set="null" expr="20" line="148" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>20</e></m></meta>
		</CLASSIC_ONE>
		<CLASSIC_TWO public="1" get="inline" set="null" expr="21" line="149" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>21</e></m></meta>
		</CLASSIC_TWO>
		<CLASSIC_DPAD_UP public="1" get="inline" set="null" expr="5" line="151" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>5</e></m></meta>
		</CLASSIC_DPAD_UP>
		<CLASSIC_DPAD_DOWN public="1" get="inline" set="null" expr="6" line="152" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>6</e></m></meta>
		</CLASSIC_DPAD_DOWN>
		<CLASSIC_DPAD_LEFT public="1" get="inline" set="null" expr="7" line="153" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>7</e></m></meta>
		</CLASSIC_DPAD_LEFT>
		<CLASSIC_DPAD_RIGHT public="1" get="inline" set="null" expr="8" line="154" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>8</e></m></meta>
		</CLASSIC_DPAD_RIGHT>
		<REMOTE_TILT_PITCH public="1" get="inline" set="null" expr="2" line="156" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>2</e></m></meta>
		</REMOTE_TILT_PITCH>
		<REMOTE_TILT_ROLL public="1" get="inline" set="null" expr="3" line="157" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>3</e></m></meta>
		</REMOTE_TILT_ROLL>
		<NUNCHUK_TILT_PITCH public="1" get="inline" set="null" expr="3" line="159" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>3</e></m></meta>
		</NUNCHUK_TILT_PITCH>
		<NUNCHUK_TILT_ROLL public="1" get="inline" set="null" expr="2" line="160" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>2</e></m></meta>
		</NUNCHUK_TILT_ROLL>
		<REMOTE_NULL_AXIS public="1" get="inline" set="null" expr="4" line="162" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>4</e></m></meta>
		</REMOTE_NULL_AXIS>
		<NUNCHUK_NULL_AXIS public="1" get="inline" set="null" expr="4" line="163" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>4</e></m></meta>
		</NUNCHUK_NULL_AXIS>
		<REMOTE_DPAD public="1" set="null" expr="new FlxGamepadAnalogStick(0, 1, { up : REMOTE_DPAD_UP, down : REMOTE_DPAD_DOWN, left : REMOTE_DPAD_LEFT, right : REMOTE_DPAD_RIGHT, threshold : 0.5, mode : ONLY_DIGITAL })" line="166" static="1">
			<c path="flixel.input.gamepad.FlxGamepadAnalogStick"/>
			<meta><m n=":value"><e>new FlxGamepadAnalogStick(0, 1, { up : REMOTE_DPAD_UP, down : REMOTE_DPAD_DOWN, left : REMOTE_DPAD_LEFT, right : REMOTE_DPAD_RIGHT, threshold : 0.5, mode : ONLY_DIGITAL })</e></m></meta>
		</REMOTE_DPAD>
		<LEFT_ANALOG_STICK public="1" set="null" expr="new FlxGamepadAnalogStick(0, 1, { up : 28, down : 29, left : 30, right : 31 })" line="178" static="1">
			<c path="flixel.input.gamepad.FlxGamepadAnalogStick"/>
			<meta><m n=":value"><e>new FlxGamepadAnalogStick(0, 1, { up : 28, down : 29, left : 30, right : 31 })</e></m></meta>
			<haxe_doc>* the nunchuk only has the "left" analog stick</haxe_doc>
		</LEFT_ANALOG_STICK>
		<RIGHT_ANALOG_STICK public="1" set="null" expr="new FlxGamepadAnalogStick(2, 3, { up : 32, down : 33, left : 34, right : 35 })" line="182" static="1">
			<c path="flixel.input.gamepad.FlxGamepadAnalogStick"/>
			<meta><m n=":value"><e>new FlxGamepadAnalogStick(2, 3, { up : 32, down : 33, left : 34, right : 35 })</e></m></meta>
			<haxe_doc>* the classic controller has both the "left" and "right" analog sticks</haxe_doc>
		</RIGHT_ANALOG_STICK>
		<LEFT_TRIGGER_FAKE public="1" get="inline" set="null" expr="4" line="185" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>4</e></m></meta>
		</LEFT_TRIGGER_FAKE>
		<RIGHT_TRIGGER_FAKE public="1" get="inline" set="null" expr="5" line="186" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>5</e></m></meta>
		</RIGHT_TRIGGER_FAKE>
		<REMOTE_DPAD_UP public="1" get="inline" set="null" expr="22" line="189" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>22</e></m></meta>
		</REMOTE_DPAD_UP>
		<REMOTE_DPAD_DOWN public="1" get="inline" set="null" expr="23" line="190" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>23</e></m></meta>
		</REMOTE_DPAD_DOWN>
		<REMOTE_DPAD_LEFT public="1" get="inline" set="null" expr="24" line="191" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>24</e></m></meta>
		</REMOTE_DPAD_LEFT>
		<REMOTE_DPAD_RIGHT public="1" get="inline" set="null" expr="25" line="192" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>25</e></m></meta>
		</REMOTE_DPAD_RIGHT>
		<REMOTE_DPAD_X public="1" get="inline" set="null" expr="26" line="194" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>26</e></m></meta>
		</REMOTE_DPAD_X>
		<REMOTE_DPAD_Y public="1" get="inline" set="null" expr="27" line="195" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>27</e></m></meta>
		</REMOTE_DPAD_Y>
		<haxe_doc>* WiiRemote hardware input ID's when using the device directly
 * Hardware ID's: "Nintendo RVL-CNT-01-TR" and "Nintendo RVL-CNT-01" -- the latter does not have the Motion-Plus attachment
 * 
 * NOTE: On Windows this requires the HID-Wiimote driver by Julian LÃ¶hr, available here:
 * https://github.com/jloehr/HID-Wiimote
 * 
 * @author larsiusprime</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="flixel.input.gamepad.id.XInputID" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/input/gamepad/id/XInputID.hx">
		<A public="1" get="inline" set="null" expr="6" line="54" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>6</e></m></meta>
		</A>
		<B public="1" get="inline" set="null" expr="7" line="55" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>7</e></m></meta>
		</B>
		<X public="1" get="inline" set="null" expr="8" line="56" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>8</e></m></meta>
		</X>
		<Y public="1" get="inline" set="null" expr="9" line="57" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>9</e></m></meta>
		</Y>
		<BACK public="1" get="inline" set="null" expr="10" line="59" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>10</e></m></meta>
		</BACK>
		<GUIDE public="1" get="inline" set="null" expr="-1" line="60" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>-1</e></m></meta>
		</GUIDE>
		<START public="1" get="inline" set="null" expr="12" line="61" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>12</e></m></meta>
		</START>
		<LEFT_STICK_CLICK public="1" get="inline" set="null" expr="13" line="63" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>13</e></m></meta>
		</LEFT_STICK_CLICK>
		<RIGHT_STICK_CLICK public="1" get="inline" set="null" expr="14" line="64" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>14</e></m></meta>
		</RIGHT_STICK_CLICK>
		<LB public="1" get="inline" set="null" expr="15" line="66" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>15</e></m></meta>
		</LB>
		<RB public="1" get="inline" set="null" expr="16" line="67" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>16</e></m></meta>
		</RB>
		<DPAD_UP public="1" get="inline" set="null" expr="17" line="69" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>17</e></m></meta>
		</DPAD_UP>
		<DPAD_DOWN public="1" get="inline" set="null" expr="18" line="70" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>18</e></m></meta>
		</DPAD_DOWN>
		<DPAD_LEFT public="1" get="inline" set="null" expr="19" line="71" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>19</e></m></meta>
		</DPAD_LEFT>
		<DPAD_RIGHT public="1" get="inline" set="null" expr="20" line="72" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>20</e></m></meta>
		</DPAD_RIGHT>
		<LEFT_ANALOG_STICK public="1" set="null" expr="new FlxGamepadAnalogStick(0, 1, { up : 21, down : 22, left : 23, right : 24 })" line="74" static="1">
			<c path="flixel.input.gamepad.FlxGamepadAnalogStick"/>
			<meta><m n=":value"><e>new FlxGamepadAnalogStick(0, 1, { up : 21, down : 22, left : 23, right : 24 })</e></m></meta>
		</LEFT_ANALOG_STICK>
		<RIGHT_ANALOG_STICK public="1" set="null" expr="new FlxGamepadAnalogStick(2, 3, { up : 25, down : 26, left : 27, right : 28 })" line="75" static="1">
			<c path="flixel.input.gamepad.FlxGamepadAnalogStick"/>
			<meta><m n=":value"><e>new FlxGamepadAnalogStick(2, 3, { up : 25, down : 26, left : 27, right : 28 })</e></m></meta>
		</RIGHT_ANALOG_STICK>
		<LEFT_TRIGGER public="1" get="inline" set="null" expr="4" line="77" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>4</e></m></meta>
		</LEFT_TRIGGER>
		<RIGHT_TRIGGER public="1" get="inline" set="null" expr="5" line="78" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>5</e></m></meta>
		</RIGHT_TRIGGER>
		<haxe_doc>* IDs for generic XInput controllers
 * 
 * Compatible with the Xbox 360 controller, the Xbox One controller, and anything that masquerades as either of those.
 *
 *-------
 * NOTES
 *-------
 *
 * WINDOWS: we assume the user is using the default drivers that ship with windows.
 *
 * LINUX: we assume the user is using the xpad driver, specifically Valve's version, steamos-xpad-dkms
 * (we got weird errors when using xboxdrv). For full instructions on installation, see:
 * http://askubuntu.com/questions/165210/how-do-i-get-an-xbox-360-controller-working/441548#441548
 *
 * MAC: we assume the user is using the 360 Controller driver, specifically this one:
 * https://github.com/360Controller/360Controller/releases</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="flixel.input.gamepad.lists.FlxBaseGamepadList" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/input/gamepad/lists/FlxBaseGamepadList.hx">
		<status><x path="flixel.input.FlxInputState"/></status>
		<gamepad><c path="flixel.input.gamepad.FlxGamepad"/></gamepad>
		<check get="inline" set="null" line="18"><f a="id">
	<x path="flixel.input.gamepad.FlxGamepadInputID"/>
	<x path="Bool"/>
</f></check>
		<checkRaw get="inline" set="null" line="23"><f a="id">
	<x path="Int"/>
	<x path="Bool"/>
</f></checkRaw>
		<ANY public="1" get="accessor" set="null"><x path="Bool"/></ANY>
		<get_ANY set="method" line="30"><f a=""><x path="Bool"/></f></get_ANY>
		<new public="1" set="method" line="12"><f a="status:gamepad">
	<x path="flixel.input.FlxInputState"/>
	<c path="flixel.input.gamepad.FlxGamepad"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="flixel.input.gamepad.lists.FlxGamepadAnalogList" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/input/gamepad/lists/FlxGamepadAnalogList.hx">
		<value public="1" set="null"><c path="flixel.input.gamepad.lists.FlxGamepadAnalogValueList"/></value>
		<justMoved public="1" set="null"><c path="flixel.input.gamepad.lists.FlxGamepadAnalogStateList"/></justMoved>
		<justReleased public="1" set="null"><c path="flixel.input.gamepad.lists.FlxGamepadAnalogStateList"/></justReleased>
		<new public="1" set="method" line="16"><f a="gamepad">
	<c path="flixel.input.gamepad.FlxGamepad"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>* A helper class for gamepad input.
 * Provides optimized gamepad button checking using direct array access.</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":keep"/>
		</meta>
	</class>
	<class path="flixel.input.gamepad.lists.FlxGamepadAnalogStateList" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/input/gamepad/lists/FlxGamepadAnalogStateList.hx">
		<gamepad><c path="flixel.input.gamepad.FlxGamepad"/></gamepad>
		<status><x path="flixel.input.FlxInputState"/></status>
		<LEFT_STICK public="1" get="accessor" set="null"><x path="Bool"/></LEFT_STICK>
		<get_LEFT_STICK get="inline" set="null" line="16"><f a=""><x path="Bool"/></f></get_LEFT_STICK>
		<LEFT_STICK_X public="1" get="accessor" set="null"><x path="Bool"/></LEFT_STICK_X>
		<get_LEFT_STICK_X get="inline" set="null" line="17"><f a=""><x path="Bool"/></f></get_LEFT_STICK_X>
		<LEFT_STICK_Y public="1" get="accessor" set="null"><x path="Bool"/></LEFT_STICK_Y>
		<get_LEFT_STICK_Y get="inline" set="null" line="18"><f a=""><x path="Bool"/></f></get_LEFT_STICK_Y>
		<RIGHT_STICK public="1" get="accessor" set="null"><x path="Bool"/></RIGHT_STICK>
		<get_RIGHT_STICK get="inline" set="null" line="19"><f a=""><x path="Bool"/></f></get_RIGHT_STICK>
		<RIGHT_STICK_X public="1" get="accessor" set="null"><x path="Bool"/></RIGHT_STICK_X>
		<get_RIGHT_STICK_X get="inline" set="null" line="20"><f a=""><x path="Bool"/></f></get_RIGHT_STICK_X>
		<RIGHT_STICK_Y public="1" get="accessor" set="null"><x path="Bool"/></RIGHT_STICK_Y>
		<get_RIGHT_STICK_Y get="inline" set="null" line="21"><f a=""><x path="Bool"/></f></get_RIGHT_STICK_Y>
		<checkXY set="method" line="32">
			<f a="id">
				<x path="flixel.input.gamepad.FlxGamepadInputID"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Checks if the entire stick itself is in the given state</haxe_doc>
		</checkXY>
		<checkX get="inline" set="null" line="76"><f a="id">
	<x path="flixel.input.gamepad.FlxGamepadInputID"/>
	<x path="Bool"/>
</f></checkX>
		<checkY get="inline" set="null" line="84"><f a="id">
	<x path="flixel.input.gamepad.FlxGamepadInputID"/>
	<x path="Bool"/>
</f></checkY>
		<checkRaw get="inline" set="null" line="92"><f a="RawID:Status">
	<x path="Int"/>
	<x path="flixel.input.FlxInputState"/>
	<x path="Bool"/>
</f></checkRaw>
		<new public="1" set="method" line="23"><f a="status:gamepad">
	<x path="flixel.input.FlxInputState"/>
	<c path="flixel.input.gamepad.FlxGamepad"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>* A helper class for gamepad input.
 * Provides optimized gamepad button checking using direct array access.</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":keep"/>
		</meta>
	</class>
	<class path="flixel.input.gamepad.lists.FlxGamepadAnalogValueList" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/input/gamepad/lists/FlxGamepadAnalogValueList.hx">
		<gamepad><c path="flixel.input.gamepad.FlxGamepad"/></gamepad>
		<LEFT_STICK_X public="1" get="accessor" set="null"><x path="Float"/></LEFT_STICK_X>
		<get_LEFT_STICK_X get="inline" set="null" line="14"><f a=""><x path="Float"/></f></get_LEFT_STICK_X>
		<LEFT_STICK_Y public="1" get="accessor" set="null"><x path="Float"/></LEFT_STICK_Y>
		<get_LEFT_STICK_Y get="inline" set="null" line="15"><f a=""><x path="Float"/></f></get_LEFT_STICK_Y>
		<RIGHT_STICK_X public="1" get="accessor" set="null"><x path="Float"/></RIGHT_STICK_X>
		<get_RIGHT_STICK_X get="inline" set="null" line="16"><f a=""><x path="Float"/></f></get_RIGHT_STICK_X>
		<RIGHT_STICK_Y public="1" get="accessor" set="null"><x path="Float"/></RIGHT_STICK_Y>
		<get_RIGHT_STICK_Y get="inline" set="null" line="17"><f a=""><x path="Float"/></f></get_RIGHT_STICK_Y>
		<LEFT_TRIGGER public="1" get="accessor" set="null"><x path="Float"/></LEFT_TRIGGER>
		<get_LEFT_TRIGGER get="inline" set="null" line="18"><f a=""><x path="Float"/></f></get_LEFT_TRIGGER>
		<RIGHT_TRIGGER public="1" get="accessor" set="null"><x path="Float"/></RIGHT_TRIGGER>
		<get_RIGHT_TRIGGER get="inline" set="null" line="19"><f a=""><x path="Float"/></f></get_RIGHT_TRIGGER>
		<POINTER_X public="1" get="accessor" set="null"><x path="Float"/></POINTER_X>
		<get_POINTER_X get="inline" set="null" line="21"><f a=""><x path="Float"/></f></get_POINTER_X>
		<POINTER_Y public="1" get="accessor" set="null"><x path="Float"/></POINTER_Y>
		<get_POINTER_Y get="inline" set="null" line="22"><f a=""><x path="Float"/></f></get_POINTER_Y>
		<getAxis get="inline" set="null" line="29"><f a="id">
	<x path="flixel.input.gamepad.FlxGamepadInputID"/>
	<x path="Float"/>
</f></getAxis>
		<getXAxis get="inline" set="null" line="34"><f a="id">
	<x path="flixel.input.gamepad.FlxGamepadInputID"/>
	<x path="Float"/>
</f></getXAxis>
		<getYAxis get="inline" set="null" line="39"><f a="id">
	<x path="flixel.input.gamepad.FlxGamepadInputID"/>
	<x path="Float"/>
</f></getYAxis>
		<new public="1" set="method" line="24"><f a="gamepad">
	<c path="flixel.input.gamepad.FlxGamepad"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>* A helper class for gamepad input.
 * Provides optimized gamepad button checking using direct array access.</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":keep"/>
		</meta>
	</class>
	<class path="flixel.input.gamepad.lists.FlxGamepadButtonList" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/input/gamepad/lists/FlxGamepadButtonList.hx">
		<extends path="flixel.input.gamepad.lists.FlxBaseGamepadList"/>
		<A public="1" get="accessor" set="null"><x path="Bool"/></A>
		<get_A get="inline" set="null" line="12"><f a=""><x path="Bool"/></f></get_A>
		<B public="1" get="accessor" set="null"><x path="Bool"/></B>
		<get_B get="inline" set="null" line="13"><f a=""><x path="Bool"/></f></get_B>
		<X public="1" get="accessor" set="null"><x path="Bool"/></X>
		<get_X get="inline" set="null" line="14"><f a=""><x path="Bool"/></f></get_X>
		<Y public="1" get="accessor" set="null"><x path="Bool"/></Y>
		<get_Y get="inline" set="null" line="15"><f a=""><x path="Bool"/></f></get_Y>
		<LEFT_SHOULDER public="1" get="accessor" set="null"><x path="Bool"/></LEFT_SHOULDER>
		<get_LEFT_SHOULDER get="inline" set="null" line="16"><f a=""><x path="Bool"/></f></get_LEFT_SHOULDER>
		<RIGHT_SHOULDER public="1" get="accessor" set="null"><x path="Bool"/></RIGHT_SHOULDER>
		<get_RIGHT_SHOULDER get="inline" set="null" line="17"><f a=""><x path="Bool"/></f></get_RIGHT_SHOULDER>
		<BACK public="1" get="accessor" set="null"><x path="Bool"/></BACK>
		<get_BACK get="inline" set="null" line="18"><f a=""><x path="Bool"/></f></get_BACK>
		<START public="1" get="accessor" set="null"><x path="Bool"/></START>
		<get_START get="inline" set="null" line="19"><f a=""><x path="Bool"/></f></get_START>
		<LEFT_STICK_CLICK public="1" get="accessor" set="null"><x path="Bool"/></LEFT_STICK_CLICK>
		<get_LEFT_STICK_CLICK get="inline" set="null" line="20"><f a=""><x path="Bool"/></f></get_LEFT_STICK_CLICK>
		<RIGHT_STICK_CLICK public="1" get="accessor" set="null"><x path="Bool"/></RIGHT_STICK_CLICK>
		<get_RIGHT_STICK_CLICK get="inline" set="null" line="21"><f a=""><x path="Bool"/></f></get_RIGHT_STICK_CLICK>
		<GUIDE public="1" get="accessor" set="null"><x path="Bool"/></GUIDE>
		<get_GUIDE get="inline" set="null" line="22"><f a=""><x path="Bool"/></f></get_GUIDE>
		<DPAD_UP public="1" get="accessor" set="null"><x path="Bool"/></DPAD_UP>
		<get_DPAD_UP get="inline" set="null" line="23"><f a=""><x path="Bool"/></f></get_DPAD_UP>
		<DPAD_DOWN public="1" get="accessor" set="null"><x path="Bool"/></DPAD_DOWN>
		<get_DPAD_DOWN get="inline" set="null" line="24"><f a=""><x path="Bool"/></f></get_DPAD_DOWN>
		<DPAD_LEFT public="1" get="accessor" set="null"><x path="Bool"/></DPAD_LEFT>
		<get_DPAD_LEFT get="inline" set="null" line="25"><f a=""><x path="Bool"/></f></get_DPAD_LEFT>
		<DPAD_RIGHT public="1" get="accessor" set="null"><x path="Bool"/></DPAD_RIGHT>
		<get_DPAD_RIGHT get="inline" set="null" line="26"><f a=""><x path="Bool"/></f></get_DPAD_RIGHT>
		<LEFT_TRIGGER public="1" get="accessor" set="null"><x path="Bool"/></LEFT_TRIGGER>
		<get_LEFT_TRIGGER get="inline" set="null" line="28"><f a=""><x path="Bool"/></f></get_LEFT_TRIGGER>
		<RIGHT_TRIGGER public="1" get="accessor" set="null"><x path="Bool"/></RIGHT_TRIGGER>
		<get_RIGHT_TRIGGER get="inline" set="null" line="29"><f a=""><x path="Bool"/></f></get_RIGHT_TRIGGER>
		<EXTRA_0 public="1" get="accessor" set="null"><x path="Bool"/></EXTRA_0>
		<get_EXTRA_0 get="inline" set="null" line="34"><f a=""><x path="Bool"/></f></get_EXTRA_0>
		<EXTRA_1 public="1" get="accessor" set="null"><x path="Bool"/></EXTRA_1>
		<get_EXTRA_1 get="inline" set="null" line="35"><f a=""><x path="Bool"/></f></get_EXTRA_1>
		<EXTRA_2 public="1" get="accessor" set="null"><x path="Bool"/></EXTRA_2>
		<get_EXTRA_2 get="inline" set="null" line="36"><f a=""><x path="Bool"/></f></get_EXTRA_2>
		<EXTRA_3 public="1" get="accessor" set="null"><x path="Bool"/></EXTRA_3>
		<get_EXTRA_3 get="inline" set="null" line="37"><f a=""><x path="Bool"/></f></get_EXTRA_3>
		<new public="1" set="method" line="39"><f a="status:gamepad">
	<x path="flixel.input.FlxInputState"/>
	<c path="flixel.input.gamepad.FlxGamepad"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>* A helper class for gamepad input.
 * Provides optimized gamepad button checking using direct array access.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="flixel.input.gamepad.lists.FlxGamepadMotionValueList" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/input/gamepad/lists/FlxGamepadMotionValueList.hx">
		<gamepad><c path="flixel.input.gamepad.FlxGamepad"/></gamepad>
		<isSupported public="1" get="accessor" set="null">
			<x path="Bool"/>
			<meta><m n=":allow"><e>flixel.input.gamepad.FlxGamepad</e></m></meta>
		</isSupported>
		<TILT_PITCH public="1" get="accessor" set="null">
			<x path="Float"/>
			<haxe_doc>* analog value (-1.0 to +1.0) tilting towards or away from the ceiling (think "look up", "look down")</haxe_doc>
		</TILT_PITCH>
		<get_TILT_PITCH get="inline" set="null" line="23"><f a=""><x path="Float"/></f></get_TILT_PITCH>
		<TILT_ROLL public="1" get="accessor" set="null">
			<x path="Float"/>
			<haxe_doc>* analog value (-1.0 to +1.0) tilting side-to-side (think "twisting", or "do a barrel roll!")</haxe_doc>
		</TILT_ROLL>
		<get_TILT_ROLL get="inline" set="null" line="27"><f a=""><x path="Float"/></f></get_TILT_ROLL>
		<getAxis get="inline" set="null" line="34"><f a="id">
	<x path="flixel.input.gamepad.FlxGamepadInputID"/>
	<x path="Float"/>
</f></getAxis>
		<get_isSupported get="inline" set="null" line="41"><f a=""><x path="Bool"/></f></get_isSupported>
		<new public="1" set="method" line="29"><f a="gamepad">
	<c path="flixel.input.gamepad.FlxGamepad"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>* A helper class for gamepad input.
 * Provides optimized gamepad button checking using direct array access.</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":keep"/>
		</meta>
	</class>
	<class path="flixel.input.gamepad.lists.FlxGamepadPointerValueList" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/input/gamepad/lists/FlxGamepadPointerValueList.hx">
		<gamepad><c path="flixel.input.gamepad.FlxGamepad"/></gamepad>
		<isSupported public="1" get="accessor" set="null">
			<x path="Bool"/>
			<meta><m n=":allow"><e>flixel.input.gamepad.FlxGamepad</e></m></meta>
			<haxe_doc>* whether or not the current gamepad model supports any pointer features (IR Camera, touch surface, etc)</haxe_doc>
		</isSupported>
		<X public="1" get="accessor" set="null">
			<x path="Float"/>
			<haxe_doc>* horizontal position (0.0-1.0) on the touch-surface or pointer-space</haxe_doc>
		</X>
		<get_X get="inline" set="null" line="23"><f a=""><x path="Float"/></f></get_X>
		<Y public="1" get="accessor" set="null">
			<x path="Float"/>
			<haxe_doc>* vertical position (0.0-1.0) on the touch-surface or pointer-space</haxe_doc>
		</Y>
		<get_Y get="inline" set="null" line="28"><f a=""><x path="Float"/></f></get_Y>
		<getAxis get="inline" set="null" line="35"><f a="id">
	<x path="flixel.input.gamepad.FlxGamepadInputID"/>
	<x path="Float"/>
</f></getAxis>
		<get_isSupported get="inline" set="null" line="42"><f a=""><x path="Bool"/></f></get_isSupported>
		<new public="1" set="method" line="30"><f a="gamepad">
	<c path="flixel.input.gamepad.FlxGamepad"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>* A helper class for gamepad input -- returns X/Y analog coordinate values between 0.0 and 1.0
 * Provides optimized gamepad button checking using direct array access.</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":keep"/>
		</meta>
	</class>
	<class path="flixel.input.gamepad.mappings.FlxGamepadMapping" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/input/gamepad/mappings/FlxGamepadMapping.hx">
		<supportsMotion public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</supportsMotion>
		<supportsPointer public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</supportsPointer>
		<leftStick public="1"><c path="flixel.input.gamepad.FlxGamepadAnalogStick"/></leftStick>
		<rightStick public="1"><c path="flixel.input.gamepad.FlxGamepadAnalogStick"/></rightStick>
		<attachment set="accessor" expr="NONE">
			<e path="flixel.input.gamepad.FlxGamepadAttachment"/>
			<meta>
				<m n=":value"><e>NONE</e></m>
				<m n=":allow"><e>flixel.input.gamepad.FlxGamepad</e></m>
			</meta>
		</attachment>
		<manufacturer><e path="flixel.input.gamepad.mappings.Manufacturer"/></manufacturer>
		<initValues set="method" line="41"><f a=""><x path="Void"/></f></initValues>
		<getAnalogStick public="1" set="method" line="43"><f a="ID">
	<x path="flixel.input.gamepad.FlxGamepadInputID"/>
	<c path="flixel.input.gamepad.FlxGamepadAnalogStick"/>
</f></getAnalogStick>
		<getID public="1" set="method" line="59">
			<f a="rawID">
				<x path="Int"/>
				<x path="flixel.input.gamepad.FlxGamepadInputID"/>
			</f>
			<haxe_doc>* Given a raw hardware code, return the "universal" ID</haxe_doc>
		</getID>
		<getRawID public="1" set="method" line="67">
			<f a="ID">
				<x path="flixel.input.gamepad.FlxGamepadInputID"/>
				<x path="Int"/>
			</f>
			<haxe_doc>* Given an ID, return the raw hardware code</haxe_doc>
		</getRawID>
		<isAxisForMotion public="1" set="method" line="72"><f a="ID">
	<x path="flixel.input.gamepad.FlxGamepadInputID"/>
	<x path="Bool"/>
</f></isAxisForMotion>
		<isAxisFlipped public="1" set="method" line="80">
			<f a="axisID">
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Whether this axis needs to be flipped</haxe_doc>
		</isAxisFlipped>
		<set_attachment set="method" line="101"><f a="attachment">
	<e path="flixel.input.gamepad.FlxGamepadAttachment"/>
	<e path="flixel.input.gamepad.FlxGamepadAttachment"/>
</f></set_attachment>
		<new public="1" set="method" line="24"><f a="?attachment">
	<e path="flixel.input.gamepad.FlxGamepadAttachment"/>
	<x path="Void"/>
</f></new>
	</class>
	<enum path="flixel.input.gamepad.mappings.Manufacturer" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/input/gamepad/mappings/FlxGamepadMapping.hx" module="flixel.input.gamepad.mappings.FlxGamepadMapping">
		<GooglePepper/>
		<AdobeWindows/>
		<Unknown/>
		<meta>
			<m n=":flatEnum"/>
			<m n="SuppressWarnings"><e>"checkstyle:MemberName"</e></m>
		</meta>
	</enum>
	<class path="flixel.input.gamepad.mappings.LogitechMapping" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/input/gamepad/mappings/LogitechMapping.hx">
		<extends path="flixel.input.gamepad.mappings.FlxGamepadMapping"/>
		<initValues set="method" line="16" override="1"><f a=""><x path="Void"/></f></initValues>
		<getID public="1" set="method" line="22" override="1"><f a="rawID">
	<x path="Int"/>
	<x path="flixel.input.gamepad.FlxGamepadInputID"/>
</f></getID>
		<getRawID public="1" set="method" line="55" override="1"><f a="ID">
	<x path="flixel.input.gamepad.FlxGamepadInputID"/>
	<x path="Int"/>
</f></getRawID>
		<new public="1" set="method" line="6"><f a="?attachment">
	<e path="flixel.input.gamepad.FlxGamepadAttachment"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="flixel.input.gamepad.mappings.MFiMapping" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/input/gamepad/mappings/MFiMapping.hx">
		<extends path="flixel.input.gamepad.mappings.FlxGamepadMapping"/>
		<initValues set="method" line="8" override="1"><f a=""><x path="Void"/></f></initValues>
		<getID public="1" set="method" line="14" override="1"><f a="rawID">
	<x path="Int"/>
	<x path="flixel.input.gamepad.FlxGamepadInputID"/>
</f></getID>
		<getRawID public="1" set="method" line="45" override="1"><f a="ID">
	<x path="flixel.input.gamepad.FlxGamepadInputID"/>
	<x path="Int"/>
</f></getRawID>
		<new public="1" set="method" line="6"><f a="?attachment">
	<e path="flixel.input.gamepad.FlxGamepadAttachment"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="flixel.input.gamepad.mappings.MayflashWiiRemoteMapping" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/input/gamepad/mappings/MayflashWiiRemoteMapping.hx">
		<extends path="flixel.input.gamepad.mappings.FlxGamepadMapping"/>
		<initValues set="method" line="19" override="1"><f a=""><x path="Void"/></f></initValues>
		<getID public="1" set="method" line="25" override="1"><f a="rawID">
	<x path="Int"/>
	<x path="flixel.input.gamepad.FlxGamepadInputID"/>
</f></getID>
		<getIDClassicController set="method" line="35"><f a="rawID">
	<x path="Int"/>
	<x path="flixel.input.gamepad.FlxGamepadInputID"/>
</f></getIDClassicController>
		<getIDNunchuk set="method" line="66"><f a="rawID">
	<x path="Int"/>
	<x path="flixel.input.gamepad.FlxGamepadInputID"/>
</f></getIDNunchuk>
		<getIDDefault set="method" line="92"><f a="rawID">
	<x path="Int"/>
	<x path="flixel.input.gamepad.FlxGamepadInputID"/>
</f></getIDDefault>
		<getRawID public="1" set="method" line="111" override="1"><f a="ID">
	<x path="flixel.input.gamepad.FlxGamepadInputID"/>
	<x path="Int"/>
</f></getRawID>
		<getRawClassicController set="method" line="121"><f a="ID">
	<x path="flixel.input.gamepad.FlxGamepadInputID"/>
	<x path="Int"/>
</f></getRawClassicController>
		<getRawNunchuk set="method" line="154"><f a="ID">
	<x path="flixel.input.gamepad.FlxGamepadInputID"/>
	<x path="Int"/>
</f></getRawNunchuk>
		<getRawDefault set="method" line="181"><f a="ID">
	<x path="flixel.input.gamepad.FlxGamepadInputID"/>
	<x path="Int"/>
</f></getRawDefault>
		<set_attachment set="method" line="244" override="1"><f a="attachment">
	<e path="flixel.input.gamepad.FlxGamepadAttachment"/>
	<e path="flixel.input.gamepad.FlxGamepadAttachment"/>
</f></set_attachment>
		<new public="1" set="method" line="7"><f a="?attachment">
	<e path="flixel.input.gamepad.FlxGamepadAttachment"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="flixel.input.gamepad.mappings.OUYAMapping" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/input/gamepad/mappings/OUYAMapping.hx">
		<extends path="flixel.input.gamepad.mappings.FlxGamepadMapping"/>
		<initValues set="method" line="16" override="1"><f a=""><x path="Void"/></f></initValues>
		<getID public="1" set="method" line="22" override="1"><f a="rawID">
	<x path="Int"/>
	<x path="flixel.input.gamepad.FlxGamepadInputID"/>
</f></getID>
		<getRawID public="1" set="method" line="53" override="1"><f a="ID">
	<x path="flixel.input.gamepad.FlxGamepadInputID"/>
	<x path="Int"/>
</f></getRawID>
		<new public="1" set="method" line="6"><f a="?attachment">
	<e path="flixel.input.gamepad.FlxGamepadAttachment"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="flixel.input.gamepad.mappings.PS4Mapping" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/input/gamepad/mappings/PS4Mapping.hx">
		<extends path="flixel.input.gamepad.mappings.FlxGamepadMapping"/>
		<initValues set="method" line="19" override="1"><f a=""><x path="Void"/></f></initValues>
		<getID public="1" set="method" line="25" override="1"><f a="rawID">
	<x path="Int"/>
	<x path="flixel.input.gamepad.FlxGamepadInputID"/>
</f></getID>
		<getRawID public="1" set="method" line="56" override="1"><f a="ID">
	<x path="flixel.input.gamepad.FlxGamepadInputID"/>
	<x path="Int"/>
</f></getRawID>
		<new public="1" set="method" line="6"><f a="?attachment">
	<e path="flixel.input.gamepad.FlxGamepadAttachment"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="flixel.input.gamepad.mappings.PSVitaMapping" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/input/gamepad/mappings/PSVitaMapping.hx">
		<extends path="flixel.input.gamepad.mappings.FlxGamepadMapping"/>
		<initValues set="method" line="8" override="1"><f a=""><x path="Void"/></f></initValues>
		<getID public="1" set="method" line="14" override="1"><f a="rawID">
	<x path="Int"/>
	<x path="flixel.input.gamepad.FlxGamepadInputID"/>
</f></getID>
		<getRawID public="1" set="method" line="42" override="1"><f a="ID">
	<x path="flixel.input.gamepad.FlxGamepadInputID"/>
	<x path="Int"/>
</f></getRawID>
		<isAxisFlipped public="1" set="method" line="70" override="1"><f a="axisID">
	<x path="Int"/>
	<x path="Bool"/>
</f></isAxisFlipped>
		<new public="1" set="method" line="6"><f a="?attachment">
	<e path="flixel.input.gamepad.FlxGamepadAttachment"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="flixel.input.gamepad.mappings.WiiRemoteMapping" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/input/gamepad/mappings/WiiRemoteMapping.hx">
		<extends path="flixel.input.gamepad.mappings.FlxGamepadMapping"/>
		<initValues set="method" line="16" override="1"><f a=""><x path="Void"/></f></initValues>
		<getID public="1" set="method" line="23" override="1"><f a="rawID">
	<x path="Int"/>
	<x path="flixel.input.gamepad.FlxGamepadInputID"/>
</f></getID>
		<getIDClassicController set="method" line="33"><f a="rawID">
	<x path="Int"/>
	<x path="flixel.input.gamepad.FlxGamepadInputID"/>
</f></getIDClassicController>
		<getIDNunchuk set="method" line="66"><f a="rawID">
	<x path="Int"/>
	<x path="flixel.input.gamepad.FlxGamepadInputID"/>
</f></getIDNunchuk>
		<getIDDefault set="method" line="92"><f a="rawID">
	<x path="Int"/>
	<x path="flixel.input.gamepad.FlxGamepadInputID"/>
</f></getIDDefault>
		<getRawID public="1" set="method" line="111" override="1"><f a="ID">
	<x path="flixel.input.gamepad.FlxGamepadInputID"/>
	<x path="Int"/>
</f></getRawID>
		<getRawClassicController set="method" line="121"><f a="ID">
	<x path="flixel.input.gamepad.FlxGamepadInputID"/>
	<x path="Int"/>
</f></getRawClassicController>
		<getRawNunchuk set="method" line="154"><f a="ID">
	<x path="flixel.input.gamepad.FlxGamepadInputID"/>
	<x path="Int"/>
</f></getRawNunchuk>
		<getRawDefault set="method" line="181"><f a="ID">
	<x path="flixel.input.gamepad.FlxGamepadInputID"/>
	<x path="Int"/>
</f></getRawDefault>
		<isAxisForMotion public="1" set="method" line="202" override="1"><f a="ID">
	<x path="flixel.input.gamepad.FlxGamepadInputID"/>
	<x path="Bool"/>
</f></isAxisForMotion>
		<isAxisFlipped public="1" set="method" line="217" override="1"><f a="axisID">
	<x path="Int"/>
	<x path="Bool"/>
</f></isAxisFlipped>
		<set_attachment set="method" line="265" override="1"><f a="attachment">
	<e path="flixel.input.gamepad.FlxGamepadAttachment"/>
	<e path="flixel.input.gamepad.FlxGamepadAttachment"/>
</f></set_attachment>
		<new public="1" set="method" line="7"><f a="?attachment">
	<e path="flixel.input.gamepad.FlxGamepadAttachment"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="flixel.input.gamepad.mappings.XInputMapping" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/input/gamepad/mappings/XInputMapping.hx">
		<extends path="flixel.input.gamepad.mappings.FlxGamepadMapping"/>
		<initValues set="method" line="19" override="1"><f a=""><x path="Void"/></f></initValues>
		<getID public="1" set="method" line="25" override="1"><f a="rawID">
	<x path="Int"/>
	<x path="flixel.input.gamepad.FlxGamepadInputID"/>
</f></getID>
		<getRawID public="1" set="method" line="63" override="1"><f a="ID">
	<x path="flixel.input.gamepad.FlxGamepadInputID"/>
	<x path="Int"/>
</f></getRawID>
		<new public="1" set="method" line="6"><f a="?attachment">
	<e path="flixel.input.gamepad.FlxGamepadAttachment"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<abstract path="flixel.input.keyboard.FlxKey" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/input/keyboard/FlxKey.hx">
		<from>
			<icast><x path="Int"/></icast>
			<icast field="fromString"><c path="String"/></icast>
		</from>
		<this><x path="Int"/></this>
		<to>
			<icast><x path="Int"/></icast>
			<icast field="toString"><c path="String"/></icast>
		</to>
		<haxe_doc>* Maps enum values and strings to integer keycodes.</haxe_doc>
		<meta><m n=":enum"/></meta>
		<impl><class path="flixel.input.keyboard._FlxKey.FlxKey_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/input/keyboard/FlxKey.hx" private="1" module="flixel.input.keyboard.FlxKey">
	<fromStringMap public="1" set="null" expr="FlxMacroUtil.buildMap(&quot;flixel.input.keyboard.FlxKey&quot;)" line="53" static="1">
		<x path="Map">
			<c path="String"/>
			<x path="flixel.input.keyboard.FlxKey"/>
		</x>
		<meta><m n=":value"><e>FlxMacroUtil.buildMap("flixel.input.keyboard.FlxKey")</e></m></meta>
	</fromStringMap>
	<toStringMap public="1" set="null" expr="FlxMacroUtil.buildMap(&quot;flixel.input.keyboard.FlxKey&quot;, true)" line="53" static="1">
		<x path="Map">
			<x path="flixel.input.keyboard.FlxKey"/>
			<c path="String"/>
		</x>
		<meta><m n=":value"><e>FlxMacroUtil.buildMap("flixel.input.keyboard.FlxKey", true)</e></m></meta>
	</toStringMap>
	<ANY public="1" get="inline" set="null" expr="cast -2" line="18" static="1">
		<x path="flixel.input.keyboard.FlxKey"/>
		<meta>
			<m n=":value"><e>cast -2</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</ANY>
	<NONE public="1" get="inline" set="null" expr="cast -1" line="19" static="1">
		<x path="flixel.input.keyboard.FlxKey"/>
		<meta>
			<m n=":value"><e>cast -1</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NONE>
	<A public="1" get="inline" set="null" expr="cast 65" line="20" static="1">
		<x path="flixel.input.keyboard.FlxKey"/>
		<meta>
			<m n=":value"><e>cast 65</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</A>
	<B public="1" get="inline" set="null" expr="cast 66" line="21" static="1">
		<x path="flixel.input.keyboard.FlxKey"/>
		<meta>
			<m n=":value"><e>cast 66</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</B>
	<C public="1" get="inline" set="null" expr="cast 67" line="22" static="1">
		<x path="flixel.input.keyboard.FlxKey"/>
		<meta>
			<m n=":value"><e>cast 67</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</C>
	<D public="1" get="inline" set="null" expr="cast 68" line="23" static="1">
		<x path="flixel.input.keyboard.FlxKey"/>
		<meta>
			<m n=":value"><e>cast 68</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</D>
	<E public="1" get="inline" set="null" expr="cast 69" line="24" static="1">
		<x path="flixel.input.keyboard.FlxKey"/>
		<meta>
			<m n=":value"><e>cast 69</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</E>
	<F public="1" get="inline" set="null" expr="cast 70" line="25" static="1">
		<x path="flixel.input.keyboard.FlxKey"/>
		<meta>
			<m n=":value"><e>cast 70</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</F>
	<G public="1" get="inline" set="null" expr="cast 71" line="26" static="1">
		<x path="flixel.input.keyboard.FlxKey"/>
		<meta>
			<m n=":value"><e>cast 71</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</G>
	<H public="1" get="inline" set="null" expr="cast 72" line="27" static="1">
		<x path="flixel.input.keyboard.FlxKey"/>
		<meta>
			<m n=":value"><e>cast 72</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</H>
	<I public="1" get="inline" set="null" expr="cast 73" line="28" static="1">
		<x path="flixel.input.keyboard.FlxKey"/>
		<meta>
			<m n=":value"><e>cast 73</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</I>
	<J public="1" get="inline" set="null" expr="cast 74" line="29" static="1">
		<x path="flixel.input.keyboard.FlxKey"/>
		<meta>
			<m n=":value"><e>cast 74</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</J>
	<K public="1" get="inline" set="null" expr="cast 75" line="30" static="1">
		<x path="flixel.input.keyboard.FlxKey"/>
		<meta>
			<m n=":value"><e>cast 75</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</K>
	<L public="1" get="inline" set="null" expr="cast 76" line="31" static="1">
		<x path="flixel.input.keyboard.FlxKey"/>
		<meta>
			<m n=":value"><e>cast 76</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</L>
	<M public="1" get="inline" set="null" expr="cast 77" line="32" static="1">
		<x path="flixel.input.keyboard.FlxKey"/>
		<meta>
			<m n=":value"><e>cast 77</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</M>
	<N public="1" get="inline" set="null" expr="cast 78" line="33" static="1">
		<x path="flixel.input.keyboard.FlxKey"/>
		<meta>
			<m n=":value"><e>cast 78</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</N>
	<O public="1" get="inline" set="null" expr="cast 79" line="34" static="1">
		<x path="flixel.input.keyboard.FlxKey"/>
		<meta>
			<m n=":value"><e>cast 79</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</O>
	<P public="1" get="inline" set="null" expr="cast 80" line="35" static="1">
		<x path="flixel.input.keyboard.FlxKey"/>
		<meta>
			<m n=":value"><e>cast 80</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</P>
	<Q public="1" get="inline" set="null" expr="cast 81" line="36" static="1">
		<x path="flixel.input.keyboard.FlxKey"/>
		<meta>
			<m n=":value"><e>cast 81</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Q>
	<R public="1" get="inline" set="null" expr="cast 82" line="37" static="1">
		<x path="flixel.input.keyboard.FlxKey"/>
		<meta>
			<m n=":value"><e>cast 82</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</R>
	<S public="1" get="inline" set="null" expr="cast 83" line="38" static="1">
		<x path="flixel.input.keyboard.FlxKey"/>
		<meta>
			<m n=":value"><e>cast 83</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</S>
	<T public="1" get="inline" set="null" expr="cast 84" line="39" static="1">
		<x path="flixel.input.keyboard.FlxKey"/>
		<meta>
			<m n=":value"><e>cast 84</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</T>
	<U public="1" get="inline" set="null" expr="cast 85" line="40" static="1">
		<x path="flixel.input.keyboard.FlxKey"/>
		<meta>
			<m n=":value"><e>cast 85</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</U>
	<V public="1" get="inline" set="null" expr="cast 86" line="41" static="1">
		<x path="flixel.input.keyboard.FlxKey"/>
		<meta>
			<m n=":value"><e>cast 86</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</V>
	<W public="1" get="inline" set="null" expr="cast 87" line="42" static="1">
		<x path="flixel.input.keyboard.FlxKey"/>
		<meta>
			<m n=":value"><e>cast 87</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</W>
	<X public="1" get="inline" set="null" expr="cast 88" line="43" static="1">
		<x path="flixel.input.keyboard.FlxKey"/>
		<meta>
			<m n=":value"><e>cast 88</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</X>
	<Y public="1" get="inline" set="null" expr="cast 89" line="44" static="1">
		<x path="flixel.input.keyboard.FlxKey"/>
		<meta>
			<m n=":value"><e>cast 89</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Y>
	<Z public="1" get="inline" set="null" expr="cast 90" line="45" static="1">
		<x path="flixel.input.keyboard.FlxKey"/>
		<meta>
			<m n=":value"><e>cast 90</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Z>
	<ZERO public="1" get="inline" set="null" expr="cast 48" line="46" static="1">
		<x path="flixel.input.keyboard.FlxKey"/>
		<meta>
			<m n=":value"><e>cast 48</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</ZERO>
	<ONE public="1" get="inline" set="null" expr="cast 49" line="47" static="1">
		<x path="flixel.input.keyboard.FlxKey"/>
		<meta>
			<m n=":value"><e>cast 49</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</ONE>
	<TWO public="1" get="inline" set="null" expr="cast 50" line="48" static="1">
		<x path="flixel.input.keyboard.FlxKey"/>
		<meta>
			<m n=":value"><e>cast 50</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</TWO>
	<THREE public="1" get="inline" set="null" expr="cast 51" line="49" static="1">
		<x path="flixel.input.keyboard.FlxKey"/>
		<meta>
			<m n=":value"><e>cast 51</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</THREE>
	<FOUR public="1" get="inline" set="null" expr="cast 52" line="50" static="1">
		<x path="flixel.input.keyboard.FlxKey"/>
		<meta>
			<m n=":value"><e>cast 52</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</FOUR>
	<FIVE public="1" get="inline" set="null" expr="cast 53" line="51" static="1">
		<x path="flixel.input.keyboard.FlxKey"/>
		<meta>
			<m n=":value"><e>cast 53</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</FIVE>
	<SIX public="1" get="inline" set="null" expr="cast 54" line="52" static="1">
		<x path="flixel.input.keyboard.FlxKey"/>
		<meta>
			<m n=":value"><e>cast 54</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</SIX>
	<SEVEN public="1" get="inline" set="null" expr="cast 55" line="53" static="1">
		<x path="flixel.input.keyboard.FlxKey"/>
		<meta>
			<m n=":value"><e>cast 55</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</SEVEN>
	<EIGHT public="1" get="inline" set="null" expr="cast 56" line="54" static="1">
		<x path="flixel.input.keyboard.FlxKey"/>
		<meta>
			<m n=":value"><e>cast 56</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</EIGHT>
	<NINE public="1" get="inline" set="null" expr="cast 57" line="55" static="1">
		<x path="flixel.input.keyboard.FlxKey"/>
		<meta>
			<m n=":value"><e>cast 57</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NINE>
	<PAGEUP public="1" get="inline" set="null" expr="cast 33" line="56" static="1">
		<x path="flixel.input.keyboard.FlxKey"/>
		<meta>
			<m n=":value"><e>cast 33</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</PAGEUP>
	<PAGEDOWN public="1" get="inline" set="null" expr="cast 34" line="57" static="1">
		<x path="flixel.input.keyboard.FlxKey"/>
		<meta>
			<m n=":value"><e>cast 34</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</PAGEDOWN>
	<HOME public="1" get="inline" set="null" expr="cast 36" line="58" static="1">
		<x path="flixel.input.keyboard.FlxKey"/>
		<meta>
			<m n=":value"><e>cast 36</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</HOME>
	<END public="1" get="inline" set="null" expr="cast 35" line="59" static="1">
		<x path="flixel.input.keyboard.FlxKey"/>
		<meta>
			<m n=":value"><e>cast 35</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</END>
	<INSERT public="1" get="inline" set="null" expr="cast 45" line="60" static="1">
		<x path="flixel.input.keyboard.FlxKey"/>
		<meta>
			<m n=":value"><e>cast 45</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</INSERT>
	<ESCAPE public="1" get="inline" set="null" expr="cast 27" line="61" static="1">
		<x path="flixel.input.keyboard.FlxKey"/>
		<meta>
			<m n=":value"><e>cast 27</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</ESCAPE>
	<MINUS public="1" get="inline" set="null" expr="cast 189" line="62" static="1">
		<x path="flixel.input.keyboard.FlxKey"/>
		<meta>
			<m n=":value"><e>cast 189</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</MINUS>
	<PLUS public="1" get="inline" set="null" expr="cast 187" line="63" static="1">
		<x path="flixel.input.keyboard.FlxKey"/>
		<meta>
			<m n=":value"><e>cast 187</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</PLUS>
	<DELETE public="1" get="inline" set="null" expr="cast 46" line="64" static="1">
		<x path="flixel.input.keyboard.FlxKey"/>
		<meta>
			<m n=":value"><e>cast 46</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</DELETE>
	<BACKSPACE public="1" get="inline" set="null" expr="cast 8" line="65" static="1">
		<x path="flixel.input.keyboard.FlxKey"/>
		<meta>
			<m n=":value"><e>cast 8</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</BACKSPACE>
	<LBRACKET public="1" get="inline" set="null" expr="cast 219" line="66" static="1">
		<x path="flixel.input.keyboard.FlxKey"/>
		<meta>
			<m n=":value"><e>cast 219</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</LBRACKET>
	<RBRACKET public="1" get="inline" set="null" expr="cast 221" line="67" static="1">
		<x path="flixel.input.keyboard.FlxKey"/>
		<meta>
			<m n=":value"><e>cast 221</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</RBRACKET>
	<BACKSLASH public="1" get="inline" set="null" expr="cast 220" line="68" static="1">
		<x path="flixel.input.keyboard.FlxKey"/>
		<meta>
			<m n=":value"><e>cast 220</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</BACKSLASH>
	<CAPSLOCK public="1" get="inline" set="null" expr="cast 20" line="69" static="1">
		<x path="flixel.input.keyboard.FlxKey"/>
		<meta>
			<m n=":value"><e>cast 20</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</CAPSLOCK>
	<SEMICOLON public="1" get="inline" set="null" expr="cast 186" line="70" static="1">
		<x path="flixel.input.keyboard.FlxKey"/>
		<meta>
			<m n=":value"><e>cast 186</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</SEMICOLON>
	<QUOTE public="1" get="inline" set="null" expr="cast 222" line="71" static="1">
		<x path="flixel.input.keyboard.FlxKey"/>
		<meta>
			<m n=":value"><e>cast 222</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</QUOTE>
	<ENTER public="1" get="inline" set="null" expr="cast 13" line="72" static="1">
		<x path="flixel.input.keyboard.FlxKey"/>
		<meta>
			<m n=":value"><e>cast 13</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</ENTER>
	<SHIFT public="1" get="inline" set="null" expr="cast 16" line="73" static="1">
		<x path="flixel.input.keyboard.FlxKey"/>
		<meta>
			<m n=":value"><e>cast 16</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</SHIFT>
	<COMMA public="1" get="inline" set="null" expr="cast 188" line="74" static="1">
		<x path="flixel.input.keyboard.FlxKey"/>
		<meta>
			<m n=":value"><e>cast 188</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</COMMA>
	<PERIOD public="1" get="inline" set="null" expr="cast 190" line="75" static="1">
		<x path="flixel.input.keyboard.FlxKey"/>
		<meta>
			<m n=":value"><e>cast 190</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</PERIOD>
	<SLASH public="1" get="inline" set="null" expr="cast 191" line="76" static="1">
		<x path="flixel.input.keyboard.FlxKey"/>
		<meta>
			<m n=":value"><e>cast 191</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</SLASH>
	<GRAVEACCENT public="1" get="inline" set="null" expr="cast 192" line="77" static="1">
		<x path="flixel.input.keyboard.FlxKey"/>
		<meta>
			<m n=":value"><e>cast 192</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</GRAVEACCENT>
	<CONTROL public="1" get="inline" set="null" expr="cast 17" line="78" static="1">
		<x path="flixel.input.keyboard.FlxKey"/>
		<meta>
			<m n=":value"><e>cast 17</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</CONTROL>
	<ALT public="1" get="inline" set="null" expr="cast 18" line="79" static="1">
		<x path="flixel.input.keyboard.FlxKey"/>
		<meta>
			<m n=":value"><e>cast 18</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</ALT>
	<SPACE public="1" get="inline" set="null" expr="cast 32" line="80" static="1">
		<x path="flixel.input.keyboard.FlxKey"/>
		<meta>
			<m n=":value"><e>cast 32</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</SPACE>
	<UP public="1" get="inline" set="null" expr="cast 38" line="81" static="1">
		<x path="flixel.input.keyboard.FlxKey"/>
		<meta>
			<m n=":value"><e>cast 38</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</UP>
	<DOWN public="1" get="inline" set="null" expr="cast 40" line="82" static="1">
		<x path="flixel.input.keyboard.FlxKey"/>
		<meta>
			<m n=":value"><e>cast 40</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</DOWN>
	<LEFT public="1" get="inline" set="null" expr="cast 37" line="83" static="1">
		<x path="flixel.input.keyboard.FlxKey"/>
		<meta>
			<m n=":value"><e>cast 37</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</LEFT>
	<RIGHT public="1" get="inline" set="null" expr="cast 39" line="84" static="1">
		<x path="flixel.input.keyboard.FlxKey"/>
		<meta>
			<m n=":value"><e>cast 39</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</RIGHT>
	<TAB public="1" get="inline" set="null" expr="cast 9" line="85" static="1">
		<x path="flixel.input.keyboard.FlxKey"/>
		<meta>
			<m n=":value"><e>cast 9</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</TAB>
	<PRINTSCREEN public="1" get="inline" set="null" expr="cast 301" line="86" static="1">
		<x path="flixel.input.keyboard.FlxKey"/>
		<meta>
			<m n=":value"><e>cast 301</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</PRINTSCREEN>
	<F1 public="1" get="inline" set="null" expr="cast 112" line="87" static="1">
		<x path="flixel.input.keyboard.FlxKey"/>
		<meta>
			<m n=":value"><e>cast 112</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</F1>
	<F2 public="1" get="inline" set="null" expr="cast 113" line="88" static="1">
		<x path="flixel.input.keyboard.FlxKey"/>
		<meta>
			<m n=":value"><e>cast 113</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</F2>
	<F3 public="1" get="inline" set="null" expr="cast 114" line="89" static="1">
		<x path="flixel.input.keyboard.FlxKey"/>
		<meta>
			<m n=":value"><e>cast 114</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</F3>
	<F4 public="1" get="inline" set="null" expr="cast 115" line="90" static="1">
		<x path="flixel.input.keyboard.FlxKey"/>
		<meta>
			<m n=":value"><e>cast 115</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</F4>
	<F5 public="1" get="inline" set="null" expr="cast 116" line="91" static="1">
		<x path="flixel.input.keyboard.FlxKey"/>
		<meta>
			<m n=":value"><e>cast 116</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</F5>
	<F6 public="1" get="inline" set="null" expr="cast 117" line="92" static="1">
		<x path="flixel.input.keyboard.FlxKey"/>
		<meta>
			<m n=":value"><e>cast 117</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</F6>
	<F7 public="1" get="inline" set="null" expr="cast 118" line="93" static="1">
		<x path="flixel.input.keyboard.FlxKey"/>
		<meta>
			<m n=":value"><e>cast 118</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</F7>
	<F8 public="1" get="inline" set="null" expr="cast 119" line="94" static="1">
		<x path="flixel.input.keyboard.FlxKey"/>
		<meta>
			<m n=":value"><e>cast 119</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</F8>
	<F9 public="1" get="inline" set="null" expr="cast 120" line="95" static="1">
		<x path="flixel.input.keyboard.FlxKey"/>
		<meta>
			<m n=":value"><e>cast 120</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</F9>
	<F10 public="1" get="inline" set="null" expr="cast 121" line="96" static="1">
		<x path="flixel.input.keyboard.FlxKey"/>
		<meta>
			<m n=":value"><e>cast 121</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</F10>
	<F11 public="1" get="inline" set="null" expr="cast 122" line="97" static="1">
		<x path="flixel.input.keyboard.FlxKey"/>
		<meta>
			<m n=":value"><e>cast 122</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</F11>
	<F12 public="1" get="inline" set="null" expr="cast 123" line="98" static="1">
		<x path="flixel.input.keyboard.FlxKey"/>
		<meta>
			<m n=":value"><e>cast 123</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</F12>
	<NUMPADZERO public="1" get="inline" set="null" expr="cast 96" line="99" static="1">
		<x path="flixel.input.keyboard.FlxKey"/>
		<meta>
			<m n=":value"><e>cast 96</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPADZERO>
	<NUMPADONE public="1" get="inline" set="null" expr="cast 97" line="100" static="1">
		<x path="flixel.input.keyboard.FlxKey"/>
		<meta>
			<m n=":value"><e>cast 97</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPADONE>
	<NUMPADTWO public="1" get="inline" set="null" expr="cast 98" line="101" static="1">
		<x path="flixel.input.keyboard.FlxKey"/>
		<meta>
			<m n=":value"><e>cast 98</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPADTWO>
	<NUMPADTHREE public="1" get="inline" set="null" expr="cast 99" line="102" static="1">
		<x path="flixel.input.keyboard.FlxKey"/>
		<meta>
			<m n=":value"><e>cast 99</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPADTHREE>
	<NUMPADFOUR public="1" get="inline" set="null" expr="cast 100" line="103" static="1">
		<x path="flixel.input.keyboard.FlxKey"/>
		<meta>
			<m n=":value"><e>cast 100</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPADFOUR>
	<NUMPADFIVE public="1" get="inline" set="null" expr="cast 101" line="104" static="1">
		<x path="flixel.input.keyboard.FlxKey"/>
		<meta>
			<m n=":value"><e>cast 101</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPADFIVE>
	<NUMPADSIX public="1" get="inline" set="null" expr="cast 102" line="105" static="1">
		<x path="flixel.input.keyboard.FlxKey"/>
		<meta>
			<m n=":value"><e>cast 102</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPADSIX>
	<NUMPADSEVEN public="1" get="inline" set="null" expr="cast 103" line="106" static="1">
		<x path="flixel.input.keyboard.FlxKey"/>
		<meta>
			<m n=":value"><e>cast 103</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPADSEVEN>
	<NUMPADEIGHT public="1" get="inline" set="null" expr="cast 104" line="107" static="1">
		<x path="flixel.input.keyboard.FlxKey"/>
		<meta>
			<m n=":value"><e>cast 104</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPADEIGHT>
	<NUMPADNINE public="1" get="inline" set="null" expr="cast 105" line="108" static="1">
		<x path="flixel.input.keyboard.FlxKey"/>
		<meta>
			<m n=":value"><e>cast 105</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPADNINE>
	<NUMPADMINUS public="1" get="inline" set="null" expr="cast 109" line="109" static="1">
		<x path="flixel.input.keyboard.FlxKey"/>
		<meta>
			<m n=":value"><e>cast 109</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPADMINUS>
	<NUMPADPLUS public="1" get="inline" set="null" expr="cast 107" line="110" static="1">
		<x path="flixel.input.keyboard.FlxKey"/>
		<meta>
			<m n=":value"><e>cast 107</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPADPLUS>
	<NUMPADPERIOD public="1" get="inline" set="null" expr="cast 110" line="111" static="1">
		<x path="flixel.input.keyboard.FlxKey"/>
		<meta>
			<m n=":value"><e>cast 110</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPADPERIOD>
	<NUMPADMULTIPLY public="1" get="inline" set="null" expr="cast 106" line="112" static="1">
		<x path="flixel.input.keyboard.FlxKey"/>
		<meta>
			<m n=":value"><e>cast 106</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPADMULTIPLY>
	<fromString public="1" get="inline" set="null" line="115" static="1">
		<f a="s">
			<c path="String"/>
			<x path="flixel.input.keyboard.FlxKey"/>
		</f>
		<meta><m n=":from"/></meta>
	</fromString>
	<toString public="1" get="inline" set="null" line="122" static="1">
		<f a="this">
			<x path="Int"/>
			<c path="String"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":to"/>
		</meta>
	</toString>
	<meta>
		<m n=":directlyUsed"/>
		<m n=":final"/>
		<m n=":enum"/>
	</meta>
</class></impl>
	</abstract>
	<class path="flixel.input.keyboard._FlxKey.FlxKey_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/input/keyboard/FlxKey.hx" private="1" module="flixel.input.keyboard.FlxKey">
		<fromStringMap public="1" set="null" expr="FlxMacroUtil.buildMap(&quot;flixel.input.keyboard.FlxKey&quot;)" line="53" static="1">
			<x path="Map">
				<c path="String"/>
				<x path="flixel.input.keyboard.FlxKey"/>
			</x>
			<meta><m n=":value"><e>FlxMacroUtil.buildMap("flixel.input.keyboard.FlxKey")</e></m></meta>
		</fromStringMap>
		<toStringMap public="1" set="null" expr="FlxMacroUtil.buildMap(&quot;flixel.input.keyboard.FlxKey&quot;, true)" line="53" static="1">
			<x path="Map">
				<x path="flixel.input.keyboard.FlxKey"/>
				<c path="String"/>
			</x>
			<meta><m n=":value"><e>FlxMacroUtil.buildMap("flixel.input.keyboard.FlxKey", true)</e></m></meta>
		</toStringMap>
		<ANY public="1" get="inline" set="null" expr="cast -2" line="18" static="1">
			<x path="flixel.input.keyboard.FlxKey"/>
			<meta>
				<m n=":value"><e>cast -2</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</ANY>
		<NONE public="1" get="inline" set="null" expr="cast -1" line="19" static="1">
			<x path="flixel.input.keyboard.FlxKey"/>
			<meta>
				<m n=":value"><e>cast -1</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NONE>
		<A public="1" get="inline" set="null" expr="cast 65" line="20" static="1">
			<x path="flixel.input.keyboard.FlxKey"/>
			<meta>
				<m n=":value"><e>cast 65</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</A>
		<B public="1" get="inline" set="null" expr="cast 66" line="21" static="1">
			<x path="flixel.input.keyboard.FlxKey"/>
			<meta>
				<m n=":value"><e>cast 66</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</B>
		<C public="1" get="inline" set="null" expr="cast 67" line="22" static="1">
			<x path="flixel.input.keyboard.FlxKey"/>
			<meta>
				<m n=":value"><e>cast 67</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</C>
		<D public="1" get="inline" set="null" expr="cast 68" line="23" static="1">
			<x path="flixel.input.keyboard.FlxKey"/>
			<meta>
				<m n=":value"><e>cast 68</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</D>
		<E public="1" get="inline" set="null" expr="cast 69" line="24" static="1">
			<x path="flixel.input.keyboard.FlxKey"/>
			<meta>
				<m n=":value"><e>cast 69</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</E>
		<F public="1" get="inline" set="null" expr="cast 70" line="25" static="1">
			<x path="flixel.input.keyboard.FlxKey"/>
			<meta>
				<m n=":value"><e>cast 70</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</F>
		<G public="1" get="inline" set="null" expr="cast 71" line="26" static="1">
			<x path="flixel.input.keyboard.FlxKey"/>
			<meta>
				<m n=":value"><e>cast 71</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</G>
		<H public="1" get="inline" set="null" expr="cast 72" line="27" static="1">
			<x path="flixel.input.keyboard.FlxKey"/>
			<meta>
				<m n=":value"><e>cast 72</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</H>
		<I public="1" get="inline" set="null" expr="cast 73" line="28" static="1">
			<x path="flixel.input.keyboard.FlxKey"/>
			<meta>
				<m n=":value"><e>cast 73</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</I>
		<J public="1" get="inline" set="null" expr="cast 74" line="29" static="1">
			<x path="flixel.input.keyboard.FlxKey"/>
			<meta>
				<m n=":value"><e>cast 74</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</J>
		<K public="1" get="inline" set="null" expr="cast 75" line="30" static="1">
			<x path="flixel.input.keyboard.FlxKey"/>
			<meta>
				<m n=":value"><e>cast 75</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</K>
		<L public="1" get="inline" set="null" expr="cast 76" line="31" static="1">
			<x path="flixel.input.keyboard.FlxKey"/>
			<meta>
				<m n=":value"><e>cast 76</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</L>
		<M public="1" get="inline" set="null" expr="cast 77" line="32" static="1">
			<x path="flixel.input.keyboard.FlxKey"/>
			<meta>
				<m n=":value"><e>cast 77</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</M>
		<N public="1" get="inline" set="null" expr="cast 78" line="33" static="1">
			<x path="flixel.input.keyboard.FlxKey"/>
			<meta>
				<m n=":value"><e>cast 78</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</N>
		<O public="1" get="inline" set="null" expr="cast 79" line="34" static="1">
			<x path="flixel.input.keyboard.FlxKey"/>
			<meta>
				<m n=":value"><e>cast 79</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</O>
		<P public="1" get="inline" set="null" expr="cast 80" line="35" static="1">
			<x path="flixel.input.keyboard.FlxKey"/>
			<meta>
				<m n=":value"><e>cast 80</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</P>
		<Q public="1" get="inline" set="null" expr="cast 81" line="36" static="1">
			<x path="flixel.input.keyboard.FlxKey"/>
			<meta>
				<m n=":value"><e>cast 81</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Q>
		<R public="1" get="inline" set="null" expr="cast 82" line="37" static="1">
			<x path="flixel.input.keyboard.FlxKey"/>
			<meta>
				<m n=":value"><e>cast 82</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</R>
		<S public="1" get="inline" set="null" expr="cast 83" line="38" static="1">
			<x path="flixel.input.keyboard.FlxKey"/>
			<meta>
				<m n=":value"><e>cast 83</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</S>
		<T public="1" get="inline" set="null" expr="cast 84" line="39" static="1">
			<x path="flixel.input.keyboard.FlxKey"/>
			<meta>
				<m n=":value"><e>cast 84</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</T>
		<U public="1" get="inline" set="null" expr="cast 85" line="40" static="1">
			<x path="flixel.input.keyboard.FlxKey"/>
			<meta>
				<m n=":value"><e>cast 85</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</U>
		<V public="1" get="inline" set="null" expr="cast 86" line="41" static="1">
			<x path="flixel.input.keyboard.FlxKey"/>
			<meta>
				<m n=":value"><e>cast 86</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</V>
		<W public="1" get="inline" set="null" expr="cast 87" line="42" static="1">
			<x path="flixel.input.keyboard.FlxKey"/>
			<meta>
				<m n=":value"><e>cast 87</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</W>
		<X public="1" get="inline" set="null" expr="cast 88" line="43" static="1">
			<x path="flixel.input.keyboard.FlxKey"/>
			<meta>
				<m n=":value"><e>cast 88</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</X>
		<Y public="1" get="inline" set="null" expr="cast 89" line="44" static="1">
			<x path="flixel.input.keyboard.FlxKey"/>
			<meta>
				<m n=":value"><e>cast 89</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Y>
		<Z public="1" get="inline" set="null" expr="cast 90" line="45" static="1">
			<x path="flixel.input.keyboard.FlxKey"/>
			<meta>
				<m n=":value"><e>cast 90</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Z>
		<ZERO public="1" get="inline" set="null" expr="cast 48" line="46" static="1">
			<x path="flixel.input.keyboard.FlxKey"/>
			<meta>
				<m n=":value"><e>cast 48</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</ZERO>
		<ONE public="1" get="inline" set="null" expr="cast 49" line="47" static="1">
			<x path="flixel.input.keyboard.FlxKey"/>
			<meta>
				<m n=":value"><e>cast 49</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</ONE>
		<TWO public="1" get="inline" set="null" expr="cast 50" line="48" static="1">
			<x path="flixel.input.keyboard.FlxKey"/>
			<meta>
				<m n=":value"><e>cast 50</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</TWO>
		<THREE public="1" get="inline" set="null" expr="cast 51" line="49" static="1">
			<x path="flixel.input.keyboard.FlxKey"/>
			<meta>
				<m n=":value"><e>cast 51</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</THREE>
		<FOUR public="1" get="inline" set="null" expr="cast 52" line="50" static="1">
			<x path="flixel.input.keyboard.FlxKey"/>
			<meta>
				<m n=":value"><e>cast 52</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</FOUR>
		<FIVE public="1" get="inline" set="null" expr="cast 53" line="51" static="1">
			<x path="flixel.input.keyboard.FlxKey"/>
			<meta>
				<m n=":value"><e>cast 53</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</FIVE>
		<SIX public="1" get="inline" set="null" expr="cast 54" line="52" static="1">
			<x path="flixel.input.keyboard.FlxKey"/>
			<meta>
				<m n=":value"><e>cast 54</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</SIX>
		<SEVEN public="1" get="inline" set="null" expr="cast 55" line="53" static="1">
			<x path="flixel.input.keyboard.FlxKey"/>
			<meta>
				<m n=":value"><e>cast 55</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</SEVEN>
		<EIGHT public="1" get="inline" set="null" expr="cast 56" line="54" static="1">
			<x path="flixel.input.keyboard.FlxKey"/>
			<meta>
				<m n=":value"><e>cast 56</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</EIGHT>
		<NINE public="1" get="inline" set="null" expr="cast 57" line="55" static="1">
			<x path="flixel.input.keyboard.FlxKey"/>
			<meta>
				<m n=":value"><e>cast 57</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NINE>
		<PAGEUP public="1" get="inline" set="null" expr="cast 33" line="56" static="1">
			<x path="flixel.input.keyboard.FlxKey"/>
			<meta>
				<m n=":value"><e>cast 33</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</PAGEUP>
		<PAGEDOWN public="1" get="inline" set="null" expr="cast 34" line="57" static="1">
			<x path="flixel.input.keyboard.FlxKey"/>
			<meta>
				<m n=":value"><e>cast 34</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</PAGEDOWN>
		<HOME public="1" get="inline" set="null" expr="cast 36" line="58" static="1">
			<x path="flixel.input.keyboard.FlxKey"/>
			<meta>
				<m n=":value"><e>cast 36</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</HOME>
		<END public="1" get="inline" set="null" expr="cast 35" line="59" static="1">
			<x path="flixel.input.keyboard.FlxKey"/>
			<meta>
				<m n=":value"><e>cast 35</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</END>
		<INSERT public="1" get="inline" set="null" expr="cast 45" line="60" static="1">
			<x path="flixel.input.keyboard.FlxKey"/>
			<meta>
				<m n=":value"><e>cast 45</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</INSERT>
		<ESCAPE public="1" get="inline" set="null" expr="cast 27" line="61" static="1">
			<x path="flixel.input.keyboard.FlxKey"/>
			<meta>
				<m n=":value"><e>cast 27</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</ESCAPE>
		<MINUS public="1" get="inline" set="null" expr="cast 189" line="62" static="1">
			<x path="flixel.input.keyboard.FlxKey"/>
			<meta>
				<m n=":value"><e>cast 189</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</MINUS>
		<PLUS public="1" get="inline" set="null" expr="cast 187" line="63" static="1">
			<x path="flixel.input.keyboard.FlxKey"/>
			<meta>
				<m n=":value"><e>cast 187</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</PLUS>
		<DELETE public="1" get="inline" set="null" expr="cast 46" line="64" static="1">
			<x path="flixel.input.keyboard.FlxKey"/>
			<meta>
				<m n=":value"><e>cast 46</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</DELETE>
		<BACKSPACE public="1" get="inline" set="null" expr="cast 8" line="65" static="1">
			<x path="flixel.input.keyboard.FlxKey"/>
			<meta>
				<m n=":value"><e>cast 8</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</BACKSPACE>
		<LBRACKET public="1" get="inline" set="null" expr="cast 219" line="66" static="1">
			<x path="flixel.input.keyboard.FlxKey"/>
			<meta>
				<m n=":value"><e>cast 219</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</LBRACKET>
		<RBRACKET public="1" get="inline" set="null" expr="cast 221" line="67" static="1">
			<x path="flixel.input.keyboard.FlxKey"/>
			<meta>
				<m n=":value"><e>cast 221</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</RBRACKET>
		<BACKSLASH public="1" get="inline" set="null" expr="cast 220" line="68" static="1">
			<x path="flixel.input.keyboard.FlxKey"/>
			<meta>
				<m n=":value"><e>cast 220</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</BACKSLASH>
		<CAPSLOCK public="1" get="inline" set="null" expr="cast 20" line="69" static="1">
			<x path="flixel.input.keyboard.FlxKey"/>
			<meta>
				<m n=":value"><e>cast 20</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</CAPSLOCK>
		<SEMICOLON public="1" get="inline" set="null" expr="cast 186" line="70" static="1">
			<x path="flixel.input.keyboard.FlxKey"/>
			<meta>
				<m n=":value"><e>cast 186</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</SEMICOLON>
		<QUOTE public="1" get="inline" set="null" expr="cast 222" line="71" static="1">
			<x path="flixel.input.keyboard.FlxKey"/>
			<meta>
				<m n=":value"><e>cast 222</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</QUOTE>
		<ENTER public="1" get="inline" set="null" expr="cast 13" line="72" static="1">
			<x path="flixel.input.keyboard.FlxKey"/>
			<meta>
				<m n=":value"><e>cast 13</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</ENTER>
		<SHIFT public="1" get="inline" set="null" expr="cast 16" line="73" static="1">
			<x path="flixel.input.keyboard.FlxKey"/>
			<meta>
				<m n=":value"><e>cast 16</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</SHIFT>
		<COMMA public="1" get="inline" set="null" expr="cast 188" line="74" static="1">
			<x path="flixel.input.keyboard.FlxKey"/>
			<meta>
				<m n=":value"><e>cast 188</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</COMMA>
		<PERIOD public="1" get="inline" set="null" expr="cast 190" line="75" static="1">
			<x path="flixel.input.keyboard.FlxKey"/>
			<meta>
				<m n=":value"><e>cast 190</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</PERIOD>
		<SLASH public="1" get="inline" set="null" expr="cast 191" line="76" static="1">
			<x path="flixel.input.keyboard.FlxKey"/>
			<meta>
				<m n=":value"><e>cast 191</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</SLASH>
		<GRAVEACCENT public="1" get="inline" set="null" expr="cast 192" line="77" static="1">
			<x path="flixel.input.keyboard.FlxKey"/>
			<meta>
				<m n=":value"><e>cast 192</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</GRAVEACCENT>
		<CONTROL public="1" get="inline" set="null" expr="cast 17" line="78" static="1">
			<x path="flixel.input.keyboard.FlxKey"/>
			<meta>
				<m n=":value"><e>cast 17</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</CONTROL>
		<ALT public="1" get="inline" set="null" expr="cast 18" line="79" static="1">
			<x path="flixel.input.keyboard.FlxKey"/>
			<meta>
				<m n=":value"><e>cast 18</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</ALT>
		<SPACE public="1" get="inline" set="null" expr="cast 32" line="80" static="1">
			<x path="flixel.input.keyboard.FlxKey"/>
			<meta>
				<m n=":value"><e>cast 32</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</SPACE>
		<UP public="1" get="inline" set="null" expr="cast 38" line="81" static="1">
			<x path="flixel.input.keyboard.FlxKey"/>
			<meta>
				<m n=":value"><e>cast 38</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</UP>
		<DOWN public="1" get="inline" set="null" expr="cast 40" line="82" static="1">
			<x path="flixel.input.keyboard.FlxKey"/>
			<meta>
				<m n=":value"><e>cast 40</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</DOWN>
		<LEFT public="1" get="inline" set="null" expr="cast 37" line="83" static="1">
			<x path="flixel.input.keyboard.FlxKey"/>
			<meta>
				<m n=":value"><e>cast 37</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</LEFT>
		<RIGHT public="1" get="inline" set="null" expr="cast 39" line="84" static="1">
			<x path="flixel.input.keyboard.FlxKey"/>
			<meta>
				<m n=":value"><e>cast 39</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</RIGHT>
		<TAB public="1" get="inline" set="null" expr="cast 9" line="85" static="1">
			<x path="flixel.input.keyboard.FlxKey"/>
			<meta>
				<m n=":value"><e>cast 9</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</TAB>
		<PRINTSCREEN public="1" get="inline" set="null" expr="cast 301" line="86" static="1">
			<x path="flixel.input.keyboard.FlxKey"/>
			<meta>
				<m n=":value"><e>cast 301</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</PRINTSCREEN>
		<F1 public="1" get="inline" set="null" expr="cast 112" line="87" static="1">
			<x path="flixel.input.keyboard.FlxKey"/>
			<meta>
				<m n=":value"><e>cast 112</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</F1>
		<F2 public="1" get="inline" set="null" expr="cast 113" line="88" static="1">
			<x path="flixel.input.keyboard.FlxKey"/>
			<meta>
				<m n=":value"><e>cast 113</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</F2>
		<F3 public="1" get="inline" set="null" expr="cast 114" line="89" static="1">
			<x path="flixel.input.keyboard.FlxKey"/>
			<meta>
				<m n=":value"><e>cast 114</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</F3>
		<F4 public="1" get="inline" set="null" expr="cast 115" line="90" static="1">
			<x path="flixel.input.keyboard.FlxKey"/>
			<meta>
				<m n=":value"><e>cast 115</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</F4>
		<F5 public="1" get="inline" set="null" expr="cast 116" line="91" static="1">
			<x path="flixel.input.keyboard.FlxKey"/>
			<meta>
				<m n=":value"><e>cast 116</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</F5>
		<F6 public="1" get="inline" set="null" expr="cast 117" line="92" static="1">
			<x path="flixel.input.keyboard.FlxKey"/>
			<meta>
				<m n=":value"><e>cast 117</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</F6>
		<F7 public="1" get="inline" set="null" expr="cast 118" line="93" static="1">
			<x path="flixel.input.keyboard.FlxKey"/>
			<meta>
				<m n=":value"><e>cast 118</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</F7>
		<F8 public="1" get="inline" set="null" expr="cast 119" line="94" static="1">
			<x path="flixel.input.keyboard.FlxKey"/>
			<meta>
				<m n=":value"><e>cast 119</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</F8>
		<F9 public="1" get="inline" set="null" expr="cast 120" line="95" static="1">
			<x path="flixel.input.keyboard.FlxKey"/>
			<meta>
				<m n=":value"><e>cast 120</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</F9>
		<F10 public="1" get="inline" set="null" expr="cast 121" line="96" static="1">
			<x path="flixel.input.keyboard.FlxKey"/>
			<meta>
				<m n=":value"><e>cast 121</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</F10>
		<F11 public="1" get="inline" set="null" expr="cast 122" line="97" static="1">
			<x path="flixel.input.keyboard.FlxKey"/>
			<meta>
				<m n=":value"><e>cast 122</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</F11>
		<F12 public="1" get="inline" set="null" expr="cast 123" line="98" static="1">
			<x path="flixel.input.keyboard.FlxKey"/>
			<meta>
				<m n=":value"><e>cast 123</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</F12>
		<NUMPADZERO public="1" get="inline" set="null" expr="cast 96" line="99" static="1">
			<x path="flixel.input.keyboard.FlxKey"/>
			<meta>
				<m n=":value"><e>cast 96</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPADZERO>
		<NUMPADONE public="1" get="inline" set="null" expr="cast 97" line="100" static="1">
			<x path="flixel.input.keyboard.FlxKey"/>
			<meta>
				<m n=":value"><e>cast 97</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPADONE>
		<NUMPADTWO public="1" get="inline" set="null" expr="cast 98" line="101" static="1">
			<x path="flixel.input.keyboard.FlxKey"/>
			<meta>
				<m n=":value"><e>cast 98</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPADTWO>
		<NUMPADTHREE public="1" get="inline" set="null" expr="cast 99" line="102" static="1">
			<x path="flixel.input.keyboard.FlxKey"/>
			<meta>
				<m n=":value"><e>cast 99</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPADTHREE>
		<NUMPADFOUR public="1" get="inline" set="null" expr="cast 100" line="103" static="1">
			<x path="flixel.input.keyboard.FlxKey"/>
			<meta>
				<m n=":value"><e>cast 100</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPADFOUR>
		<NUMPADFIVE public="1" get="inline" set="null" expr="cast 101" line="104" static="1">
			<x path="flixel.input.keyboard.FlxKey"/>
			<meta>
				<m n=":value"><e>cast 101</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPADFIVE>
		<NUMPADSIX public="1" get="inline" set="null" expr="cast 102" line="105" static="1">
			<x path="flixel.input.keyboard.FlxKey"/>
			<meta>
				<m n=":value"><e>cast 102</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPADSIX>
		<NUMPADSEVEN public="1" get="inline" set="null" expr="cast 103" line="106" static="1">
			<x path="flixel.input.keyboard.FlxKey"/>
			<meta>
				<m n=":value"><e>cast 103</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPADSEVEN>
		<NUMPADEIGHT public="1" get="inline" set="null" expr="cast 104" line="107" static="1">
			<x path="flixel.input.keyboard.FlxKey"/>
			<meta>
				<m n=":value"><e>cast 104</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPADEIGHT>
		<NUMPADNINE public="1" get="inline" set="null" expr="cast 105" line="108" static="1">
			<x path="flixel.input.keyboard.FlxKey"/>
			<meta>
				<m n=":value"><e>cast 105</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPADNINE>
		<NUMPADMINUS public="1" get="inline" set="null" expr="cast 109" line="109" static="1">
			<x path="flixel.input.keyboard.FlxKey"/>
			<meta>
				<m n=":value"><e>cast 109</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPADMINUS>
		<NUMPADPLUS public="1" get="inline" set="null" expr="cast 107" line="110" static="1">
			<x path="flixel.input.keyboard.FlxKey"/>
			<meta>
				<m n=":value"><e>cast 107</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPADPLUS>
		<NUMPADPERIOD public="1" get="inline" set="null" expr="cast 110" line="111" static="1">
			<x path="flixel.input.keyboard.FlxKey"/>
			<meta>
				<m n=":value"><e>cast 110</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPADPERIOD>
		<NUMPADMULTIPLY public="1" get="inline" set="null" expr="cast 106" line="112" static="1">
			<x path="flixel.input.keyboard.FlxKey"/>
			<meta>
				<m n=":value"><e>cast 106</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPADMULTIPLY>
		<fromString public="1" get="inline" set="null" line="115" static="1">
			<f a="s">
				<c path="String"/>
				<x path="flixel.input.keyboard.FlxKey"/>
			</f>
			<meta><m n=":from"/></meta>
		</fromString>
		<toString public="1" get="inline" set="null" line="122" static="1">
			<f a="this">
				<x path="Int"/>
				<c path="String"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":to"/>
			</meta>
		</toString>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":final"/>
			<m n=":enum"/>
		</meta>
	</class>
	<class path="flixel.input.keyboard.FlxKeyList" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/input/keyboard/FlxKeyList.hx">
		<extends path="flixel.input.FlxBaseKeyList"/>
		<A public="1" get="accessor" set="null"><x path="Bool"/></A>
		<get_A get="inline" set="null" line="12"><f a=""><x path="Bool"/></f></get_A>
		<B public="1" get="accessor" set="null"><x path="Bool"/></B>
		<get_B get="inline" set="null" line="13"><f a=""><x path="Bool"/></f></get_B>
		<C public="1" get="accessor" set="null"><x path="Bool"/></C>
		<get_C get="inline" set="null" line="14"><f a=""><x path="Bool"/></f></get_C>
		<D public="1" get="accessor" set="null"><x path="Bool"/></D>
		<get_D get="inline" set="null" line="15"><f a=""><x path="Bool"/></f></get_D>
		<E public="1" get="accessor" set="null"><x path="Bool"/></E>
		<get_E get="inline" set="null" line="16"><f a=""><x path="Bool"/></f></get_E>
		<F public="1" get="accessor" set="null"><x path="Bool"/></F>
		<get_F get="inline" set="null" line="17"><f a=""><x path="Bool"/></f></get_F>
		<G public="1" get="accessor" set="null"><x path="Bool"/></G>
		<get_G get="inline" set="null" line="18"><f a=""><x path="Bool"/></f></get_G>
		<H public="1" get="accessor" set="null"><x path="Bool"/></H>
		<get_H get="inline" set="null" line="19"><f a=""><x path="Bool"/></f></get_H>
		<I public="1" get="accessor" set="null"><x path="Bool"/></I>
		<get_I get="inline" set="null" line="20"><f a=""><x path="Bool"/></f></get_I>
		<J public="1" get="accessor" set="null"><x path="Bool"/></J>
		<get_J get="inline" set="null" line="21"><f a=""><x path="Bool"/></f></get_J>
		<K public="1" get="accessor" set="null"><x path="Bool"/></K>
		<get_K get="inline" set="null" line="22"><f a=""><x path="Bool"/></f></get_K>
		<L public="1" get="accessor" set="null"><x path="Bool"/></L>
		<get_L get="inline" set="null" line="23"><f a=""><x path="Bool"/></f></get_L>
		<M public="1" get="accessor" set="null"><x path="Bool"/></M>
		<get_M get="inline" set="null" line="24"><f a=""><x path="Bool"/></f></get_M>
		<N public="1" get="accessor" set="null"><x path="Bool"/></N>
		<get_N get="inline" set="null" line="25"><f a=""><x path="Bool"/></f></get_N>
		<O public="1" get="accessor" set="null"><x path="Bool"/></O>
		<get_O get="inline" set="null" line="26"><f a=""><x path="Bool"/></f></get_O>
		<P public="1" get="accessor" set="null"><x path="Bool"/></P>
		<get_P get="inline" set="null" line="27"><f a=""><x path="Bool"/></f></get_P>
		<Q public="1" get="accessor" set="null"><x path="Bool"/></Q>
		<get_Q get="inline" set="null" line="28"><f a=""><x path="Bool"/></f></get_Q>
		<R public="1" get="accessor" set="null"><x path="Bool"/></R>
		<get_R get="inline" set="null" line="29"><f a=""><x path="Bool"/></f></get_R>
		<S public="1" get="accessor" set="null"><x path="Bool"/></S>
		<get_S get="inline" set="null" line="30"><f a=""><x path="Bool"/></f></get_S>
		<T public="1" get="accessor" set="null"><x path="Bool"/></T>
		<get_T get="inline" set="null" line="31"><f a=""><x path="Bool"/></f></get_T>
		<U public="1" get="accessor" set="null"><x path="Bool"/></U>
		<get_U get="inline" set="null" line="32"><f a=""><x path="Bool"/></f></get_U>
		<V public="1" get="accessor" set="null"><x path="Bool"/></V>
		<get_V get="inline" set="null" line="33"><f a=""><x path="Bool"/></f></get_V>
		<W public="1" get="accessor" set="null"><x path="Bool"/></W>
		<get_W get="inline" set="null" line="34"><f a=""><x path="Bool"/></f></get_W>
		<X public="1" get="accessor" set="null"><x path="Bool"/></X>
		<get_X get="inline" set="null" line="35"><f a=""><x path="Bool"/></f></get_X>
		<Y public="1" get="accessor" set="null"><x path="Bool"/></Y>
		<get_Y get="inline" set="null" line="36"><f a=""><x path="Bool"/></f></get_Y>
		<Z public="1" get="accessor" set="null"><x path="Bool"/></Z>
		<get_Z get="inline" set="null" line="37"><f a=""><x path="Bool"/></f></get_Z>
		<ZERO public="1" get="accessor" set="null"><x path="Bool"/></ZERO>
		<get_ZERO get="inline" set="null" line="38"><f a=""><x path="Bool"/></f></get_ZERO>
		<ONE public="1" get="accessor" set="null"><x path="Bool"/></ONE>
		<get_ONE get="inline" set="null" line="39"><f a=""><x path="Bool"/></f></get_ONE>
		<TWO public="1" get="accessor" set="null"><x path="Bool"/></TWO>
		<get_TWO get="inline" set="null" line="40"><f a=""><x path="Bool"/></f></get_TWO>
		<THREE public="1" get="accessor" set="null"><x path="Bool"/></THREE>
		<get_THREE get="inline" set="null" line="41"><f a=""><x path="Bool"/></f></get_THREE>
		<FOUR public="1" get="accessor" set="null"><x path="Bool"/></FOUR>
		<get_FOUR get="inline" set="null" line="42"><f a=""><x path="Bool"/></f></get_FOUR>
		<FIVE public="1" get="accessor" set="null"><x path="Bool"/></FIVE>
		<get_FIVE get="inline" set="null" line="43"><f a=""><x path="Bool"/></f></get_FIVE>
		<SIX public="1" get="accessor" set="null"><x path="Bool"/></SIX>
		<get_SIX get="inline" set="null" line="44"><f a=""><x path="Bool"/></f></get_SIX>
		<SEVEN public="1" get="accessor" set="null"><x path="Bool"/></SEVEN>
		<get_SEVEN get="inline" set="null" line="45"><f a=""><x path="Bool"/></f></get_SEVEN>
		<EIGHT public="1" get="accessor" set="null"><x path="Bool"/></EIGHT>
		<get_EIGHT get="inline" set="null" line="46"><f a=""><x path="Bool"/></f></get_EIGHT>
		<NINE public="1" get="accessor" set="null"><x path="Bool"/></NINE>
		<get_NINE get="inline" set="null" line="47"><f a=""><x path="Bool"/></f></get_NINE>
		<PAGEUP public="1" get="accessor" set="null"><x path="Bool"/></PAGEUP>
		<get_PAGEUP get="inline" set="null" line="48"><f a=""><x path="Bool"/></f></get_PAGEUP>
		<PAGEDOWN public="1" get="accessor" set="null"><x path="Bool"/></PAGEDOWN>
		<get_PAGEDOWN get="inline" set="null" line="49"><f a=""><x path="Bool"/></f></get_PAGEDOWN>
		<HOME public="1" get="accessor" set="null"><x path="Bool"/></HOME>
		<get_HOME get="inline" set="null" line="50"><f a=""><x path="Bool"/></f></get_HOME>
		<END public="1" get="accessor" set="null"><x path="Bool"/></END>
		<get_END get="inline" set="null" line="51"><f a=""><x path="Bool"/></f></get_END>
		<INSERT public="1" get="accessor" set="null"><x path="Bool"/></INSERT>
		<get_INSERT get="inline" set="null" line="52"><f a=""><x path="Bool"/></f></get_INSERT>
		<ESCAPE public="1" get="accessor" set="null"><x path="Bool"/></ESCAPE>
		<get_ESCAPE get="inline" set="null" line="53"><f a=""><x path="Bool"/></f></get_ESCAPE>
		<MINUS public="1" get="accessor" set="null"><x path="Bool"/></MINUS>
		<get_MINUS get="inline" set="null" line="54"><f a=""><x path="Bool"/></f></get_MINUS>
		<PLUS public="1" get="accessor" set="null"><x path="Bool"/></PLUS>
		<get_PLUS get="inline" set="null" line="55"><f a=""><x path="Bool"/></f></get_PLUS>
		<DELETE public="1" get="accessor" set="null"><x path="Bool"/></DELETE>
		<get_DELETE get="inline" set="null" line="56"><f a=""><x path="Bool"/></f></get_DELETE>
		<BACKSPACE public="1" get="accessor" set="null"><x path="Bool"/></BACKSPACE>
		<get_BACKSPACE get="inline" set="null" line="57"><f a=""><x path="Bool"/></f></get_BACKSPACE>
		<LBRACKET public="1" get="accessor" set="null"><x path="Bool"/></LBRACKET>
		<get_LBRACKET get="inline" set="null" line="58"><f a=""><x path="Bool"/></f></get_LBRACKET>
		<RBRACKET public="1" get="accessor" set="null"><x path="Bool"/></RBRACKET>
		<get_RBRACKET get="inline" set="null" line="59"><f a=""><x path="Bool"/></f></get_RBRACKET>
		<BACKSLASH public="1" get="accessor" set="null"><x path="Bool"/></BACKSLASH>
		<get_BACKSLASH get="inline" set="null" line="60"><f a=""><x path="Bool"/></f></get_BACKSLASH>
		<CAPSLOCK public="1" get="accessor" set="null"><x path="Bool"/></CAPSLOCK>
		<get_CAPSLOCK get="inline" set="null" line="61"><f a=""><x path="Bool"/></f></get_CAPSLOCK>
		<SEMICOLON public="1" get="accessor" set="null"><x path="Bool"/></SEMICOLON>
		<get_SEMICOLON get="inline" set="null" line="62"><f a=""><x path="Bool"/></f></get_SEMICOLON>
		<QUOTE public="1" get="accessor" set="null"><x path="Bool"/></QUOTE>
		<get_QUOTE get="inline" set="null" line="63"><f a=""><x path="Bool"/></f></get_QUOTE>
		<ENTER public="1" get="accessor" set="null"><x path="Bool"/></ENTER>
		<get_ENTER get="inline" set="null" line="64"><f a=""><x path="Bool"/></f></get_ENTER>
		<SHIFT public="1" get="accessor" set="null"><x path="Bool"/></SHIFT>
		<get_SHIFT get="inline" set="null" line="65"><f a=""><x path="Bool"/></f></get_SHIFT>
		<COMMA public="1" get="accessor" set="null"><x path="Bool"/></COMMA>
		<get_COMMA get="inline" set="null" line="66"><f a=""><x path="Bool"/></f></get_COMMA>
		<PERIOD public="1" get="accessor" set="null"><x path="Bool"/></PERIOD>
		<get_PERIOD get="inline" set="null" line="67"><f a=""><x path="Bool"/></f></get_PERIOD>
		<SLASH public="1" get="accessor" set="null"><x path="Bool"/></SLASH>
		<get_SLASH get="inline" set="null" line="68"><f a=""><x path="Bool"/></f></get_SLASH>
		<GRAVEACCENT public="1" get="accessor" set="null"><x path="Bool"/></GRAVEACCENT>
		<get_GRAVEACCENT get="inline" set="null" line="69"><f a=""><x path="Bool"/></f></get_GRAVEACCENT>
		<CONTROL public="1" get="accessor" set="null"><x path="Bool"/></CONTROL>
		<get_CONTROL get="inline" set="null" line="70"><f a=""><x path="Bool"/></f></get_CONTROL>
		<ALT public="1" get="accessor" set="null"><x path="Bool"/></ALT>
		<get_ALT get="inline" set="null" line="71"><f a=""><x path="Bool"/></f></get_ALT>
		<SPACE public="1" get="accessor" set="null"><x path="Bool"/></SPACE>
		<get_SPACE get="inline" set="null" line="72"><f a=""><x path="Bool"/></f></get_SPACE>
		<UP public="1" get="accessor" set="null"><x path="Bool"/></UP>
		<get_UP get="inline" set="null" line="73"><f a=""><x path="Bool"/></f></get_UP>
		<DOWN public="1" get="accessor" set="null"><x path="Bool"/></DOWN>
		<get_DOWN get="inline" set="null" line="74"><f a=""><x path="Bool"/></f></get_DOWN>
		<LEFT public="1" get="accessor" set="null"><x path="Bool"/></LEFT>
		<get_LEFT get="inline" set="null" line="75"><f a=""><x path="Bool"/></f></get_LEFT>
		<RIGHT public="1" get="accessor" set="null"><x path="Bool"/></RIGHT>
		<get_RIGHT get="inline" set="null" line="76"><f a=""><x path="Bool"/></f></get_RIGHT>
		<TAB public="1" get="accessor" set="null"><x path="Bool"/></TAB>
		<get_TAB get="inline" set="null" line="77"><f a=""><x path="Bool"/></f></get_TAB>
		<PRINTSCREEN public="1" get="accessor" set="null"><x path="Bool"/></PRINTSCREEN>
		<get_PRINTSCREEN get="inline" set="null" line="78"><f a=""><x path="Bool"/></f></get_PRINTSCREEN>
		<F1 public="1" get="accessor" set="null"><x path="Bool"/></F1>
		<get_F1 get="inline" set="null" line="79"><f a=""><x path="Bool"/></f></get_F1>
		<F2 public="1" get="accessor" set="null"><x path="Bool"/></F2>
		<get_F2 get="inline" set="null" line="80"><f a=""><x path="Bool"/></f></get_F2>
		<F3 public="1" get="accessor" set="null"><x path="Bool"/></F3>
		<get_F3 get="inline" set="null" line="81"><f a=""><x path="Bool"/></f></get_F3>
		<F4 public="1" get="accessor" set="null"><x path="Bool"/></F4>
		<get_F4 get="inline" set="null" line="82"><f a=""><x path="Bool"/></f></get_F4>
		<F5 public="1" get="accessor" set="null"><x path="Bool"/></F5>
		<get_F5 get="inline" set="null" line="83"><f a=""><x path="Bool"/></f></get_F5>
		<F6 public="1" get="accessor" set="null"><x path="Bool"/></F6>
		<get_F6 get="inline" set="null" line="84"><f a=""><x path="Bool"/></f></get_F6>
		<F7 public="1" get="accessor" set="null"><x path="Bool"/></F7>
		<get_F7 get="inline" set="null" line="85"><f a=""><x path="Bool"/></f></get_F7>
		<F8 public="1" get="accessor" set="null"><x path="Bool"/></F8>
		<get_F8 get="inline" set="null" line="86"><f a=""><x path="Bool"/></f></get_F8>
		<F9 public="1" get="accessor" set="null"><x path="Bool"/></F9>
		<get_F9 get="inline" set="null" line="87"><f a=""><x path="Bool"/></f></get_F9>
		<F10 public="1" get="accessor" set="null"><x path="Bool"/></F10>
		<get_F10 get="inline" set="null" line="88"><f a=""><x path="Bool"/></f></get_F10>
		<F11 public="1" get="accessor" set="null"><x path="Bool"/></F11>
		<get_F11 get="inline" set="null" line="89"><f a=""><x path="Bool"/></f></get_F11>
		<F12 public="1" get="accessor" set="null"><x path="Bool"/></F12>
		<get_F12 get="inline" set="null" line="90"><f a=""><x path="Bool"/></f></get_F12>
		<NUMPADONE public="1" get="accessor" set="null"><x path="Bool"/></NUMPADONE>
		<get_NUMPADONE get="inline" set="null" line="91"><f a=""><x path="Bool"/></f></get_NUMPADONE>
		<NUMPADTWO public="1" get="accessor" set="null"><x path="Bool"/></NUMPADTWO>
		<get_NUMPADTWO get="inline" set="null" line="92"><f a=""><x path="Bool"/></f></get_NUMPADTWO>
		<NUMPADTHREE public="1" get="accessor" set="null"><x path="Bool"/></NUMPADTHREE>
		<get_NUMPADTHREE get="inline" set="null" line="93"><f a=""><x path="Bool"/></f></get_NUMPADTHREE>
		<NUMPADFOUR public="1" get="accessor" set="null"><x path="Bool"/></NUMPADFOUR>
		<get_NUMPADFOUR get="inline" set="null" line="94"><f a=""><x path="Bool"/></f></get_NUMPADFOUR>
		<NUMPADFIVE public="1" get="accessor" set="null"><x path="Bool"/></NUMPADFIVE>
		<get_NUMPADFIVE get="inline" set="null" line="95"><f a=""><x path="Bool"/></f></get_NUMPADFIVE>
		<NUMPADSIX public="1" get="accessor" set="null"><x path="Bool"/></NUMPADSIX>
		<get_NUMPADSIX get="inline" set="null" line="96"><f a=""><x path="Bool"/></f></get_NUMPADSIX>
		<NUMPADSEVEN public="1" get="accessor" set="null"><x path="Bool"/></NUMPADSEVEN>
		<get_NUMPADSEVEN get="inline" set="null" line="97"><f a=""><x path="Bool"/></f></get_NUMPADSEVEN>
		<NUMPADEIGHT public="1" get="accessor" set="null"><x path="Bool"/></NUMPADEIGHT>
		<get_NUMPADEIGHT get="inline" set="null" line="98"><f a=""><x path="Bool"/></f></get_NUMPADEIGHT>
		<NUMPADNINE public="1" get="accessor" set="null"><x path="Bool"/></NUMPADNINE>
		<get_NUMPADNINE get="inline" set="null" line="99"><f a=""><x path="Bool"/></f></get_NUMPADNINE>
		<NUMPADZERO public="1" get="accessor" set="null"><x path="Bool"/></NUMPADZERO>
		<get_NUMPADZERO get="inline" set="null" line="100"><f a=""><x path="Bool"/></f></get_NUMPADZERO>
		<NUMPADMINUS public="1" get="accessor" set="null"><x path="Bool"/></NUMPADMINUS>
		<get_NUMPADMINUS get="inline" set="null" line="101"><f a=""><x path="Bool"/></f></get_NUMPADMINUS>
		<NUMPADPLUS public="1" get="accessor" set="null"><x path="Bool"/></NUMPADPLUS>
		<get_NUMPADPLUS get="inline" set="null" line="102"><f a=""><x path="Bool"/></f></get_NUMPADPLUS>
		<NUMPADPERIOD public="1" get="accessor" set="null"><x path="Bool"/></NUMPADPERIOD>
		<get_NUMPADPERIOD get="inline" set="null" line="103"><f a=""><x path="Bool"/></f></get_NUMPADPERIOD>
		<NUMPADMULTIPLY public="1" get="accessor" set="null"><x path="Bool"/></NUMPADMULTIPLY>
		<get_NUMPADMULTIPLY get="inline" set="null" line="104"><f a=""><x path="Bool"/></f></get_NUMPADMULTIPLY>
		<new public="1" set="method" line="10"><f a="status:keyManager">
	<x path="flixel.input.FlxInputState"/>
	<c path="flixel.input.FlxKeyManager">
		<d/>
		<d/>
	</c>
	<x path="Void"/>
</f></new>
		<haxe_doc>* A helper class for keyboard input.
 * Provides optimized key checking using direct array access.</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":keep"/>
		</meta>
	</class>
	<class path="flixel.input.keyboard.FlxKeyboard" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/input/keyboard/FlxKeyboard.hx">
		<extends path="flixel.input.FlxKeyManager">
			<x path="flixel.input.keyboard.FlxKey"/>
			<c path="flixel.input.keyboard.FlxKeyList"/>
		</extends>
		<_nativeCorrection>
			<x path="Map">
				<c path="String"/>
				<x path="Int"/>
			</x>
			<haxe_doc>* Function and numpad keycodes on native targets are incorrect, 
	 * this workaround fixes that. Thanks @HaxePunk!
	 * @see https://github.com/openfl/openfl-native/issues/193</haxe_doc>
		</_nativeCorrection>
		<onKeyUp set="method" line="92" override="1"><f a="event">
	<t path="flash.events.KeyboardEvent"/>
	<x path="Void"/>
</f></onKeyUp>
		<onKeyDown set="method" line="105" override="1"><f a="event">
	<t path="flash.events.KeyboardEvent"/>
	<x path="Void"/>
</f></onKeyDown>
		<resolveKeyCode set="method" line="118" override="1"><f a="e">
	<t path="flash.events.KeyboardEvent"/>
	<x path="Int"/>
</f></resolveKeyCode>
		<record set="method" line="136">
			<f a=""><c path="Array"><c path="flixel.system.replay.CodeValuePair"/></c></f>
			<meta><m n=":allow"><e>flixel.system.replay.FlxReplay</e></m></meta>
			<haxe_doc>* If any keys are not "released",
	 * this function will return an array indicating
	 * which keys are pressed and what state they are in.
	 * 
	 * @return	An array of key state data. Null if there is no data.</haxe_doc>
		</record>
		<playback set="method" line="165">
			<f a="Record">
				<c path="Array"><c path="flixel.system.replay.CodeValuePair"/></c>
				<x path="Void"/>
			</f>
			<meta><m n=":allow"><e>flixel.system.replay.FlxReplay</e></m></meta>
			<haxe_doc>* Part of the keystroke recording system.
	 * Takes data about key presses and sets it into array.
	 * 
	 * @param	Record	Array of data about key states.</haxe_doc>
		</playback>
		<new public="1" set="method" line="23"><f a=""><x path="Void"/></f></new>
		<haxe_doc>* Keeps track of what keys are pressed and how with handy Bools or strings.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<typedef path="flixel.input.keyboard.FlxKeyInput" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/input/keyboard/FlxKeyboard.hx" module="flixel.input.keyboard.FlxKeyboard"><c path="flixel.input.FlxInput"><x path="flixel.input.keyboard.FlxKey"/></c></typedef>
	<class path="openfl.display.BitmapData" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/display/BitmapData.hx">
		<implements path="openfl.display.IBitmapDrawable"/>
		<__isGLES expr="null" line="65" static="1">
			<t path="Null"><x path="Bool"/></t>
			<meta><m n=":value"><e>null</e></m></meta>
		</__isGLES>
		<fromBase64 public="1" set="method" line="570" static="1">
			<f a="base64:type:?onload" v="::null">
				<c path="String"/>
				<c path="String"/>
				<f a="">
					<c path="openfl.display.BitmapData"/>
					<x path="Void"/>
				</f>
				<c path="openfl.display.BitmapData"/>
			</f>
			<meta><m n=":value"><e>{ onload : null }</e></m></meta>
		</fromBase64>
		<fromBytes public="1" set="method" line="579" static="1">
			<f a="bytes:?rawAlpha:?onload" v=":null:null">
				<x path="openfl.utils.ByteArray"/>
				<x path="openfl.utils.ByteArray"/>
				<f a="">
					<c path="openfl.display.BitmapData"/>
					<x path="Void"/>
				</f>
				<c path="openfl.display.BitmapData"/>
			</f>
			<meta><m n=":value"><e>{ onload : null, rawAlpha : null }</e></m></meta>
		</fromBytes>
		<fromFile public="1" set="method" line="602" static="1">
			<f a="path:?onload:?onerror" v=":null:null">
				<c path="String"/>
				<f a="">
					<c path="openfl.display.BitmapData"/>
					<x path="Void"/>
				</f>
				<f a=""><x path="Void"/></f>
				<c path="openfl.display.BitmapData"/>
			</f>
			<meta><m n=":value"><e>{ onerror : null, onload : null }</e></m></meta>
		</fromFile>
		<fromImage public="1" set="method" line="611" static="1">
			<f a="image:?transparent" v=":true">
				<c path="lime.graphics.Image"/>
				<x path="Bool"/>
				<c path="openfl.display.BitmapData"/>
			</f>
			<meta><m n=":value"><e>{ transparent : true }</e></m></meta>
		</fromImage>
		<__asRenderTexture set="method" line="1140" static="1">
			<f a="?width:?height" v="0:0">
				<x path="Int"/>
				<x path="Int"/>
				<c path="openfl.display.BitmapData"/>
			</f>
			<meta><m n=":value"><e>{ height : 0, width : 0 }</e></m></meta>
		</__asRenderTexture>
		<height public="1" set="null"><x path="Int"/></height>
		<image public="1" set="null"><c path="lime.graphics.Image"/></image>
		<rect public="1" set="null"><c path="openfl.geom.Rectangle"/></rect>
		<transparent public="1" set="null"><x path="Bool"/></transparent>
		<width public="1" set="null"><x path="Int"/></width>
		<__worldTransform public="1"><c path="openfl.geom.Matrix"/></__worldTransform>
		<__worldColorTransform public="1"><c path="openfl.geom.ColorTransform"/></__worldColorTransform>
		<__cacheAsBitmap public="1"><x path="Bool"/></__cacheAsBitmap>
		<__blendMode><x path="openfl.display.BlendMode"/></__blendMode>
		<__shader><c path="openfl.display.Shader"/></__shader>
		<__buffer><c path="lime.graphics.opengl.GLBuffer"/></__buffer>
		<__isValid><x path="Bool"/></__isValid>
		<__surface><x path="lime.graphics.cairo.CairoSurface"/></__surface>
		<__texture><c path="lime.graphics.opengl.GLTexture"/></__texture>
		<__textureImage><c path="lime.graphics.Image"/></__textureImage>
		<__pingPongTexture><c path="openfl._internal.renderer.opengl.utils.PingPongTexture"/></__pingPongTexture>
		<__usingPingPongTexture expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</__usingPingPongTexture>
		<__uvData><c path="openfl.display.TextureUvs"/></__uvData>
		<applyFilter public="1" set="method" line="152"><f a="sourceBitmapData:sourceRect:destPoint:filter">
	<c path="openfl.display.BitmapData"/>
	<c path="openfl.geom.Rectangle"/>
	<c path="openfl.geom.Point"/>
	<c path="openfl.filters.BitmapFilter"/>
	<x path="Void"/>
</f></applyFilter>
		<clone public="1" set="method" line="172"><f a=""><c path="openfl.display.BitmapData"/></f></clone>
		<colorTransform public="1" set="method" line="187"><f a="rect:colorTransform">
	<c path="openfl.geom.Rectangle"/>
	<c path="openfl.geom.ColorTransform"/>
	<x path="Void"/>
</f></colorTransform>
		<compare public="1" set="method" line="197"><f a="otherBitmapData">
	<c path="openfl.display.BitmapData"/>
	<d/>
</f></compare>
		<copyChannel public="1" set="method" line="323"><f a="sourceBitmapData:sourceRect:destPoint:sourceChannel:destChannel">
	<c path="openfl.display.BitmapData"/>
	<c path="openfl.geom.Rectangle"/>
	<c path="openfl.geom.Point"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></copyChannel>
		<copyPixels public="1" set="method" line="353">
			<f a="sourceBitmapData:sourceRect:destPoint:?alphaBitmapData:?alphaPoint:?mergeAlpha" v=":::null:null:false">
				<c path="openfl.display.BitmapData"/>
				<c path="openfl.geom.Rectangle"/>
				<c path="openfl.geom.Point"/>
				<c path="openfl.display.BitmapData"/>
				<c path="openfl.geom.Point"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ mergeAlpha : false, alphaPoint : null, alphaBitmapData : null }</e></m></meta>
		</copyPixels>
		<dispose public="1" set="method" line="363"><f a=""><x path="Void"/></f></dispose>
		<draw public="1" set="method" line="402">
			<f a="source:?matrix:?colorTransform:?blendMode:?clipRect:?smoothing" v=":null:null:null:null:false">
				<c path="openfl.display.IBitmapDrawable"/>
				<c path="openfl.geom.Matrix"/>
				<c path="openfl.geom.ColorTransform"/>
				<x path="openfl.display.BlendMode"/>
				<c path="openfl.geom.Rectangle"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ smoothing : false, clipRect : null, blendMode : null, colorTransform : null, matrix : null }</e></m></meta>
		</draw>
		<encode public="1" set="method" line="524">
			<f a="rect:compressor:?byteArray" v="::null">
				<c path="openfl.geom.Rectangle"/>
				<d/>
				<x path="openfl.utils.ByteArray"/>
				<x path="openfl.utils.ByteArray"/>
			</f>
			<meta><m n=":value"><e>{ byteArray : null }</e></m></meta>
		</encode>
		<fillRect public="1" set="method" line="545"><f a="rect:color">
	<c path="openfl.geom.Rectangle"/>
	<x path="Int"/>
	<x path="Void"/>
</f></fillRect>
		<floodFill public="1" set="method" line="561"><f a="x:y:color">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></floodFill>
		<generateFilterRect public="1" set="method" line="623"><f a="sourceRect:filter">
	<c path="openfl.geom.Rectangle"/>
	<c path="openfl.filters.BitmapFilter"/>
	<c path="openfl.geom.Rectangle"/>
</f></generateFilterRect>
		<getBuffer public="1" set="method" line="630"><f a="gl">
	<c path="lime.graphics.GLRenderContext"/>
	<c path="lime.graphics.opengl.GLBuffer"/>
</f></getBuffer>
		<getColorBoundsRect public="1" set="method" line="655">
			<f a="mask:color:?findColor" v="::true">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
				<c path="openfl.geom.Rectangle"/>
			</f>
			<meta><m n=":value"><e>{ findColor : true }</e></m></meta>
		</getColorBoundsRect>
		<getPixel public="1" set="method" line="672"><f a="x:y">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></getPixel>
		<getPixel32 public="1" set="method" line="680"><f a="x:y">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></getPixel32>
		<getPixels public="1" set="method" line="688"><f a="rect">
	<c path="openfl.geom.Rectangle"/>
	<x path="openfl.utils.ByteArray"/>
</f></getPixels>
		<getSurface public="1" set="method" line="697"><f a=""><x path="lime.graphics.cairo.CairoImageSurface"/></f></getSurface>
		<getTexture public="1" set="method" line="712"><f a="gl">
	<c path="lime.graphics.GLRenderContext"/>
	<c path="lime.graphics.opengl.GLTexture"/>
</f></getTexture>
		<getVector public="1" set="method" line="802"><f a="rect">
	<c path="openfl.geom.Rectangle"/>
	<x path="openfl.Vector"><x path="UInt"/></x>
</f></getVector>
		<histogram public="1" set="method" line="819">
			<f a="?hRect" v="null">
				<c path="openfl.geom.Rectangle"/>
				<c path="Array"><c path="Array"><x path="Int"/></c></c>
			</f>
			<meta><m n=":value"><e>{ hRect : null }</e></m></meta>
		</histogram>
		<hitTest public="1" set="method" line="836">
			<f a="firstPoint:firstAlphaThreshold:secondObject:?secondBitmapDataPoint:?secondAlphaThreshold" v=":::null:1">
				<c path="openfl.geom.Point"/>
				<x path="Int"/>
				<d/>
				<c path="openfl.geom.Point"/>
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":value"><e>{ secondAlphaThreshold : 1, secondBitmapDataPoint : null }</e></m></meta>
		</hitTest>
		<lock public="1" set="method" line="946"><f a=""><x path="Void"/></f></lock>
		<merge public="1" set="method" line="953"><f a="sourceBitmapData:sourceRect:destPoint:redMultiplier:greenMultiplier:blueMultiplier:alphaMultiplier">
	<c path="openfl.display.BitmapData"/>
	<c path="openfl.geom.Rectangle"/>
	<c path="openfl.geom.Point"/>
	<x path="UInt"/>
	<x path="UInt"/>
	<x path="UInt"/>
	<x path="UInt"/>
	<x path="Void"/>
</f></merge>
		<noise public="1" set="method" line="962">
			<f a="randomSeed:?low:?high:?channelOptions:?grayScale" v=":0:255:7:false">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ grayScale : false, channelOptions : 7, high : 255, low : 0 }</e></m></meta>
		</noise>
		<paletteMap public="1" set="method" line="1019">
			<f a="sourceBitmapData:sourceRect:destPoint:?redArray:?greenArray:?blueArray:?alphaArray" v=":::null:null:null:null">
				<c path="openfl.display.BitmapData"/>
				<c path="openfl.geom.Rectangle"/>
				<c path="openfl.geom.Point"/>
				<c path="Array"><x path="Int"/></c>
				<c path="Array"><x path="Int"/></c>
				<c path="Array"><x path="Int"/></c>
				<c path="Array"><x path="Int"/></c>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ alphaArray : null, blueArray : null, greenArray : null, redArray : null }</e></m></meta>
		</paletteMap>
		<perlinNoise public="1" set="method" line="1064">
			<f a="baseX:baseY:numOctaves:randomSeed:stitch:fractalNoise:?channelOptions:?grayScale:?offsets" v="::::::7:false:null">
				<x path="Float"/>
				<x path="Float"/>
				<x path="UInt"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="UInt"/>
				<x path="Bool"/>
				<c path="Array"><c path="openfl.geom.Point"/></c>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ offsets : null, grayScale : false, channelOptions : 7 }</e></m></meta>
		</perlinNoise>
		<scroll public="1" set="method" line="1071"><f a="x:y">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></scroll>
		<setPixel public="1" set="method" line="1080"><f a="x:y:color">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></setPixel>
		<setPixel32 public="1" set="method" line="1089"><f a="x:y:color">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></setPixel32>
		<setPixels public="1" set="method" line="1098"><f a="rect:byteArray">
	<c path="openfl.geom.Rectangle"/>
	<x path="openfl.utils.ByteArray"/>
	<x path="Void"/>
</f></setPixels>
		<setVector public="1" set="method" line="1107"><f a="rect:inputVector">
	<c path="openfl.geom.Rectangle"/>
	<x path="openfl.Vector"><x path="UInt"/></x>
	<x path="Void"/>
</f></setVector>
		<threshold public="1" set="method" line="1124">
			<f a="sourceBitmapData:sourceRect:destPoint:operation:threshold:?color:?mask:?copySource" v=":::::0x00000000:0xFFFFFFFF:false">
				<c path="openfl.display.BitmapData"/>
				<c path="openfl.geom.Rectangle"/>
				<c path="openfl.geom.Point"/>
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Int"/>
			</f>
			<meta><m n=":value"><e>{ copySource : false, mask : 0xFFFFFFFF, color : 0x00000000 }</e></m></meta>
		</threshold>
		<unlock public="1" set="method" line="1133">
			<f a="?changeRect" v="null">
				<c path="openfl.geom.Rectangle"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ changeRect : null }</e></m></meta>
		</unlock>
		<__createUVs set="method" line="1149">
			<f a="?x0:?y0:?x1:?y1:?x2:?y2:?x3:?y3" v="0:0:1:0:1:1:0:1">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ y3 : 1, x3 : 0, y2 : 1, x2 : 1, y1 : 0, x1 : 1, y0 : 0, x0 : 0 }</e></m></meta>
		</__createUVs>
		<__drawGL set="method" line="1165">
			<f a="renderSession:source:?matrix:?colorTransform:?blendMode:?clipRect:?smoothing:?drawSelf:?clearBuffer:?readPixels:?powerOfTwo" v="::null:null:null:null:false:false:false:false:true">
				<c path="openfl._internal.renderer.RenderSession"/>
				<c path="openfl.display.IBitmapDrawable"/>
				<c path="openfl.geom.Matrix"/>
				<c path="openfl.geom.ColorTransform"/>
				<x path="openfl.display.BlendMode"/>
				<c path="openfl.geom.Rectangle"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ powerOfTwo : true, readPixels : false, clearBuffer : false, drawSelf : false, smoothing : false, clipRect : null, blendMode : null, colorTransform : null, matrix : null }</e></m></meta>
		</__drawGL>
		<__fromBase64 get="inline" set="null" line="1180"><f a="base64:type:?onload">
	<c path="String"/>
	<c path="String"/>
	<f a="">
		<c path="openfl.display.BitmapData"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></__fromBase64>
		<__fromBytes get="inline" set="null" line="1197">
			<f a="bytes:?rawAlpha:?onload" v=":null:">
				<x path="openfl.utils.ByteArray"/>
				<x path="openfl.utils.ByteArray"/>
				<f a="">
					<c path="openfl.display.BitmapData"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ rawAlpha : null }</e></m></meta>
		</__fromBytes>
		<__fromFile set="method" line="1233"><f a="path:onload:onerror">
	<c path="String"/>
	<f a="">
		<c path="openfl.display.BitmapData"/>
		<x path="Void"/>
	</f>
	<f a=""><x path="Void"/></f>
	<x path="Void"/>
</f></__fromFile>
		<__fromImage set="method" line="1250"><f a="image">
	<c path="lime.graphics.Image"/>
	<x path="Void"/>
</f></__fromImage>
		<__renderCairo public="1" set="method" line="1272"><f a="renderSession">
	<c path="openfl._internal.renderer.RenderSession"/>
	<x path="Void"/>
</f></__renderCairo>
		<__renderCairoMask public="1" set="method" line="1322"><f a="renderSession">
	<c path="openfl._internal.renderer.RenderSession"/>
	<x path="Void"/>
</f></__renderCairoMask>
		<__renderCanvas public="1" set="method" line="1329"><f a="renderSession">
	<c path="openfl._internal.renderer.RenderSession"/>
	<x path="Void"/>
</f></__renderCanvas>
		<__renderCanvasMask public="1" set="method" line="1359"><f a="renderSession">
	<c path="openfl._internal.renderer.RenderSession"/>
	<x path="Void"/>
</f></__renderCanvasMask>
		<__renderGL public="1" set="method" line="1366"><f a="renderSession">
	<c path="openfl._internal.renderer.RenderSession"/>
	<x path="Void"/>
</f></__renderGL>
		<__resize set="method" line="1373"><f a="width:height">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></__resize>
		<__sync set="method" line="1383"><f a=""><x path="Void"/></f></__sync>
		<__updateChildren public="1" set="method" line="1392"><f a="transformOnly">
	<x path="Bool"/>
	<x path="Void"/>
</f></__updateChildren>
		<__updateMask public="1" set="method" line="1399"><f a="maskGraphics">
	<c path="openfl.display.Graphics"/>
	<x path="Void"/>
</f></__updateMask>
		<__updateTransforms public="1" set="method" line="1406">
			<f a="?overrideTransform" v="null">
				<c path="openfl.geom.Matrix"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ overrideTransform : null }</e></m></meta>
		</__updateTransforms>
		<new public="1" set="method" line="89">
			<f a="width:height:?transparent:?fillColor" v="::true:0xFFFFFFFF">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="UInt"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ fillColor : 0xFFFFFFFF, transparent : true }</e></m></meta>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":access"><e>lime.graphics.Image</e></m>
			<m n=":access"><e>lime.graphics.ImageBuffer</e></m>
			<m n=":access"><e>lime.math.Rectangle</e></m>
			<m n=":access"><e>openfl.display.DisplayObject</e></m>
			<m n=":access"><e>openfl.display.Graphics</e></m>
			<m n=":access"><e>openfl.geom.ColorTransform</e></m>
			<m n=":access"><e>openfl.geom.Matrix</e></m>
			<m n=":access"><e>openfl.geom.Point</e></m>
			<m n=":access"><e>openfl.geom.Rectangle</e></m>
			<m n=":autoBuild"><e>openfl.Assets.embedBitmap()</e></m>
		</meta>
	</class>
	<class path="flixel.input.mouse._FlxMouse.GraphicCursor" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/input/mouse/FlxMouse.hx" private="1" module="flixel.input.mouse.FlxMouse">
		<extends path="openfl.display.BitmapData"/>
		<resourceName expr="&quot;__ASSET__:bitmap_flixel_input_mouse__FlxMouse_GraphicCursor&quot;" line="1" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"__ASSET__:bitmap_flixel_input_mouse__FlxMouse_GraphicCursor"</e></m></meta>
		</resourceName>
		<new public="1" set="method" line="1">
			<f a="width:height:?transparent:?fillRGBA" v="::true:0xFFFFFFFF">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ fillRGBA : 0xFFFFFFFF, transparent : true }</e></m></meta>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>openfl.Assets.embedBitmap()</e></m>
			<m n=":autoBuild"><e>openfl.Assets.embedBitmap()</e></m>
			<m n=":bitmap"><e>"assets/images/ui/cursor.png"</e></m>
		</meta>
	</class>
	<class path="flixel.input.mouse.FlxMouse" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/input/mouse/FlxMouse.hx">
		<extends path="flixel.input.FlxPointer"/>
		<implements path="flixel.input.IFlxInputManager"/>
		<enabled public="1" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
			<haxe_doc>* Whether or not mouse input is currently enabled.
	 * @since 4.1.0</haxe_doc>
		</enabled>
		<wheel public="1" set="null" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* Current "delta" value of mouse wheel. If the wheel was just scrolled up, 
	 * it will have a positive value and vice versa. Otherwise the value will be 0.</haxe_doc>
		</wheel>
		<cursorContainer public="1" set="null">
			<t path="flash.display.Sprite"/>
			<haxe_doc>* A display container for the mouse cursor. It is a child of FlxGame and 
	 * sits at the right "height". Not used on flash with the native cursor API.</haxe_doc>
		</cursorContainer>
		<visible public="1" set="accessor" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
			<haxe_doc>* Used to toggle the visiblity of the mouse cursor - works on both 
	 * the flixel and the system cursor, depending on which one is active.</haxe_doc>
		</visible>
		<useSystemCursor public="1" set="accessor" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
			<haxe_doc>* Tells flixel to use the default system mouse cursor instead of custom Flixel mouse cursors.</haxe_doc>
		</useSystemCursor>
		<pressed public="1" get="accessor" set="null">
			<x path="Bool"/>
			<haxe_doc>* Check to see if the left mouse button is currently pressed.</haxe_doc>
		</pressed>
		<justPressed public="1" get="accessor" set="null">
			<x path="Bool"/>
			<haxe_doc>* Check to see if the left mouse button has just been pressed.</haxe_doc>
		</justPressed>
		<justReleased public="1" get="accessor" set="null">
			<x path="Bool"/>
			<haxe_doc>* Check to see if the left mouse button has just been released.</haxe_doc>
		</justReleased>
		<justPressedTimeInTicks public="1" get="accessor" set="null">
			<x path="Int"/>
			<haxe_doc>* Time in ticks of last left mouse button press.
	 * @since 4.3.0</haxe_doc>
		</justPressedTimeInTicks>
		<pressedRight public="1" get="accessor" set="null">
			<x path="Bool"/>
			<haxe_doc>* Check to see if the right mouse button is currently pressed.</haxe_doc>
		</pressedRight>
		<justPressedRight public="1" get="accessor" set="null">
			<x path="Bool"/>
			<haxe_doc>* Check to see if the right mouse button has just been pressed.</haxe_doc>
		</justPressedRight>
		<justReleasedRight public="1" get="accessor" set="null">
			<x path="Bool"/>
			<haxe_doc>* Check to see if the right mouse button has just been released.</haxe_doc>
		</justReleasedRight>
		<justPressedTimeInTicksRight public="1" get="accessor" set="null">
			<x path="Int"/>
			<haxe_doc>* Time in ticks of last right mouse button press.
	 * @since 4.3.0</haxe_doc>
		</justPressedTimeInTicksRight>
		<pressedMiddle public="1" get="accessor" set="null">
			<x path="Bool"/>
			<haxe_doc>* Check to see if the middle mouse button is currently pressed.</haxe_doc>
		</pressedMiddle>
		<justPressedMiddle public="1" get="accessor" set="null">
			<x path="Bool"/>
			<haxe_doc>* Check to see if the middle mouse button has just been pressed.</haxe_doc>
		</justPressedMiddle>
		<justReleasedMiddle public="1" get="accessor" set="null">
			<x path="Bool"/>
			<haxe_doc>* Check to see if the middle mouse button has just been released.</haxe_doc>
		</justReleasedMiddle>
		<justPressedTimeInTicksMiddle public="1" get="accessor" set="null">
			<x path="Int"/>
			<haxe_doc>* Time in ticks of last middle mouse button press.
	 * @since 4.3.0</haxe_doc>
		</justPressedTimeInTicksMiddle>
		<_leftButton>
			<c path="flixel.input.mouse.FlxMouseButton"/>
			<meta><m n=":allow"><e>flixel.input.mouse.FlxMouseButton</e></m></meta>
			<haxe_doc>* The left mouse button.</haxe_doc>
		</_leftButton>
		<_middleButton>
			<c path="flixel.input.mouse.FlxMouseButton"/>
			<meta><m n=":allow"><e>flixel.input.mouse.FlxMouseButton</e></m></meta>
			<haxe_doc>* The middle mouse button.</haxe_doc>
		</_middleButton>
		<_rightButton>
			<c path="flixel.input.mouse.FlxMouseButton"/>
			<meta><m n=":allow"><e>flixel.input.mouse.FlxMouseButton</e></m></meta>
			<haxe_doc>* The right mouse button.</haxe_doc>
		</_rightButton>
		<_cursor expr="null">
			<t path="flash.display.Bitmap"/>
			<meta><m n=":value"><e>null</e></m></meta>
			<haxe_doc>* This is just a reference to the current cursor image, if there is one.</haxe_doc>
		</_cursor>
		<_cursorBitmapData><t path="flash.display.BitmapData"/></_cursorBitmapData>
		<_wheelUsed expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</_wheelUsed>
		<_visibleWhenFocusLost expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</_visibleWhenFocusLost>
		<_lastX expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* Helper variables for recording purposes.</haxe_doc>
		</_lastX>
		<_lastY expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</_lastY>
		<_lastWheel expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</_lastWheel>
		<_lastLeftButtonState><x path="flixel.input.FlxInputState"/></_lastLeftButtonState>
		<_stage><t path="flash.display.Stage"/></_stage>
		<load public="1" set="method" line="175">
			<f a="?Graphic:?Scale:?XOffset:?YOffset" v=":1:0:0">
				<d/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ YOffset : 0, XOffset : 0, Scale : 1 }</e></m></meta>
			<haxe_doc>* Helper variables for flash native cursors</haxe_doc>
		</load>
		<unload public="1" set="method" line="246">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Unload the current cursor graphic. If the current cursor is visible,
	 * then the default system cursor is loaded up to replace the old one.</haxe_doc>
		</unload>
		<destroy public="1" set="method" line="334">
			<f a=""><x path="Void"/></f>
			<meta>
				<m n=":has_untyped"/>
				<m n=":noCompletion"/>
			</meta>
			<haxe_doc>* Clean up memory. Internal use only.</haxe_doc>
		</destroy>
		<reset public="1" set="method" line="373">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Resets the just pressed/just released flags and sets mouse to not pressed.</haxe_doc>
		</reset>
		<update set="method" line="422">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Called by the internal game loop to update the mouse pointer's position in the game world.
	 * Also updates the just pressed/just released flags.</haxe_doc>
		</update>
		<onFocus set="method" line="453">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Called from the main Event.ACTIVATE that is dispatched in FlxGame</haxe_doc>
		</onFocus>
		<onFocusLost set="method" line="467">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Called from the main Event.DEACTIVATE that is dispatched in FlxGame</haxe_doc>
		</onFocusLost>
		<onGameStart set="method" line="481"><f a=""><x path="Void"/></f></onGameStart>
		<onMouseWheel set="method" line="491">
			<f a="FlashEvent">
				<t path="flash.events.MouseEvent"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Internal event handler for input and focus.</haxe_doc>
		</onMouseWheel>
		<onMouseLeave get="inline" set="null" line="505">
			<f a="_">
				<unknown/>
				<x path="Void"/>
			</f>
			<haxe_doc>* We're detecting the mouse leave event to prevent a bug where `pressed` remains true 
	 * for the middle and right mouse button when pressed and dragged outside the window.</haxe_doc>
		</onMouseLeave>
		<get_pressed get="inline" set="null" line="512"><f a=""><x path="Bool"/></f></get_pressed>
		<get_justPressed get="inline" set="null" line="513"><f a=""><x path="Bool"/></f></get_justPressed>
		<get_justReleased get="inline" set="null" line="514"><f a=""><x path="Bool"/></f></get_justReleased>
		<get_justPressedTimeInTicks get="inline" set="null" line="515"><f a=""><x path="Int"/></f></get_justPressedTimeInTicks>
		<get_pressedRight get="inline" set="null" line="518"><f a=""><x path="Bool"/></f></get_pressedRight>
		<get_justPressedRight get="inline" set="null" line="519"><f a=""><x path="Bool"/></f></get_justPressedRight>
		<get_justReleasedRight get="inline" set="null" line="520"><f a=""><x path="Bool"/></f></get_justReleasedRight>
		<get_justPressedTimeInTicksRight get="inline" set="null" line="521"><f a=""><x path="Int"/></f></get_justPressedTimeInTicksRight>
		<get_pressedMiddle get="inline" set="null" line="523"><f a=""><x path="Bool"/></f></get_pressedMiddle>
		<get_justPressedMiddle get="inline" set="null" line="524"><f a=""><x path="Bool"/></f></get_justPressedMiddle>
		<get_justReleasedMiddle get="inline" set="null" line="525"><f a=""><x path="Bool"/></f></get_justReleasedMiddle>
		<get_justPressedTimeInTicksMiddle get="inline" set="null" line="526"><f a=""><x path="Int"/></f></get_justPressedTimeInTicksMiddle>
		<showSystemCursor set="method" line="529"><f a=""><x path="Void"/></f></showSystemCursor>
		<hideSystemCursor set="method" line="540"><f a=""><x path="Void"/></f></hideSystemCursor>
		<set_useSystemCursor set="method" line="557"><f a="Value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_useSystemCursor>
		<showCursor set="method" line="570"><f a=""><x path="Void"/></f></showCursor>
		<hideCursor set="method" line="590"><f a=""><x path="Void"/></f></hideCursor>
		<set_visible set="method" line="596"><f a="Value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_visible>
		<record set="method" line="607">
			<f a=""><c path="flixel.system.replay.MouseRecord"/></f>
			<meta><m n=":allow"><e>flixel.system.replay.FlxReplay</e></m></meta>
		</record>
		<playback set="method" line="623">
			<f a="Record">
				<c path="flixel.system.replay.MouseRecord"/>
				<x path="Void"/>
			</f>
			<meta><m n=":allow"><e>flixel.system.replay.FlxReplay</e></m></meta>
		</playback>
		<new set="method" line="387">
			<f a="CursorContainer">
				<t path="flash.display.Sprite"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":has_untyped"/>
				<m n=":allow"><e>flixel.FlxG</e></m>
			</meta>
			<haxe_doc>* @param   CursorContainer   The cursor container sprite passed by FlxGame</haxe_doc>
		</new>
		<haxe_doc>* This class helps contain and track the mouse pointer in your game.
 * Automatically accounts for parallax scrolling, etc.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="flixel.input.mouse.FlxMouseButton" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/input/mouse/FlxMouseButton.hx">
		<extends path="flixel.input.FlxInput"><x path="Int"/></extends>
		<implements path="flixel.util.IFlxDestroyable"/>
		<getByID public="1" set="method" line="11" static="1"><f a="id">
	<x path="flixel.input.mouse.FlxMouseButtonID"/>
	<c path="flixel.input.mouse.FlxMouseButton"/>
</f></getByID>
		<justPressedPosition public="1" set="null" expr="FlxPoint.get()">
			<c path="flixel.math.FlxPoint"/>
			<meta><m n=":value"><e>FlxPoint.get()</e></m></meta>
		</justPressedPosition>
		<justPressedTimeInTicks public="1" set="null" expr="-1">
			<x path="Int"/>
			<meta><m n=":value"><e>-1</e></m></meta>
		</justPressedTimeInTicks>
		<update public="1" set="method" line="31" override="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Updates the last and current state of this mouse button.</haxe_doc>
		</update>
		<destroy public="1" get="inline" set="null" line="48"><f a=""><x path="Void"/></f></destroy>
		<onDown public="1" set="method" line="53"><f a="_">
	<unknown/>
	<x path="Void"/>
</f></onDown>
		<onUp public="1" set="method" line="74"><f a="?_">
	<unknown/>
	<x path="Void"/>
</f></onUp>
		<new public="1" set="method" line="9"><f a="ID">
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<abstract path="flixel.input.mouse.FlxMouseButtonID" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/input/mouse/FlxMouseButton.hx" module="flixel.input.mouse.FlxMouseButton">
		<this><x path="Int"/></this>
		<to><icast><x path="Int"/></icast></to>
		<haxe_doc>* These IDs are negative to avoid overlaps with possible touch point IDs.</haxe_doc>
		<meta><m n=":enum"/></meta>
		<impl><class path="flixel.input.mouse._FlxMouseButton.FlxMouseButtonID_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/input/mouse/FlxMouseButton.hx" private="1" module="flixel.input.mouse.FlxMouseButton" extern="1">
	<LEFT public="1" get="inline" set="null" expr="cast -1" line="88" static="1">
		<x path="flixel.input.mouse.FlxMouseButtonID"/>
		<meta>
			<m n=":value"><e>cast -1</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</LEFT>
	<MIDDLE public="1" get="inline" set="null" expr="cast -2" line="89" static="1">
		<x path="flixel.input.mouse.FlxMouseButtonID"/>
		<meta>
			<m n=":value"><e>cast -2</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</MIDDLE>
	<RIGHT public="1" get="inline" set="null" expr="cast -3" line="90" static="1">
		<x path="flixel.input.mouse.FlxMouseButtonID"/>
		<meta>
			<m n=":value"><e>cast -3</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</RIGHT>
	<meta>
		<m n=":final"/>
		<m n=":enum"/>
	</meta>
</class></impl>
	</abstract>
	<class path="flixel.input.mouse._FlxMouseButton.FlxMouseButtonID_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/input/mouse/FlxMouseButton.hx" private="1" module="flixel.input.mouse.FlxMouseButton" extern="1">
		<LEFT public="1" get="inline" set="null" expr="cast -1" line="88" static="1">
			<x path="flixel.input.mouse.FlxMouseButtonID"/>
			<meta>
				<m n=":value"><e>cast -1</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</LEFT>
		<MIDDLE public="1" get="inline" set="null" expr="cast -2" line="89" static="1">
			<x path="flixel.input.mouse.FlxMouseButtonID"/>
			<meta>
				<m n=":value"><e>cast -2</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</MIDDLE>
		<RIGHT public="1" get="inline" set="null" expr="cast -3" line="90" static="1">
			<x path="flixel.input.mouse.FlxMouseButtonID"/>
			<meta>
				<m n=":value"><e>cast -3</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</RIGHT>
		<meta>
			<m n=":final"/>
			<m n=":enum"/>
		</meta>
	</class>
	<class path="flixel.input.mouse.FlxMouseEventManager" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/input/mouse/FlxMouseEventManager.hx">
		<extends path="flixel.FlxBasic"/>
		<_registeredObjects expr="[]" line="37" static="1">
			<c path="Array"><c path="flixel.input.mouse._FlxMouseEventManager.ObjectMouseData"><c path="flixel.FlxObject"/></c></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</_registeredObjects>
		<_mouseOverObjects expr="[]" line="38" static="1">
			<c path="Array"><c path="flixel.input.mouse._FlxMouseEventManager.ObjectMouseData"><c path="flixel.FlxObject"/></c></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</_mouseOverObjects>
		<_point expr="FlxPoint.get()" line="40" static="1">
			<c path="flixel.math.FlxPoint"/>
			<meta><m n=":value"><e>FlxPoint.get()</e></m></meta>
		</_point>
		<init public="1" get="inline" set="null" line="45" static="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* As alternative you can call FlxMouseEventManager.init().</haxe_doc>
		</init>
		<add public="1" params="T" set="method" line="67" static="1">
			<f a="Object:?OnMouseDown:?OnMouseUp:?OnMouseOver:?OnMouseOut:?MouseChildren:?MouseEnabled:?PixelPerfect:?MouseButtons" v=":::::false:true:true:">
				<c path="add.T"/>
				<f a="">
					<c path="add.T"/>
					<x path="Void"/>
				</f>
				<f a="">
					<c path="add.T"/>
					<x path="Void"/>
				</f>
				<f a="">
					<c path="add.T"/>
					<x path="Void"/>
				</f>
				<f a="">
					<c path="add.T"/>
					<x path="Void"/>
				</f>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<c path="Array"><x path="flixel.input.mouse.FlxMouseButtonID"/></c>
				<c path="add.T"/>
			</f>
			<meta><m n=":value"><e>{ PixelPerfect : true, MouseEnabled : true, MouseChildren : false }</e></m></meta>
			<haxe_doc>* Adds an object to the FlxMouseEventManager registry. Automatically initializes the plugin.
	 *
	 * @param   OnMouseDown     Callback when mouse is pressed down over this object.
	 *                          Must have Object as argument - e.g. onMouseDown(object:FlxObject).
	 * @param   OnMouseUp       Callback when mouse is released over this object.
	 *                          Must have Object as argument - e.g. onMouseDown(object:FlxObject).
	 * @param   OnMouseOver     Callback when mouse is this object.
	 *                          Must have Object as argument - e.g. onMouseDown(object:FlxObject).
	 * @param   OnMouseOut      Callback when mouse moves out of this object.
	 *                          Must have Object as argument - e.g. onMouseDown(object:FlxObject).
	 * @param   MouseChildren   If true, other objects overlapped by this will still receive mouse events.
	 * @param   MouseEnabled    If true, this object will receive mouse events.
	 * @param   PixelPerfect    If true, the collision check will be pixel-perfect. Only works for FlxSprites.
	 * @param   MouseButtons    The mouse buttons that can trigger callbacks. Left only by default.</haxe_doc>
		</add>
		<remove public="1" params="T" set="method" line="87" static="1">
			<f a="Object">
				<c path="remove.T"/>
				<c path="remove.T"/>
			</f>
			<haxe_doc>* Removes a registered object from the registry.</haxe_doc>
		</remove>
		<removeAll public="1" set="method" line="103" static="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Removes all registered objects from the registry.</haxe_doc>
		</removeAll>
		<reorder public="1" set="method" line="124" static="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Reorders the registered objects, using the current object drawing order.
	 * This should be called if you alter the draw/update order of a registered object,
	 * That is, if you alter the position of a registered object inside its FlxGroup.
	 * It may also be called if the objects are not registered by the same order they are
	 * added to FlxGroup.</haxe_doc>
		</reorder>
		<setMouseDownCallback public="1" params="T" set="method" line="139" static="1">
			<f a="Object:OnMouseDown">
				<c path="setMouseDownCallback.T"/>
				<f a="">
					<c path="setMouseDownCallback.T"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<haxe_doc>* Sets the mouseDown callback associated with an object.
	 *
	 * @param 	OnMouseDown 	Callback when mouse is pressed down over this object. Must have Object as argument - e.g. onMouseDown(object:FlxObject).</haxe_doc>
		</setMouseDownCallback>
		<setMouseUpCallback public="1" params="T" set="method" line="155" static="1">
			<f a="Object:OnMouseUp">
				<c path="setMouseUpCallback.T"/>
				<f a="">
					<c path="setMouseUpCallback.T"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<haxe_doc>* Sets the mouseUp callback associated with an object.
	 *
	 * @param   OnMouseUp   Callback when mouse is released over this object.
	 *                      Must have Object as argument - e.g. onMouseDown(object:FlxObject).</haxe_doc>
		</setMouseUpCallback>
		<setMouseOverCallback public="1" params="T" set="method" line="171" static="1">
			<f a="Object:OnMouseOver">
				<c path="setMouseOverCallback.T"/>
				<f a="">
					<c path="setMouseOverCallback.T"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<haxe_doc>* Sets the mouseOver callback associated with an object.
	 *
	 * @param   OnMouseOver   Callback when mouse is over this object.
	 *                        Must have Object as argument - e.g. onMouseDown(object:FlxObject).</haxe_doc>
		</setMouseOverCallback>
		<setMouseOutCallback public="1" params="T" set="method" line="187" static="1">
			<f a="Object:OnMouseOut">
				<c path="setMouseOutCallback.T"/>
				<f a="">
					<c path="setMouseOutCallback.T"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<haxe_doc>* Sets the mouseOut callback associated with an object.
	 *
	 * @param   OnMouseOver   Callback when mouse is moves out of this object.
	 *                        Must have Object as argument - e.g. onMouseDown(object:FlxObject).</haxe_doc>
		</setMouseOutCallback>
		<setObjectMouseEnabled public="1" params="T" set="method" line="202" static="1">
			<f a="Object:MouseEnabled">
				<c path="setObjectMouseEnabled.T"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Enables/disables mouse behavior for an object.
	 * 
	 * @param   MouseEnabled   Whether this object will be tested for mouse events.</haxe_doc>
		</setObjectMouseEnabled>
		<isObjectMouseEnabled public="1" params="T" set="method" line="215" static="1">
			<f a="Object">
				<c path="isObjectMouseEnabled.T"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Checks if a registered object is mouseEnabled.</haxe_doc>
		</isObjectMouseEnabled>
		<setObjectMouseChildren public="1" params="T" set="method" line="234" static="1">
			<f a="Object:MouseChildren">
				<c path="setObjectMouseChildren.T"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Enables/disables mouseChildren for an object.
	 *
	 * @param   MouseChildren   Whether this object will allow other overlapping object to receive mouse events.</haxe_doc>
		</setObjectMouseChildren>
		<isObjectMouseChildren public="1" params="T" set="method" line="247" static="1">
			<f a="Object">
				<c path="isObjectMouseChildren.T"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Checks if an object allows mouseChildren.</haxe_doc>
		</isObjectMouseChildren>
		<setObjectMouseButtons public="1" params="T" set="method" line="264" static="1">
			<f a="object:mouseButtons">
				<c path="setObjectMouseButtons.T"/>
				<c path="Array"><x path="flixel.input.mouse.FlxMouseButtonID"/></c>
				<x path="Void"/>
			</f>
			<haxe_doc>* @param   MouseButtons    The mouse buttons that can trigger callbacks. Left only by default.</haxe_doc>
		</setObjectMouseButtons>
		<traverseFlxGroup set="method" line="275" static="1">
			<f a="Group:OrderedObjects">
				<c path="flixel.group.FlxTypedGroup"><d/></c>
				<c path="Array"><c path="flixel.input.mouse._FlxMouseEventManager.ObjectMouseData"><d/></c></c>
				<x path="Void"/>
			</f>
			<meta><m n=":access"><e>flixel.group.FlxTypedGroup.resolveGroup</e></m></meta>
		</traverseFlxGroup>
		<getRegister params="T" set="method" line="296" static="1"><f a="Object:?Register">
	<c path="getRegister.T"/>
	<c path="Array"><c path="flixel.input.mouse._FlxMouseEventManager.ObjectMouseData"><c path="flixel.FlxObject"/></c></c>
	<c path="flixel.input.mouse._FlxMouseEventManager.ObjectMouseData"><c path="getRegister.T"/></c>
</f></getRegister>
		<destroy public="1" set="method" line="328" override="1"><f a=""><x path="Void"/></f></destroy>
		<update public="1" set="method" line="336" override="1"><f a="elapsed">
	<x path="Float"/>
	<x path="Void"/>
</f></update>
		<clearRegistry set="method" line="421"><f a=""><x path="Void"/></f></clearRegistry>
		<checkOverlap params="T" set="method" line="427"><f a="Register">
	<c path="flixel.input.mouse._FlxMouseEventManager.ObjectMouseData"><c path="checkOverlap.T"/></c>
	<x path="Bool"/>
</f></checkOverlap>
		<checkOverlapWithPoint params="T" get="inline" set="null" line="464"><f a="Register:Point:Camera">
	<c path="flixel.input.mouse._FlxMouseEventManager.ObjectMouseData"><c path="checkOverlapWithPoint.T"/></c>
	<c path="flixel.math.FlxPoint"/>
	<c path="flixel.FlxCamera"/>
	<x path="Bool"/>
</f></checkOverlapWithPoint>
		<checkPixelPerfectOverlap get="inline" set="null" line="476"><f a="Point:Sprite:Camera">
	<c path="flixel.math.FlxPoint"/>
	<c path="flixel.FlxSprite"/>
	<c path="flixel.FlxCamera"/>
	<x path="Bool"/>
</f></checkPixelPerfectOverlap>
		<new public="1" set="method" line="314"><f a=""><x path="Void"/></f></new>
		<haxe_doc>* Provides mouse event detection for FlxObjects and FlxSprites (pixel-perfect for those).
 * To use it, initialize the manager and register objects / sprites. 
 * 
 *    FlxG.plugins.add(new FlxMouseEventManager());
 *    var object = new FlxObject();
 *    FlxMouseEventManager.add(object, onMouseDown, onMouseUp, onMouseOver, onMouseOut);
 * 
 * Or simply add a new object and this plugin will initialize itself: 
 * 
 *    FlxMouseEventManager.add(object, onMouseDown, onMouseUp, onMouseOver, onMouseOut);
 * 
 * Also implement the callbacks with the object's type as parameters:
 * 
 *    function onMouseDown(object:FlxObject) {}
 *    function onMouseUp(object:FlxObject) {}
 *    function onMouseOver(object:FlxObject) {}
 *    function onMouseOut(object:FlxObject) {} 
 * 
 * @author TiagoLr (~~~ ProG4mr ~~~)</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="flixel.input.mouse._FlxMouseEventManager.ObjectMouseData" params="T" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/input/mouse/FlxMouseEventManager.hx" private="1" module="flixel.input.mouse.FlxMouseEventManager">
		<implements path="flixel.util.IFlxDestroyable"/>
		<object public="1"><c path="flixel.FlxObject"/></object>
		<onMouseDown public="1"><f a="">
	<c path="flixel.input.mouse._FlxMouseEventManager.ObjectMouseData.T"/>
	<x path="Void"/>
</f></onMouseDown>
		<onMouseUp public="1"><f a="">
	<c path="flixel.input.mouse._FlxMouseEventManager.ObjectMouseData.T"/>
	<x path="Void"/>
</f></onMouseUp>
		<onMouseOver public="1"><f a="">
	<c path="flixel.input.mouse._FlxMouseEventManager.ObjectMouseData.T"/>
	<x path="Void"/>
</f></onMouseOver>
		<onMouseOut public="1"><f a="">
	<c path="flixel.input.mouse._FlxMouseEventManager.ObjectMouseData.T"/>
	<x path="Void"/>
</f></onMouseOut>
		<mouseChildren public="1"><x path="Bool"/></mouseChildren>
		<mouseEnabled public="1"><x path="Bool"/></mouseEnabled>
		<pixelPerfect public="1"><x path="Bool"/></pixelPerfect>
		<sprite public="1"><c path="flixel.FlxSprite"/></sprite>
		<mouseButtons public="1"><c path="Array"><x path="flixel.input.mouse.FlxMouseButtonID"/></c></mouseButtons>
		<currentMouseButton public="1"><t path="Null"><x path="flixel.input.mouse.FlxMouseButtonID"/></t></currentMouseButton>
		<destroy public="1" set="method" line="515"><f a=""><x path="Void"/></f></destroy>
		<new public="1" set="method" line="501"><f a="object:onMouseDown:onMouseUp:onMouseOver:onMouseOut:mouseChildren:mouseEnabled:pixelPerfect:mouseButtons">
	<c path="flixel.input.mouse._FlxMouseEventManager.ObjectMouseData.T"/>
	<f a="">
		<c path="flixel.input.mouse._FlxMouseEventManager.ObjectMouseData.T"/>
		<x path="Void"/>
	</f>
	<f a="">
		<c path="flixel.input.mouse._FlxMouseEventManager.ObjectMouseData.T"/>
		<x path="Void"/>
	</f>
	<f a="">
		<c path="flixel.input.mouse._FlxMouseEventManager.ObjectMouseData.T"/>
		<x path="Void"/>
	</f>
	<f a="">
		<c path="flixel.input.mouse._FlxMouseEventManager.ObjectMouseData.T"/>
		<x path="Void"/>
	</f>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<c path="Array"><x path="flixel.input.mouse.FlxMouseButtonID"/></c>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="flixel.input.touch.FlxTouch" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/input/touch/FlxTouch.hx">
		<extends path="flixel.input.FlxPointer"/>
		<implements path="flixel.input.IFlxInput"/>
		<implements path="flixel.util.IFlxDestroyable"/>
		<touchPointID public="1" get="accessor" set="null">
			<x path="Int"/>
			<haxe_doc>* The _unique_ ID of this touch. You should not make not any further assumptions
	 * about this value - IDs are not guaranteed to start from 0 or ascend in order.
	 * The behavior may vary from device to device.</haxe_doc>
		</touchPointID>
		<justReleased public="1" get="accessor" set="null"><x path="Bool"/></justReleased>
		<released public="1" get="accessor" set="null"><x path="Bool"/></released>
		<pressed public="1" get="accessor" set="null"><x path="Bool"/></pressed>
		<justPressed public="1" get="accessor" set="null"><x path="Bool"/></justPressed>
		<input><c path="flixel.input.FlxInput"><x path="Int"/></c></input>
		<flashPoint expr="new Point()">
			<c path="openfl.geom.Point"/>
			<meta><m n=":value"><e>new Point()</e></m></meta>
		</flashPoint>
		<justPressedPosition public="1" set="null" expr="FlxPoint.get()">
			<c path="flixel.math.FlxPoint"/>
			<meta><m n=":value"><e>FlxPoint.get()</e></m></meta>
		</justPressedPosition>
		<justPressedTimeInTicks public="1" set="null" expr="-1">
			<x path="Int"/>
			<meta><m n=":value"><e>-1</e></m></meta>
		</justPressedTimeInTicks>
		<destroy public="1" set="method" line="37"><f a=""><x path="Void"/></f></destroy>
		<recycle public="1" set="method" line="47">
			<f a="x:y:pointID">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Resets the justPressed/justReleased flags and sets touch to not pressed.</haxe_doc>
		</recycle>
		<update set="method" line="70">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Called by the internal game loop to update the just pressed/just released flags.</haxe_doc>
		</update>
		<setXY set="method" line="93">
			<f a="X:Y">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Function for updating touch coordinates. Called by the TouchManager.
	 * 
	 * @param	X	stageX touch coordinate
	 * @param	Y	stageY touch coordinate</haxe_doc>
		</setXY>
		<get_touchPointID get="inline" set="null" line="101"><f a=""><x path="Int"/></f></get_touchPointID>
		<get_justReleased get="inline" set="null" line="106"><f a=""><x path="Bool"/></f></get_justReleased>
		<get_released get="inline" set="null" line="111"><f a=""><x path="Bool"/></f></get_released>
		<get_pressed get="inline" set="null" line="116"><f a=""><x path="Bool"/></f></get_pressed>
		<get_justPressed get="inline" set="null" line="121"><f a=""><x path="Bool"/></f></get_justPressed>
		<new set="method" line="59">
			<f a="?x:?y:?pointID" v="0:0:0">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ pointID : 0, y : 0, x : 0 }</e></m></meta>
			<haxe_doc>* @param	X			stageX touch coordinate
	 * @param	Y			stageX touch coordinate
	 * @param	PointID		touchPointID of the touch</haxe_doc>
		</new>
		<haxe_doc>* Helper class, contains and tracks touch points in your game.
 * Automatically accounts for parallax scrolling, etc.</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":allow"><e>flixel.input.touch.FlxTouchManager</e></m>
		</meta>
	</class>
	<class path="flixel.input.touch.FlxTouchManager" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/input/touch/FlxTouchManager.hx">
		<implements path="flixel.input.IFlxInputManager"/>
		<maxTouchPoints public="1" expr="0" line="18" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* The maximum number of concurrent touch points supported by the current device.</haxe_doc>
		</maxTouchPoints>
		<list public="1">
			<c path="Array"><c path="flixel.input.touch.FlxTouch"/></c>
			<haxe_doc>* All active touches including just created, moving and just released.</haxe_doc>
		</list>
		<_inactiveTouches>
			<c path="Array"><c path="flixel.input.touch.FlxTouch"/></c>
			<haxe_doc>* Storage for inactive touches (some sort of cache for them).</haxe_doc>
		</_inactiveTouches>
		<_touchesCache>
			<x path="Map">
				<x path="Int"/>
				<c path="flixel.input.touch.FlxTouch"/>
			</x>
			<haxe_doc>* Helper storage for active touches (for faster access)</haxe_doc>
		</_touchesCache>
		<getByID public="1" get="inline" set="null" line="37">
			<f a="TouchPointID">
				<x path="Int"/>
				<c path="flixel.input.touch.FlxTouch"/>
			</f>
			<haxe_doc>* WARNING: can be null if no active touch with the provided ID could be found</haxe_doc>
		</getByID>
		<getFirst public="1" set="method" line="45">
			<f a=""><c path="flixel.input.touch.FlxTouch"/></f>
			<haxe_doc>* Return the first touch if there is one, beware of null</haxe_doc>
		</getFirst>
		<destroy public="1" set="method" line="61">
			<f a=""><x path="Void"/></f>
			<meta><m n=":noCompletion"/></meta>
			<haxe_doc>* Clean up memory. Internal use only.</haxe_doc>
		</destroy>
		<justStarted public="1" set="method" line="84">
			<f a="?TouchArray">
				<c path="Array"><c path="flixel.input.touch.FlxTouch"/></c>
				<c path="Array"><c path="flixel.input.touch.FlxTouch"/></c>
			</f>
			<haxe_doc>* Gets all touches which were just started
	 * 
	 * @param	TouchArray	Optional array to fill with touch objects
	 * @return	Array with touches</haxe_doc>
		</justStarted>
		<justReleased public="1" set="method" line="115">
			<f a="?TouchArray">
				<c path="Array"><c path="flixel.input.touch.FlxTouch"/></c>
				<c path="Array"><c path="flixel.input.touch.FlxTouch"/></c>
			</f>
			<haxe_doc>* Gets all touches which were just ended
	 * 
	 * @param	TouchArray	Optional array to fill with touch objects
	 * @return	Array with touches</haxe_doc>
		</justReleased>
		<reset public="1" set="method" line="142">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Resets all touches to inactive state.</haxe_doc>
		</reset>
		<handleTouchBegin set="method" line="175">
			<f a="FlashEvent">
				<t path="flash.events.TouchEvent"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Event handler so FlxGame can update touches.</haxe_doc>
		</handleTouchBegin>
		<handleTouchEnd set="method" line="192">
			<f a="FlashEvent">
				<t path="flash.events.TouchEvent"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Event handler so FlxGame can update touches.</haxe_doc>
		</handleTouchEnd>
		<handleTouchMove set="method" line="205">
			<f a="FlashEvent">
				<t path="flash.events.TouchEvent"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Event handler so FlxGame can update touches.</haxe_doc>
		</handleTouchMove>
		<add set="method" line="221">
			<f a="Touch">
				<c path="flixel.input.touch.FlxTouch"/>
				<c path="flixel.input.touch.FlxTouch"/>
			</f>
			<haxe_doc>* Internal function for adding new touches to the manager
	 * 
	 * @param	Touch	A new FlxTouch object
	 * @return	The added FlxTouch object</haxe_doc>
		</add>
		<recycle set="method" line="236">
			<f a="X:Y:PointID">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<c path="flixel.input.touch.FlxTouch"/>
			</f>
			<haxe_doc>* Internal function for touch reuse
	 * 
	 * @param	X			stageX touch coordinate
	 * @param	Y			stageY touch coordinate
	 * @param	PointID		id of the touch
	 * @return	A recycled touch object</haxe_doc>
		</recycle>
		<update set="method" line="252">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Called by the internal game loop to update the touch position in the game world.
	 * Also updates the just pressed/just released flags.</haxe_doc>
		</update>
		<onFocus set="method" line="278"><f a=""><x path="Void"/></f></onFocus>
		<onFocusLost set="method" line="280"><f a=""><x path="Void"/></f></onFocusLost>
		<new set="method" line="159">
			<f a=""><x path="Void"/></f>
			<meta><m n=":allow"><e>flixel.FlxG</e></m></meta>
		</new>
		<haxe_doc>* ...
 * @author Zaphod</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="flixel.math.FlxAngle" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/math/FlxAngle.hx">
		<sinCosGenerator public="1" set="method" static="1">
			<f a="length:sinAmplitude:cosAmplitude:frequency">
				<d/>
				<d/>
				<d/>
				<d/>
				<d/>
			</f>
			<haxe_doc>* Generate a sine and cosine table during compilation
	 * 
	 * The parameters allow you to specify the length, amplitude and frequency of the wave. 
	 * You have to call this function with constant parameters and either use it on your own or assign it to FlxAngle.sincos
	 * 
	 * @param length 		The length of the wave
	 * @param sinAmplitude 	The amplitude to apply to the sine table (default 1.0) if you need values between say -+ 125 then give 125 as the value
	 * @param cosAmplitude 	The amplitude to apply to the cosine table (default 1.0) if you need values between say -+ 125 then give 125 as the value
	 * @param frequency 	The frequency of the sine and cosine table data
	 * @return	Returns the cosine/sine table in a FlxSinCos</haxe_doc>
		</sinCosGenerator>
		<TO_DEG public="1" get="accessor" set="null" static="1">
			<x path="Float"/>
			<haxe_doc>* Convert radians to degrees by multiplying it with this value.</haxe_doc>
		</TO_DEG>
		<TO_RAD public="1" get="accessor" set="null" static="1">
			<x path="Float"/>
			<haxe_doc>* Convert degrees to radians by multiplying it with this value.</haxe_doc>
		</TO_RAD>
		<wrapAngle public="1" set="method" line="64" static="1">
			<f a="angle">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>* Keeps an angle value between -180 and +180 by wrapping it
	 * e.g an angle of +270 will be converted to -90
	 * Should be called whenever the angle is updated on a FlxSprite to stop it from going insane.
	 * 
	 * @param	angle	The angle value to check
	 * 
	 * @return	The new angle value, returns the same as the input angle if it was within bounds</haxe_doc>
		</wrapAngle>
		<asDegrees public="1" get="inline" set="null" line="85" static="1">
			<f a="radians">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>* Converts a Radian value into a Degree
	 * Converts the radians value into degrees and returns
	 * 
	 * @param 	radians 	The value in radians
	 * @return	Degrees</haxe_doc>
		</asDegrees>
		<asRadians public="1" get="inline" set="null" line="97" static="1">
			<f a="degrees">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>* Converts a Degrees value into a Radian
	 * Converts the degrees value into radians and returns
	 * 
	 * @param 	degrees The value in degrees
	 * @return	Radians</haxe_doc>
		</asRadians>
		<angleBetween public="1" set="method" line="111" static="1">
			<f a="SpriteA:SpriteB:?AsDegrees" v="::false">
				<c path="flixel.FlxSprite"/>
				<c path="flixel.FlxSprite"/>
				<x path="Bool"/>
				<x path="Float"/>
			</f>
			<meta><m n=":value"><e>{ AsDegrees : false }</e></m></meta>
			<haxe_doc>* Find the angle (in radians) between the two FlxSprite, taking their x/y and origin into account.
	 * The angle is calculated in clockwise positive direction (down = 90 degrees positive, right = 0 degrees positive, up = 90 degrees negative)
	 * 
	 * @param	SpriteA		The FlxSprite to test from
	 * @param	SpriteB		The FlxSprite to test to
	 * @param	AsDegrees	If you need the value in degrees instead of radians, set to true
	 * @return	The angle (in radians unless asDegrees is true)</haxe_doc>
		</angleBetween>
		<angleBetweenPoint public="1" set="method" line="131" static="1">
			<f a="Sprite:Target:?AsDegrees" v="::false">
				<c path="flixel.FlxSprite"/>
				<c path="flixel.math.FlxPoint"/>
				<x path="Bool"/>
				<x path="Float"/>
			</f>
			<meta><m n=":value"><e>{ AsDegrees : false }</e></m></meta>
			<haxe_doc>* Find the angle (in radians) between an FlxSprite and an FlxPoint. The source sprite takes its x/y and origin into account.
	 * The angle is calculated in clockwise positive direction (down = 90 degrees positive, right = 0 degrees positive, up = 90 degrees negative)
	 * 
	 * @param	Sprite		The FlxSprite to test from
	 * @param	Target		The FlxPoint to angle the FlxSprite towards
	 * @param	AsDegrees	If you need the value in degrees instead of radians, set to true
	 * @return	The angle (in radians unless AsDegrees is true)</haxe_doc>
		</angleBetweenPoint>
		<angleBetweenMouse public="1" set="method" line="153" static="1">
			<f a="Object:?AsDegrees" v=":false">
				<c path="flixel.FlxObject"/>
				<x path="Bool"/>
				<x path="Float"/>
			</f>
			<meta><m n=":value"><e>{ AsDegrees : false }</e></m></meta>
			<haxe_doc>* Find the angle (in radians) between an FlxSprite and the mouse, taking their x/y and origin into account.
	 * The angle is calculated in clockwise positive direction (down = 90 degrees positive, right = 0 degrees positive, up = 90 degrees negative)
	 * 
	 * @param	Object		The FlxObject to test from
	 * @param	AsDegrees	If you need the value in degrees instead of radians, set to true
	 * @return	The angle (in radians unless AsDegrees is true)</haxe_doc>
		</angleBetweenMouse>
		<angleBetweenTouch public="1" set="method" line="183" static="1">
			<f a="Object:Touch:?AsDegrees" v="::false">
				<c path="flixel.FlxObject"/>
				<c path="flixel.input.touch.FlxTouch"/>
				<x path="Bool"/>
				<x path="Float"/>
			</f>
			<meta><m n=":value"><e>{ AsDegrees : false }</e></m></meta>
			<haxe_doc>* Find the angle (in radians) between an FlxSprite and a FlxTouch, taking their x/y and origin into account.
	 * The angle is calculated in clockwise positive direction (down = 90 degrees positive, right = 0 degrees positive, up = 90 degrees negative)
	 * 
	 * @param	Object		The FlxObject to test from
	 * @param	Touch		The FlxTouch to test to
	 * @param	AsDegrees	If you need the value in degrees instead of radians, set to true
	 * @return	The angle (in radians unless AsDegrees is true)</haxe_doc>
		</angleBetweenTouch>
		<angleFromFacing public="1" set="method" line="207" static="1">
			<f a="FacingBitmask:?AsDegrees" v=":false">
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Float"/>
			</f>
			<meta><m n=":value"><e>{ AsDegrees : false }</e></m></meta>
			<haxe_doc>*  Translate an object's facing to angle.
	 * 
	 * @param	FacingBitmask	Bitmask from which to calculate the angle, as in FlxSprite::facing
	 * @param	AsDegrees		If you need the value in degrees instead of radians, set to true
	 * @return	The angle (in radians unless AsDegrees is true)</haxe_doc>
		</angleFromFacing>
		<getCartesianCoords public="1" set="method" line="232" static="1">
			<f a="Radius:Angle:?point">
				<x path="Float"/>
				<x path="Float"/>
				<c path="flixel.math.FlxPoint"/>
				<c path="flixel.math.FlxPoint"/>
			</f>
			<haxe_doc>* Convert polar coordinates (radius + angle) to cartesian coordinates (x + y)
	 * 
	 * @param	Radius	The radius
	 * @param	Angle	The angle, in degrees
	 * @param	point	Optional FlxPoint if you don't want a new one created
	 * @return	The point in cartesian coords</haxe_doc>
		</getCartesianCoords>
		<getPolarCoords public="1" set="method" line="251" static="1">
			<f a="X:Y:?point">
				<x path="Float"/>
				<x path="Float"/>
				<c path="flixel.math.FlxPoint"/>
				<c path="flixel.math.FlxPoint"/>
			</f>
			<haxe_doc>* Convert cartesian coordinates (x + y) to polar coordinates (radius + angle) 
	 * 
	 * @param	X		x position
	 * @param	Y		y position
	 * @param	point	Optional FlxPoint if you don't want a new one created
	 * @return	The point in polar coords (x = Radius (degrees), y = Angle)</haxe_doc>
		</getPolarCoords>
		<get_TO_DEG get="inline" set="null" line="262" static="1"><f a=""><x path="Float"/></f></get_TO_DEG>
		<get_TO_RAD get="inline" set="null" line="267" static="1"><f a=""><x path="Float"/></f></get_TO_RAD>
		<haxe_doc>* A set of functions related to angle calculations.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<typedef path="flixel.math.FlxSinCos" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/math/FlxAngle.hx" module="flixel.math.FlxAngle"><a>
	<sin><c path="Array"><x path="Float"/></c></sin>
	<cos><c path="Array"><x path="Float"/></c></cos>
</a></typedef>
	<class path="flixel.math.FlxMath" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/math/FlxMath.hx">
		<MIN_VALUE_FLOAT public="1" get="inline" set="null" expr="5e-324" line="24" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>5e-324</e></m></meta>
			<haxe_doc>* Minimum value of a floating point number.</haxe_doc>
		</MIN_VALUE_FLOAT>
		<MAX_VALUE_FLOAT public="1" get="inline" set="null" expr="1.79e+308" line="29" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>1.79e+308</e></m></meta>
			<haxe_doc>* Maximum value of a floating point number.</haxe_doc>
		</MAX_VALUE_FLOAT>
		<MIN_VALUE_INT public="1" get="inline" set="null" expr="-MAX_VALUE_INT" line="33" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>-MAX_VALUE_INT</e></m></meta>
			<haxe_doc>* Minimum value of an integer.</haxe_doc>
		</MIN_VALUE_INT>
		<MAX_VALUE_INT public="1" get="inline" set="null" expr="0x7FFFFFFF" line="37" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x7FFFFFFF</e></m></meta>
			<haxe_doc>* Maximum value of an integer.</haxe_doc>
		</MAX_VALUE_INT>
		<SQUARE_ROOT_OF_TWO public="1" get="inline" set="null" expr="1.41421356237" line="41" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>1.41421356237</e></m></meta>
			<haxe_doc>* Approximation of `Math.sqrt(2)`.</haxe_doc>
		</SQUARE_ROOT_OF_TWO>
		<EPSILON public="1" get="inline" set="null" expr="0.0000001" line="45" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>0.0000001</e></m></meta>
			<haxe_doc>* Used to account for floating-point inaccuracies.</haxe_doc>
		</EPSILON>
		<roundDecimal public="1" set="method" line="58" static="1">
			<f a="Value:Precision">
				<x path="Float"/>
				<x path="Int"/>
				<x path="Float"/>
			</f>
			<haxe_doc>* Round a decimal number to have reduced precision (less decimal numbers).
	 * 
	 * ```haxe
	 * roundDecimal(1.2485, 2) = 1.25
	 * ```
	 * 
	 * @param	Value		Any number.
	 * @param	Precision	Number of decimals the result should have.
	 * @return	The rounded value of that number.</haxe_doc>
		</roundDecimal>
		<bound public="1" get="inline" set="null" line="78" static="1">
			<f a="Value:?Min:?Max">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>* Bound a number by a minimum and maximum. Ensures that this number is 
	 * no smaller than the minimum, and no larger than the maximum.
	 * Leaving a bound `null` means that side is unbounded.
	 * 
	 * @param	Value	Any number.
	 * @param	Min		Any number.
	 * @param	Max		Any number.
	 * @return	The bounded value of the number.</haxe_doc>
		</bound>
		<lerp public="1" get="inline" set="null" line="97" static="1">
			<f a="a:b:ratio">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>* Returns the linear interpolation of two numbers if `ratio`
	 * is between 0 and 1, and the linear extrapolation otherwise.
	 * 
	 * Examples:
	 * 
	 * ```haxe
	 * lerp(a, b, 0) = a
	 * lerp(a, b, 1) = b
	 * lerp(5, 15, 0.5) = 10
	 * lerp(5, 15, -1) = -5
	 * ```</haxe_doc>
		</lerp>
		<inBounds public="1" get="inline" set="null" line="110" static="1">
			<f a="Value:Min:Max">
				<x path="Float"/>
				<t path="Null"><x path="Float"/></t>
				<t path="Null"><x path="Float"/></t>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Checks if number is in defined range. A null bound means that side is unbounded.
	 *
	 * @param Value		Number to check.
	 * @param Min		Lower bound of range.
	 * @param Max 		Higher bound of range.
	 * @return Returns true if Value is in range.</haxe_doc>
		</inBounds>
		<isOdd public="1" get="inline" set="null" line="118" static="1">
			<f a="n">
				<x path="Float"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Returns `true` if the given number is odd.</haxe_doc>
		</isOdd>
		<isEven public="1" get="inline" set="null" line="126" static="1">
			<f a="n">
				<x path="Float"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Returns `true` if the given number is even.</haxe_doc>
		</isEven>
		<numericComparison public="1" set="method" line="134" static="1">
			<f a="a:b">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
			</f>
			<haxe_doc>* Returns `-1` if `a` is smaller, `1` if `b` is bigger and `0` if both numbers are equal.</haxe_doc>
		</numericComparison>
		<pointInCoordinates public="1" set="method" line="159" static="1">
			<f a="pointX:pointY:rectX:rectY:rectWidth:rectHeight">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Returns true if the given x/y coordinate is within the given rectangular block
	 * 
	 * @param	pointX		The X value to test
	 * @param	pointY		The Y value to test
	 * @param	rectX		The X value of the region to test within
	 * @param	rectY		The Y value of the region to test within
	 * @param	rectWidth	The width of the region to test within
	 * @param	rectHeight	The height of the region to test within
	 * 
	 * @return	true if pointX/pointY is within the region, otherwise false</haxe_doc>
		</pointInCoordinates>
		<pointInFlxRect public="1" set="method" line="179" static="1">
			<f a="pointX:pointY:rect">
				<x path="Float"/>
				<x path="Float"/>
				<c path="flixel.math.FlxRect"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Returns true if the given x/y coordinate is within the given rectangular block
	 * 
	 * @param	pointX		The X value to test
	 * @param	pointY		The Y value to test
	 * @param	rect		The FlxRect to test within
	 * @return	true if pointX/pointY is within the FlxRect, otherwise false</haxe_doc>
		</pointInFlxRect>
		<mouseInFlxRect public="1" set="method" line="193" static="1">
			<f a="useWorldCoords:rect">
				<x path="Bool"/>
				<c path="flixel.math.FlxRect"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Returns true if the mouse world x/y coordinate are within the given rectangular block
	 * 
	 * @param	useWorldCoords	If true the world x/y coordinates of the mouse will be used, otherwise screen x/y
	 * @param	rect			The FlxRect to test within. If this is null for any reason this function always returns true.
	 * 
	 * @return	true if mouse is within the FlxRect, otherwise false</haxe_doc>
		</mouseInFlxRect>
		<pointInRectangle public="1" set="method" line="219" static="1">
			<f a="pointX:pointY:rect">
				<x path="Float"/>
				<x path="Float"/>
				<t path="flash.geom.Rectangle"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Returns true if the given x/y coordinate is within the Rectangle
	 * 
	 * @param	pointX		The X value to test
	 * @param	pointY		The Y value to test
	 * @param	rect		The Rectangle to test within
	 * @return	true if pointX/pointY is within the Rectangle, otherwise false</haxe_doc>
		</pointInRectangle>
		<maxAdd public="1" set="method" line="234" static="1">
			<f a="value:amount:max:?min" v=":::0">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":value"><e>{ min : 0 }</e></m></meta>
			<haxe_doc>* Adds the given amount to the value, but never lets the value
	 * go over the specified maximum or under the specified minimum.
	 * 
	 * @param 	value 	The value to add the amount to
	 * @param 	amount 	The amount to add to the value
	 * @param 	max 	The maximum the value is allowed to be
	 * @param 	min 	The minimum the value is allowed to be
	 * @return The new value</haxe_doc>
		</maxAdd>
		<wrap public="1" set="method" line="259" static="1">
			<f a="value:min:max">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>* Makes sure that value always stays between 0 and max,
	 * by wrapping the value around.
	 * 
	 * @param 	value 	The value to wrap around
	 * @param 	min		The minimum the value is allowed to be
	 * @param 	max 	The maximum the value is allowed to be
	 * @return The wrapped value</haxe_doc>
		</wrap>
		<remapToRange public="1" set="method" line="279" static="1">
			<f a="value:start1:stop1:start2:stop2">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>* Remaps a number from one range to another.
	 * 
	 * @param 	value	The incoming value to be converted
	 * @param 	start1 	Lower bound of the value's current range
	 * @param 	stop1 	Upper bound of the value's current range
	 * @param 	start2  Lower bound of the value's target range
	 * @param 	stop2 	Upper bound of the value's target range
	 * @return The remapped value</haxe_doc>
		</remapToRange>
		<dotProduct public="1" get="inline" set="null" line="294" static="1">
			<f a="ax:ay:bx:by">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>* Finds the dot product value of two vectors
	 * 
	 * @param	ax		Vector X
	 * @param	ay		Vector Y
	 * @param	bx		Vector X
	 * @param	by		Vector Y
	 * 
	 * @return	Result of the dot product</haxe_doc>
		</dotProduct>
		<vectorLength public="1" get="inline" set="null" line="302" static="1">
			<f a="dx:dy">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>* Returns the length of the given vector.</haxe_doc>
		</vectorLength>
		<distanceBetween public="1" get="inline" set="null" line="314" static="1">
			<f a="SpriteA:SpriteB">
				<c path="flixel.FlxSprite"/>
				<c path="flixel.FlxSprite"/>
				<x path="Int"/>
			</f>
			<haxe_doc>* Find the distance (in pixels, rounded) between two FlxSprites, taking their origin into account
	 * 
	 * @param	SpriteA		The first FlxSprite
	 * @param	SpriteB		The second FlxSprite
	 * @return	Distance between the sprites in pixels</haxe_doc>
		</distanceBetween>
		<isDistanceWithin public="1" get="inline" set="null" line="331" static="1">
			<f a="SpriteA:SpriteB:Distance:?IncludeEqual" v=":::false">
				<c path="flixel.FlxSprite"/>
				<c path="flixel.FlxSprite"/>
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":value"><e>{ IncludeEqual : false }</e></m></meta>
			<haxe_doc>* Check if the distance between two FlxSprites is within a specified number. 
	 * A faster algorithm than distanceBetween because the Math.sqrt() is avoided.
	 *
	 * @param	SpriteA		The first FlxSprite
	 * @param	SpriteB		The second FlxSprite
	 * @param	Distance	The distance to check
	 * @param	IncludeEqual	If set to true, the function will return true if the calculated distance is equal to the given Distance
	 * @return	True if the distance between the sprites is less than the given Distance</haxe_doc>
		</isDistanceWithin>
		<distanceToPoint public="1" get="inline" set="null" line="350" static="1">
			<f a="Sprite:Target">
				<c path="flixel.FlxSprite"/>
				<c path="flixel.math.FlxPoint"/>
				<x path="Int"/>
			</f>
			<haxe_doc>* Find the distance (in pixels, rounded) from an FlxSprite
	 * to the given FlxPoint, taking the source origin into account.
	 * 
	 * @param	Sprite	The FlxSprite
	 * @param	Target	The FlxPoint
	 * @return	Distance in pixels</haxe_doc>
		</distanceToPoint>
		<isDistanceToPointWithin public="1" get="inline" set="null" line="369" static="1">
			<f a="Sprite:Target:Distance:?IncludeEqual" v=":::false">
				<c path="flixel.FlxSprite"/>
				<c path="flixel.math.FlxPoint"/>
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":value"><e>{ IncludeEqual : false }</e></m></meta>
			<haxe_doc>* Check if the distance from an FlxSprite to the given
	 * FlxPoint is within a specified number. 
	 * A faster algorithm than distanceToPoint because the Math.sqrt() is avoided.
	 * 
	 * @param	Sprite	The FlxSprite
	 * @param	Target	The FlxPoint
	 * @param	Distance	The distance to check
	 * @param	IncludeEqual	If set to true, the function will return true if the calculated distance is equal to the given Distance
	 * @return	True if the distance between the sprites is less than the given Distance</haxe_doc>
		</isDistanceToPointWithin>
		<distanceToMouse public="1" get="inline" set="null" line="389" static="1">
			<f a="Sprite">
				<c path="flixel.FlxSprite"/>
				<x path="Int"/>
			</f>
			<haxe_doc>* Find the distance (in pixels, rounded) from the object x/y and the mouse x/y
	 * 
	 * @param	Sprite	The FlxSprite to test against
	 * @return	The distance between the given sprite and the mouse coordinates</haxe_doc>
		</distanceToMouse>
		<isDistanceToMouseWithin public="1" get="inline" set="null" line="405" static="1">
			<f a="Sprite:Distance:?IncludeEqual" v="::false">
				<c path="flixel.FlxSprite"/>
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":value"><e>{ IncludeEqual : false }</e></m></meta>
			<haxe_doc>* Check if the distance from the object x/y and the mouse x/y is within a specified number. 
	 * A faster algorithm than distanceToMouse because the Math.sqrt() is avoided.
	 *
	 * @param	Sprite		The FlxSprite to test against
	 * @param	Distance	The distance to check
	 * @param	IncludeEqual	If set to true, the function will return true if the calculated distance is equal to the given Distance
	 * @return	True if the distance between the sprites is less than the given Distance</haxe_doc>
		</isDistanceToMouseWithin>
		<distanceToTouch public="1" get="inline" set="null" line="425" static="1">
			<f a="Sprite:Touch">
				<c path="flixel.FlxSprite"/>
				<c path="flixel.input.touch.FlxTouch"/>
				<x path="Int"/>
			</f>
			<haxe_doc>* Find the distance (in pixels, rounded) from the object x/y and the FlxPoint screen x/y
	 * 
	 * @param	Sprite	The FlxSprite to test against
	 * @param	Touch	The FlxTouch to test against
	 * @return	The distance between the given sprite and the mouse coordinates</haxe_doc>
		</distanceToTouch>
		<isDistanceToTouchWithin public="1" get="inline" set="null" line="441" static="1">
			<f a="Sprite:Touch:Distance:?IncludeEqual" v=":::false">
				<c path="flixel.FlxSprite"/>
				<c path="flixel.input.touch.FlxTouch"/>
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":value"><e>{ IncludeEqual : false }</e></m></meta>
			<haxe_doc>* Check if the distance from the object x/y and the FlxPoint screen x/y is within a specified number. 
	 * A faster algorithm than distanceToTouch because the Math.sqrt() is avoided.
	 *
	 * @param	Sprite	The FlxSprite to test against
	 * @param	Distance	The distance to check
	 * @param	IncludeEqual	If set to true, the function will return true if the calculated distance is equal to the given Distance
	 * @return	True if the distance between the sprites is less than the given Distance</haxe_doc>
		</isDistanceToTouchWithin>
		<getDecimals public="1" set="method" line="456" static="1">
			<f a="n">
				<x path="Float"/>
				<x path="Int"/>
			</f>
			<haxe_doc>* Returns the amount of decimals a `Float` has.</haxe_doc>
		</getDecimals>
		<equal public="1" get="inline" set="null" line="469" static="1">
			<f a="aValueA:aValueB:?aDiff" v="::EPSILON">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":value"><e>{ aDiff : EPSILON }</e></m></meta>
		</equal>
		<signOf public="1" get="inline" set="null" line="477" static="1">
			<f a="n">
				<x path="Float"/>
				<x path="Int"/>
			</f>
			<haxe_doc>* Returns `-1` if the number is smaller than `0` and `1` otherwise</haxe_doc>
		</signOf>
		<sameSign public="1" get="inline" set="null" line="485" static="1">
			<f a="a:b">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Checks if two numbers have the same sign (using `FlxMath.signOf()`).</haxe_doc>
		</sameSign>
		<fastSin public="1" get="inline" set="null" line="497" static="1">
			<f a="n">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc><![CDATA[* A faster but slightly less accurate version of `Math.sin()`.
	 * About 2-6 times faster with < 0.05% average error.
	 * 
	 * @param	n	The angle in radians.
	 * @return	An approximated sine of `n`.]]></haxe_doc>
		</fastSin>
		<fastCos public="1" get="inline" set="null" line="529" static="1">
			<f a="n">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc><![CDATA[* A faster, but less accurate version of `Math.cos()`.
	 * About 2-6 times faster with < 0.05% average error.
	 * 
	 * @param	n	The angle in radians.
	 * @return	An approximated cosine of `n`.]]></haxe_doc>
		</fastCos>
		<sinh public="1" get="inline" set="null" line="537" static="1">
			<f a="n">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>* Hyperbolic sine.</haxe_doc>
		</sinh>
		<maxInt public="1" get="inline" set="null" line="545" static="1">
			<f a="a:b">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>* Returns the bigger argument.</haxe_doc>
		</maxInt>
		<minInt public="1" get="inline" set="null" line="553" static="1">
			<f a="a:b">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>* Returns the smaller argument.</haxe_doc>
		</minInt>
		<absInt public="1" get="inline" set="null" line="561" static="1">
			<f a="n">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>* Returns the absolute integer value.</haxe_doc>
		</absInt>
		<haxe_doc>* A class containing a set of math-related functions.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="flixel.math.FlxMatrix" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/math/FlxMatrix.hx">
		<extends path="openfl.geom.Matrix"/>
		<rotateWithTrig public="1" get="inline" set="null" line="19">
			<f a="cos:sin">
				<x path="Float"/>
				<x path="Float"/>
				<c path="flixel.math.FlxMatrix"/>
			</f>
			<haxe_doc>* Rotates this matrix, but takes the values of sine and cosine,
	 * so it might be useful when you rotate multiple matrices by the same angle
	 * @param	cos	The cosine value for rotation angle
	 * @param	sin	The sine value for rotation angle
	 * @return	this transformed matrix</haxe_doc>
		</rotateWithTrig>
		<rotateBy180 public="1" get="inline" set="null" line="40">
			<f a=""><c path="flixel.math.FlxMatrix"/></f>
			<haxe_doc>* Adds 180 degrees to rotation of this matrix
	 * @return	rotated matrix</haxe_doc>
		</rotateBy180>
		<rotateByPositive90 public="1" get="inline" set="null" line="50">
			<f a=""><c path="flixel.math.FlxMatrix"/></f>
			<haxe_doc>* Adds 90 degrees to rotation of this matrix
	 * @return	rotated matrix</haxe_doc>
		</rotateByPositive90>
		<rotateByNegative90 public="1" get="inline" set="null" line="60">
			<f a=""><c path="flixel.math.FlxMatrix"/></f>
			<haxe_doc>* Subtract 90 degrees from rotation of this matrix
	 * @return	rotated matrix</haxe_doc>
		</rotateByNegative90>
		<transformX public="1" get="inline" set="null" line="76">
			<f a="px:py">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>* Transforms x coordinate of the point.
	 * Took original code from openfl.geom.Matrix (which isn't available on flash target).
	 * 
	 * @param	px	x coordinate of the point
	 * @param	py	y coordinate of the point
	 * @return	transformed x coordinate of the point
	 *
	 * @since 4.3.0</haxe_doc>
		</transformX>
		<transformY public="1" get="inline" set="null" line="91">
			<f a="px:py">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>* Transforms y coordinate of the point.
	 * Took original code from openfl.geom.Matrix (which isn't available on flash target).
	 * 
	 * @param	px	x coordinate of the point
	 * @param	py	y coordinate of the point
	 * @return	transformed y coordinate of the point
	 *
	 * @since 4.3.0</haxe_doc>
		</transformY>
		<new public="1" set="method" line="10"><f a="?a:?b:?c:?d:?tx:?ty">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>* Helper class for making fast matrix calculations for rendering.
 * It mostly copies Matrix class, but with some additions for
 * faster rotation by 90 degrees.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="flixel.math.FlxCallbackPoint" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/math/FlxPoint.hx" module="flixel.math.FlxPoint">
		<extends path="flixel.math.FlxPoint"/>
		<_setXCallback><f a="">
	<c path="flixel.math.FlxPoint"/>
	<x path="Void"/>
</f></_setXCallback>
		<_setYCallback><f a="">
	<c path="flixel.math.FlxPoint"/>
	<x path="Void"/>
</f></_setYCallback>
		<_setXYCallback><f a="">
	<c path="flixel.math.FlxPoint"/>
	<x path="Void"/>
</f></_setXYCallback>
		<set public="1" get="inline" set="null" line="497" override="1">
			<f a="?X:?Y" v="0:0">
				<x path="Float"/>
				<x path="Float"/>
				<c path="flixel.math.FlxCallbackPoint"/>
			</f>
			<meta><m n=":value"><e>{ Y : 0, X : 0 }</e></m></meta>
		</set>
		<set_x get="inline" set="null" line="505" override="1"><f a="Value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_x>
		<set_y get="inline" set="null" line="513" override="1"><f a="Value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_y>
		<destroy public="1" set="method" line="521" override="1"><f a=""><x path="Void"/></f></destroy>
		<put public="1" set="method" line="529" override="1"><f a=""><x path="Void"/></f></put>
		<new public="1" set="method" line="480">
			<f a="setXCallback:?setYCallback:?setXYCallback">
				<f a="">
					<c path="flixel.math.FlxPoint"/>
					<x path="Void"/>
				</f>
				<f a="">
					<c path="flixel.math.FlxPoint"/>
					<x path="Void"/>
				</f>
				<f a="">
					<c path="flixel.math.FlxPoint"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<haxe_doc>* If you only specify one callback function, then the remaining two will use the same.
	 * 
	 * @param	setXCallback	Callback for set_x()
	 * @param	setYCallback	Callback for set_y()
	 * @param	setXYCallback	Callback for set()</haxe_doc>
		</new>
		<haxe_doc>* A FlxPoint that calls a function when set_x(), set_y() or set() is called. Used in FlxSpriteGroup.
 * IMPORTANT: Calling set(x, y); is MUCH FASTER than setting x and y separately. Needs to be destroyed unlike simple FlxPoints!</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="flixel.math.FlxVector" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/math/FlxVector.hx">
		<extends path="flixel.math.FlxPoint"/>
		<EPSILON public="1" get="inline" set="null" expr="0.0000001" line="10" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>0.0000001</e></m></meta>
		</EPSILON>
		<EPSILON_SQUARED public="1" get="inline" set="null" expr="EPSILON * EPSILON" line="11" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>EPSILON * EPSILON</e></m></meta>
		</EPSILON_SQUARED>
		<_pool expr="new FlxPool&lt;FlxVector&gt;(FlxVector)" line="13" static="1">
			<c path="flixel.util.FlxPool_flixel_math_FlxVector"/>
			<meta><m n=":value"><e><![CDATA[new FlxPool<FlxVector>(FlxVector)]]></e></m></meta>
		</_pool>
		<_vector1 expr="new FlxVector()" line="15" static="1">
			<c path="flixel.math.FlxVector"/>
			<meta><m n=":value"><e>new FlxVector()</e></m></meta>
		</_vector1>
		<_vector2 expr="new FlxVector()" line="16" static="1">
			<c path="flixel.math.FlxVector"/>
			<meta><m n=":value"><e>new FlxVector()</e></m></meta>
		</_vector2>
		<_vector3 expr="new FlxVector()" line="17" static="1">
			<c path="flixel.math.FlxVector"/>
			<meta><m n=":value"><e>new FlxVector()</e></m></meta>
		</_vector3>
		<get public="1" get="inline" set="null" line="26" static="1">
			<f a="?X:?Y" v="0:0">
				<x path="Float"/>
				<x path="Float"/>
				<c path="flixel.math.FlxVector"/>
			</f>
			<meta><m n=":value"><e>{ Y : 0, X : 0 }</e></m></meta>
			<haxe_doc>* Recycle or create new FlxVector.
	 * Be sure to put() them back into the pool after you're done with them!
	 * 
	 * @param	X		The X-coordinate of the point in space.
	 * @param	Y		The Y-coordinate of the point in space.</haxe_doc>
		</get>
		<put public="1" set="method" line="36" override="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Add this FlxVector to the recycling pool.</haxe_doc>
		</put>
		<dx public="1" get="accessor" set="null">
			<x path="Float"/>
			<haxe_doc>* The horizontal component of the unit vector</haxe_doc>
		</dx>
		<dy public="1" get="accessor" set="null">
			<x path="Float"/>
			<haxe_doc>* The vertical component of the unit vector</haxe_doc>
		</dy>
		<length public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<haxe_doc>* Length of the vector</haxe_doc>
		</length>
		<lengthSquared public="1" get="accessor" set="null">
			<x path="Float"/>
			<haxe_doc>* length of the vector squared</haxe_doc>
		</lengthSquared>
		<degrees public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<haxe_doc>* The angle formed by the vector with the horizontal axis (in degrees)</haxe_doc>
		</degrees>
		<radians public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<haxe_doc>* The angle formed by the vector with the horizontal axis (in radians)</haxe_doc>
		</radians>
		<rx public="1" get="accessor" set="null">
			<x path="Float"/>
			<haxe_doc>* The horizontal component of the right normal of the vector</haxe_doc>
		</rx>
		<ry public="1" get="accessor" set="null">
			<x path="Float"/>
			<haxe_doc>* The vertical component of the right normal of the vector</haxe_doc>
		</ry>
		<lx public="1" get="accessor" set="null">
			<x path="Float"/>
			<haxe_doc>* The horizontal component of the left normal of the vector</haxe_doc>
		</lx>
		<ly public="1" get="accessor" set="null">
			<x path="Float"/>
			<haxe_doc>* The vertical component of the left normal of the vector</haxe_doc>
		</ly>
		<set public="1" set="method" line="92" override="1">
			<f a="?X:?Y" v="0:0">
				<x path="Float"/>
				<x path="Float"/>
				<c path="flixel.math.FlxVector"/>
			</f>
			<meta><m n=":value"><e>{ Y : 0, X : 0 }</e></m></meta>
			<haxe_doc>* Set the coordinates of this point object.
	 * 
	 * @param	X		The X-coordinate of the point in space.
	 * @param	Y		The Y-coordinate of the point in space.</haxe_doc>
		</set>
		<scale public="1" set="method" line="105" override="1">
			<f a="k">
				<x path="Float"/>
				<c path="flixel.math.FlxVector"/>
			</f>
			<haxe_doc>* Scale this vector.
	 * 
	 * @param	k - scale coefficient
	 * @return	scaled vector</haxe_doc>
		</scale>
		<scaleNew public="1" get="inline" set="null" line="117">
			<f a="k">
				<x path="Float"/>
				<c path="flixel.math.FlxVector"/>
			</f>
			<haxe_doc>* Returns scaled copy of this vector.
	 * 
	 * @param	k - scale coefficient
	 * @return	scaled vector</haxe_doc>
		</scaleNew>
		<addNew public="1" get="inline" set="null" line="128">
			<f a="v">
				<c path="flixel.math.FlxVector"/>
				<c path="flixel.math.FlxVector"/>
			</f>
			<haxe_doc>* Return new vector which equals to sum of this vector and passed v vector.
	 * 
	 * @param	v	vector to add
	 * @return	addition result</haxe_doc>
		</addNew>
		<subtractNew public="1" get="inline" set="null" line="141">
			<f a="v">
				<c path="flixel.math.FlxVector"/>
				<c path="flixel.math.FlxVector"/>
			</f>
			<haxe_doc>* Returns new vector which is result of subtraction of v vector from this vector.
	 * 
	 * @param	v	vector to subtract
	 * @return	subtraction result</haxe_doc>
		</subtractNew>
		<dotProduct public="1" get="inline" set="null" line="154">
			<f a="v">
				<c path="flixel.math.FlxVector"/>
				<x path="Float"/>
			</f>
			<haxe_doc>* Dot product between two vectors.
	 * 
	 * @param	v	vector to multiply
	 * @return	dot product of two vectors</haxe_doc>
		</dotProduct>
		<dotProdWithNormalizing public="1" get="inline" set="null" line="165">
			<f a="v">
				<c path="flixel.math.FlxVector"/>
				<x path="Float"/>
			</f>
			<haxe_doc>* Dot product of vectors with normalization of the second vector.
	 * 
	 * @param	v	vector to multiply
	 * @return	dot product of two vectors</haxe_doc>
		</dotProdWithNormalizing>
		<isPerpendicular public="1" get="inline" set="null" line="177">
			<f a="v">
				<c path="flixel.math.FlxVector"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Check the perpendicularity of two vectors.
	 * 
	 * @param	v	vector to check
	 * @return	true - if they are perpendicular</haxe_doc>
		</isPerpendicular>
		<crossProductLength public="1" get="inline" set="null" line="188">
			<f a="v">
				<c path="flixel.math.FlxVector"/>
				<x path="Float"/>
			</f>
			<haxe_doc>* Find the length of cross product between two vectors.
	 * 
	 * @param	v	vector to multiply
	 * @return	the length of cross product of two vectors</haxe_doc>
		</crossProductLength>
		<isParallel public="1" get="inline" set="null" line="199">
			<f a="v">
				<c path="flixel.math.FlxVector"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Check for parallelism of two vectors.
	 * 
	 * @param	v	vector to check
	 * @return	true - if they are parallel</haxe_doc>
		</isParallel>
		<isZero public="1" get="inline" set="null" line="209">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>* Check if this vector has zero length.
	 * 
	 * @return	true - if the vector is zero</haxe_doc>
		</isZero>
		<zero public="1" get="inline" set="null" line="217">
			<f a=""><c path="flixel.math.FlxVector"/></f>
			<haxe_doc>* Vector reset</haxe_doc>
		</zero>
		<normalize public="1" set="method" line="226">
			<f a=""><c path="flixel.math.FlxVector"/></f>
			<haxe_doc>* Normalization of the vector (reduction to unit length)</haxe_doc>
		</normalize>
		<isNormalized public="1" get="inline" set="null" line="238">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>* Check the vector for unit length</haxe_doc>
		</isNormalized>
		<rotateByRadians public="1" get="inline" set="null" line="249">
			<f a="rads">
				<x path="Float"/>
				<c path="flixel.math.FlxVector"/>
			</f>
			<haxe_doc>* Rotate the vector for a given angle.
	 * 
	 * @param	rads	angle to rotate
	 * @return	rotated vector</haxe_doc>
		</rotateByRadians>
		<rotateByDegrees public="1" get="inline" set="null" line="267">
			<f a="degs">
				<x path="Float"/>
				<c path="flixel.math.FlxVector"/>
			</f>
			<haxe_doc>* Rotate the vector for a given angle.
	 * 
	 * @param	degs	angle to rotate
	 * @return	rotated vector</haxe_doc>
		</rotateByDegrees>
		<rotateWithTrig public="1" get="inline" set="null" line="279">
			<f a="sin:cos">
				<x path="Float"/>
				<x path="Float"/>
				<c path="flixel.math.FlxVector"/>
			</f>
			<haxe_doc>* Rotate the vector with the values of sine and cosine of the angle of rotation.
	 * 
	 * @param	sin	the value of sine of the angle of rotation
	 * @param	cos	the value of cosine of the angle of rotation
	 * @return	rotated vector</haxe_doc>
		</rotateWithTrig>
		<rightNormal public="1" set="method" line="290">
			<f a="?vec">
				<c path="flixel.math.FlxVector"/>
				<c path="flixel.math.FlxVector"/>
			</f>
			<haxe_doc>* Right normal of the vector</haxe_doc>
		</rightNormal>
		<leftNormal public="1" set="method" line="303">
			<f a="?vec">
				<c path="flixel.math.FlxVector"/>
				<c path="flixel.math.FlxVector"/>
			</f>
			<haxe_doc>* Left normal of the vector</haxe_doc>
		</leftNormal>
		<negate public="1" get="inline" set="null" line="316">
			<f a=""><c path="flixel.math.FlxVector"/></f>
			<haxe_doc>* Change direction of the vector to opposite</haxe_doc>
		</negate>
		<negateNew public="1" get="inline" set="null" line="323"><f a=""><c path="flixel.math.FlxVector"/></f></negateNew>
		<projectTo public="1" set="method" line="336">
			<f a="v:?proj">
				<c path="flixel.math.FlxVector"/>
				<c path="flixel.math.FlxVector"/>
				<c path="flixel.math.FlxVector"/>
			</f>
			<haxe_doc>* The projection of this vector to vector that is passed as an argument 
	 * (without modifying the original Vector!).
	 * 
	 * @param	v	vector to project
	 * @param	proj	optional argument - result vector
	 * @return	projection of the vector</haxe_doc>
		</projectTo>
		<projectToNormalized public="1" set="method" line="356">
			<f a="v:?proj">
				<c path="flixel.math.FlxVector"/>
				<c path="flixel.math.FlxVector"/>
				<c path="flixel.math.FlxVector"/>
			</f>
			<haxe_doc>* Projecting this vector on the normalized vector v.
	 * 
	 * @param	v	this vector has to be normalized, ie have unit length
	 * @param	proj	optional argument - result vector
	 * @return	projection of the vector</haxe_doc>
		</projectToNormalized>
		<perpProduct public="1" get="inline" set="null" line="371">
			<f a="v">
				<c path="flixel.math.FlxVector"/>
				<x path="Float"/>
			</f>
			<haxe_doc>* Dot product of left the normal vector and vector v</haxe_doc>
		</perpProduct>
		<ratio public="1" set="method" line="384">
			<f a="a:b:v">
				<c path="flixel.math.FlxVector"/>
				<c path="flixel.math.FlxVector"/>
				<c path="flixel.math.FlxVector"/>
				<x path="Float"/>
			</f>
			<haxe_doc>* Find the ratio between the perpProducts of this vector and v vector. This helps to find the intersection point.
	 * 
	 * @param	a	start point of the vector
	 * @param	b	start point of the v vector
	 * @param	v	the second vector
	 * @return	the ratio between the perpProducts of this vector and v vector</haxe_doc>
		</ratio>
		<findIntersection public="1" set="method" line="403">
			<f a="a:b:v:?intersection">
				<c path="flixel.math.FlxVector"/>
				<c path="flixel.math.FlxVector"/>
				<c path="flixel.math.FlxVector"/>
				<c path="flixel.math.FlxVector"/>
				<c path="flixel.math.FlxVector"/>
			</f>
			<haxe_doc>* Finding the point of intersection of vectors.
	 * 
	 * @param	a	start point of the vector
	 * @param	b	start point of the v vector
	 * @param	v	the second vector
	 * @return the point of intersection of vectors</haxe_doc>
		</findIntersection>
		<findIntersectionInBounds public="1" set="method" line="428">
			<f a="a:b:v:?intersection">
				<c path="flixel.math.FlxVector"/>
				<c path="flixel.math.FlxVector"/>
				<c path="flixel.math.FlxVector"/>
				<c path="flixel.math.FlxVector"/>
				<c path="flixel.math.FlxVector"/>
			</f>
			<haxe_doc>* Finding the point of intersection of vectors if it is in the "bounds" of the vectors.
	 * 
	 * @param	a	start point of the vector
	 * @param	b	start point of the v vector
	 * @param	v	the second vector
	 * @return the point of intersection of vectors if it is in the "bounds" of the vectors</haxe_doc>
		</findIntersectionInBounds>
		<truncate public="1" get="inline" set="null" line="450">
			<f a="max">
				<x path="Float"/>
				<c path="flixel.math.FlxVector"/>
			</f>
			<haxe_doc>* Limit the length of this vector.
	 * 
	 * @param	max	maximum length of this vector</haxe_doc>
		</truncate>
		<radiansBetween public="1" get="inline" set="null" line="462">
			<f a="v">
				<c path="flixel.math.FlxVector"/>
				<x path="Float"/>
			</f>
			<haxe_doc>* Get the angle between vectors (in radians).
	 * 
	 * @param	v	second vector, which we find the angle
	 * @return	the angle in radians</haxe_doc>
		</radiansBetween>
		<degreesBetween public="1" get="inline" set="null" line="473">
			<f a="v">
				<c path="flixel.math.FlxVector"/>
				<x path="Float"/>
			</f>
			<haxe_doc>* The angle between vectors (in degrees).
	 * 
	 * @param	v	second vector, which we find the angle
	 * @return	the angle in radians</haxe_doc>
		</degreesBetween>
		<sign public="1" set="method" line="484">
			<f a="a:b">
				<c path="flixel.math.FlxVector"/>
				<c path="flixel.math.FlxVector"/>
				<x path="Int"/>
			</f>
			<haxe_doc>* The sign of half-plane of point with respect to the vector through the a and b points.
	 * 
	 * @param	a	start point of the wall-vector
	 * @param	b	end point of the wall-vector</haxe_doc>
		</sign>
		<dist public="1" get="inline" set="null" line="497">
			<f a="v">
				<c path="flixel.math.FlxVector"/>
				<x path="Float"/>
			</f>
			<haxe_doc>* The distance between points</haxe_doc>
		</dist>
		<distSquared public="1" get="inline" set="null" line="505">
			<f a="v">
				<c path="flixel.math.FlxVector"/>
				<x path="Float"/>
			</f>
			<haxe_doc>* The squared distance between points</haxe_doc>
		</distSquared>
		<bounce public="1" get="inline" set="null" line="519">
			<f a="normal:?bounceCoeff" v=":1">
				<c path="flixel.math.FlxVector"/>
				<x path="Float"/>
				<c path="flixel.math.FlxVector"/>
			</f>
			<meta><m n=":value"><e>{ bounceCoeff : 1 }</e></m></meta>
			<haxe_doc><![CDATA[* Reflect the vector with respect to the normal of the "wall".
	 * 
	 * @param normal left normal of the "wall". It must be normalized (no checks)
	 * @param bounceCoeff bounce coefficient (0 <= bounceCoeff <= 1)
	 * @return reflected vector (angle of incidence equals to angle of reflection)]]></haxe_doc>
		</bounce>
		<bounceWithFriction public="1" get="inline" set="null" line="535">
			<f a="normal:?bounceCoeff:?friction" v=":1:0">
				<c path="flixel.math.FlxVector"/>
				<x path="Float"/>
				<x path="Float"/>
				<c path="flixel.math.FlxVector"/>
			</f>
			<meta><m n=":value"><e>{ friction : 0, bounceCoeff : 1 }</e></m></meta>
			<haxe_doc><![CDATA[* Reflect the vector with respect to the normal. This operation takes "friction" into account.
	 * 
	 * @param normal left normal of the "wall". It must be normalized (no checks)
	 * @param bounceCoeff bounce coefficient (0 <= bounceCoeff <= 1)
	 * @param friction friction coefficient
	 * @return reflected vector]]></haxe_doc>
		</bounceWithFriction>
		<isValid public="1" get="inline" set="null" line="553">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>* Checking if this is a valid vector.
	 * 
	 * @return	true - if the vector is valid</haxe_doc>
		</isValid>
		<clone public="1" set="method" line="564">
			<f a="?vec">
				<c path="flixel.math.FlxVector"/>
				<c path="flixel.math.FlxVector"/>
			</f>
			<haxe_doc>* Copies this vector.
	 * 
	 * @param	vec		optional vector to copy this vector to
	 * @return	copy	of this vector</haxe_doc>
		</clone>
		<get_dx get="inline" set="null" line="576"><f a=""><x path="Float"/></f></get_dx>
		<get_dy get="inline" set="null" line="583"><f a=""><x path="Float"/></f></get_dy>
		<get_length get="inline" set="null" line="590"><f a=""><x path="Float"/></f></get_length>
		<set_length get="inline" set="null" line="595"><f a="l">
	<x path="Float"/>
	<x path="Float"/>
</f></set_length>
		<get_lengthSquared get="inline" set="null" line="606"><f a=""><x path="Float"/></f></get_lengthSquared>
		<get_degrees get="inline" set="null" line="611"><f a=""><x path="Float"/></f></get_degrees>
		<set_degrees get="inline" set="null" line="616"><f a="degs">
	<x path="Float"/>
	<x path="Float"/>
</f></set_degrees>
		<get_radians set="method" line="622"><f a=""><x path="Float"/></f></get_radians>
		<set_radians get="inline" set="null" line="629"><f a="rads">
	<x path="Float"/>
	<x path="Float"/>
</f></set_radians>
		<get_rx get="inline" set="null" line="638"><f a=""><x path="Float"/></f></get_rx>
		<get_ry get="inline" set="null" line="643"><f a=""><x path="Float"/></f></get_ry>
		<get_lx get="inline" set="null" line="648"><f a=""><x path="Float"/></f></get_lx>
		<get_ly get="inline" set="null" line="653"><f a=""><x path="Float"/></f></get_ly>
		<new public="1" set="method" line="8"><f a="?X:?Y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>* 2-dimensional vector class</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="flixel.math.FlxVelocity" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/math/FlxVelocity.hx">
		<moveTowardsObject public="1" set="method" line="23" static="1">
			<f a="Source:Dest:?Speed:?MaxTime" v="::60:0">
				<c path="flixel.FlxSprite"/>
				<c path="flixel.FlxSprite"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ MaxTime : 0, Speed : 60 }</e></m></meta>
			<haxe_doc>* Sets the source FlxSprite x/y velocity so it will move directly towards the destination FlxSprite at the speed given (in pixels per second)
	 * If you specify a maxTime then it will adjust the speed (over-writing what you set) so it arrives at the destination in that number of seconds.
	 * Timings are approximate due to the way Flash timers work, and irrespective of SWF frame rate. Allow for a variance of +- 50ms.
	 * The source object doesn't stop moving automatically should it ever reach the destination coordinates.
	 * If you need the object to accelerate, see accelerateTowardsObject() instead
	 * Note: Doesn't take into account acceleration, maxVelocity or drag (if you set drag or acceleration too high this object may not move at all)
	 * 
	 * @param	Source		The FlxSprite on which the velocity will be set
	 * @param	Dest		The FlxSprite where the source object will move to
	 * @param	Speed		The speed it will move, in pixels per second (default is 60 pixels/sec)
	 * @param	MaxTime		Time given in milliseconds (1000 = 1 sec). If set the speed is adjusted so the source will arrive at destination in the given number of ms</haxe_doc>
		</moveTowardsObject>
		<accelerateTowardsObject public="1" set="method" line="49" static="1">
			<f a="Source:Dest:Acceleration:MaxSpeed">
				<c path="flixel.FlxSprite"/>
				<c path="flixel.FlxSprite"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Sets the x/y acceleration on the source FlxSprite so it will move towards the destination FlxSprite at the speed given (in pixels per second)
	 * You must give a maximum speed value, beyond which the FlxSprite won't go any faster.
	 * If you don't need acceleration look at moveTowardsObject() instead.
	 * 
	 * @param	Source			The FlxSprite on which the acceleration will be set
	 * @param	Dest			The FlxSprite where the source object will move towards
	 * @param	Acceleration	The speed it will accelerate in pixels per second
	 * @param	MaxSpeed		The maximum speed in pixels per second in which the sprite can move</haxe_doc>
		</accelerateTowardsObject>
		<moveTowardsMouse public="1" set="method" line="66" static="1">
			<f a="Source:?Speed:?MaxTime" v=":60:0">
				<c path="flixel.FlxSprite"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ MaxTime : 0, Speed : 60 }</e></m></meta>
			<haxe_doc>* Move the given FlxSprite towards the mouse pointer coordinates at a steady velocity
	 * If you specify a maxTime then it will adjust the speed (over-writing what you set) so it arrives at the destination in that number of seconds.
	 * Timings are approximate due to the way Flash timers work, and irrespective of SWF frame rate. Allow for a variance of +- 50ms.
	 * The source object doesn't stop moving automatically should it ever reach the destination coordinates.
	 * 
	 * @param	Source		The FlxSprite to move
	 * @param	Speed		The speed it will move, in pixels per second (default is 60 pixels/sec)
	 * @param	MaxTime		Time given in milliseconds (1000 = 1 sec). If set the speed is adjusted so the source will arrive at destination in the given number of ms</haxe_doc>
		</moveTowardsMouse>
		<moveTowardsTouch public="1" set="method" line="94" static="1">
			<f a="Source:Touch:?Speed:?MaxTime" v="::60:0">
				<c path="flixel.FlxSprite"/>
				<c path="flixel.input.touch.FlxTouch"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ MaxTime : 0, Speed : 60 }</e></m></meta>
			<haxe_doc>* Move the given FlxSprite towards a FlxTouch point at a steady velocity
	 * If you specify a maxTime then it will adjust the speed (over-writing what you set) so it arrives at the destination in that number of seconds.
	 * Timings are approximate due to the way Flash timers work, and irrespective of SWF frame rate. Allow for a variance of +- 50ms.
	 * The source object doesn't stop moving automatically should it ever reach the destination coordinates.
	 * 
	 * @param	source			The FlxSprite to move
	 * @param	speed				The speed it will move, in pixels per second (default is 60 pixels/sec)
	 * @param	maxTime		Time given in milliseconds (1000 = 1 sec). If set the speed is adjusted so the source will arrive at destination in the given number of ms</haxe_doc>
		</moveTowardsTouch>
		<accelerateTowardsMouse public="1" set="method" line="121" static="1">
			<f a="Source:Acceleration:MaxSpeed">
				<c path="flixel.FlxSprite"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Sets the x/y acceleration on the source FlxSprite so it will move towards the mouse coordinates at the speed given (in pixels per second)
	 * You must give a maximum speed value, beyond which the FlxSprite won't go any faster.
	 * If you don't need acceleration look at moveTowardsMouse() instead.
	 * 
	 * @param	Source			The FlxSprite on which the acceleration will be set
	 * @param	Acceleration			The speed it will accelerate in pixels per second
	 * @param	MaxSpeed		The maximum speed in pixels per second in which the sprite can move</haxe_doc>
		</accelerateTowardsMouse>
		<accelerateTowardsTouch public="1" set="method" line="140" static="1">
			<f a="Source:Touch:Acceleration:MaxSpeed">
				<c path="flixel.FlxSprite"/>
				<c path="flixel.input.touch.FlxTouch"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Sets the x/y acceleration on the source FlxSprite so it will move towards a FlxTouch at the speed given (in pixels per second)
	 * You must give a maximum speed value, beyond which the FlxSprite won't go any faster.
	 * If you don't need acceleration look at moveTowardsMouse() instead.
	 * 
	 * @param	Source			The FlxSprite on which the acceleration will be set
	 * @param	Touch			The FlxTouch on which to accelerate towards
	 * @param	Acceleration	The speed it will accelerate in pixels per second
	 * @param	MaxSpeed		The maximum speed in pixels per second in which the sprite can move</haxe_doc>
		</accelerateTowardsTouch>
		<moveTowardsPoint public="1" set="method" line="159" static="1">
			<f a="Source:Target:?Speed:?MaxTime" v="::60:0">
				<c path="flixel.FlxSprite"/>
				<c path="flixel.math.FlxPoint"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ MaxTime : 0, Speed : 60 }</e></m></meta>
			<haxe_doc>* Sets the x/y velocity on the source FlxSprite so it will move towards the target coordinates at the speed given (in pixels per second)
	 * If you specify a maxTime then it will adjust the speed (over-writing what you set) so it arrives at the destination in that number of seconds.
	 * Timings are approximate due to the way Flash timers work, and irrespective of SWF frame rate. Allow for a variance of +- 50ms.
	 * The source object doesn't stop moving automatically should it ever reach the destination coordinates.
	 * 
	 * @param	Source		The FlxSprite to move
	 * @param	Target		The FlxPoint coordinates to move the source FlxSprite towards
	 * @param	Speed		The speed it will move, in pixels per second (default is 60 pixels/sec)
	 * @param	MaxTime		Time given in milliseconds (1000 = 1 sec). If set the speed is adjusted so the source will arrive at destination in the given number of ms</haxe_doc>
		</moveTowardsPoint>
		<accelerateTowardsPoint public="1" set="method" line="187" static="1">
			<f a="Source:Target:Acceleration:MaxSpeed">
				<c path="flixel.FlxSprite"/>
				<c path="flixel.math.FlxPoint"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Sets the x/y acceleration on the source FlxSprite so it will move towards the target coordinates at the speed given (in pixels per second)
	 * You must give a maximum speed value, beyond which the FlxSprite won't go any faster.
	 * If you don't need acceleration look at moveTowardsPoint() instead.
	 * 
	 * @param	Source			The FlxSprite on which the acceleration will be set
	 * @param	Target			The FlxPoint coordinates to move the source FlxSprite towards
	 * @param	Acceleration	The speed it will accelerate in pixels per second
	 * @param	MaxSpeed		The maximum speed in pixels per second in which the sprite can move</haxe_doc>
		</accelerateTowardsPoint>
		<velocityFromAngle public="1" get="inline" set="null" line="203" static="1">
			<f a="Angle:Speed">
				<x path="Float"/>
				<x path="Float"/>
				<c path="flixel.math.FlxPoint"/>
			</f>
			<haxe_doc>* Given the angle and speed calculate the velocity and return it as an FlxPoint
	 * 
	 * @param	Angle	The angle (in degrees) calculated in clockwise positive direction (down = 90 degrees positive, right = 0 degrees positive, up = 90 degrees negative)
	 * @param	Speed	The speed it will move, in pixels per second sq
	 * @return	A FlxPoint where FlxPoint.x contains the velocity x value and FlxPoint.y contains the velocity y value</haxe_doc>
		</velocityFromAngle>
		<velocityFromFacing public="1" set="method" line="217" static="1">
			<f a="Parent:Speed">
				<c path="flixel.FlxSprite"/>
				<x path="Float"/>
				<c path="flixel.math.FlxPoint"/>
			</f>
			<haxe_doc>* Given the FlxSprite and speed calculate the velocity and return it as an FlxPoint based on the direction the sprite is facing
	 * 
	 * @param	Parent	The FlxSprite to get the facing value from
	 * @param	Speed	The speed it will move, in pixels per second
	 * @return	An FlxPoint where FlxPoint.x contains the velocity x value and FlxPoint.y contains the velocity y value</haxe_doc>
		</velocityFromFacing>
		<computeVelocity public="1" set="method" line="233" static="1">
			<f a="Velocity:Acceleration:Drag:Max:Elapsed">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>* A tween-like function that takes a starting velocity and some other factors and returns an altered velocity.
	 * 
	 * @param	Velocity		Any component of velocity (e.g. 20).
	 * @param	Acceleration		Rate at which the velocity is changing.
	 * @param	Drag			Really kind of a deceleration, this is how much the velocity changes if Acceleration is not set.
	 * @param	Max				An absolute value cap for the velocity (0 for no cap).
	 * @param	Elapsed			The amount of time passed in to the latest update cycle
	 * @return	The altered Velocity value.</haxe_doc>
		</computeVelocity>
		<accelerateFromAngle public="1" get="inline" set="null" line="279" static="1">
			<f a="source:radians:acceleration:maxSpeed:?resetVelocity" v="::::true">
				<c path="flixel.FlxSprite"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ resetVelocity : true }</e></m></meta>
			<haxe_doc>* Sets the x/y acceleration on the source FlxSprite so it will accelerate in the direction of the specified angle.
	 * You must give a maximum speed value (in pixels per second), beyond which the FlxSprite won't go any faster.
	 * 
	 * @param	Source			The FlxSprite on which the acceleration will be set
	 * @param	Radians			The angle in which the FlxPoint will be set to accelerate
	 * @param	Acceleration	The speed it will accelerate in pixels per second
	 * @param	MaxSpeed		The maximum speed in pixels per second in which the sprite can move
	 * @param	ResetVelocity	Whether to reset the FlxSprite velocity to 0 each time</haxe_doc>
		</accelerateFromAngle>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="flixel.system.GraphicLogo" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/system/FlxAssets.hx" module="flixel.system.FlxAssets">
		<extends path="openfl.display.BitmapData"/>
		<resourceName expr="&quot;__ASSET__:bitmap_flixel_system_GraphicLogo&quot;" line="1" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"__ASSET__:bitmap_flixel_system_GraphicLogo"</e></m></meta>
		</resourceName>
		<new public="1" set="method" line="1">
			<f a="width:height:?transparent:?fillRGBA" v="::true:0xFFFFFFFF">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ fillRGBA : 0xFFFFFFFF, transparent : true }</e></m></meta>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>openfl.Assets.embedBitmap()</e></m>
			<m n=":autoBuild"><e>openfl.Assets.embedBitmap()</e></m>
			<m n=":keep"/>
			<m n=":bitmap"><e>"assets/images/logo/logo.png"</e></m>
		</meta>
	</class>
	<class path="flixel.system.GraphicVirtualInput" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/system/FlxAssets.hx" module="flixel.system.FlxAssets">
		<extends path="openfl.display.BitmapData"/>
		<resourceName expr="&quot;__ASSET__:bitmap_flixel_system_GraphicVirtualInput&quot;" line="1" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"__ASSET__:bitmap_flixel_system_GraphicVirtualInput"</e></m></meta>
		</resourceName>
		<new public="1" set="method" line="1">
			<f a="width:height:?transparent:?fillRGBA" v="::true:0xFFFFFFFF">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ fillRGBA : 0xFFFFFFFF, transparent : true }</e></m></meta>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>openfl.Assets.embedBitmap()</e></m>
			<m n=":autoBuild"><e>openfl.Assets.embedBitmap()</e></m>
			<m n=":keep"/>
			<m n=":bitmap"><e>"assets/images/ui/virtual-input.png"</e></m>
		</meta>
	</class>
	<class path="haxe.io.Bytes" params="" file="D:\HaxeToolkit\haxe\std/haxe/io/Bytes.hx">
		<alloc public="1" set="method" line="462" static="1">
			<f a="length">
				<x path="Int"/>
				<c path="haxe.io.Bytes"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</alloc>
		<ofString public="1" set="method" line="490" static="1">
			<f a="s">
				<c path="String"/>
				<c path="haxe.io.Bytes"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</ofString>
		<ofData public="1" set="method" line="551" static="1">
			<f a="b">
				<t path="haxe.io.BytesData"/>
				<c path="haxe.io.Bytes"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</ofData>
		<length public="1" set="null"><x path="Int"/></length>
		<b><t path="haxe.io.BytesData"/></b>
		<blit public="1" set="method" line="79">
			<f a="pos:src:srcpos:len">
				<x path="Int"/>
				<c path="haxe.io.Bytes"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</blit>
		<sub public="1" set="method" line="133">
			<f a="pos:len">
				<x path="Int"/>
				<x path="Int"/>
				<c path="haxe.io.Bytes"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</sub>
		<getDouble public="1" set="method" line="213">
			<f a="pos">
				<x path="Int"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the IEEE double precision value at given position (in low endian encoding).
		Result is unspecified if reading outside of the bounds</haxe_doc>
		</getDouble>
		<getFloat public="1" set="method" line="232">
			<f a="pos">
				<x path="Int"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the IEEE single precision value at given position (in low endian encoding).
		Result is unspecified if reading outside of the bounds</haxe_doc>
		</getFloat>
		<setDouble public="1" set="method" line="252">
			<f a="pos:v">
				<x path="Int"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Store the IEEE double precision value at given position in low endian encoding.
		Result is unspecified if writing outside of the bounds.</haxe_doc>
		</setDouble>
		<setFloat public="1" set="method" line="275">
			<f a="pos:v">
				<x path="Int"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Store the IEEE single precision value at given position in low endian encoding.
		Result is unspecified if writing outside of the bounds.</haxe_doc>
		</setFloat>
		<getString public="1" set="method" line="360">
			<f a="pos:len">
				<x path="Int"/>
				<x path="Int"/>
				<c path="String"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</getString>
		<toString public="1" set="method" line="423">
			<f a=""><c path="String"/></f>
			<meta><m n=":has_untyped"/></meta>
		</toString>
		<new set="method" line="33"><f a="length:b">
	<x path="Int"/>
	<t path="haxe.io.BytesData"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="openfl.utils.IDataOutput" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/utils/IDataOutput.hx" interface="1">
		<get_endian public="1" set="method">
			<f a=""><x path="openfl.utils.Endian"/></f>
			<meta><m n=":compilerGenerated"/></meta>
		</get_endian>
		<set_endian public="1" set="method">
			<f a="value">
				<x path="openfl.utils.Endian"/>
				<x path="openfl.utils.Endian"/>
			</f>
			<meta><m n=":compilerGenerated"/></meta>
		</set_endian>
		<endian public="1" get="accessor" set="accessor"><x path="openfl.utils.Endian"/></endian>
		<objectEncoding public="1"><x path="UInt"/></objectEncoding>
		<writeBoolean public="1" set="method"><f a="value">
	<x path="Bool"/>
	<x path="Void"/>
</f></writeBoolean>
		<writeByte public="1" set="method"><f a="value">
	<x path="Int"/>
	<x path="Void"/>
</f></writeByte>
		<writeBytes public="1" set="method">
			<f a="bytes:?offset:?length" v=":0:0">
				<x path="openfl.utils.ByteArray"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ length : 0, offset : 0 }</e></m></meta>
		</writeBytes>
		<writeDouble public="1" set="method"><f a="value">
	<x path="Float"/>
	<x path="Void"/>
</f></writeDouble>
		<writeFloat public="1" set="method"><f a="value">
	<x path="Float"/>
	<x path="Void"/>
</f></writeFloat>
		<writeInt public="1" set="method"><f a="value">
	<x path="Int"/>
	<x path="Void"/>
</f></writeInt>
		<writeMultiByte public="1" set="method"><f a="value:charSet">
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></writeMultiByte>
		<writeShort public="1" set="method"><f a="value">
	<x path="Int"/>
	<x path="Void"/>
</f></writeShort>
		<writeUTF public="1" set="method"><f a="value">
	<c path="String"/>
	<x path="Void"/>
</f></writeUTF>
		<writeUTFBytes public="1" set="method"><f a="value">
	<c path="String"/>
	<x path="Void"/>
</f></writeUTFBytes>
		<writeUnsignedInt public="1" set="method"><f a="value">
	<x path="Int"/>
	<x path="Void"/>
</f></writeUnsignedInt>
	</class>
	<class path="openfl.utils.IDataInput" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/utils/IDataInput.hx" interface="1">
		<get_bytesAvailable public="1" set="method">
			<f a=""><x path="UInt"/></f>
			<meta><m n=":compilerGenerated"/></meta>
		</get_bytesAvailable>
		<get_endian public="1" set="method">
			<f a=""><x path="openfl.utils.Endian"/></f>
			<meta><m n=":compilerGenerated"/></meta>
		</get_endian>
		<set_endian public="1" set="method">
			<f a="value">
				<x path="openfl.utils.Endian"/>
				<x path="openfl.utils.Endian"/>
			</f>
			<meta><m n=":compilerGenerated"/></meta>
		</set_endian>
		<bytesAvailable public="1" get="accessor" set="null"><x path="UInt"/></bytesAvailable>
		<endian public="1" get="accessor" set="accessor"><x path="openfl.utils.Endian"/></endian>
		<objectEncoding public="1"><x path="UInt"/></objectEncoding>
		<readBoolean public="1" set="method"><f a=""><x path="Bool"/></f></readBoolean>
		<readByte public="1" set="method"><f a=""><x path="Int"/></f></readByte>
		<readBytes public="1" set="method">
			<f a="bytes:?offset:?length" v=":0:0">
				<x path="openfl.utils.ByteArray"/>
				<x path="UInt"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ length : 0, offset : 0 }</e></m></meta>
		</readBytes>
		<readDouble public="1" set="method"><f a=""><x path="Float"/></f></readDouble>
		<readFloat public="1" set="method"><f a=""><x path="Float"/></f></readFloat>
		<readInt public="1" set="method"><f a=""><x path="Int"/></f></readInt>
		<readMultiByte public="1" set="method"><f a="length:charSet">
	<x path="UInt"/>
	<c path="String"/>
	<c path="String"/>
</f></readMultiByte>
		<readShort public="1" set="method"><f a=""><x path="Int"/></f></readShort>
		<readUnsignedByte public="1" set="method"><f a=""><x path="Int"/></f></readUnsignedByte>
		<readUnsignedInt public="1" set="method"><f a=""><x path="Int"/></f></readUnsignedInt>
		<readUnsignedShort public="1" set="method"><f a=""><x path="Int"/></f></readUnsignedShort>
		<readUTF public="1" set="method"><f a=""><c path="String"/></f></readUTF>
		<readUTFBytes public="1" set="method"><f a="length">
	<x path="Int"/>
	<c path="String"/>
</f></readUTFBytes>
	</class>
	<class path="openfl.utils.ByteArrayData" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/utils/ByteArray.hx" module="openfl.utils.ByteArray">
		<extends path="haxe.io.Bytes"/>
		<implements path="openfl.utils.IDataOutput"/>
		<implements path="openfl.utils.IDataInput"/>
		<fromBytes public="1" set="method" line="312" static="1"><f a="bytes">
	<c path="haxe.io.Bytes"/>
	<c path="openfl.utils.ByteArrayData"/>
</f></fromBytes>
		<bytesAvailable public="1" get="accessor" set="null"><x path="UInt"/></bytesAvailable>
		<endian public="1" get="accessor" set="accessor"><x path="openfl.utils.Endian"/></endian>
		<objectEncoding public="1"><x path="UInt"/></objectEncoding>
		<position public="1"><x path="Int"/></position>
		<__endian><x path="openfl.utils.Endian"/></__endian>
		<__length><x path="Int"/></__length>
		<clear public="1" set="method" line="257"><f a=""><x path="Void"/></f></clear>
		<compress public="1" set="method" line="265">
			<f a="?algorithm" v="null">
				<x path="openfl.utils.CompressionAlgorithm"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ algorithm : null }</e></m></meta>
		</compress>
		<deflate public="1" set="method" line="305"><f a=""><x path="Void"/></f></deflate>
		<inflate public="1" set="method" line="321"><f a=""><x path="Void"/></f></inflate>
		<readBoolean public="1" set="method" line="328"><f a=""><x path="Bool"/></f></readBoolean>
		<readByte public="1" set="method" line="344"><f a=""><x path="Int"/></f></readByte>
		<readBytes public="1" set="method" line="361">
			<f a="bytes:?offset:?length" v=":0:0">
				<x path="openfl.utils.ByteArray"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ length : 0, offset : 0 }</e></m></meta>
		</readBytes>
		<readDouble public="1" set="method" line="383"><f a=""><x path="Float"/></f></readDouble>
		<readFloat public="1" set="method" line="397"><f a=""><x path="Float"/></f></readFloat>
		<readInt public="1" set="method" line="411"><f a=""><x path="Int"/></f></readInt>
		<readMultiByte public="1" set="method" line="431"><f a="length:charSet">
	<x path="Int"/>
	<c path="String"/>
	<c path="String"/>
</f></readMultiByte>
		<readShort public="1" set="method" line="438"><f a=""><x path="Int"/></f></readShort>
		<readUnsignedByte public="1" set="method" line="468"><f a=""><x path="Int"/></f></readUnsignedByte>
		<readUnsignedInt public="1" set="method" line="484"><f a=""><x path="Int"/></f></readUnsignedInt>
		<readUnsignedShort public="1" set="method" line="504"><f a=""><x path="Int"/></f></readUnsignedShort>
		<readUTF public="1" set="method" line="522"><f a=""><c path="String"/></f></readUTF>
		<readUTFBytes public="1" set="method" line="530"><f a="length">
	<x path="Int"/>
	<c path="String"/>
</f></readUTFBytes>
		<uncompress public="1" set="method" line="545">
			<f a="?algorithm" v="null">
				<x path="openfl.utils.CompressionAlgorithm"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ algorithm : null }</e></m></meta>
		</uncompress>
		<writeBoolean public="1" set="method" line="590"><f a="value">
	<x path="Bool"/>
	<x path="Void"/>
</f></writeBoolean>
		<writeByte public="1" set="method" line="597"><f a="value">
	<x path="Int"/>
	<x path="Void"/>
</f></writeByte>
		<writeBytes public="1" set="method" line="605">
			<f a="bytes:?offset:?length" v=":0:0">
				<x path="openfl.utils.ByteArray"/>
				<x path="UInt"/>
				<x path="UInt"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ length : 0, offset : 0 }</e></m></meta>
		</writeBytes>
		<writeDouble public="1" set="method" line="618"><f a="value">
	<x path="Float"/>
	<x path="Void"/>
</f></writeDouble>
		<writeFloat public="1" set="method" line="627"><f a="value">
	<x path="Float"/>
	<x path="Void"/>
</f></writeFloat>
		<writeInt public="1" set="method" line="636"><f a="value">
	<x path="Int"/>
	<x path="Void"/>
</f></writeInt>
		<writeMultiByte public="1" set="method" line="659"><f a="value:charSet">
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></writeMultiByte>
		<writeShort public="1" set="method" line="666"><f a="value">
	<x path="Int"/>
	<x path="Void"/>
</f></writeShort>
		<writeUnsignedInt public="1" set="method" line="685"><f a="value">
	<x path="Int"/>
	<x path="Void"/>
</f></writeUnsignedInt>
		<writeUTF public="1" set="method" line="692"><f a="value">
	<c path="String"/>
	<x path="Void"/>
</f></writeUTF>
		<writeUTFBytes public="1" set="method" line="702"><f a="value">
	<c path="String"/>
	<x path="Void"/>
</f></writeUTFBytes>
		<__fromBytes set="method" line="710"><f a="bytes">
	<c path="haxe.io.Bytes"/>
	<x path="Void"/>
</f></__fromBytes>
		<__resize set="method" line="718"><f a="size">
	<x path="Int"/>
	<x path="Void"/>
</f></__resize>
		<__setData get="inline" set="null" line="737"><f a="bytes">
	<c path="haxe.io.Bytes"/>
	<x path="Void"/>
</f></__setData>
		<get_bytesAvailable get="inline" set="null" line="756">
			<f a=""><x path="Int"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_bytesAvailable>
		<get_endian get="inline" set="null" line="763">
			<f a=""><x path="openfl.utils.Endian"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_endian>
		<set_endian get="inline" set="null" line="770">
			<f a="value">
				<x path="openfl.utils.Endian"/>
				<x path="openfl.utils.Endian"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_endian>
		<new public="1" set="method" line="240">
			<f a="?length" v="0">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ length : 0 }</e></m></meta>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":autoBuild"><e>lime.Assets.embedByteArray()</e></m>
			<m n=":noCompletion"/>
			<m n=":dox"><e>hide</e></m>
		</meta>
	</class>
	<class path="flixel.system.VirtualInputData" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/system/FlxAssets.hx" module="flixel.system.FlxAssets">
		<extends path="openfl.utils.ByteArrayData"/>
		<resourceName expr="&quot;__ASSET__:file_flixel_system_VirtualInputData&quot;" line="1" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"__ASSET__:file_flixel_system_VirtualInputData"</e></m></meta>
		</resourceName>
		<new public="1" set="method" line="1">
			<f a="?length" v="0">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ length : 0 }</e></m></meta>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>lime.Assets.embedByteArray()</e></m>
			<m n=":autoBuild"><e>lime.Assets.embedByteArray()</e></m>
			<m n=":file"><e>"assets/images/ui/virtual-input.txt"</e></m>
		</meta>
	</class>
	<typedef path="flixel.system.FlxAngelCodeSource" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/system/FlxAssets.hx" module="flixel.system.FlxAssets"><x path="flixel.util.typeLimit.OneOfTwo">
	<c path="Xml"/>
	<c path="String"/>
</x></typedef>
	<typedef path="flixel.system.FlxTexturePackerSource" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/system/FlxAssets.hx" module="flixel.system.FlxAssets"><x path="flixel.util.typeLimit.OneOfTwo">
	<c path="String"/>
	<t path="flixel.graphics.frames.TexturePackerObject"/>
</x></typedef>
	<typedef path="flixel.system.FlxSoundAsset" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/system/FlxAssets.hx" module="flixel.system.FlxAssets"><x path="flixel.util.typeLimit.OneOfThree">
	<c path="String"/>
	<t path="flash.media.Sound"/>
	<x path="Class"><t path="flash.media.Sound"/></x>
</x></typedef>
	<typedef path="flixel.system.FlxGraphicAsset" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/system/FlxAssets.hx" module="flixel.system.FlxAssets"><x path="flixel.util.typeLimit.OneOfThree">
	<c path="flixel.graphics.FlxGraphic"/>
	<t path="flash.display.BitmapData"/>
	<c path="String"/>
</x></typedef>
	<typedef path="flixel.system.FlxGraphicSource" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/system/FlxAssets.hx" module="flixel.system.FlxAssets"><x path="flixel.util.typeLimit.OneOfThree">
	<t path="flash.display.BitmapData"/>
	<x path="Class"><d/></x>
	<c path="String"/>
</x></typedef>
	<typedef path="flixel.system.FlxTilemapGraphicAsset" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/system/FlxAssets.hx" module="flixel.system.FlxAssets"><x path="flixel.util.typeLimit.OneOfFour">
	<c path="flixel.graphics.frames.FlxFramesCollection"/>
	<c path="flixel.graphics.FlxGraphic"/>
	<t path="flash.display.BitmapData"/>
	<c path="String"/>
</x></typedef>
	<typedef path="flixel.system.FlxBitmapFontGraphicAsset" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/system/FlxAssets.hx" module="flixel.system.FlxAssets"><x path="flixel.util.typeLimit.OneOfFour">
	<c path="flixel.graphics.frames.FlxFrame"/>
	<c path="flixel.graphics.FlxGraphic"/>
	<t path="flash.display.BitmapData"/>
	<c path="String"/>
</x></typedef>
	<typedef path="flixel.system.FlxShader" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/system/FlxAssets.hx" module="flixel.system.FlxAssets"><c path="openfl.display.Shader"/></typedef>
	<class path="flixel.system.FlxAssets" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/system/FlxAssets.hx">
		<buildFileReferences public="1" set="method" line="60" static="1">
			<f a="?directory:?subDirectories:?filterExtensions" v="&quot;assets/&quot;:false:">
				<c path="String"/>
				<x path="Bool"/>
				<c path="Array"><c path="String"/></c>
				<c path="Array"><t path="haxe.macro.Field"/></c>
			</f>
			<meta><m n=":value"><e>{ subDirectories : false, directory : "assets/" }</e></m></meta>
			<haxe_doc>* Reads files from a directory relative to this project and generates `public static inline`
	 * variables containing the string paths to the files in it. 
	 * 
	 * Example usage:
	 * 
	 * ```haxe
	 * @:build(flixel.system.FlxAssets.buildFileReferences("assets/images"))
	 * class Images {}
	 * ```
	 * 
	 * Mostly copied from:
	 * @author Mark Knol
	 * @see http://blog.stroep.nl/2014/01/haxe-macros/
	 * 
	 * @param   directory          The directory to scan for files
	 * @param   subDirectories     Whether to include subdirectories
	 * @param   filterExtensions   Example: `["jpg", "png", "gif"]` will only add files with that extension.</haxe_doc>
		</buildFileReferences>
		<FONT_DEFAULT public="1" expr="&quot;Nokia Cellphone FC Small&quot;" line="71" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"Nokia Cellphone FC Small"</e></m></meta>
		</FONT_DEFAULT>
		<FONT_DEBUGGER public="1" expr="&quot;Monsterrat&quot;" line="72" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"Monsterrat"</e></m></meta>
		</FONT_DEBUGGER>
		<drawLogo public="1" set="method" line="74" static="1"><f a="graph">
	<t path="flash.display.Graphics"/>
	<x path="Void"/>
</f></drawLogo>
		<getBitmapData public="1" get="inline" set="null" line="130" static="1"><f a="id">
	<c path="String"/>
	<t path="flash.display.BitmapData"/>
</f></getBitmapData>
		<getBitmapFromClass public="1" get="inline" set="null" line="144" static="1">
			<f a="source">
				<x path="Class"><d/></x>
				<t path="flash.display.BitmapData"/>
			</f>
			<haxe_doc>* Generates BitmapData from specified class. Less typing.
	 * 
	 * @param	source	BitmapData class to generate BitmapData object from.
	 * @return	Newly instantiated BitmapData object.</haxe_doc>
		</getBitmapFromClass>
		<resolveBitmapData public="1" set="method" line="159" static="1">
			<f a="Graphic">
				<t path="flixel.system.FlxGraphicSource"/>
				<t path="flash.display.BitmapData"/>
			</f>
			<haxe_doc><![CDATA[* Takes Dynamic object as a input and tries to convert it to BitmapData:
	 * 1) if the input is BitmapData, then it will return this BitmapData;
	 * 2) if the input is Class<BitmapData>, then it will create BitmapData from this class;
	 * 3) if the input is String, then it will get BitmapData from openfl.Assets;
	 * 4) it will return null in any other case.
	 * 
	 * @param	Graphic	input data to get BitmapData object for.
	 * @return	BitmapData for specified Dynamic object.]]></haxe_doc>
		</resolveBitmapData>
		<resolveKey public="1" set="method" line="188" static="1">
			<f a="Graphic:?Key">
				<t path="flixel.system.FlxGraphicSource"/>
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc><![CDATA[* Takes Dynamic object as a input and tries to find appropriate key String for its BitmapData:
	 * 1) if the input is BitmapData, then it will return second (optional) argument (the Key);
	 * 2) if the input is Class<BitmapData>, then it will return the name of this class;
	 * 3) if the input is String, then it will return it;
	 * 4) it will return null in any other case.
	 * 
	 * @param	Graphic	input data to get string key for.
	 * @param	Key	optional key string.
	 * @return	Key String for specified Graphic object.]]></haxe_doc>
		</resolveKey>
		<getSound public="1" get="inline" set="null" line="211" static="1"><f a="id">
	<c path="String"/>
	<t path="flash.media.Sound"/>
</f></getSound>
		<getVirtualInputFrames public="1" set="method" line="222" static="1"><f a=""><c path="flixel.graphics.frames.FlxAtlasFrames"/></f></getVirtualInputFrames>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="flixel.system.FlxBGSprite" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/system/FlxBGSprite.hx">
		<extends path="flixel.FlxSprite"/>
		<draw public="1" set="method" line="21" override="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":access"><e>flixel.FlxCamera</e></m></meta>
			<haxe_doc>* Called by game loop, updates then blits or renders current frame of animation to the screen</haxe_doc>
		</draw>
		<new public="1" set="method" line="10"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="flixel.system.FlxLinkedList" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/system/FlxLinkedList.hx">
		<implements path="flixel.util.IFlxDestroyable"/>
		<_NUM_CACHED_FLX_LIST public="1" expr="0" line="17" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* Pooling mechanism, when FlxLinkedLists are destroyed, they get added
	 * to this collection, and when they get recycled they get removed.</haxe_doc>
		</_NUM_CACHED_FLX_LIST>
		<_cachedListsHead static="1"><c path="flixel.system.FlxLinkedList"/></_cachedListsHead>
		<recycle public="1" set="method" line="23" static="1">
			<f a=""><c path="flixel.system.FlxLinkedList"/></f>
			<haxe_doc>* Recycle a cached Linked List, or creates a new one if needed.</haxe_doc>
		</recycle>
		<clearCache public="1" set="method" line="43" static="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Clear cached List nodes. You might want to do this when loading new levels
	 * (probably not though, no need to clear cache unless you run into memory problems).</haxe_doc>
		</clearCache>
		<object public="1">
			<c path="flixel.FlxObject"/>
			<haxe_doc>* Stores a reference to a FlxObject.</haxe_doc>
		</object>
		<next public="1">
			<c path="flixel.system.FlxLinkedList"/>
			<haxe_doc>* Stores a reference to the next link in the list.</haxe_doc>
		</next>
		<exists public="1" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</exists>
		<destroy public="1" set="method" line="75">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Clean up memory.</haxe_doc>
		</destroy>
		<new set="method" line="70">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Private, use recycle instead.</haxe_doc>
		</new>
		<haxe_doc>* A miniature linked list class.
 * Useful for optimizing time-critical or highly repetitive tasks!
 * See FlxQuadTree for how to use it, IF YOU DARE.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="flixel.system.FlxQuadTree" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/system/FlxQuadTree.hx">
		<extends path="flixel.math.FlxRect"/>
		<A_LIST public="1" get="inline" set="null" expr="0" line="21" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* Flag for specifying that you want to add an object to the A list.</haxe_doc>
		</A_LIST>
		<B_LIST public="1" get="inline" set="null" expr="1" line="25" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>1</e></m></meta>
			<haxe_doc>* Flag for specifying that you want to add an object to the B list.</haxe_doc>
		</B_LIST>
		<divisions public="1" static="1">
			<x path="Int"/>
			<haxe_doc>* Controls the granularity of the quad tree.  Default is 6 (decent performance on large and small worlds).</haxe_doc>
		</divisions>
		<_min static="1">
			<x path="Int"/>
			<haxe_doc>* Internal, governs and assists with the formation of the tree.</haxe_doc>
		</_min>
		<_object static="1">
			<c path="flixel.FlxObject"/>
			<haxe_doc>* Internal, used to reduce recursive method parameters during object placement and tree formation.</haxe_doc>
		</_object>
		<_objectLeftEdge static="1">
			<x path="Float"/>
			<haxe_doc>* Internal, used to reduce recursive method parameters during object placement and tree formation.</haxe_doc>
		</_objectLeftEdge>
		<_objectTopEdge static="1">
			<x path="Float"/>
			<haxe_doc>* Internal, used to reduce recursive method parameters during object placement and tree formation.</haxe_doc>
		</_objectTopEdge>
		<_objectRightEdge static="1">
			<x path="Float"/>
			<haxe_doc>* Internal, used to reduce recursive method parameters during object placement and tree formation.</haxe_doc>
		</_objectRightEdge>
		<_objectBottomEdge static="1">
			<x path="Float"/>
			<haxe_doc>* Internal, used to reduce recursive method parameters during object placement and tree formation.</haxe_doc>
		</_objectBottomEdge>
		<_list static="1">
			<x path="Int"/>
			<haxe_doc>* Internal, used during tree processing and overlap checks.</haxe_doc>
		</_list>
		<_useBothLists static="1">
			<x path="Bool"/>
			<haxe_doc>* Internal, used during tree processing and overlap checks.</haxe_doc>
		</_useBothLists>
		<_processingCallback static="1">
			<f a=":">
				<c path="flixel.FlxObject"/>
				<c path="flixel.FlxObject"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Internal, used during tree processing and overlap checks.</haxe_doc>
		</_processingCallback>
		<_notifyCallback static="1">
			<f a=":">
				<c path="flixel.FlxObject"/>
				<c path="flixel.FlxObject"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Internal, used during tree processing and overlap checks.</haxe_doc>
		</_notifyCallback>
		<_iterator static="1">
			<c path="flixel.system.FlxLinkedList"/>
			<haxe_doc>* Internal, used during tree processing and overlap checks.</haxe_doc>
		</_iterator>
		<_objectHullX static="1">
			<x path="Float"/>
			<haxe_doc>* Internal, helpers for comparing actual object-to-object overlap - see overlapNode().</haxe_doc>
		</_objectHullX>
		<_objectHullY static="1">
			<x path="Float"/>
			<haxe_doc>* Internal, helpers for comparing actual object-to-object overlap - see overlapNode().</haxe_doc>
		</_objectHullY>
		<_objectHullWidth static="1">
			<x path="Float"/>
			<haxe_doc>* Internal, helpers for comparing actual object-to-object overlap - see overlapNode().</haxe_doc>
		</_objectHullWidth>
		<_objectHullHeight static="1">
			<x path="Float"/>
			<haxe_doc>* Internal, helpers for comparing actual object-to-object overlap - see overlapNode().</haxe_doc>
		</_objectHullHeight>
		<_checkObjectHullX static="1">
			<x path="Float"/>
			<haxe_doc>* Internal, helpers for comparing actual object-to-object overlap - see overlapNode().</haxe_doc>
		</_checkObjectHullX>
		<_checkObjectHullY static="1">
			<x path="Float"/>
			<haxe_doc>* Internal, helpers for comparing actual object-to-object overlap - see overlapNode().</haxe_doc>
		</_checkObjectHullY>
		<_checkObjectHullWidth static="1">
			<x path="Float"/>
			<haxe_doc>* Internal, helpers for comparing actual object-to-object overlap - see overlapNode().</haxe_doc>
		</_checkObjectHullWidth>
		<_checkObjectHullHeight static="1">
			<x path="Float"/>
			<haxe_doc>* Internal, helpers for comparing actual object-to-object overlap - see overlapNode().</haxe_doc>
		</_checkObjectHullHeight>
		<_NUM_CACHED_QUAD_TREES public="1" expr="0" line="191" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* Pooling mechanism, turn FlxQuadTree into a linked list, when FlxQuadTrees are destroyed, they get added to the list, and when they get recycled they get removed.</haxe_doc>
		</_NUM_CACHED_QUAD_TREES>
		<_cachedTreesHead static="1"><c path="flixel.system.FlxQuadTree"/></_cachedTreesHead>
		<recycle public="1" set="method" line="213" static="1">
			<f a="X:Y:Width:Height:?Parent">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<c path="flixel.system.FlxQuadTree"/>
				<c path="flixel.system.FlxQuadTree"/>
			</f>
			<haxe_doc>* Recycle a cached Quad Tree node, or creates a new one if needed.
	 * @param	X			The X-coordinate of the point in space.
	 * @param	Y			The Y-coordinate of the point in space.
	 * @param	Width		Desired width of this node.
	 * @param	Height		Desired height of this node.
	 * @param	Parent		The parent branch or node.  Pass null to create a root.</haxe_doc>
		</recycle>
		<clearCache public="1" set="method" line="230" static="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Clear cached Quad Tree nodes. You might want to do this when loading new levels (probably not though, no need to clear cache unless you run into memory problems).</haxe_doc>
		</clearCache>
		<exists public="1"><x path="Bool"/></exists>
		<_canSubdivide>
			<x path="Bool"/>
			<haxe_doc>* Whether this branch of the tree can be subdivided or not.</haxe_doc>
		</_canSubdivide>
		<_headA>
			<c path="flixel.system.FlxLinkedList"/>
			<haxe_doc>* Refers to the internal A and B linked lists,
	 * which are used to store objects in the leaves.</haxe_doc>
		</_headA>
		<_tailA>
			<c path="flixel.system.FlxLinkedList"/>
			<haxe_doc>* Refers to the internal A and B linked lists,
	 * which are used to store objects in the leaves.</haxe_doc>
		</_tailA>
		<_headB>
			<c path="flixel.system.FlxLinkedList"/>
			<haxe_doc>* Refers to the internal A and B linked lists,
	 * which are used to store objects in the leaves.</haxe_doc>
		</_headB>
		<_tailB>
			<c path="flixel.system.FlxLinkedList"/>
			<haxe_doc>* Refers to the internal A and B linked lists,
	 * which are used to store objects in the leaves.</haxe_doc>
		</_tailB>
		<_northWestTree>
			<c path="flixel.system.FlxQuadTree"/>
			<haxe_doc>* Internal, governs and assists with the formation of the tree.</haxe_doc>
		</_northWestTree>
		<_northEastTree>
			<c path="flixel.system.FlxQuadTree"/>
			<haxe_doc>* Internal, governs and assists with the formation of the tree.</haxe_doc>
		</_northEastTree>
		<_southEastTree>
			<c path="flixel.system.FlxQuadTree"/>
			<haxe_doc>* Internal, governs and assists with the formation of the tree.</haxe_doc>
		</_southEastTree>
		<_southWestTree>
			<c path="flixel.system.FlxQuadTree"/>
			<haxe_doc>* Internal, governs and assists with the formation of the tree.</haxe_doc>
		</_southWestTree>
		<_leftEdge>
			<x path="Float"/>
			<haxe_doc>* Internal, governs and assists with the formation of the tree.</haxe_doc>
		</_leftEdge>
		<_rightEdge>
			<x path="Float"/>
			<haxe_doc>* Internal, governs and assists with the formation of the tree.</haxe_doc>
		</_rightEdge>
		<_topEdge>
			<x path="Float"/>
			<haxe_doc>* Internal, governs and assists with the formation of the tree.</haxe_doc>
		</_topEdge>
		<_bottomEdge>
			<x path="Float"/>
			<haxe_doc>* Internal, governs and assists with the formation of the tree.</haxe_doc>
		</_bottomEdge>
		<_halfWidth>
			<x path="Float"/>
			<haxe_doc>* Internal, governs and assists with the formation of the tree.</haxe_doc>
		</_halfWidth>
		<_halfHeight>
			<x path="Float"/>
			<haxe_doc>* Internal, governs and assists with the formation of the tree.</haxe_doc>
		</_halfHeight>
		<_midpointX>
			<x path="Float"/>
			<haxe_doc>* Internal, governs and assists with the formation of the tree.</haxe_doc>
		</_midpointX>
		<_midpointY>
			<x path="Float"/>
			<haxe_doc>* Internal, governs and assists with the formation of the tree.</haxe_doc>
		</_midpointY>
		<next><c path="flixel.system.FlxQuadTree"/></next>
		<reset public="1" set="method" line="242"><f a="X:Y:Width:Height:?Parent">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<c path="flixel.system.FlxQuadTree"/>
	<x path="Void"/>
</f></reset>
		<destroy public="1" set="method" line="311" override="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Clean up memory.</haxe_doc>
		</destroy>
		<load public="1" set="method" line="346">
			<f a="ObjectOrGroup1:?ObjectOrGroup2:?NotifyCallback:?ProcessCallback">
				<c path="flixel.FlxBasic"/>
				<c path="flixel.FlxBasic"/>
				<f a=":">
					<c path="flixel.FlxObject"/>
					<c path="flixel.FlxObject"/>
					<x path="Void"/>
				</f>
				<f a=":">
					<c path="flixel.FlxObject"/>
					<c path="flixel.FlxObject"/>
					<x path="Bool"/>
				</f>
				<x path="Void"/>
			</f>
			<haxe_doc>* Load objects and/or groups into the quad tree, and register notify and processing callbacks.
	 * @param ObjectOrGroup1	Any object that is or extends FlxObject or FlxGroup.
	 * @param ObjectOrGroup2	Any object that is or extends FlxObject or FlxGroup.  If null, the first parameter will be checked against itself.
	 * @param NotifyCallback	A function with the form myFunction(Object1:FlxObject,Object2:FlxObject):void that is called whenever two objects are found to overlap in world space, and either no ProcessCallback is specified, or the ProcessCallback returns true. 
	 * @param ProcessCallback	A function with the form myFunction(Object1:FlxObject,Object2:FlxObject):Boolean that is called whenever two objects are found to overlap in world space.  The NotifyCallback is only called if this function returns true.  See FlxObject.separate().</haxe_doc>
		</load>
		<add public="1" set="method" line="370">
			<f a="ObjectOrGroup:list">
				<c path="flixel.FlxBasic"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":access"><e>flixel.group.FlxTypedGroup.resolveGroup</e></m></meta>
			<haxe_doc>* Call this function to add an object to the root of the tree.
	 * This function will recursively add all group members, but
	 * not the groups themselves.
	 * @param	ObjectOrGroup	FlxObjects are just added, FlxGroups are recursed and their applicable members added accordingly.
	 * @param	List			A int flag indicating the list to which you want to add the objects.  Options are A_LIST and B_LIST.</haxe_doc>
		</add>
		<addObject set="method" line="424">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Internal function for recursively navigating and creating the tree
	 * while adding objects to the appropriate nodes.</haxe_doc>
		</addObject>
		<addToList set="method" line="515">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Internal function for recursively adding objects to leaf lists.</haxe_doc>
		</addToList>
		<execute public="1" set="method" line="565">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>* FlxQuadTree's other main function.  Call this after adding objects
	 * using FlxQuadTree.load() to compare the objects that you loaded.
	 * @return	Whether or not any overlaps were found.</haxe_doc>
		</execute>
		<overlapNode set="method" line="617">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>* An internal function for comparing an object against the contents of a node.
	 * @return	Whether or not any overlaps were found.</haxe_doc>
		</overlapNode>
		<new set="method" line="198">
			<f a="X:Y:Width:Height:?Parent">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<c path="flixel.system.FlxQuadTree"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Private, use recycle instead.</haxe_doc>
		</new>
		<haxe_doc>* A fairly generic quad tree structure for rapid overlap checks.
 * FlxQuadTree is also configured for single or dual list operation.
 * You can add items either to its A list or its B list.
 * When you do an overlap check, you can compare the A list to itself,
 * or the A list against the B list.  Handy for different things!</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="flixel.system.FlxSound" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/system/FlxSound.hx">
		<extends path="flixel.FlxBasic"/>
		<x public="1">
			<x path="Float"/>
			<haxe_doc>* The x position of this sound in world coordinates.
	 * Only really matters if you are doing proximity/panning stuff.</haxe_doc>
		</x>
		<y public="1">
			<x path="Float"/>
			<haxe_doc>* The y position of this sound in world coordinates.
	 * Only really matters if you are doing proximity/panning stuff.</haxe_doc>
		</y>
		<persist public="1">
			<x path="Bool"/>
			<haxe_doc>* Whether or not this sound should be automatically destroyed when you switch states.</haxe_doc>
		</persist>
		<name public="1" set="null">
			<c path="String"/>
			<haxe_doc>* The ID3 song name. Defaults to null. Currently only works for streamed sounds.</haxe_doc>
		</name>
		<artist public="1" set="null">
			<c path="String"/>
			<haxe_doc>* The ID3 artist name. Defaults to null. Currently only works for streamed sounds.</haxe_doc>
		</artist>
		<amplitude public="1" set="null">
			<x path="Float"/>
			<haxe_doc>* Stores the average wave amplitude of both stereo channels</haxe_doc>
		</amplitude>
		<amplitudeLeft public="1" set="null">
			<x path="Float"/>
			<haxe_doc>* Just the amplitude of the left stereo channel</haxe_doc>
		</amplitudeLeft>
		<amplitudeRight public="1" set="null">
			<x path="Float"/>
			<haxe_doc>* Just the amplitude of the left stereo channel</haxe_doc>
		</amplitudeRight>
		<autoDestroy public="1">
			<x path="Bool"/>
			<haxe_doc>* Whether to call `destroy()` when the sound has finished playing.</haxe_doc>
		</autoDestroy>
		<onComplete public="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Tracker for sound complete callback. If assigned, will be called 
	 * each time when sound reaches its end. Works only on flash and desktop targets.</haxe_doc>
		</onComplete>
		<pan public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<haxe_doc>* Pan amount. -1 = full left, 1 = full right. Proximity based panning overrides this.</haxe_doc>
		</pan>
		<playing public="1" get="accessor" set="null">
			<x path="Bool"/>
			<haxe_doc>* Whether or not the sound is currently playing.</haxe_doc>
		</playing>
		<volume public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<haxe_doc>* Set volume to a value between 0 and 1 to change how this sound is.</haxe_doc>
		</volume>
		<time public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<haxe_doc>* The position in runtime of the music playback in milliseconds.
	 * If set while paused, changes only come into effect after a `resume()` call.</haxe_doc>
		</time>
		<length public="1" get="accessor" set="null">
			<x path="Float"/>
			<haxe_doc>* The length of the sound in milliseconds.
	 * @since 4.2.0</haxe_doc>
		</length>
		<group public="1" set="accessor">
			<c path="flixel.system.FlxSoundGroup"/>
			<haxe_doc>* The sound group this sound belongs to</haxe_doc>
		</group>
		<looped public="1">
			<x path="Bool"/>
			<haxe_doc>* Whether or not this sound should loop.</haxe_doc>
		</looped>
		<loopTime public="1" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* In case of looping, the point (in milliseconds) from where to restart the sound when it loops back
	 * @since 4.1.0</haxe_doc>
		</loopTime>
		<endTime public="1">
			<t path="Null"><x path="Float"/></t>
			<haxe_doc>* At which point to stop playing the sound, in milliseconds.
	 * If not set / `null`, the sound completes normally.
	 * @since 4.2.0</haxe_doc>
		</endTime>
		<fadeTween public="1">
			<c path="flixel.tweens.FlxTween"/>
			<haxe_doc>* The tween used to fade this sound's volume in and out (set via `fadeIn()` and `fadeOut()`)
	 * @since 4.1.0</haxe_doc>
		</fadeTween>
		<_sound>
			<t path="flash.media.Sound"/>
			<haxe_doc>* Internal tracker for a Flash sound object.</haxe_doc>
		</_sound>
		<_channel>
			<t path="flash.media.SoundChannel"/>
			<haxe_doc>* Internal tracker for a Flash sound channel object.</haxe_doc>
		</_channel>
		<_transform>
			<t path="flash.media.SoundTransform"/>
			<haxe_doc>* Internal tracker for a Flash sound transform object.</haxe_doc>
		</_transform>
		<_paused>
			<x path="Bool"/>
			<haxe_doc>* Internal tracker for whether the sound is paused or not (not the same as stopped).</haxe_doc>
		</_paused>
		<_volume>
			<x path="Float"/>
			<haxe_doc>* Internal tracker for volume.</haxe_doc>
		</_volume>
		<_time expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* Internal tracker for sound channel position.</haxe_doc>
		</_time>
		<_length expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* Internal tracker for sound length, so that length can still be obtained while a sound is paused, because _sound becomes null.</haxe_doc>
		</_length>
		<_volumeAdjust expr="1.0">
			<x path="Float"/>
			<meta><m n=":value"><e>1.0</e></m></meta>
			<haxe_doc>* Internal tracker for total volume adjustment.</haxe_doc>
		</_volumeAdjust>
		<_target>
			<c path="flixel.FlxObject"/>
			<haxe_doc>* Internal tracker for the sound's "target" (for proximity and panning).</haxe_doc>
		</_target>
		<_radius>
			<x path="Float"/>
			<haxe_doc>* Internal tracker for the maximum effective radius of this sound (for proximity and panning).</haxe_doc>
		</_radius>
		<_proximityPan>
			<x path="Bool"/>
			<haxe_doc>* Internal tracker for whether to pan the sound left and right.  Default is false.</haxe_doc>
		</_proximityPan>
		<_alreadyPaused expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
			<haxe_doc>* Helper var to prevent the sound from playing after focus was regained when it was already paused.</haxe_doc>
		</_alreadyPaused>
		<reset set="method" line="188">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* An internal function for clearing all the variables used by sounds.</haxe_doc>
		</reset>
		<destroy public="1" set="method" line="216" override="1"><f a=""><x path="Void"/></f></destroy>
		<update public="1" set="method" line="246" override="1">
			<f a="elapsed">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Handles fade out, fade in, panning, proximity, and amplitude operations each frame.</haxe_doc>
		</update>
		<kill public="1" set="method" line="290" override="1"><f a=""><x path="Void"/></f></kill>
		<loadEmbedded public="1" set="method" line="305">
			<f a="EmbeddedSound:?Looped:?AutoDestroy:?OnComplete" v=":false:false:">
				<t path="flixel.system.FlxSoundAsset"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<f a=""><x path="Void"/></f>
				<c path="flixel.system.FlxSound"/>
			</f>
			<meta><m n=":value"><e>{ AutoDestroy : false, Looped : false }</e></m></meta>
			<haxe_doc>* One of the main setup functions for sounds, this function loads a sound from an embedded MP3.
	 * 
	 * @param	EmbeddedSound	An embedded Class object representing an MP3 file.
	 * @param	Looped			Whether or not this sound should loop endlessly.
	 * @param	AutoDestroy		Whether or not this FlxSound instance should be destroyed when the sound finishes playing. 
	 * 							Default value is false, but `FlxG.sound.play()` and `FlxG.sound.stream()` will set it to true by default.
	 * @return	This FlxSound instance (nice for chaining stuff together, if you're into that).</haxe_doc>
		</loadEmbedded>
		<loadStream public="1" set="method" line="342">
			<f a="SoundURL:?Looped:?AutoDestroy:?OnComplete" v=":false:false:">
				<c path="String"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<f a=""><x path="Void"/></f>
				<c path="flixel.system.FlxSound"/>
			</f>
			<meta><m n=":value"><e>{ AutoDestroy : false, Looped : false }</e></m></meta>
			<haxe_doc>* One of the main setup functions for sounds, this function loads a sound from a URL.
	 * 
	 * @param	SoundURL		A string representing the URL of the MP3 file you want to play.
	 * @param	Looped			Whether or not this sound should loop endlessly.
	 * @param	AutoDestroy		Whether or not this FlxSound instance should be destroyed when the sound finishes playing.
	 * 							Default value is false, but `FlxG.sound.play()` and `FlxG.sound.stream()` will set it to true by default.
	 * @return	This FlxSound instance (nice for chaining stuff together, if you're into that).</haxe_doc>
		</loadStream>
		<init set="method" line="375">
			<f a="?Looped:?AutoDestroy:?OnComplete" v="false:false:">
				<x path="Bool"/>
				<x path="Bool"/>
				<f a=""><x path="Void"/></f>
				<c path="flixel.system.FlxSound"/>
			</f>
			<meta><m n=":value"><e>{ AutoDestroy : false, Looped : false }</e></m></meta>
		</init>
		<proximity public="1" set="method" line="398">
			<f a="X:Y:TargetObject:Radius:?Pan" v="::::true">
				<x path="Float"/>
				<x path="Float"/>
				<c path="flixel.FlxObject"/>
				<x path="Float"/>
				<x path="Bool"/>
				<c path="flixel.system.FlxSound"/>
			</f>
			<meta><m n=":value"><e>{ Pan : true }</e></m></meta>
			<haxe_doc>* Call this function if you want this sound's volume to change
	 * based on distance from a particular FlxObject.
	 *
	 * @param	X			The X position of the sound.
	 * @param	Y			The Y position of the sound.
	 * @param	TargetObject		The object you want to track.
	 * @param	Radius			The maximum distance this sound can travel.
	 * @param	Pan			Whether panning should be used in addition to the volume changes.
	 * @return	This FlxSound instance (nice for chaining stuff together, if you're into that).</haxe_doc>
		</proximity>
		<play public="1" set="method" line="419">
			<f a="?ForceRestart:?StartTime:?EndTime" v="false:0.0:">
				<x path="Bool"/>
				<x path="Float"/>
				<x path="Float"/>
				<c path="flixel.system.FlxSound"/>
			</f>
			<meta><m n=":value"><e>{ StartTime : 0.0, ForceRestart : false }</e></m></meta>
			<haxe_doc>* Call this function to play the sound - also works on paused sounds.
	 * 
	 * @param   ForceRestart   Whether to start the sound over or not. 
	 *                         Default value is false, meaning if the sound is already playing or was
	 *                         paused when you call play(), it will continue playing from its current
	 *                         position, NOT start again from the beginning.
	 * @param   StartTime      At which point to start playing the sound, in milliseconds.
	 * @param   EndTime        At which point to stop playing the sound, in milliseconds.
	 *                         If not set / `null`, the sound completes normally.</haxe_doc>
		</play>
		<resume public="1" set="method" line="441">
			<f a=""><c path="flixel.system.FlxSound"/></f>
			<haxe_doc>* Unpause a sound. Only works on sounds that have been paused.</haxe_doc>
		</resume>
		<pause public="1" set="method" line="451">
			<f a=""><c path="flixel.system.FlxSound"/></f>
			<haxe_doc>* Call this function to pause this sound.</haxe_doc>
		</pause>
		<stop public="1" get="inline" set="null" line="465">
			<f a=""><c path="flixel.system.FlxSound"/></f>
			<haxe_doc>* Call this function to stop this sound.</haxe_doc>
		</stop>
		<fadeOut public="1" get="inline" set="null" line="477">
			<f a="?Duration:?To:?onComplete" v="1:0:">
				<x path="Float"/>
				<x path="Float"/>
				<f a="">
					<c path="flixel.tweens.FlxTween"/>
					<x path="Void"/>
				</f>
				<c path="flixel.system.FlxSound"/>
			</f>
			<meta><m n=":value"><e>{ To : 0, Duration : 1 }</e></m></meta>
			<haxe_doc>* Helper function that tweens this sound's volume.
	 * 
	 * @param	Duration	The amount of time the fade-out operation should take.
	 * @param	To			The volume to tween to, 0 by default.</haxe_doc>
		</fadeOut>
		<fadeIn public="1" get="inline" set="null" line="493">
			<f a="?Duration:?From:?To:?onComplete" v="1:0:1:">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<f a="">
					<c path="flixel.tweens.FlxTween"/>
					<x path="Void"/>
				</f>
				<c path="flixel.system.FlxSound"/>
			</f>
			<meta><m n=":value"><e>{ To : 1, From : 0, Duration : 1 }</e></m></meta>
			<haxe_doc>* Helper function that tweens this sound's volume.
	 * 
	 * @param	Duration	The amount of time the fade-in operation should take.
	 * @param	From		The volume to tween from, 0 by default.
	 * @param	To			The volume to tween to, 1 by default.</haxe_doc>
		</fadeIn>
		<volumeTween set="method" line="505"><f a="f">
	<x path="Float"/>
	<x path="Void"/>
</f></volumeTween>
		<getActualVolume public="1" get="inline" set="null" line="515">
			<f a=""><x path="Float"/></f>
			<haxe_doc>* Returns the currently selected "real" volume of the sound (takes fades and proximity into account).
	 * 
	 * @return	The adjusted volume of the sound.</haxe_doc>
		</getActualVolume>
		<setPosition public="1" get="inline" set="null" line="527">
			<f a="?X:?Y" v="0:0">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ Y : 0, X : 0 }</e></m></meta>
			<haxe_doc>* Helper function to set the coordinates of this object.
	 * Sound positioning is used in conjunction with proximity/panning.
	 * 
	 * @param        X        The new x position
	 * @param        Y        The new y position</haxe_doc>
		</setPosition>
		<updateTransform set="method" line="537">
			<f a=""><x path="Void"/></f>
			<meta><m n=":allow"><e>flixel.system.FlxSoundGroup</e></m></meta>
			<haxe_doc>* Call after adjusting the volume to update the sound channel's settings.</haxe_doc>
		</updateTransform>
		<startSound set="method" line="553">
			<f a="StartTime">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* An internal helper function used to attempt to start playing
	 * the sound and populate the _channel variable.</haxe_doc>
		</startSound>
		<stopped set="method" line="580">
			<f a="?_">
				<unknown/>
				<x path="Void"/>
			</f>
			<haxe_doc>* An internal helper function used to help Flash
	 * clean up finished sounds or restart looped sounds.</haxe_doc>
		</stopped>
		<cleanup set="method" line="603">
			<f a="destroySound:?resetPosition" v=":true">
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ resetPosition : true }</e></m></meta>
			<haxe_doc>* An internal helper function used to help Flash clean up (and potentially re-use) finished sounds.
	 * Will stop the current sound and destroy the associated SoundChannel, plus,
	 * any other commands ordered by the passed in parameters.
	 * 
	 * @param  destroySound    Whether or not to destroy the sound. If this is true,
	 *                         the position and fading will be reset as well.
	 * @param  resetPosition   Whether or not to reset the position of the sound.</haxe_doc>
		</cleanup>
		<gotID3 set="method" line="630">
			<f a="_">
				<unknown/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Internal event handler for ID3 info (i.e. fetching the song name).</haxe_doc>
		</gotID3>
		<onFocus set="method" line="639">
			<f a=""><x path="Void"/></f>
			<meta><m n=":allow"><e>flixel.system.frontEnds.SoundFrontEnd</e></m></meta>
		</onFocus>
		<onFocusLost set="method" line="646">
			<f a=""><x path="Void"/></f>
			<meta><m n=":allow"><e>flixel.system.frontEnds.SoundFrontEnd</e></m></meta>
		</onFocusLost>
		<set_group set="method" line="653"><f a="group">
	<c path="flixel.system.FlxSoundGroup"/>
	<c path="flixel.system.FlxSoundGroup"/>
</f></set_group>
		<get_playing get="inline" set="null" line="673"><f a=""><x path="Bool"/></f></get_playing>
		<get_volume get="inline" set="null" line="678"><f a=""><x path="Float"/></f></get_volume>
		<set_volume set="method" line="683"><f a="Volume">
	<x path="Float"/>
	<x path="Float"/>
</f></set_volume>
		<get_pan get="inline" set="null" line="704"><f a=""><x path="Float"/></f></get_pan>
		<set_pan get="inline" set="null" line="709"><f a="pan">
	<x path="Float"/>
	<x path="Float"/>
</f></set_pan>
		<get_time get="inline" set="null" line="714"><f a=""><x path="Float"/></f></get_time>
		<set_time set="method" line="719"><f a="time">
	<x path="Float"/>
	<x path="Float"/>
</f></set_time>
		<get_length get="inline" set="null" line="729"><f a=""><x path="Float"/></f></get_length>
		<toString public="1" set="method" line="734" override="1"><f a=""><c path="String"/></f></toString>
		<new public="1" set="method" line="179">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* The FlxSound constructor gets all the variables initialized, but NOT ready to play a sound yet.</haxe_doc>
		</new>
		<haxe_doc>* This is the universal flixel sound object, used for streaming, music, and sound effects.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="flixel.system.FlxSoundGroup" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/system/FlxSoundGroup.hx">
		<sounds public="1" expr="[]">
			<c path="Array"><c path="flixel.system.FlxSound"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
			<haxe_doc>* The sounds in this group</haxe_doc>
		</sounds>
		<volume public="1" set="accessor">
			<x path="Float"/>
			<haxe_doc>* The volume of this group</haxe_doc>
		</volume>
		<add public="1" set="method" line="32">
			<f a="sound">
				<c path="flixel.system.FlxSound"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Add a sound to this group
	 * @param	sound The sound to add to this group
	 * @return True if sound was successfully added, false otherwise</haxe_doc>
		</add>
		<remove public="1" set="method" line="48">
			<f a="sound">
				<c path="flixel.system.FlxSound"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Remove a sound from this group
	 * @param	sound The sound to remove
	 * @return True if sound was successfully removed, false otherwise</haxe_doc>
		</remove>
		<pause public="1" set="method" line="62">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Call this function to pause all sounds in this group.
	 * @since 4.3.0</haxe_doc>
		</pause>
		<resume public="1" set="method" line="72">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Unpauses all sounds in this group. Only works on sounds that have been paused.
	 * @since 4.3.0</haxe_doc>
		</resume>
		<set_volume set="method" line="78"><f a="volume">
	<x path="Float"/>
	<x path="Float"/>
</f></set_volume>
		<new public="1" set="method" line="22">
			<f a="?volume" v="1">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ volume : 1 }</e></m></meta>
			<haxe_doc>* Create a new sound group
	 * @param	volume  The initial volume of this group</haxe_doc>
		</new>
		<haxe_doc>* A way of grouping sounds for things such as collective volume control</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="flixel.system.FlxSplash" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/system/FlxSplash.hx">
		<extends path="flixel.FlxState"/>
		<nextState public="1" static="1"><x path="Class"><c path="flixel.FlxState"/></x></nextState>
		<_sprite><t path="flash.display.Sprite"/></_sprite>
		<_gfx><t path="flash.display.Graphics"/></_gfx>
		<_text><t path="flash.text.TextField"/></_text>
		<_times><c path="Array"><x path="Float"/></c></_times>
		<_colors><c path="Array"><x path="Int"/></c></_colors>
		<_functions><c path="Array"><f a=""><x path="Void"/></f></c></_functions>
		<_curPart expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</_curPart>
		<_cachedBgColor><x path="flixel.util.FlxColor"/></_cachedBgColor>
		<_cachedTimestep><x path="Bool"/></_cachedTimestep>
		<_cachedAutoPause><x path="Bool"/></_cachedAutoPause>
		<create public="1" set="method" line="32" override="1"><f a=""><x path="Void"/></f></create>
		<destroy public="1" set="method" line="80" override="1"><f a=""><x path="Void"/></f></destroy>
		<onResize public="1" set="method" line="91" override="1"><f a="Width:Height">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></onResize>
		<timerCallback set="method" line="106"><f a="Timer">
	<c path="flixel.util.FlxTimer"/>
	<x path="Void"/>
</f></timerCallback>
		<drawGreen set="method" line="121"><f a=""><x path="Void"/></f></drawGreen>
		<drawYellow set="method" line="136"><f a=""><x path="Void"/></f></drawYellow>
		<drawRed set="method" line="148"><f a=""><x path="Void"/></f></drawRed>
		<drawBlue set="method" line="160"><f a=""><x path="Void"/></f></drawBlue>
		<drawLightBlue set="method" line="172"><f a=""><x path="Void"/></f></drawLightBlue>
		<onComplete set="method" line="184"><f a="Tween">
	<c path="flixel.tweens.FlxTween"/>
	<x path="Void"/>
</f></onComplete>
		<new public="1" set="method" line="16"><f a="?MaxSize">
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="flixel.system.debug.DebuggerUtil" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/system/debug/DebuggerUtil.hx">
		<createTextField public="1" set="method" line="17" static="1">
			<f a="?X:?Y:?Color:?Size" v="0:0:FlxColor.WHITE:12">
				<x path="Float"/>
				<x path="Float"/>
				<x path="flixel.util.FlxColor"/>
				<x path="Int"/>
				<t path="flash.text.TextField"/>
			</f>
			<meta><m n=":value"><e>{ Size : 12, Color : FlxColor.WHITE, Y : 0, X : 0 }</e></m></meta>
		</createTextField>
		<initTextField public="1" params="T" set="method" line="22" static="1">
			<f a="tf:?X:?Y:?Color:?Size" v=":0:0:FlxColor.WHITE:12">
				<c path="initTextField.T"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="flixel.util.FlxColor"/>
				<x path="Int"/>
				<c path="initTextField.T"/>
			</f>
			<meta><m n=":value"><e>{ Size : 12, Color : FlxColor.WHITE, Y : 0, X : 0 }</e></m></meta>
		</initTextField>
		<fixSize set="method" line="41" static="1">
			<f a="bitmapData">
				<t path="flash.display.BitmapData"/>
				<t path="flash.display.BitmapData"/>
			</f>
			<meta><m n=":allow"><e>flixel.system</e></m></meta>
		</fixSize>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="flixel.system.debug._FlxDebugger.GraphicFlixel" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/system/debug/FlxDebugger.hx" private="1" module="flixel.system.debug.FlxDebugger">
		<extends path="openfl.display.BitmapData"/>
		<resourceName expr="&quot;__ASSET__:bitmap_flixel_system_debug__FlxDebugger_GraphicFlixel&quot;" line="1" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"__ASSET__:bitmap_flixel_system_debug__FlxDebugger_GraphicFlixel"</e></m></meta>
		</resourceName>
		<new public="1" set="method" line="1">
			<f a="width:height:?transparent:?fillRGBA" v="::true:0xFFFFFFFF">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ fillRGBA : 0xFFFFFFFF, transparent : true }</e></m></meta>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>openfl.Assets.embedBitmap()</e></m>
			<m n=":autoBuild"><e>openfl.Assets.embedBitmap()</e></m>
			<m n=":bitmap"><e>"assets/images/debugger/flixel.png"</e></m>
		</meta>
	</class>
	<class path="flixel.system.debug._FlxDebugger.GraphicDrawDebug" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/system/debug/FlxDebugger.hx" private="1" module="flixel.system.debug.FlxDebugger">
		<extends path="openfl.display.BitmapData"/>
		<resourceName expr="&quot;__ASSET__:bitmap_flixel_system_debug__FlxDebugger_GraphicDrawDebug&quot;" line="1" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"__ASSET__:bitmap_flixel_system_debug__FlxDebugger_GraphicDrawDebug"</e></m></meta>
		</resourceName>
		<new public="1" set="method" line="1">
			<f a="width:height:?transparent:?fillRGBA" v="::true:0xFFFFFFFF">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ fillRGBA : 0xFFFFFFFF, transparent : true }</e></m></meta>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>openfl.Assets.embedBitmap()</e></m>
			<m n=":autoBuild"><e>openfl.Assets.embedBitmap()</e></m>
			<m n=":bitmap"><e>"assets/images/debugger/buttons/drawDebug.png"</e></m>
		</meta>
	</class>
	<class path="flixel.system.debug.GraphicLog" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/system/debug/FlxDebugger.hx" module="flixel.system.debug.FlxDebugger">
		<extends path="openfl.display.BitmapData"/>
		<resourceName expr="&quot;__ASSET__:bitmap_flixel_system_debug_GraphicLog&quot;" line="1" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"__ASSET__:bitmap_flixel_system_debug_GraphicLog"</e></m></meta>
		</resourceName>
		<new public="1" set="method" line="1">
			<f a="width:height:?transparent:?fillRGBA" v="::true:0xFFFFFFFF">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ fillRGBA : 0xFFFFFFFF, transparent : true }</e></m></meta>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>openfl.Assets.embedBitmap()</e></m>
			<m n=":autoBuild"><e>openfl.Assets.embedBitmap()</e></m>
			<m n=":bitmap"><e>"assets/images/debugger/buttons/log.png"</e></m>
		</meta>
	</class>
	<class path="flixel.system.debug.GraphicStats" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/system/debug/FlxDebugger.hx" module="flixel.system.debug.FlxDebugger">
		<extends path="openfl.display.BitmapData"/>
		<resourceName expr="&quot;__ASSET__:bitmap_flixel_system_debug_GraphicStats&quot;" line="1" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"__ASSET__:bitmap_flixel_system_debug_GraphicStats"</e></m></meta>
		</resourceName>
		<new public="1" set="method" line="1">
			<f a="width:height:?transparent:?fillRGBA" v="::true:0xFFFFFFFF">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ fillRGBA : 0xFFFFFFFF, transparent : true }</e></m></meta>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>openfl.Assets.embedBitmap()</e></m>
			<m n=":autoBuild"><e>openfl.Assets.embedBitmap()</e></m>
			<m n=":bitmap"><e>"assets/images/debugger/buttons/stats.png"</e></m>
		</meta>
	</class>
	<class path="flixel.system.debug.GraphicWatch" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/system/debug/FlxDebugger.hx" module="flixel.system.debug.FlxDebugger">
		<extends path="openfl.display.BitmapData"/>
		<resourceName expr="&quot;__ASSET__:bitmap_flixel_system_debug_GraphicWatch&quot;" line="1" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"__ASSET__:bitmap_flixel_system_debug_GraphicWatch"</e></m></meta>
		</resourceName>
		<new public="1" set="method" line="1">
			<f a="width:height:?transparent:?fillRGBA" v="::true:0xFFFFFFFF">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ fillRGBA : 0xFFFFFFFF, transparent : true }</e></m></meta>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>openfl.Assets.embedBitmap()</e></m>
			<m n=":autoBuild"><e>openfl.Assets.embedBitmap()</e></m>
			<m n=":bitmap"><e>"assets/images/debugger/buttons/watch.png"</e></m>
		</meta>
	</class>
	<class path="flixel.system.debug.GraphicBitmapLog" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/system/debug/FlxDebugger.hx" module="flixel.system.debug.FlxDebugger">
		<extends path="openfl.display.BitmapData"/>
		<resourceName expr="&quot;__ASSET__:bitmap_flixel_system_debug_GraphicBitmapLog&quot;" line="1" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"__ASSET__:bitmap_flixel_system_debug_GraphicBitmapLog"</e></m></meta>
		</resourceName>
		<new public="1" set="method" line="1">
			<f a="width:height:?transparent:?fillRGBA" v="::true:0xFFFFFFFF">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ fillRGBA : 0xFFFFFFFF, transparent : true }</e></m></meta>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>openfl.Assets.embedBitmap()</e></m>
			<m n=":autoBuild"><e>openfl.Assets.embedBitmap()</e></m>
			<m n=":bitmap"><e>"assets/images/debugger/buttons/bitmapLog.png"</e></m>
		</meta>
	</class>
	<class path="flixel.system.debug.GraphicConsole" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/system/debug/FlxDebugger.hx" module="flixel.system.debug.FlxDebugger">
		<extends path="openfl.display.BitmapData"/>
		<resourceName expr="&quot;__ASSET__:bitmap_flixel_system_debug_GraphicConsole&quot;" line="1" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"__ASSET__:bitmap_flixel_system_debug_GraphicConsole"</e></m></meta>
		</resourceName>
		<new public="1" set="method" line="1">
			<f a="width:height:?transparent:?fillRGBA" v="::true:0xFFFFFFFF">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ fillRGBA : 0xFFFFFFFF, transparent : true }</e></m></meta>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>openfl.Assets.embedBitmap()</e></m>
			<m n=":autoBuild"><e>openfl.Assets.embedBitmap()</e></m>
			<m n=":bitmap"><e>"assets/images/debugger/buttons/console.png"</e></m>
		</meta>
	</class>
	<class path="flixel.system.debug.GraphicArrowLeft" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/system/debug/FlxDebugger.hx" module="flixel.system.debug.FlxDebugger">
		<extends path="openfl.display.BitmapData"/>
		<resourceName expr="&quot;__ASSET__:bitmap_flixel_system_debug_GraphicArrowLeft&quot;" line="1" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"__ASSET__:bitmap_flixel_system_debug_GraphicArrowLeft"</e></m></meta>
		</resourceName>
		<new public="1" set="method" line="1">
			<f a="width:height:?transparent:?fillRGBA" v="::true:0xFFFFFFFF">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ fillRGBA : 0xFFFFFFFF, transparent : true }</e></m></meta>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>openfl.Assets.embedBitmap()</e></m>
			<m n=":autoBuild"><e>openfl.Assets.embedBitmap()</e></m>
			<m n=":bitmap"><e>"assets/images/debugger/buttons/arrowLeft.png"</e></m>
		</meta>
	</class>
	<class path="flixel.system.debug.GraphicArrowRight" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/system/debug/FlxDebugger.hx" module="flixel.system.debug.FlxDebugger">
		<extends path="openfl.display.BitmapData"/>
		<resourceName expr="&quot;__ASSET__:bitmap_flixel_system_debug_GraphicArrowRight&quot;" line="1" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"__ASSET__:bitmap_flixel_system_debug_GraphicArrowRight"</e></m></meta>
		</resourceName>
		<new public="1" set="method" line="1">
			<f a="width:height:?transparent:?fillRGBA" v="::true:0xFFFFFFFF">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ fillRGBA : 0xFFFFFFFF, transparent : true }</e></m></meta>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>openfl.Assets.embedBitmap()</e></m>
			<m n=":autoBuild"><e>openfl.Assets.embedBitmap()</e></m>
			<m n=":bitmap"><e>"assets/images/debugger/buttons/arrowRight.png"</e></m>
		</meta>
	</class>
	<class path="flixel.system.debug.GraphicCloseButton" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/system/debug/FlxDebugger.hx" module="flixel.system.debug.FlxDebugger">
		<extends path="openfl.display.BitmapData"/>
		<resourceName expr="&quot;__ASSET__:bitmap_flixel_system_debug_GraphicCloseButton&quot;" line="1" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"__ASSET__:bitmap_flixel_system_debug_GraphicCloseButton"</e></m></meta>
		</resourceName>
		<new public="1" set="method" line="1">
			<f a="width:height:?transparent:?fillRGBA" v="::true:0xFFFFFFFF">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ fillRGBA : 0xFFFFFFFF, transparent : true }</e></m></meta>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>openfl.Assets.embedBitmap()</e></m>
			<m n=":autoBuild"><e>openfl.Assets.embedBitmap()</e></m>
			<m n=":bitmap"><e>"assets/images/debugger/buttons/close.png"</e></m>
		</meta>
	</class>
	<class path="flixel.system.debug.GraphicInteractive" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/system/debug/FlxDebugger.hx" module="flixel.system.debug.FlxDebugger">
		<extends path="openfl.display.BitmapData"/>
		<resourceName expr="&quot;__ASSET__:bitmap_flixel_system_debug_GraphicInteractive&quot;" line="1" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"__ASSET__:bitmap_flixel_system_debug_GraphicInteractive"</e></m></meta>
		</resourceName>
		<new public="1" set="method" line="1">
			<f a="width:height:?transparent:?fillRGBA" v="::true:0xFFFFFFFF">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ fillRGBA : 0xFFFFFFFF, transparent : true }</e></m></meta>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>openfl.Assets.embedBitmap()</e></m>
			<m n=":autoBuild"><e>openfl.Assets.embedBitmap()</e></m>
			<m n=":bitmap"><e>"assets/images/debugger/buttons/interactive.png"</e></m>
		</meta>
	</class>
	<class path="flixel.system.debug.FlxDebugger" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/system/debug/FlxDebugger.hx">
		<extends path="openfl.display.Sprite"/>
		<GUTTER public="1" get="inline" set="null" expr="2" line="69" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>2</e></m></meta>
			<haxe_doc>* Internal, used to space out windows from the edges.</haxe_doc>
		</GUTTER>
		<TOP_HEIGHT public="1" get="inline" set="null" expr="20" line="73" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>20</e></m></meta>
			<haxe_doc>* Internal, used to space out windows from the edges.</haxe_doc>
		</TOP_HEIGHT>
		<stats public="1"><c path="flixel.system.debug.stats.Stats"/></stats>
		<log public="1"><c path="flixel.system.debug.log.Log"/></log>
		<watch public="1"><c path="flixel.system.debug.watch.Watch"/></watch>
		<bitmapLog public="1"><c path="flixel.system.debug.log.BitmapLog"/></bitmapLog>
		<vcr public="1"><c path="flixel.system.debug.VCR"/></vcr>
		<console public="1"><c path="flixel.system.debug.console.Console"/></console>
		<interaction public="1"><c path="flixel.system.debug.interaction.Interaction"/></interaction>
		<completionList><c path="flixel.system.debug.completion.CompletionList"/></completionList>
		<_layout expr="FlxDebuggerLayout.STANDARD">
			<e path="flixel.system.debug.FlxDebuggerLayout"/>
			<meta><m n=":value"><e>FlxDebuggerLayout.STANDARD</e></m></meta>
			<haxe_doc>* Internal, tracks what debugger window layout user has currently selected.</haxe_doc>
		</_layout>
		<_screen expr="new Point()">
			<t path="flash.geom.Point"/>
			<meta><m n=":value"><e>new Point()</e></m></meta>
			<haxe_doc>* Internal, stores width and height of the game.</haxe_doc>
		</_screen>
		<_screenBounds>
			<t path="flash.geom.Rectangle"/>
			<haxe_doc>* Stores the bounds in which the windows can move.</haxe_doc>
		</_screenBounds>
		<_buttons expr="[LEFT =&gt; [], CENTER =&gt; [], RIGHT =&gt; []]">
			<x path="Map">
				<e path="flixel.util.FlxHorizontalAlign"/>
				<c path="Array"><c path="flixel.system.ui.FlxSystemButton"/></c>
			</x>
			<meta><m n=":value"><e><![CDATA[[LEFT => [], CENTER => [], RIGHT => []]]]></e></m></meta>
		</_buttons>
		<_topBar>
			<t path="flash.display.Sprite"/>
			<haxe_doc>* The flash Sprite used for the top bar of the debugger ui</haxe_doc>
		</_topBar>
		<_windows expr="[]">
			<c path="Array"><c path="flixel.system.debug.Window"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</_windows>
		<_usingSystemCursor expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</_usingSystemCursor>
		<_wasMouseVisible expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</_wasMouseVisible>
		<_wasUsingSystemCursor expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</_wasUsingSystemCursor>
		<destroy public="1" set="method" line="188">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Clean up memory.</haxe_doc>
		</destroy>
		<update public="1" set="method" line="233"><f a=""><x path="Void"/></f></update>
		<setLayout public="1" get="inline" set="null" line="244">
			<f a="Layout">
				<e path="flixel.system.debug.FlxDebuggerLayout"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Change the way the debugger's windows are laid out.
	 * 
	 * @param   Layout   The layout codes can be found in FlxDebugger, for example FlxDebugger.MICRO</haxe_doc>
		</setLayout>
		<resetLayout public="1" set="method" line="254">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Forces the debugger windows to reset to the last specified layout.
	 * The default layout is STANDARD.</haxe_doc>
		</resetLayout>
		<onResize public="1" set="method" line="321"><f a="Width:Height">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></onResize>
		<updateBounds set="method" line="335"><f a=""><x path="Void"/></f></updateBounds>
		<hAlignButtons set="method" line="347">
			<f a="Sprites:?Padding:?Set:?LeftOffset" v=":0:true:0">
				<c path="Array"><c path="flixel.system.ui.FlxSystemButton"/></c>
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":value"><e>{ LeftOffset : 0, Set : true, Padding : 0 }</e></m></meta>
			<haxe_doc>* Align an array of debugger buttons, used for the middle and right layouts</haxe_doc>
		</hAlignButtons>
		<resetButtonLayout set="method" line="367">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Position the debugger buttons</haxe_doc>
		</resetButtonLayout>
		<addButton public="1" set="method" line="388">
			<f a="Position:?Icon:?UpHandler:?ToggleMode:?UpdateLayout" v=":::false:false">
				<e path="flixel.util.FlxHorizontalAlign"/>
				<t path="flash.display.BitmapData"/>
				<f a=""><x path="Void"/></f>
				<x path="Bool"/>
				<x path="Bool"/>
				<c path="flixel.system.ui.FlxSystemButton"/>
			</f>
			<meta><m n=":value"><e>{ UpdateLayout : false, ToggleMode : false }</e></m></meta>
			<haxe_doc>* Create and add a new debugger button.
	 * 
	 * @param   Position       Either LEFT, CENTER or RIGHT.
	 * @param   Icon           The icon to use for the button
	 * @param   UpHandler      The function to be called when the button is pressed.
	 * @param   ToggleMode     Whether this is a toggle button or not.
	 * @param   UpdateLayout   Whether to update the button layout.
	 * @return  The added button.</haxe_doc>
		</addButton>
		<removeButton public="1" set="method" line="407">
			<f a="Button:?UpdateLayout" v=":true">
				<c path="flixel.system.ui.FlxSystemButton"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ UpdateLayout : true }</e></m></meta>
			<haxe_doc>* Removes and destroys a button from the debugger.
	 * 
	 * @param   Button         The FlxSystemButton instance to remove.
	 * @param   UpdateLayout   Whether to update the button layout.</haxe_doc>
		</removeButton>
		<addWindowToggleButton public="1" set="method" line="420"><f a="window:icon">
	<c path="flixel.system.debug.Window"/>
	<x path="Class"><t path="flash.display.BitmapData"/></x>
	<x path="Void"/>
</f></addWindowToggleButton>
		<addWindow public="1" get="inline" set="null" line="428"><f a="window">
	<c path="flixel.system.debug.Window"/>
	<c path="flixel.system.debug.Window"/>
</f></addWindow>
		<removeWindow public="1" get="inline" set="null" line="440"><f a="window">
	<c path="flixel.system.debug.Window"/>
	<x path="Void"/>
</f></removeWindow>
		<addChild public="1" set="method" line="447" override="1"><f a="child">
	<c path="openfl.display.DisplayObject"/>
	<c path="openfl.display.DisplayObject"/>
</f></addChild>
		<onMouseOver set="method" line="459">
			<f a="_">
				<unknown/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Mouse handler that helps with fake "mouse focus" type behavior.</haxe_doc>
		</onMouseOver>
		<onMouseOut set="method" line="467">
			<f a="_">
				<unknown/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Mouse handler that helps with fake "mouse focus" type behavior.</haxe_doc>
		</onMouseOut>
		<onMouseFocus set="method" line="472"><f a=""><x path="Void"/></f></onMouseFocus>
		<onMouseFocusLost set="method" line="484">
			<f a=""><x path="Void"/></f>
			<meta><m n=":allow"><e>flixel.system.debug</e></m></meta>
		</onMouseFocusLost>
		<toggleDrawDebug get="inline" set="null" line="496"><f a=""><x path="Void"/></f></toggleDrawDebug>
		<openHomepage get="inline" set="null" line="501"><f a=""><x path="Void"/></f></openHomepage>
		<openGitHub get="inline" set="null" line="506"><f a=""><x path="Void"/></f></openGitHub>
		<new set="method" line="118">
			<f a="Width:Height">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":allow"><e>flixel.FlxGame</e></m></meta>
			<haxe_doc>* Instantiates the debugger overlay.
	 * 
	 * @param   Width    The width of the screen.
	 * @param   Height   The height of the screen.</haxe_doc>
		</new>
		<haxe_doc>* Container for the new debugger overlay. Most of the functionality is in the debug folder widgets,
 * but this class instantiates the widgets and handles their basic formatting and arrangement.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<enum path="flixel.system.debug.FlxDebuggerLayout" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/system/debug/FlxDebugger.hx" module="flixel.system.debug.FlxDebugger">
		<STANDARD/>
		<MICRO/>
		<BIG/>
		<TOP/>
		<LEFT/>
		<RIGHT/>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<class path="flixel.system.debug.Tooltip" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/system/debug/Tooltip.hx">
		<_tooltips expr="[]" line="18" static="1">
			<c path="Array"><c path="flixel.system.debug.TooltipOverlay"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</_tooltips>
		<_container static="1"><t path="flash.display.Sprite"/></_container>
		<init public="1" set="method" line="21" static="1"><f a="container">
	<t path="flash.display.Sprite"/>
	<x path="Void"/>
</f></init>
		<add public="1" set="method" line="26" static="1"><f a="element:text">
	<t path="flash.display.Sprite"/>
	<c path="String"/>
	<x path="Void"/>
</f></add>
		<remove public="1" set="method" line="34" static="1"><f a="element">
	<t path="flash.display.Sprite"/>
	<x path="Bool"/>
</f></remove>
		<haxe_doc>* Manages tooltips to be used within the debugger.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="flixel.system.debug.TooltipOverlay" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/system/debug/Tooltip.hx" module="flixel.system.debug.Tooltip">
		<extends path="openfl.display.Sprite"/>
		<BG_COLOR get="inline" set="null" expr="0xFF3A3A3A" line="61" static="1">
			<x path="flixel.util.FlxColor"/>
			<meta><m n=":value"><e>0xFF3A3A3A</e></m></meta>
			<haxe_doc>* The background color of all tooltips.</haxe_doc>
		</BG_COLOR>
		<TEXT_ALPHA get="inline" set="null" expr="0.8" line="66" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>0.8</e></m></meta>
			<haxe_doc>* Alpha applied to the tooltips text.</haxe_doc>
		</TEXT_ALPHA>
		<MARGIN_X get="inline" set="null" expr="10" line="71" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>10</e></m></meta>
			<haxe_doc>* How many pixels the tooltip should be away from the target in the x axis.</haxe_doc>
		</MARGIN_X>
		<MARGIN_Y get="inline" set="null" expr="10" line="76" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>10</e></m></meta>
			<haxe_doc>* How many pixels the tooltip should be away from the target in the y axis.</haxe_doc>
		</MARGIN_Y>
		<_width>
			<x path="Int"/>
			<haxe_doc>* Width of the tooltip. Using Sprite.width is super unreliable for some reason!</haxe_doc>
		</_width>
		<_height>
			<x path="Int"/>
			<haxe_doc>* Height of the tooltip. Using Sprite.height is super unreliable for some reason!</haxe_doc>
		</_height>
		<_background>
			<t path="flash.display.Bitmap"/>
			<haxe_doc>* Main elements</haxe_doc>
		</_background>
		<_shadow><t path="flash.display.Bitmap"/></_shadow>
		<_text><t path="flash.text.TextField"/></_text>
		<owner public="1" set="null">
			<t path="flash.display.Sprite"/>
			<haxe_doc>* The element the tooltip is attached to.</haxe_doc>
		</owner>
		<maxSize public="1">
			<t path="flash.geom.Point"/>
			<haxe_doc>* Maximum size allowed for the tooltip. A negative value (or zero) makes
	 * the tooltip auto-adjust its size to properly house its text.</haxe_doc>
		</maxSize>
		<destroy public="1" set="method" line="143">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Clean up memory.</haxe_doc>
		</destroy>
		<resize public="1" set="method" line="161">
			<f a="Width:Height">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Resize the tooltip. Subject to pre-specified minimums, maximums, and bounding rectangles.
	 *
	 * @param 	Width	How wide to make the tooltip. If zero is specified, the tooltip will adjust its size to properly accommodate the text.
	 * @param 	Height	How tall to make the tooltip. If zero is specified, the tooltip will adjust its size to properly accommodate the text.</haxe_doc>
		</resize>
		<reposition public="1" set="method" line="174">
			<f a="X:Y">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Change the position of the tooltip.
	 * 
	 * @param 	X	Desired X position of top left corner of the tooltip.
	 * @param 	Y	Desired Y position of top left corner of the tooltip.</haxe_doc>
		</reposition>
		<setVisible public="1" set="method" line="181"><f a="Value">
	<x path="Bool"/>
	<x path="Void"/>
</f></setVisible>
		<toggleVisible public="1" set="method" line="192"><f a=""><x path="Void"/></f></toggleVisible>
		<putOnTop public="1" get="inline" set="null" line="197"><f a=""><x path="Void"/></f></putOnTop>
		<update public="1" set="method" line="202"><f a=""><x path="Void"/></f></update>
		<updateSize set="method" line="207">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Update the Flash shapes to match the new size, and reposition the header, shadow, and handle accordingly.</haxe_doc>
		</updateSize>
		<ensureOnScreen set="method" line="218"><f a=""><x path="Void"/></f></ensureOnScreen>
		<handleMouseEvents set="method" line="234"><f a="event">
	<t path="flash.events.MouseEvent"/>
	<x path="Void"/>
</f></handleMouseEvents>
		<new public="1" set="method" line="113">
			<f a="target:text:?width:?height" v="::0:0">
				<t path="flash.display.Sprite"/>
				<c path="String"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ height : 0, width : 0 }</e></m></meta>
			<haxe_doc>* Creates a new tooltip.
	 * 
	 * @param	target	Element where the tooltip will be attached to.
	 * @param	text	Text displayed with this tooltip.
	 * @param	width	Width of the tooltip.  If a negative value (or zero) is specified, the tooltip will adjust its width to properly accommodate the text.
	 * @param	height	Height of the tooltip.  If a negative value (or zero) is specified, the tooltip will adjust its height to properly accommodate the text.</haxe_doc>
		</new>
		<haxe_doc>* A generic, Flash-based tooltip class, created for use in FlxDebugger.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="flixel.system.debug._VCR.GraphicOpen" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/system/debug/VCR.hx" private="1" module="flixel.system.debug.VCR">
		<extends path="openfl.display.BitmapData"/>
		<resourceName expr="&quot;__ASSET__:bitmap_flixel_system_debug__VCR_GraphicOpen&quot;" line="1" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"__ASSET__:bitmap_flixel_system_debug__VCR_GraphicOpen"</e></m></meta>
		</resourceName>
		<new public="1" set="method" line="1">
			<f a="width:height:?transparent:?fillRGBA" v="::true:0xFFFFFFFF">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ fillRGBA : 0xFFFFFFFF, transparent : true }</e></m></meta>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>openfl.Assets.embedBitmap()</e></m>
			<m n=":autoBuild"><e>openfl.Assets.embedBitmap()</e></m>
			<m n=":bitmap"><e>"assets/images/debugger/buttons/open.png"</e></m>
		</meta>
	</class>
	<class path="flixel.system.debug._VCR.GraphicPause" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/system/debug/VCR.hx" private="1" module="flixel.system.debug.VCR">
		<extends path="openfl.display.BitmapData"/>
		<resourceName expr="&quot;__ASSET__:bitmap_flixel_system_debug__VCR_GraphicPause&quot;" line="1" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"__ASSET__:bitmap_flixel_system_debug__VCR_GraphicPause"</e></m></meta>
		</resourceName>
		<new public="1" set="method" line="1">
			<f a="width:height:?transparent:?fillRGBA" v="::true:0xFFFFFFFF">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ fillRGBA : 0xFFFFFFFF, transparent : true }</e></m></meta>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>openfl.Assets.embedBitmap()</e></m>
			<m n=":autoBuild"><e>openfl.Assets.embedBitmap()</e></m>
			<m n=":bitmap"><e>"assets/images/debugger/buttons/pause.png"</e></m>
		</meta>
	</class>
	<class path="flixel.system.debug._VCR.GraphicRecordOff" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/system/debug/VCR.hx" private="1" module="flixel.system.debug.VCR">
		<extends path="openfl.display.BitmapData"/>
		<resourceName expr="&quot;__ASSET__:bitmap_flixel_system_debug__VCR_GraphicRecordOff&quot;" line="1" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"__ASSET__:bitmap_flixel_system_debug__VCR_GraphicRecordOff"</e></m></meta>
		</resourceName>
		<new public="1" set="method" line="1">
			<f a="width:height:?transparent:?fillRGBA" v="::true:0xFFFFFFFF">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ fillRGBA : 0xFFFFFFFF, transparent : true }</e></m></meta>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>openfl.Assets.embedBitmap()</e></m>
			<m n=":autoBuild"><e>openfl.Assets.embedBitmap()</e></m>
			<m n=":bitmap"><e>"assets/images/debugger/buttons/record_off.png"</e></m>
		</meta>
	</class>
	<class path="flixel.system.debug._VCR.GraphicRecordOn" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/system/debug/VCR.hx" private="1" module="flixel.system.debug.VCR">
		<extends path="openfl.display.BitmapData"/>
		<resourceName expr="&quot;__ASSET__:bitmap_flixel_system_debug__VCR_GraphicRecordOn&quot;" line="1" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"__ASSET__:bitmap_flixel_system_debug__VCR_GraphicRecordOn"</e></m></meta>
		</resourceName>
		<new public="1" set="method" line="1">
			<f a="width:height:?transparent:?fillRGBA" v="::true:0xFFFFFFFF">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ fillRGBA : 0xFFFFFFFF, transparent : true }</e></m></meta>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>openfl.Assets.embedBitmap()</e></m>
			<m n=":autoBuild"><e>openfl.Assets.embedBitmap()</e></m>
			<m n=":bitmap"><e>"assets/images/debugger/buttons/record_on.png"</e></m>
		</meta>
	</class>
	<class path="flixel.system.debug._VCR.GraphicRestart" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/system/debug/VCR.hx" private="1" module="flixel.system.debug.VCR">
		<extends path="openfl.display.BitmapData"/>
		<resourceName expr="&quot;__ASSET__:bitmap_flixel_system_debug__VCR_GraphicRestart&quot;" line="1" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"__ASSET__:bitmap_flixel_system_debug__VCR_GraphicRestart"</e></m></meta>
		</resourceName>
		<new public="1" set="method" line="1">
			<f a="width:height:?transparent:?fillRGBA" v="::true:0xFFFFFFFF">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ fillRGBA : 0xFFFFFFFF, transparent : true }</e></m></meta>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>openfl.Assets.embedBitmap()</e></m>
			<m n=":autoBuild"><e>openfl.Assets.embedBitmap()</e></m>
			<m n=":bitmap"><e>"assets/images/debugger/buttons/restart.png"</e></m>
		</meta>
	</class>
	<class path="flixel.system.debug._VCR.GraphicStep" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/system/debug/VCR.hx" private="1" module="flixel.system.debug.VCR">
		<extends path="openfl.display.BitmapData"/>
		<resourceName expr="&quot;__ASSET__:bitmap_flixel_system_debug__VCR_GraphicStep&quot;" line="1" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"__ASSET__:bitmap_flixel_system_debug__VCR_GraphicStep"</e></m></meta>
		</resourceName>
		<new public="1" set="method" line="1">
			<f a="width:height:?transparent:?fillRGBA" v="::true:0xFFFFFFFF">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ fillRGBA : 0xFFFFFFFF, transparent : true }</e></m></meta>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>openfl.Assets.embedBitmap()</e></m>
			<m n=":autoBuild"><e>openfl.Assets.embedBitmap()</e></m>
			<m n=":bitmap"><e>"assets/images/debugger/buttons/step.png"</e></m>
		</meta>
	</class>
	<class path="flixel.system.debug._VCR.GraphicStop" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/system/debug/VCR.hx" private="1" module="flixel.system.debug.VCR">
		<extends path="openfl.display.BitmapData"/>
		<resourceName expr="&quot;__ASSET__:bitmap_flixel_system_debug__VCR_GraphicStop&quot;" line="1" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"__ASSET__:bitmap_flixel_system_debug__VCR_GraphicStop"</e></m></meta>
		</resourceName>
		<new public="1" set="method" line="1">
			<f a="width:height:?transparent:?fillRGBA" v="::true:0xFFFFFFFF">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ fillRGBA : 0xFFFFFFFF, transparent : true }</e></m></meta>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>openfl.Assets.embedBitmap()</e></m>
			<m n=":autoBuild"><e>openfl.Assets.embedBitmap()</e></m>
			<m n=":bitmap"><e>"assets/images/debugger/buttons/stop.png"</e></m>
		</meta>
	</class>
	<class path="flixel.system.debug.VCR" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/system/debug/VCR.hx">
		<runtimeDisplay public="1">
			<t path="flash.text.TextField"/>
			<haxe_doc>* Texfield that displays the runtime display data for a game replay</haxe_doc>
		</runtimeDisplay>
		<runtime public="1" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</runtime>
		<manualPause public="1" set="null" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
			<haxe_doc>* `true` if the pause happened via the debugger UI, `false` if it happened programmatically
	 * (or if the VCR is not paused at all right now).</haxe_doc>
		</manualPause>
		<playbackToggleBtn public="1"><c path="flixel.system.ui.FlxSystemButton"/></playbackToggleBtn>
		<stepBtn public="1"><c path="flixel.system.ui.FlxSystemButton"/></stepBtn>
		<restartBtn public="1"><c path="flixel.system.ui.FlxSystemButton"/></restartBtn>
		<recordBtn public="1"><c path="flixel.system.ui.FlxSystemButton"/></recordBtn>
		<openBtn public="1"><c path="flixel.system.ui.FlxSystemButton"/></openBtn>
		<onManualPause set="method" line="139"><f a=""><x path="Void"/></f></onManualPause>
		<onPause public="1" set="method" line="150">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Called when the user presses the Pause button.
	 * This is different from user-defined pause behavior, or focus lost behavior.
	 * Does NOT pause music playback!!</haxe_doc>
		</onPause>
		<onResume public="1" set="method" line="160">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Called when the user presses the Play button.
	 * This is different from user-defined unpause behavior, or focus gained behavior.</haxe_doc>
		</onResume>
		<onStep public="1" set="method" line="171">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Called when the user presses the fast-forward-looking button.
	 * Requests a 1-frame step forward in the game loop.</haxe_doc>
		</onStep>
		<new public="1" set="method" line="61">
			<f a="Debugger">
				<c path="flixel.system.debug.FlxDebugger"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Creates the "VCR" control panel for debugger pausing, stepping, and recording.</haxe_doc>
		</new>
		<haxe_doc>* This class contains the record, stop, play, and step 1 frame buttons seen on the top edge of the debugger overlay.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="flixel.system.debug._Window.GraphicWindowHandle" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/system/debug/Window.hx" private="1" module="flixel.system.debug.Window">
		<extends path="openfl.display.BitmapData"/>
		<resourceName expr="&quot;__ASSET__:bitmap_flixel_system_debug__Window_GraphicWindowHandle&quot;" line="1" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"__ASSET__:bitmap_flixel_system_debug__Window_GraphicWindowHandle"</e></m></meta>
		</resourceName>
		<new public="1" set="method" line="1">
			<f a="width:height:?transparent:?fillRGBA" v="::true:0xFFFFFFFF">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ fillRGBA : 0xFFFFFFFF, transparent : true }</e></m></meta>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>openfl.Assets.embedBitmap()</e></m>
			<m n=":autoBuild"><e>openfl.Assets.embedBitmap()</e></m>
			<m n=":bitmap"><e>"assets/images/debugger/windowHandle.png"</e></m>
		</meta>
	</class>
	<class path="flixel.system.debug.Window" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/system/debug/Window.hx">
		<extends path="openfl.display.Sprite"/>
		<BG_COLOR public="1" get="inline" set="null" expr="0xDD5F5F5F" line="29" static="1">
			<x path="flixel.util.FlxColor"/>
			<meta><m n=":value"><e>0xDD5F5F5F</e></m></meta>
			<haxe_doc>* The background color of the window.</haxe_doc>
		</BG_COLOR>
		<HEADER_COLOR public="1" get="inline" set="null" expr="0xBB000000" line="31" static="1">
			<x path="flixel.util.FlxColor"/>
			<meta><m n=":value"><e>0xBB000000</e></m></meta>
		</HEADER_COLOR>
		<HEADER_ALPHA public="1" get="inline" set="null" expr="0.8" line="32" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>0.8</e></m></meta>
		</HEADER_ALPHA>
		<HEADER_HEIGHT public="1" get="inline" set="null" expr="15" line="33" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>15</e></m></meta>
		</HEADER_HEIGHT>
		<WINDOW_AMOUNT expr="0" line="38" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* How many windows there are currently in total.</haxe_doc>
		</WINDOW_AMOUNT>
		<minSize public="1"><t path="flash.geom.Point"/></minSize>
		<maxSize public="1"><t path="flash.geom.Point"/></maxSize>
		<toggleButton public="1"><c path="flixel.system.ui.FlxSystemButton"/></toggleButton>
		<_width>
			<x path="Int"/>
			<haxe_doc>* Width of the window. Using Sprite.width is super unreliable for some reason!</haxe_doc>
		</_width>
		<_height>
			<x path="Int"/>
			<haxe_doc>* Height of the window. Using Sprite.height is super unreliable for some reason!</haxe_doc>
		</_height>
		<_bounds>
			<t path="flash.geom.Rectangle"/>
			<haxe_doc>* Controls where the window is allowed to be positioned.</haxe_doc>
		</_bounds>
		<_background>
			<t path="flash.display.Bitmap"/>
			<haxe_doc>* Window elements</haxe_doc>
		</_background>
		<_header><t path="flash.display.Bitmap"/></_header>
		<_shadow><t path="flash.display.Bitmap"/></_shadow>
		<_title><t path="flash.text.TextField"/></_title>
		<_handle><t path="flash.display.Bitmap"/></_handle>
		<_closeButton><c path="flixel.system.ui.FlxSystemButton"/></_closeButton>
		<_overHeader>
			<x path="Bool"/>
			<haxe_doc>* Interaction helpers.</haxe_doc>
		</_overHeader>
		<_overHandle><x path="Bool"/></_overHandle>
		<_drag><t path="flash.geom.Point"/></_drag>
		<_dragging><x path="Bool"/></_dragging>
		<_resizing><x path="Bool"/></_resizing>
		<_resizable><x path="Bool"/></_resizable>
		<_closable><x path="Bool"/></_closable>
		<_id>
			<x path="Int"/>
			<haxe_doc>* The ID of this window.</haxe_doc>
		</_id>
		<destroy public="1" set="method" line="165">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Clean up memory.</haxe_doc>
		</destroy>
		<resize public="1" set="method" line="219">
			<f a="Width:Height">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Resize the window.  Subject to pre-specified minimums, maximums, and bounding rectangles.
	 *
	 * @param 	Width	How wide to make the window.
	 * @param 	Height	How tall to make the window.</haxe_doc>
		</resize>
		<reposition public="1" set="method" line="232">
			<f a="X:Y">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Change the position of the window.  Subject to pre-specified bounding rectangles.
	 * 
	 * @param 	X	Desired X position of top left corner of the window.
	 * @param 	Y	Desired Y position of top left corner of the window.</haxe_doc>
		</reposition>
		<updateBounds public="1" set="method" line="239"><f a="Bounds">
	<t path="flash.geom.Rectangle"/>
	<x path="Void"/>
</f></updateBounds>
		<setVisible public="1" set="method" line="252"><f a="Value">
	<x path="Bool"/>
	<x path="Void"/>
</f></setVisible>
		<toggleVisible public="1" set="method" line="269"><f a=""><x path="Void"/></f></toggleVisible>
		<putOnTop public="1" get="inline" set="null" line="274"><f a=""><x path="Void"/></f></putOnTop>
		<loadSaveData set="method" line="279"><f a=""><x path="Void"/></f></loadSaveData>
		<initSaveData set="method" line="292"><f a=""><x path="Void"/></f></initSaveData>
		<update public="1" set="method" line="303"><f a=""><x path="Void"/></f></update>
		<init set="method" line="310">
			<f a="?E">
				<t path="flash.events.Event"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Used to set up basic mouse listeners..</haxe_doc>
		</init>
		<onMouseMove set="method" line="332">
			<f a="?E">
				<t path="flash.events.MouseEvent"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Mouse movement handler.  Figures out if mouse is over handle or header bar or what.</haxe_doc>
		</onMouseMove>
		<onMouseDown set="method" line="371">
			<f a="?E">
				<t path="flash.events.MouseEvent"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Figure out if window is being repositioned (clicked on header) or resized (clicked on handle).</haxe_doc>
		</onMouseDown>
		<onMouseUp set="method" line="392">
			<f a="?E">
				<t path="flash.events.MouseEvent"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* User let go of header bar or handler (or nothing), so turn off drag and resize behaviors.</haxe_doc>
		</onMouseUp>
		<bound public="1" set="method" line="401">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Keep the window within the pre-specified bounding rectangle.</haxe_doc>
		</bound>
		<updateSize set="method" line="413">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Update the Flash shapes to match the new size, and reposition the header, shadow, and handle accordingly.</haxe_doc>
		</updateSize>
		<close public="1" set="method" line="436"><f a=""><x path="Void"/></f></close>
		<new public="1" set="method" line="95">
			<f a="Title:?Icon:?Width:?Height:?Resizable:?Bounds:?Closable" v="::0:0:true::false">
				<c path="String"/>
				<t path="flash.display.BitmapData"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Bool"/>
				<t path="flash.geom.Rectangle"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ Closable : false, Resizable : true, Height : 0, Width : 0 }</e></m></meta>
			<haxe_doc>* Creates a new window object.  This Flash-based class is mainly (only?) used by FlxDebugger.
	 * 
	 * @param   Title       The name of the window, displayed in the header bar.
	 * @param   Icon	    The icon to use for the window header.
	 * @param   Width       The initial width of the window.
	 * @param   Height      The initial height of the window.
	 * @param   Resizable   Whether you can change the size of the window with a drag handle.
	 * @param   Bounds      A rectangle indicating the valid screen area for the window.
	 * @param   Closable    Whether this window has a close button that removes the window.</haxe_doc>
		</new>
		<haxe_doc>* A generic, Flash-based window class, created for use in FlxDebugger.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="flixel.system.debug.completion.CompletionHandler" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/system/debug/completion/CompletionHandler.hx">
		<ENTRY_VALUE get="inline" set="null" expr="&quot;Entry Value&quot;" line="16" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"Entry Value"</e></m></meta>
		</ENTRY_VALUE>
		<ENTRY_TYPE get="inline" set="null" expr="&quot;Entry Type&quot;" line="17" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"Entry Type"</e></m></meta>
		</ENTRY_TYPE>
		<completionList><c path="flixel.system.debug.completion.CompletionList"/></completionList>
		<input><c path="openfl.text.TextField"/></input>
		<watchingSelection expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</watchingSelection>
		<getTextUntilCaret set="method" line="35"><f a=""><c path="String"/></f></getTextUntilCaret>
		<getCaretIndex set="method" line="40"><f a=""><x path="Int"/></f></getCaretIndex>
		<onKeyUp set="method" line="50"><f a="e">
	<c path="openfl.events.KeyboardEvent"/>
	<x path="Void"/>
</f></onKeyUp>
		<invokeCompletion set="method" line="77"><f a="path:isPeriod">
	<c path="String"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></invokeCompletion>
		<getGlobals set="method" line="109"><f a=""><c path="Array"><c path="String"/></c></f></getGlobals>
		<getCharXPosition set="method" line="118"><f a=""><x path="Float"/></f></getCharXPosition>
		<getCompletedText set="method" line="126"><f a="text:selectedItem">
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
</f></getCompletedText>
		<completed set="method" line="132"><f a="selectedItem">
	<c path="String"/>
	<x path="Void"/>
</f></completed>
		<selectionChanged set="method" line="140"><f a="selectedItem">
	<c path="String"/>
	<x path="Void"/>
</f></selectionChanged>
		<getReadableType set="method" line="157"><f a="v">
	<d/>
	<c path="String"/>
</f></getReadableType>
		<completionClosed set="method" line="174"><f a=""><x path="Void"/></f></completionClosed>
		<getPathBeforeDot set="method" line="184"><f a="text">
	<c path="String"/>
	<c path="String"/>
</f></getPathBeforeDot>
		<getWordAfterDot set="method" line="191"><f a="text">
	<c path="String"/>
	<c path="String"/>
</f></getWordAfterDot>
		<getLastWord set="method" line="205"><f a="text">
	<c path="String"/>
	<c path="String"/>
</f></getLastWord>
		<new public="1" set="method" line="23"><f a="completionList:input">
	<c path="flixel.system.debug.completion.CompletionList"/>
	<c path="openfl.text.TextField"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="flixel.system.debug.completion.CompletionList" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/system/debug/completion/CompletionList.hx">
		<extends path="openfl.display.Sprite"/>
		<completed public="1"><f a="">
	<c path="String"/>
	<x path="Void"/>
</f></completed>
		<selectionChanged public="1"><f a="">
	<c path="String"/>
	<x path="Void"/>
</f></selectionChanged>
		<closed public="1"><f a=""><x path="Void"/></f></closed>
		<filter public="1" set="accessor"><c path="String"/></filter>
		<items public="1" set="null"><c path="Array"><c path="String"/></c></items>
		<entries expr="[]">
			<c path="Array"><c path="flixel.system.debug.completion.CompletionListEntry"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</entries>
		<originalItems><c path="Array"><c path="String"/></c></originalItems>
		<selectedIndex expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</selectedIndex>
		<lowerVisibleIndex expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</lowerVisibleIndex>
		<upperVisibleIndex expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</upperVisibleIndex>
		<scrollBar><c path="flixel.system.debug.completion.CompletionListScrollBar"/></scrollBar>
		<actualHeight><x path="Int"/></actualHeight>
		<show public="1" set="method" line="43"><f a="x:items">
	<x path="Float"/>
	<c path="Array"><c path="String"/></c>
	<x path="Void"/>
</f></show>
		<setY public="1" set="method" line="53"><f a="y">
	<x path="Float"/>
	<x path="Void"/>
</f></setY>
		<close public="1" set="method" line="58"><f a=""><x path="Void"/></f></close>
		<createPopupEntries set="method" line="67"><f a="amount">
	<x path="Int"/>
	<x path="Void"/>
</f></createPopupEntries>
		<createScrollBar set="method" line="78"><f a=""><x path="Void"/></f></createScrollBar>
		<onKeyDown set="method" line="85"><f a="e">
	<c path="openfl.events.KeyboardEvent"/>
	<x path="Void"/>
</f></onKeyDown>
		<updateIndices set="method" line="112"><f a="modifier">
	<x path="Int"/>
	<x path="Void"/>
</f></updateIndices>
		<bound set="method" line="133"><f a="index">
	<x path="Int"/>
	<x path="Int"/>
</f></bound>
		<updateEntries set="method" line="138"><f a=""><x path="Void"/></f></updateEntries>
		<updateLabels set="method" line="145"><f a=""><x path="Void"/></f></updateLabels>
		<updateSelectedItem set="method" line="156"><f a=""><x path="Void"/></f></updateSelectedItem>
		<setItems set="method" line="166"><f a="items">
	<c path="Array"><c path="String"/></c>
	<x path="Void"/>
</f></setItems>
		<filterItems set="method" line="181"><f a="filter">
	<c path="String"/>
	<c path="Array"><c path="String"/></c>
</f></filterItems>
		<sortItems set="method" line="197">
			<f a="filter:items">
				<c path="String"/>
				<c path="Array"><c path="String"/></c>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc><![CDATA[* sort items so that:
	 *   - strings starting with the filter have a higher priority than those only containing it
	 *   - of those, shorter items (-> closer to the filter) have a higher priority]]></haxe_doc>
		</sortItems>
		<startsWithExt set="method" line="221">
			<f a="s:start">
				<c path="String"/>
				<c path="String"/>
				<x path="Int"/>
			</f>
			<haxe_doc>* Custom startsWith() that ignores leading underscores.</haxe_doc>
		</startsWithExt>
		<set_filter set="method" line="230"><f a="filter">
	<c path="String"/>
	<c path="String"/>
</f></set_filter>
		<new public="1" set="method" line="28"><f a="capacity">
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="flixel.system.debug.completion.CompletionListEntry" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/system/debug/completion/CompletionListEntry.hx">
		<extends path="openfl.display.Sprite"/>
		<WIDTH public="1" get="inline" set="null" expr="150" line="11" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>150</e></m></meta>
		</WIDTH>
		<HEIGHT public="1" get="inline" set="null" expr="20" line="12" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>20</e></m></meta>
		</HEIGHT>
		<COLOR_NORMAL get="inline" set="null" expr="0xFF5F5F5F" line="14" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0xFF5F5F5F</e></m></meta>
		</COLOR_NORMAL>
		<COLOR_HIGHLIGHT get="inline" set="null" expr="0xFF6D6D6D" line="15" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0xFF6D6D6D</e></m></meta>
		</COLOR_HIGHLIGHT>
		<GUTTER get="inline" set="null" expr="4" line="16" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>4</e></m></meta>
		</GUTTER>
		<normalBitmapData static="1"><c path="openfl.display.BitmapData"/></normalBitmapData>
		<highlightBitmapData static="1"><c path="openfl.display.BitmapData"/></highlightBitmapData>
		<selected public="1" set="accessor" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</selected>
		<background><c path="openfl.display.Bitmap"/></background>
		<label><c path="openfl.text.TextField"/></label>
		<initBitmapDatas set="method" line="40"><f a=""><x path="Void"/></f></initBitmapDatas>
		<setItem public="1" set="method" line="48"><f a="item">
	<c path="String"/>
	<x path="Void"/>
</f></setItem>
		<set_selected set="method" line="58"><f a="selected">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_selected>
		<new public="1" set="method" line="26"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="flixel.system.debug.completion.CompletionListScrollBar" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/system/debug/completion/CompletionListScrollBar.hx">
		<extends path="openfl.display.Sprite"/>
		<BG_COLOR get="inline" set="null" expr="0xFF444444" line="10" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0xFF444444</e></m></meta>
		</BG_COLOR>
		<HANDLE_COLOR get="inline" set="null" expr="0xFF222222" line="11" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0xFF222222</e></m></meta>
		</HANDLE_COLOR>
		<handle><c path="openfl.display.Bitmap"/></handle>
		<updateHandle public="1" set="method" line="27"><f a="lower:items:entries">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></updateHandle>
		<new public="1" set="method" line="15"><f a="x:y:width:height">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="flixel.system.debug.console.Console" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/system/debug/console/Console.hx">
		<extends path="flixel.system.debug.Window"/>
		<DEFAULT_TEXT get="inline" set="null" expr="&quot;Using the console requires hscript - please run &apos;haxelib install hscript&apos;.&quot;" line="37" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"Using the console requires hscript - please run 'haxelib install hscript'."</e></m></meta>
			<haxe_doc>* The text that is displayed in the console's input field by default.</haxe_doc>
		</DEFAULT_TEXT>
		<registeredObjects public="1" expr="new Map&lt;String,Dynamic&gt;()">
			<x path="Map">
				<c path="String"/>
				<d/>
			</x>
			<meta><m n=":value"><e><![CDATA[new Map<String,Dynamic>()]]></e></m></meta>
			<haxe_doc>* Map containing all registered Objects. You can use registerObject() or add them directly to this map.</haxe_doc>
		</registeredObjects>
		<registeredFunctions public="1" expr="new Map&lt;String,Dynamic&gt;()">
			<x path="Map">
				<c path="String"/>
				<d/>
			</x>
			<meta><m n=":value"><e><![CDATA[new Map<String,Dynamic>()]]></e></m></meta>
			<haxe_doc>* Map containing all registered Functions. You can use registerFunction() or add them directly to this map.</haxe_doc>
		</registeredFunctions>
		<registeredHelp public="1" expr="new Map&lt;String,String&gt;()">
			<x path="Map">
				<c path="String"/>
				<c path="String"/>
			</x>
			<meta><m n=":value"><e><![CDATA[new Map<String,String>()]]></e></m></meta>
			<haxe_doc>* Map containing all registered help text. Set these values from registerObject() or registerFunction().</haxe_doc>
		</registeredHelp>
		<objectStack public="1" expr="[]">
			<c path="Array"><c path="flixel.FlxObject"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
			<haxe_doc>* Internal helper var containing all the FlxObjects created via the create command.</haxe_doc>
		</objectStack>
		<input>
			<c path="openfl.text.TextField"/>
			<haxe_doc>* The input textfield used to enter commands.</haxe_doc>
		</input>
		<inputMouseDown expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</inputMouseDown>
		<stageMouseDown expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</stageMouseDown>
		<history public="1"><c path="flixel.system.debug.console.ConsoleHistory"/></history>
		<completionList><c path="flixel.system.debug.completion.CompletionList"/></completionList>
		<createInputTextField set="method" line="95"><f a=""><x path="Void"/></f></createInputTextField>
		<registerEventListeners set="method" line="110"><f a=""><x path="Void"/></f></registerEventListeners>
		<update public="1" set="method" line="133" override="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":access"><e>flixel.FlxGame.onFocus</e></m></meta>
		</update>
		<onFocus set="method" line="150">
			<f a="_">
				<unknown/>
				<x path="Void"/>
			</f>
			<meta><m n=":access"><e>flixel.FlxGame</e></m></meta>
		</onFocus>
		<onFocusLost set="method" line="173">
			<f a="_">
				<unknown/>
				<x path="Void"/>
			</f>
			<meta><m n=":access"><e>flixel.FlxGame</e></m></meta>
		</onFocusLost>
		<registerFunction public="1" get="inline" set="null" line="281">
			<f a="functionAlias:func:?helpText">
				<c path="String"/>
				<d/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Register a new function to use in any command.
	 * 
	 * @param 	FunctionAlias	The name with which you want to access the function.
	 * @param 	Function		The function to register.
	 * @param 	HelpText		An optional string to trace to the console using the "help" command.</haxe_doc>
		</registerFunction>
		<registerObject public="1" get="inline" set="null" line="298">
			<f a="objectAlias:anyObject">
				<c path="String"/>
				<d/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Register a new object to use in any command.
	 * 
	 * @param 	ObjectAlias		The name with which you want to access the object.
	 * @param 	AnyObject		The object to register.</haxe_doc>
		</registerObject>
		<registerClass public="1" get="inline" set="null" line="311">
			<f a="cl">
				<x path="Class"><d/></x>
				<x path="Void"/>
			</f>
			<haxe_doc>* Register a new class to use in any command.
	 * 
	 * @param 	cl			The class to register.</haxe_doc>
		</registerClass>
		<destroy public="1" set="method" line="316" override="1"><f a=""><x path="Void"/></f></destroy>
		<updateSize set="method" line="342" override="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Adjusts the width and height of the text field accordingly.</haxe_doc>
		</updateSize>
		<new public="1" set="method" line="74">
			<f a="completionList">
				<c path="flixel.system.debug.completion.CompletionList"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Creates a new console window object.</haxe_doc>
		</new>
		<haxe_doc>* A powerful console for the flixel debugger screen with supports custom commands, registering 
 * objects and functions and saves the last 25 commands used. Inspired by Eric Smith's "CoolConsole".
 * @link http://www.youtube.com/watch?v=QWfpw7elWk8</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="flixel.system.debug.console.ConsoleCommands" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/system/debug/console/ConsoleCommands.hx">
		<_console><c path="flixel.system.debug.console.Console"/></_console>
		<_watchingMouse expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
			<haxe_doc>* Helper variable for toggling the mouse coords in the watch window.</haxe_doc>
		</_watchingMouse>
		<help set="method" line="74"><f a="?Alias">
	<c path="String"/>
	<c path="String"/>
</f></help>
		<close get="inline" set="null" line="104"><f a=""><x path="Void"/></f></close>
		<create params="T" set="method" line="109">
			<f a="ObjClass:?MousePos:?Params" v=":true:">
				<x path="Class"><c path="create.T"/></x>
				<x path="Bool"/>
				<c path="Array"><d/></c>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ MousePos : true }</e></m></meta>
		</create>
		<fields set="method" line="139"><f a="Object">
	<d/>
	<c path="String"/>
</f></fields>
		<listObjects set="method" line="145"><f a=""><x path="Void"/></f></listObjects>
		<listFunctions set="method" line="150"><f a=""><x path="Void"/></f></listFunctions>
		<watchMouse set="method" line="155"><f a=""><x path="Void"/></f></watchMouse>
		<pause set="method" line="171"><f a=""><x path="Void"/></f></pause>
		<step set="method" line="185"><f a=""><x path="Void"/></f></step>
		<new public="1" set="method" line="23"><f a="console">
	<c path="flixel.system.debug.console.Console"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="flixel.system.debug.console.ConsoleHistory" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/system/debug/console/ConsoleHistory.hx">
		<MAX_LENGTH get="inline" set="null" expr="50" line="5" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>50</e></m></meta>
		</MAX_LENGTH>
		<commands public="1"><c path="Array"><c path="String"/></c></commands>
		<isEmpty public="1" get="accessor" set="null"><x path="Bool"/></isEmpty>
		<index expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</index>
		<getPreviousCommand public="1" set="method" line="27"><f a=""><c path="String"/></f></getPreviousCommand>
		<getNextCommand public="1" set="method" line="34"><f a=""><c path="String"/></f></getNextCommand>
		<addCommand public="1" set="method" line="41"><f a="command">
	<c path="String"/>
	<x path="Void"/>
</f></addCommand>
		<clear public="1" set="method" line="56"><f a=""><x path="Void"/></f></clear>
		<get_isEmpty set="method" line="62"><f a=""><x path="Bool"/></f></get_isEmpty>
		<new public="1" set="method" line="13"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="flixel.system.debug.console.ConsoleUtil" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/system/debug/console/ConsoleUtil.hx">
		<getFields public="1" set="method" line="100" static="1"><f a="Object">
	<d/>
	<c path="Array"><c path="String"/></c>
</f></getFields>
		<sortFields set="method" line="126" static="1"><f a="fields">
	<c path="Array"><c path="String"/></c>
	<c path="Array"><c path="String"/></c>
</f></sortFields>
		<log public="1" get="inline" set="null" line="151" static="1">
			<f a="Text">
				<d/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Shortcut to log a text with the Console LogStyle.
	 * 
	 * @param	Text	The text to log.</haxe_doc>
		</log>
		<haxe_doc>* A set of helper functions used by the console.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="flixel.system.debug.interaction.Interaction" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/system/debug/interaction/Interaction.hx">
		<extends path="flixel.system.debug.Window"/>
		<activeTool public="1" set="null"><c path="flixel.system.debug.interaction.tools.Tool"/></activeTool>
		<selectedItems public="1" set="null" expr="new FlxTypedGroup()">
			<c path="flixel.group.FlxTypedGroup"><c path="flixel.FlxObject"/></c>
			<meta><m n=":value"><e>new FlxTypedGroup()</e></m></meta>
		</selectedItems>
		<flixelPointer public="1" expr="new FlxPoint()">
			<c path="flixel.math.FlxPoint"/>
			<meta><m n=":value"><e>new FlxPoint()</e></m></meta>
		</flixelPointer>
		<pointerJustPressed public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</pointerJustPressed>
		<pointerJustReleased public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</pointerJustReleased>
		<pointerPressed public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</pointerPressed>
		<_container><t path="flash.display.Sprite"/></_container>
		<_customCursor><t path="flash.display.Sprite"/></_customCursor>
		<_tools expr="[]">
			<c path="Array"><c path="flixel.system.debug.interaction.tools.Tool"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</_tools>
		<_turn expr="2">
			<x path="Int"/>
			<meta><m n=":value"><e>2</e></m></meta>
		</_turn>
		<_keysDown expr="new Map()">
			<x path="Map">
				<x path="Int"/>
				<x path="Bool"/>
			</x>
			<meta><m n=":value"><e>new Map()</e></m></meta>
		</_keysDown>
		<_keysUp expr="new Map()">
			<x path="Map">
				<x path="Int"/>
				<x path="Int"/>
			</x>
			<meta><m n=":value"><e>new Map()</e></m></meta>
		</_keysUp>
		<_wasMouseVisible><x path="Bool"/></_wasMouseVisible>
		<_wasUsingSystemCursor><x path="Bool"/></_wasUsingSystemCursor>
		<_debuggerInteraction expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</_debuggerInteraction>
		<_flixelPointer expr="new FlxPointer()">
			<c path="flixel.input.FlxPointer"/>
			<meta><m n=":value"><e>new FlxPointer()</e></m></meta>
		</_flixelPointer>
		<handleDebuggerVisibilityChanged set="method" line="83"><f a=""><x path="Void"/></f></handleDebuggerVisibilityChanged>
		<updateMouse set="method" line="91"><f a="event">
	<t path="flash.events.MouseEvent"/>
	<x path="Void"/>
</f></updateMouse>
		<handleMouseClick set="method" line="127"><f a="event">
	<t path="flash.events.MouseEvent"/>
	<x path="Void"/>
</f></handleMouseClick>
		<belongsToDebugger set="method" line="143"><f a="object">
	<t path="flash.display.DisplayObject"/>
	<x path="Bool"/>
</f></belongsToDebugger>
		<handleMouseInDebugger set="method" line="152"><f a="event">
	<t path="flash.events.MouseEvent"/>
	<x path="Void"/>
</f></handleMouseInDebugger>
		<handleKeyEvent set="method" line="167"><f a="event">
	<t path="flash.events.KeyboardEvent"/>
	<x path="Void"/>
</f></handleKeyEvent>
		<addTool set="method" line="178"><f a="tool">
	<c path="flixel.system.debug.interaction.tools.Tool"/>
	<x path="Void"/>
</f></addTool>
		<destroy public="1" set="method" line="198" override="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Clean up memory.</haxe_doc>
		</destroy>
		<isActive public="1" set="method" line="229"><f a=""><x path="Bool"/></f></isActive>
		<update public="1" set="method" line="234" override="1"><f a=""><x path="Void"/></f></update>
		<postDraw set="method" line="252">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Called after the game state has been drawn.</haxe_doc>
		</postDraw>
		<getDebugGraphics public="1" set="method" line="263"><f a=""><t path="flash.display.Graphics"/></f></getDebugGraphics>
		<drawItemsSelection set="method" line="278"><f a=""><x path="Void"/></f></drawItemsSelection>
		<getTool set="method" line="301"><f a="className">
	<x path="Class"><c path="flixel.system.debug.interaction.tools.Tool"/></x>
	<c path="flixel.system.debug.interaction.tools.Tool"/>
</f></getTool>
		<toggleVisible public="1" set="method" line="309" override="1"><f a=""><x path="Void"/></f></toggleVisible>
		<registerCustomCursor public="1" set="method" line="321"><f a="name:icon">
	<c path="String"/>
	<t path="flash.display.BitmapData"/>
	<x path="Void"/>
</f></registerCustomCursor>
		<updateCustomCursors public="1" set="method" line="337"><f a=""><x path="Void"/></f></updateCustomCursors>
		<saveSystemCursorInfo set="method" line="379"><f a=""><x path="Void"/></f></saveSystemCursorInfo>
		<restoreSystemCursor set="method" line="387"><f a=""><x path="Void"/></f></restoreSystemCursor>
		<setActiveTool public="1" set="method" line="396"><f a="value">
	<c path="flixel.system.debug.interaction.tools.Tool"/>
	<x path="Void"/>
</f></setActiveTool>
		<setSystemCursorVisibility set="method" line="426"><f a="status">
	<x path="Bool"/>
	<x path="Void"/>
</f></setSystemCursorVisibility>
		<setToolsCursorVisibility set="method" line="434"><f a="status">
	<x path="Bool"/>
	<x path="Void"/>
</f></setToolsCursorVisibility>
		<clearSelection public="1" set="method" line="451"><f a=""><x path="Void"/></f></clearSelection>
		<keyPressed public="1" set="method" line="456"><f a="key">
	<x path="Int"/>
	<x path="Bool"/>
</f></keyPressed>
		<keyJustPressed public="1" set="method" line="461"><f a="key">
	<x path="Int"/>
	<x path="Bool"/>
</f></keyJustPressed>
		<findItemsWithinState public="1" set="method" line="467"><f a="items:state:area">
	<c path="Array"><c path="flixel.FlxBasic"/></c>
	<c path="flixel.FlxState"/>
	<c path="flixel.math.FlxRect"/>
	<x path="Void"/>
</f></findItemsWithinState>
		<findItemsWithinArea public="1" set="method" line="485">
			<f a="items:members:area">
				<c path="Array"><c path="flixel.FlxBasic"/></c>
				<c path="Array"><c path="flixel.FlxBasic"/></c>
				<c path="flixel.math.FlxRect"/>
				<x path="Void"/>
			</f>
			<meta><m n=":access"><e>flixel.group.FlxTypedGroup</e></m></meta>
			<haxe_doc>* Find all items within an area. In order to improve performance and reduce temporary allocations,
	 * the method has no return, you must pass an array where items will be placed. The method decides
	 * if an item is within the searching area or not by checking if the item's hitbox (obtained from
	 * `getHitbox()`) overlaps the area parameter.
	 * 
	 * @param	items		array where the method will place all found items. Any previous content in the array will be preserved.
	 * @param	members		array where the method will recursively search for items.
	 * @param	area		a rectangle that describes the area where the method should search within.</haxe_doc>
		</findItemsWithinArea>
		<new public="1" set="method" line="55"><f a="container">
	<t path="flash.display.Sprite"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>* Adds a new functionality to Flixel debugger that allows any object
 * on the screen to be dragged, moved or deleted while the game is
 * still running.
 * 
 * @author	Fernando Bevilacqua (dovyski@gmail.com)</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="flixel.system.debug.interaction.tools.GraphicEraserTool" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/system/debug/interaction/tools/Eraser.hx" module="flixel.system.debug.interaction.tools.Eraser">
		<extends path="openfl.display.BitmapData"/>
		<resourceName expr="&quot;__ASSET__:bitmap_flixel_system_debug_interaction_tools_GraphicEraserTool&quot;" line="1" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"__ASSET__:bitmap_flixel_system_debug_interaction_tools_GraphicEraserTool"</e></m></meta>
		</resourceName>
		<new public="1" set="method" line="1">
			<f a="width:height:?transparent:?fillRGBA" v="::true:0xFFFFFFFF">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ fillRGBA : 0xFFFFFFFF, transparent : true }</e></m></meta>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>openfl.Assets.embedBitmap()</e></m>
			<m n=":autoBuild"><e>openfl.Assets.embedBitmap()</e></m>
			<m n=":bitmap"><e>"assets/images/debugger/buttons/eraser.png"</e></m>
		</meta>
	</class>
	<class path="flixel.system.debug.interaction.tools.Tool" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/system/debug/interaction/tools/Tool.hx">
		<extends path="openfl.display.Sprite"/>
		<implements path="flixel.util.IFlxDestroyable"/>
		<button public="1" set="null"><c path="flixel.system.ui.FlxSystemButton"/></button>
		<cursor public="1" set="null"><t path="flash.display.BitmapData"/></cursor>
		<_name expr="&quot;(Unknown tool)&quot;">
			<c path="String"/>
			<meta><m n=":value"><e>"(Unknown tool)"</e></m></meta>
		</_name>
		<_shortcut><c path="String"/></_shortcut>
		<_brain><c path="flixel.system.debug.interaction.Interaction"/></_brain>
		<init public="1" set="method" line="23"><f a="brain">
	<c path="flixel.system.debug.interaction.Interaction"/>
	<c path="flixel.system.debug.interaction.tools.Tool"/>
</f></init>
		<update public="1" set="method" line="29"><f a=""><x path="Void"/></f></update>
		<draw public="1" set="method" line="31"><f a=""><x path="Void"/></f></draw>
		<activate public="1" set="method" line="33"><f a=""><x path="Void"/></f></activate>
		<deactivate public="1" set="method" line="35"><f a=""><x path="Void"/></f></deactivate>
		<destroy public="1" set="method" line="37"><f a=""><x path="Void"/></f></destroy>
		<isActive public="1" set="method" line="39"><f a=""><x path="Bool"/></f></isActive>
		<setButton set="method" line="44"><f a="Icon">
	<x path="Class"><t path="flash.display.BitmapData"/></x>
	<x path="Void"/>
</f></setButton>
		<setCursor set="method" line="55"><f a="Icon">
	<t path="flash.display.BitmapData"/>
	<x path="Void"/>
</f></setCursor>
		<onButtonClicked set="method" line="61"><f a=""><x path="Void"/></f></onButtonClicked>
		<getName public="1" set="method" line="66"><f a=""><c path="String"/></f></getName>
		<new public="1" set="method" line="14"><f a=""><x path="Void"/></f></new>
		<haxe_doc>* The base class of all tools in the interactive debug. 
 * 
 * @author Fernando Bevilacqua (dovyski@gmail.com)</haxe_doc>
	</class>
	<class path="flixel.system.debug.interaction.tools.Eraser" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/system/debug/interaction/tools/Eraser.hx">
		<extends path="flixel.system.debug.interaction.tools.Tool"/>
		<init public="1" set="method" line="20" override="1"><f a="Brain">
	<c path="flixel.system.debug.interaction.Interaction"/>
	<c path="flixel.system.debug.interaction.tools.Tool"/>
</f></init>
		<update public="1" set="method" line="27" override="1"><f a=""><x path="Void"/></f></update>
		<activate public="1" set="method" line="33" override="1"><f a=""><x path="Void"/></f></activate>
		<doDeletion set="method" line="41"><f a="remove">
	<x path="Bool"/>
	<x path="Void"/>
</f></doDeletion>
		<findAndDelete set="method" line="51">
			<f a="items:?remove" v=":false">
				<c path="flixel.group.FlxTypedGroup"><c path="flixel.FlxObject"/></c>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ remove : false }</e></m></meta>
		</findAndDelete>
		<removeFromMemory set="method" line="71"><f a="item:parentGroup">
	<c path="flixel.FlxBasic"/>
	<t path="flixel.group.FlxGroup"/>
	<x path="Void"/>
</f></removeFromMemory>
		<new public="1" set="method" line="18"><f a=""><x path="Void"/></f></new>
		<haxe_doc>* A tool to delete items from the screen.
 * 
 * @author Fernando Bevilacqua (dovyski@gmail.com)</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="flixel.system.debug.interaction.tools.GraphicMoverTool" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/system/debug/interaction/tools/Mover.hx" module="flixel.system.debug.interaction.tools.Mover">
		<extends path="openfl.display.BitmapData"/>
		<resourceName expr="&quot;__ASSET__:bitmap_flixel_system_debug_interaction_tools_GraphicMoverTool&quot;" line="1" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"__ASSET__:bitmap_flixel_system_debug_interaction_tools_GraphicMoverTool"</e></m></meta>
		</resourceName>
		<new public="1" set="method" line="1">
			<f a="width:height:?transparent:?fillRGBA" v="::true:0xFFFFFFFF">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ fillRGBA : 0xFFFFFFFF, transparent : true }</e></m></meta>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>openfl.Assets.embedBitmap()</e></m>
			<m n=":autoBuild"><e>openfl.Assets.embedBitmap()</e></m>
			<m n=":bitmap"><e>"assets/images/debugger/buttons/mover.png"</e></m>
		</meta>
	</class>
	<class path="flixel.system.debug.interaction.tools.Mover" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/system/debug/interaction/tools/Mover.hx">
		<extends path="flixel.system.debug.interaction.tools.Tool"/>
		<_dragging expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</_dragging>
		<_lastCursorPosition><c path="flixel.math.FlxPoint"/></_lastCursorPosition>
		<init public="1" set="method" line="22" override="1"><f a="brain">
	<c path="flixel.system.debug.interaction.Interaction"/>
	<c path="flixel.system.debug.interaction.tools.Tool"/>
</f></init>
		<update public="1" set="method" line="35" override="1"><f a=""><x path="Void"/></f></update>
		<stopDragging set="method" line="52"><f a=""><x path="Void"/></f></stopDragging>
		<startDragging set="method" line="57"><f a=""><x path="Void"/></f></startDragging>
		<doDragging set="method" line="71"><f a=""><x path="Void"/></f></doDragging>
		<new public="1" set="method" line="17"><f a=""><x path="Void"/></f></new>
		<haxe_doc>* A tool to move selected items.
 * 
 * @author Fernando Bevilacqua (dovyski@gmail.com)</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="flixel.system.debug.interaction.tools.GraphicCursorCross" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/system/debug/interaction/tools/Pointer.hx" module="flixel.system.debug.interaction.tools.Pointer">
		<extends path="openfl.display.BitmapData"/>
		<resourceName expr="&quot;__ASSET__:bitmap_flixel_system_debug_interaction_tools_GraphicCursorCross&quot;" line="1" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"__ASSET__:bitmap_flixel_system_debug_interaction_tools_GraphicCursorCross"</e></m></meta>
		</resourceName>
		<new public="1" set="method" line="1">
			<f a="width:height:?transparent:?fillRGBA" v="::true:0xFFFFFFFF">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ fillRGBA : 0xFFFFFFFF, transparent : true }</e></m></meta>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>openfl.Assets.embedBitmap()</e></m>
			<m n=":autoBuild"><e>openfl.Assets.embedBitmap()</e></m>
			<m n=":bitmap"><e>"assets/images/debugger/cursorCross.png"</e></m>
		</meta>
	</class>
	<class path="flixel.system.debug.interaction.tools.Pointer" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/system/debug/interaction/tools/Pointer.hx">
		<extends path="flixel.system.debug.interaction.tools.Tool"/>
		<_selectionStartPoint expr="new FlxPoint()">
			<c path="flixel.math.FlxPoint"/>
			<meta><m n=":value"><e>new FlxPoint()</e></m></meta>
		</_selectionStartPoint>
		<_selectionEndPoint expr="new FlxPoint()">
			<c path="flixel.math.FlxPoint"/>
			<meta><m n=":value"><e>new FlxPoint()</e></m></meta>
		</_selectionEndPoint>
		<_selectionHappening expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</_selectionHappening>
		<_selectionCancelled expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</_selectionCancelled>
		<_selectionArea expr="new FlxRect()">
			<c path="flixel.math.FlxRect"/>
			<meta><m n=":value"><e>new FlxRect()</e></m></meta>
		</_selectionArea>
		<_itemsInSelectionArea expr="[]">
			<c path="Array"><c path="flixel.FlxBasic"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</_itemsInSelectionArea>
		<init public="1" set="method" line="30" override="1"><f a="brain">
	<c path="flixel.system.debug.interaction.Interaction"/>
	<c path="flixel.system.debug.interaction.tools.Tool"/>
</f></init>
		<update public="1" set="method" line="41" override="1"><f a=""><x path="Void"/></f></update>
		<calculateSelectionArea set="method" line="77"><f a=""><x path="Void"/></f></calculateSelectionArea>
		<startSelection public="1" set="method" line="101">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Start a selection area. A selection area is a rectangular shaped area
	 * whose boundaries will be used to select game elements.</haxe_doc>
		</startSelection>
		<cancelSelection public="1" set="method" line="115">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Cancel any selection activity that is happening, removing the selection rectangle from the screen.
	 * Any item within the (canceled) selection area will be ignored. If you want to stop the selection
	 * and actually process the action/items, use `stopSelection()`.</haxe_doc>
		</cancelSelection>
		<stopSelection public="1" set="method" line="129">
			<f a="?findItems" v="true">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ findItems : true }</e></m></meta>
			<haxe_doc>* Stop any selection activity that is happening. 
	 * 
	 * @param	findItems	If `true` (default), all items within the (stopped) selection area will be included in the list of selected items of the tool.</haxe_doc>
		</stopSelection>
		<updateConsoleSelection set="method" line="151">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* We register the current selection to the console for easy interaction.</haxe_doc>
		</updateConsoleSelection>
		<handleItemAddition set="method" line="161"><f a="itemsInSelectionArea">
	<c path="Array"><c path="flixel.FlxBasic"/></c>
	<x path="Void"/>
</f></handleItemAddition>
		<draw public="1" set="method" line="184" override="1"><f a=""><x path="Void"/></f></draw>
		<new public="1" set="method" line="21"><f a=""><x path="Void"/></f></new>
		<haxe_doc>* A tool to use the mouse cursor to select game elements.
 * 
 * @author Fernando Bevilacqua (dovyski@gmail.com)</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="flixel.system.debug.log.BitmapLog" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/system/debug/log/BitmapLog.hx">
		<extends path="flixel.system.debug.Window"/>
		<zoom public="1" set="accessor" expr="1">
			<x path="Float"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</zoom>
		<_canvas get="accessor" set="null"><t path="flash.display.BitmapData"/></_canvas>
		<_canvasBitmap><t path="flash.display.Bitmap"/></_canvasBitmap>
		<_entries expr="[]">
			<c path="Array"><t path="flixel.system.debug.log.BitmapLogEntry"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</_entries>
		<_curIndex expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</_curIndex>
		<_curEntry get="accessor" set="null"><t path="flixel.system.debug.log.BitmapLogEntry"/></_curEntry>
		<_curBitmap get="accessor" set="null"><t path="flash.display.BitmapData"/></_curBitmap>
		<_point expr="FlxPoint.get()">
			<c path="flixel.math.FlxPoint"/>
			<meta><m n=":value"><e>FlxPoint.get()</e></m></meta>
		</_point>
		<_lastMousePos expr="FlxPoint.get()">
			<c path="flixel.math.FlxPoint"/>
			<meta><m n=":value"><e>FlxPoint.get()</e></m></meta>
		</_lastMousePos>
		<_curMouseOffset expr="FlxPoint.get()">
			<c path="flixel.math.FlxPoint"/>
			<meta><m n=":value"><e>FlxPoint.get()</e></m></meta>
		</_curMouseOffset>
		<_matrix expr="new Matrix()">
			<t path="flash.geom.Matrix"/>
			<meta><m n=":value"><e>new Matrix()</e></m></meta>
		</_matrix>
		<_buttonLeft><c path="flixel.system.ui.FlxSystemButton"/></_buttonLeft>
		<_buttonText><c path="flixel.system.ui.FlxSystemButton"/></_buttonText>
		<_buttonRight><c path="flixel.system.ui.FlxSystemButton"/></_buttonRight>
		<_counterText><t path="flash.text.TextField"/></_counterText>
		<_dimensionsText><t path="flash.text.TextField"/></_dimensionsText>
		<_ui><t path="flash.display.Sprite"/></_ui>
		<_middleMouseDown expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</_middleMouseDown>
		<_footer><t path="flash.display.Bitmap"/></_footer>
		<_footerText><t path="flash.text.TextField"/></_footerText>
		<createHeaderUI set="method" line="85"><f a=""><x path="Void"/></f></createHeaderUI>
		<createFooterUI set="method" line="116"><f a=""><x path="Void"/></f></createFooterUI>
		<destroy public="1" set="method" line="129" override="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Clean up memory.</haxe_doc>
		</destroy>
		<update public="1" set="method" line="150" override="1"><f a=""><x path="Void"/></f></update>
		<updateSize set="method" line="161" override="1"><f a=""><x path="Void"/></f></updateSize>
		<resize public="1" set="method" line="168" override="1"><f a="Width:Height">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></resize>
		<resizeTexts public="1" set="method" line="191"><f a=""><x path="Void"/></f></resizeTexts>
		<next get="inline" set="null" line="210">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Show the next logged BitmapData in memory</haxe_doc>
		</next>
		<previous get="inline" set="null" line="219">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Show the previous logged BitmapData in memory</haxe_doc>
		</previous>
		<resetSettings get="inline" set="null" line="225"><f a=""><x path="Void"/></f></resetSettings>
		<add public="1" set="method" line="234">
			<f a="bmp:?name" v=":&quot;&quot;">
				<t path="flash.display.BitmapData"/>
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":value"><e>{ name : "" }</e></m></meta>
			<haxe_doc>* Add a BitmapData to the log</haxe_doc>
		</add>
		<clearAt public="1" set="method" line="248">
			<f a="?Index" v="-1">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ Index : -1 }</e></m></meta>
			<haxe_doc>* Clear one bitmap object from the log -- the last one, by default</haxe_doc>
		</clearAt>
		<clear public="1" set="method" line="266"><f a=""><x path="Void"/></f></clear>
		<refreshCanvas set="method" line="281"><f a="?Index">
	<x path="Int"/>
	<x path="Bool"/>
</f></refreshCanvas>
		<refreshTexts set="method" line="327"><f a=""><x path="Void"/></f></refreshTexts>
		<drawBoundingBox set="method" line="339"><f a="bitmap">
	<t path="flash.display.BitmapData"/>
	<x path="Void"/>
</f></drawBoundingBox>
		<onMouseWheel set="method" line="348"><f a="e">
	<t path="flash.events.MouseEvent"/>
	<x path="Void"/>
</f></onMouseWheel>
		<onMiddleDown set="method" line="354"><f a="e">
	<t path="flash.events.MouseEvent"/>
	<x path="Void"/>
</f></onMiddleDown>
		<onMiddleUp set="method" line="360"><f a="e">
	<t path="flash.events.MouseEvent"/>
	<x path="Void"/>
</f></onMiddleUp>
		<set_zoom set="method" line="365"><f a="Value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_zoom>
		<get__canvas get="inline" set="null" line="374"><f a=""><t path="flash.display.BitmapData"/></f></get__canvas>
		<get__curEntry get="inline" set="null" line="379"><f a=""><t path="flixel.system.debug.log.BitmapLogEntry"/></f></get__curEntry>
		<get__curBitmap get="inline" set="null" line="384"><f a=""><t path="flash.display.BitmapData"/></f></get__curBitmap>
		<new public="1" set="method" line="51"><f a=""><x path="Void"/></f></new>
		<haxe_doc>* An output window that lets you paste BitmapData in the debugger overlay.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<typedef path="flixel.system.debug.log.BitmapLogEntry" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/system/debug/log/BitmapLog.hx" module="flixel.system.debug.log.BitmapLog"><a>
	<name><c path="String"/></name>
	<bitmap><t path="flash.display.BitmapData"/></bitmap>
</a></typedef>
	<class path="flixel.system.debug.log.Log" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/system/debug/log/Log.hx">
		<extends path="flixel.system.debug.Window"/>
		<MAX_LOG_LINES public="1" get="inline" set="null" expr="200" line="13" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>200</e></m></meta>
		</MAX_LOG_LINES>
		<LINE_BREAK get="inline" set="null" expr="&quot;&lt;br&gt;&quot;" line="14" static="1">
			<c path="String"/>
			<meta><m n=":value"><e><![CDATA["<br>"]]></e></m></meta>
		</LINE_BREAK>
		<_text><t path="flash.text.TextField"/></_text>
		<_lines><c path="Array"><c path="String"/></c></_lines>
		<destroy public="1" set="method" line="42" override="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Clean up memory.</haxe_doc>
		</destroy>
		<add public="1" set="method" line="60">
			<f a="Data:Style:?FireOnce" v="::false">
				<c path="Array"><d/></c>
				<c path="flixel.system.debug.log.LogStyle"/>
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":value"><e>{ FireOnce : false }</e></m></meta>
			<haxe_doc>* Adds a new line to the log window.
	 * @param 	Data		The data being logged.
	 * @param 	Style		The LogStyle to be used for the log
	 * @param 	FireOnce   	Whether you only want to log the Data in case it hasn't been added already</haxe_doc>
		</add>
		<clear public="1" set="method" line="134"><f a=""><x path="Void"/></f></clear>
		<updateSize set="method" line="146" override="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Adjusts the width and height of the text field accordingly.</haxe_doc>
		</updateSize>
		<new public="1" set="method" line="22">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Creates a log window object.</haxe_doc>
		</new>
		<haxe_doc>* A simple trace output window for use in the debugger overlay.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="flixel.system.debug.log.LogStyle" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/system/debug/log/LogStyle.hx">
		<NORMAL public="1" expr="new LogStyle()" line="9" static="1">
			<c path="flixel.system.debug.log.LogStyle"/>
			<meta><m n=":value"><e>new LogStyle()</e></m></meta>
		</NORMAL>
		<WARNING public="1" expr="new LogStyle(&quot;[WARNING] &quot;, &quot;D9F85C&quot;, 12, false, false, false, &quot;flixel/sounds/beep&quot;, true)" line="10" static="1">
			<c path="flixel.system.debug.log.LogStyle"/>
			<meta><m n=":value"><e>new LogStyle("[WARNING] ", "D9F85C", 12, false, false, false, "flixel/sounds/beep", true)</e></m></meta>
		</WARNING>
		<ERROR public="1" expr="new LogStyle(&quot;[ERROR] &quot;, &quot;FF8888&quot;, 12, false, false, false, &quot;flixel/sounds/beep&quot;, true)" line="11" static="1">
			<c path="flixel.system.debug.log.LogStyle"/>
			<meta><m n=":value"><e>new LogStyle("[ERROR] ", "FF8888", 12, false, false, false, "flixel/sounds/beep", true)</e></m></meta>
		</ERROR>
		<NOTICE public="1" expr="new LogStyle(&quot;[NOTICE] &quot;, &quot;5CF878&quot;, 12, false)" line="12" static="1">
			<c path="flixel.system.debug.log.LogStyle"/>
			<meta><m n=":value"><e>new LogStyle("[NOTICE] ", "5CF878", 12, false)</e></m></meta>
		</NOTICE>
		<CONSOLE public="1" expr="new LogStyle(&quot;&#62; &quot;, &quot;5A96FA&quot;, 12, false)" line="13" static="1">
			<c path="flixel.system.debug.log.LogStyle"/>
			<meta><m n=":value"><e><![CDATA[new LogStyle("&#62; ", "5A96FA", 12, false)]]></e></m></meta>
		</CONSOLE>
		<prefix public="1">
			<c path="String"/>
			<haxe_doc>* A prefix which is always attached to the start of the logged data.</haxe_doc>
		</prefix>
		<color public="1"><c path="String"/></color>
		<size public="1"><x path="Int"/></size>
		<bold public="1"><x path="Bool"/></bold>
		<italic public="1"><x path="Bool"/></italic>
		<underlined public="1"><x path="Bool"/></underlined>
		<errorSound public="1">
			<c path="String"/>
			<haxe_doc>* A sound to be played when this LogStyle is used.</haxe_doc>
		</errorSound>
		<openConsole public="1">
			<x path="Bool"/>
			<haxe_doc>* Whether the console should be forced to open when this LogStyle is used.</haxe_doc>
		</openConsole>
		<callbackFunction public="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* A callback function that is called when this LogStyle is used.</haxe_doc>
		</callbackFunction>
		<new public="1" set="method" line="50">
			<f a="?Prefix:?Color:?Size:?Bold:?Italic:?Underlined:?ErrorSound:?OpenConsole:?CallbackFunction" v="&quot;&quot;:&quot;FFFFFF&quot;:12:false:false:false::false:">
				<c path="String"/>
				<c path="String"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<c path="String"/>
				<x path="Bool"/>
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ OpenConsole : false, Underlined : false, Italic : false, Bold : false, Size : 12, Color : "FFFFFF", Prefix : "" }</e></m></meta>
			<haxe_doc>* Create a new LogStyle to be used in conjunction with FlxG.log.advanced()
	 * 
	 * @param	Prefix				A prefix which is always attached to the start of the logged data.
	 * @param	Color				The text color.
	 * @param	Size				The text size.
	 * @param 	Bold				Whether the text is bold or not.
	 * @param	Italic				Whether the text is italic or not.
	 * @param	Underlined			Whether the text is underlined or not.
	 * @param	ErrorSound			A sound to be played when this LogStyle is used.
	 * @param	OpenConsole			Whether the console should be forced to open when this LogStyle is used.
	 * @param	CallbackFunction	A callback function that is called when this LogStyle is used.</haxe_doc>
		</new>
		<haxe_doc>* A class that allows you to create a custom style for FlxG.log.advanced(). 
 * Also used internally for the pre-defined styles.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="flixel.system.debug.stats._Stats.GraphicMinimizeButton" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/system/debug/stats/Stats.hx" private="1" module="flixel.system.debug.stats.Stats">
		<extends path="openfl.display.BitmapData"/>
		<resourceName expr="&quot;__ASSET__:bitmap_flixel_system_debug_stats__Stats_GraphicMinimizeButton&quot;" line="1" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"__ASSET__:bitmap_flixel_system_debug_stats__Stats_GraphicMinimizeButton"</e></m></meta>
		</resourceName>
		<new public="1" set="method" line="1">
			<f a="width:height:?transparent:?fillRGBA" v="::true:0xFFFFFFFF">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ fillRGBA : 0xFFFFFFFF, transparent : true }</e></m></meta>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>openfl.Assets.embedBitmap()</e></m>
			<m n=":autoBuild"><e>openfl.Assets.embedBitmap()</e></m>
			<m n=":bitmap"><e>"assets/images/debugger/buttons/minimize.png"</e></m>
		</meta>
	</class>
	<class path="flixel.system.debug.stats._Stats.GraphicMaximizeButton" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/system/debug/stats/Stats.hx" private="1" module="flixel.system.debug.stats.Stats">
		<extends path="openfl.display.BitmapData"/>
		<resourceName expr="&quot;__ASSET__:bitmap_flixel_system_debug_stats__Stats_GraphicMaximizeButton&quot;" line="1" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"__ASSET__:bitmap_flixel_system_debug_stats__Stats_GraphicMaximizeButton"</e></m></meta>
		</resourceName>
		<new public="1" set="method" line="1">
			<f a="width:height:?transparent:?fillRGBA" v="::true:0xFFFFFFFF">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ fillRGBA : 0xFFFFFFFF, transparent : true }</e></m></meta>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>openfl.Assets.embedBitmap()</e></m>
			<m n=":autoBuild"><e>openfl.Assets.embedBitmap()</e></m>
			<m n=":bitmap"><e>"assets/images/debugger/buttons/maximize.png"</e></m>
		</meta>
	</class>
	<class path="flixel.system.debug.stats.Stats" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/system/debug/stats/Stats.hx">
		<extends path="flixel.system.debug.Window"/>
		<UPDATE_DELAY get="inline" set="null" expr="250" line="33" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>250</e></m></meta>
			<haxe_doc>* How often to update the stats, in ms. The lower, the more performance-intense!</haxe_doc>
		</UPDATE_DELAY>
		<INITIAL_WIDTH get="inline" set="null" expr="160" line="37" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>160</e></m></meta>
			<haxe_doc>* The initial width of the stats window.</haxe_doc>
		</INITIAL_WIDTH>
		<MIN_HEIGHT expr="0" line="41" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* The minimal height of the window.</haxe_doc>
		</MIN_HEIGHT>
		<FPS_COLOR get="inline" set="null" expr="0xff96ff00" line="43" static="1">
			<x path="flixel.util.FlxColor"/>
			<meta><m n=":value"><e>0xff96ff00</e></m></meta>
		</FPS_COLOR>
		<MEMORY_COLOR get="inline" set="null" expr="0xff009cff" line="44" static="1">
			<x path="flixel.util.FlxColor"/>
			<meta><m n=":value"><e>0xff009cff</e></m></meta>
		</MEMORY_COLOR>
		<DRAW_TIME_COLOR get="inline" set="null" expr="0xffA60004" line="45" static="1">
			<x path="flixel.util.FlxColor"/>
			<meta><m n=":value"><e>0xffA60004</e></m></meta>
		</DRAW_TIME_COLOR>
		<UPDATE_TIME_COLOR get="inline" set="null" expr="0xffdcd400" line="46" static="1">
			<x path="flixel.util.FlxColor"/>
			<meta><m n=":value"><e>0xffdcd400</e></m></meta>
		</UPDATE_TIME_COLOR>
		<LABEL_COLOR public="1" get="inline" set="null" expr="0xaaffffff" line="48" static="1">
			<x path="flixel.util.FlxColor"/>
			<meta><m n=":value"><e>0xaaffffff</e></m></meta>
		</LABEL_COLOR>
		<TEXT_SIZE public="1" get="inline" set="null" expr="11" line="49" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>11</e></m></meta>
		</TEXT_SIZE>
		<DECIMALS public="1" get="inline" set="null" expr="1" line="50" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</DECIMALS>
		<_leftTextField><t path="flash.text.TextField"/></_leftTextField>
		<_rightTextField><t path="flash.text.TextField"/></_rightTextField>
		<_itvTime expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</_itvTime>
		<_frameCount><x path="Int"/></_frameCount>
		<_currentTime><x path="Int"/></_currentTime>
		<fpsGraph><c path="flixel.system.debug.stats.StatsGraph"/></fpsGraph>
		<memoryGraph><c path="flixel.system.debug.stats.StatsGraph"/></memoryGraph>
		<drawTimeGraph><c path="flixel.system.debug.stats.StatsGraph"/></drawTimeGraph>
		<updateTimeGraph><c path="flixel.system.debug.stats.StatsGraph"/></updateTimeGraph>
		<flashPlayerFramerate expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</flashPlayerFramerate>
		<visibleCount expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</visibleCount>
		<activeCount expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</activeCount>
		<updateTime expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</updateTime>
		<drawTime expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</drawTime>
		<drawCallsCount expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</drawCallsCount>
		<_lastTime expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</_lastTime>
		<_updateTimer expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</_updateTimer>
		<_update expr="[]">
			<c path="Array"><x path="Int"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</_update>
		<_updateMarker expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</_updateMarker>
		<_draw expr="[]">
			<c path="Array"><x path="Int"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</_draw>
		<_drawMarker expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</_drawMarker>
		<_drawCalls expr="[]">
			<c path="Array"><x path="Int"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</_drawCalls>
		<_drawCallsMarker expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</_drawCallsMarker>
		<_visibleObject expr="[]">
			<c path="Array"><x path="Int"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</_visibleObject>
		<_visibleObjectMarker expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</_visibleObjectMarker>
		<_activeObject expr="[]">
			<c path="Array"><x path="Int"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</_activeObject>
		<_activeObjectMarker expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</_activeObjectMarker>
		<_paused expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</_paused>
		<_toggleSizeButton><c path="flixel.system.ui.FlxSystemButton"/></_toggleSizeButton>
		<start public="1" set="method" line="171">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Starts Stats window update logic</haxe_doc>
		</start>
		<stop public="1" set="method" line="184">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Stops Stats window</haxe_doc>
		</stop>
		<destroy public="1" set="method" line="192" override="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Clean up memory.</haxe_doc>
		</destroy>
		<update public="1" set="method" line="232" override="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Called each frame, but really only updates once every second or so, to save on performance.
	 * Takes all the data in the accumulators and parses it into useful performance data.</haxe_doc>
		</update>
		<updateTexts set="method" line="307"><f a=""><x path="Void"/></f></updateTexts>
		<divide set="method" line="323"><f a="f1:f2">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></divide>
		<currentFps public="1" get="inline" set="null" line="333">
			<f a=""><x path="Float"/></f>
			<haxe_doc>* Calculates current game fps.</haxe_doc>
		</currentFps>
		<intervalTime public="1" get="inline" set="null" line="341">
			<f a=""><x path="Float"/></f>
			<haxe_doc>* Time since performance monitoring started.</haxe_doc>
		</intervalTime>
		<currentMem public="1" get="inline" set="null" line="349">
			<f a=""><x path="Float"/></f>
			<haxe_doc>* Current RAM consumption.</haxe_doc>
		</currentMem>
		<flixelUpdate public="1" set="method" line="359">
			<f a="Time">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* How long updates took.
	 * 
	 * @param 	Time	How long this update took.</haxe_doc>
		</flixelUpdate>
		<flixelDraw public="1" set="method" line="371">
			<f a="Time">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* How long rendering took.
	 * 
	 * @param	Time	How long this render took.</haxe_doc>
		</flixelDraw>
		<activeObjects public="1" set="method" line="383">
			<f a="Count">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* How many objects were updated.
	 * 
	 * @param 	Count	How many objects were updated.</haxe_doc>
		</activeObjects>
		<visibleObjects public="1" set="method" line="395">
			<f a="Count">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* How many objects were rendered.
	 * 
	 * @param 	Count	How many objects were rendered.</haxe_doc>
		</visibleObjects>
		<drawCalls public="1" set="method" line="407">
			<f a="Drawcalls">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* How many times drawTiles() method was called.
	 * 
	 * @param 	Count	How many times drawTiles() method was called.</haxe_doc>
		</drawCalls>
		<onFocus public="1" set="method" line="417">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Re-enables tracking of the stats.</haxe_doc>
		</onFocus>
		<onFocusLost public="1" set="method" line="425">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Pauses tracking of the stats.</haxe_doc>
		</onFocusLost>
		<toggleSize set="method" line="430"><f a=""><x path="Void"/></f></toggleSize>
		<updateSize set="method" line="453" override="1"><f a=""><x path="Void"/></f></updateSize>
		<new public="1" set="method" line="96">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Creates a new window with fps and memory graphs, as well as other useful stats for debugging.</haxe_doc>
		</new>
		<haxe_doc>* A simple performance monitor widget, for use in the debugger overlay.
 * 
 * @author Adam "Atomic" Saltsman
 * @author Anton Karlov</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="flixel.system.debug.stats.StatsGraph" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/system/debug/stats/StatsGraph.hx">
		<extends path="openfl.display.Sprite"/>
		<AXIS_COLOR get="inline" set="null" expr="0xffffff" line="18" static="1">
			<x path="flixel.util.FlxColor"/>
			<meta><m n=":value"><e>0xffffff</e></m></meta>
		</AXIS_COLOR>
		<AXIS_ALPHA get="inline" set="null" expr="0.5" line="19" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>0.5</e></m></meta>
		</AXIS_ALPHA>
		<HISTORY_MAX get="inline" set="null" expr="30" line="20" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>30</e></m></meta>
		</HISTORY_MAX>
		<minLabel public="1"><t path="flash.text.TextField"/></minLabel>
		<curLabel public="1"><t path="flash.text.TextField"/></curLabel>
		<maxLabel public="1"><t path="flash.text.TextField"/></maxLabel>
		<avgLabel public="1"><t path="flash.text.TextField"/></avgLabel>
		<minValue public="1" expr="FlxMath.MAX_VALUE_FLOAT">
			<x path="Float"/>
			<meta><m n=":value"><e>FlxMath.MAX_VALUE_FLOAT</e></m></meta>
		</minValue>
		<maxValue public="1" expr="FlxMath.MIN_VALUE_FLOAT">
			<x path="Float"/>
			<meta><m n=":value"><e>FlxMath.MIN_VALUE_FLOAT</e></m></meta>
		</maxValue>
		<graphColor public="1"><x path="flixel.util.FlxColor"/></graphColor>
		<history public="1" expr="[]">
			<c path="Array"><x path="Float"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</history>
		<_axis><t path="flash.display.Shape"/></_axis>
		<_width><x path="Int"/></_width>
		<_height><x path="Int"/></_height>
		<_unit><c path="String"/></_unit>
		<_labelWidth><x path="Int"/></_labelWidth>
		<_label><c path="String"/></_label>
		<drawAxes set="method" line="77">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Redraws the axes of the graph.</haxe_doc>
		</drawAxes>
		<drawGraph set="method" line="95">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Redraws the graph based on the values stored in the history.</haxe_doc>
		</drawGraph>
		<update public="1" set="method" line="116"><f a="Value">
	<x path="Float"/>
	<x path="Void"/>
</f></update>
		<formatValue set="method" line="135"><f a="value">
	<x path="Float"/>
	<c path="String"/>
</f></formatValue>
		<average public="1" set="method" line="140"><f a=""><x path="Float"/></f></average>
		<destroy public="1" set="method" line="148"><f a=""><x path="Void"/></f></destroy>
		<new public="1" set="method" line="41">
			<f a="X:Y:Width:Height:GraphColor:Unit:?LabelWidth:?Label" v="::::::45:">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="flixel.util.FlxColor"/>
				<c path="String"/>
				<x path="Int"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ LabelWidth : 45 }</e></m></meta>
		</new>
		<haxe_doc>* This is a helper function for the stats window to draw a graph with given values.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="openfl.text.TextField" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/text/TextField.hx">
		<extends path="openfl.display.InteractiveObject"/>
		<__defaultTextFormat static="1"><c path="openfl.text.TextFormat"/></__defaultTextFormat>
		<antiAliasType public="1" get="accessor" set="accessor"><x path="openfl.text.AntiAliasType"/></antiAliasType>
		<autoSize public="1" get="accessor" set="accessor"><x path="openfl.text.TextFieldAutoSize"/></autoSize>
		<background public="1" get="accessor" set="accessor"><x path="Bool"/></background>
		<backgroundColor public="1" get="accessor" set="accessor"><x path="Int"/></backgroundColor>
		<border public="1" get="accessor" set="accessor"><x path="Bool"/></border>
		<borderColor public="1" get="accessor" set="accessor"><x path="Int"/></borderColor>
		<bottomScrollV public="1" get="accessor" set="null"><x path="Int"/></bottomScrollV>
		<caretIndex public="1" get="accessor" set="null"><x path="Int"/></caretIndex>
		<defaultTextFormat public="1" get="accessor" set="accessor"><c path="openfl.text.TextFormat"/></defaultTextFormat>
		<displayAsPassword public="1" get="accessor" set="accessor"><x path="Bool"/></displayAsPassword>
		<embedFonts public="1" get="accessor" set="accessor"><x path="Bool"/></embedFonts>
		<gridFitType public="1" get="accessor" set="accessor"><x path="openfl.text.GridFitType"/></gridFitType>
		<htmlText public="1" get="accessor" set="accessor"><c path="String"/></htmlText>
		<length public="1" get="accessor" set="null"><x path="Int"/></length>
		<maxChars public="1" get="accessor" set="accessor"><x path="Int"/></maxChars>
		<maxScrollH public="1" get="accessor" set="null"><x path="Int"/></maxScrollH>
		<maxScrollV public="1" get="accessor" set="null"><x path="Int"/></maxScrollV>
		<multiline public="1" get="accessor" set="accessor"><x path="Bool"/></multiline>
		<numLines public="1" get="accessor" set="null"><x path="Int"/></numLines>
		<restrict public="1" get="accessor" set="accessor"><c path="String"/></restrict>
		<scrollH public="1" get="accessor" set="accessor"><x path="Int"/></scrollH>
		<scrollV public="1" get="accessor" set="accessor"><x path="Int"/></scrollV>
		<selectable public="1" get="accessor" set="accessor"><x path="Bool"/></selectable>
		<selectionBeginIndex public="1" get="accessor" set="null"><x path="Int"/></selectionBeginIndex>
		<selectionEndIndex public="1" get="accessor" set="null"><x path="Int"/></selectionEndIndex>
		<sharpness public="1" get="accessor" set="accessor"><x path="Float"/></sharpness>
		<text public="1" get="accessor" set="accessor"><c path="String"/></text>
		<textColor public="1" get="accessor" set="accessor"><x path="Int"/></textColor>
		<textHeight public="1" get="accessor" set="null"><x path="Float"/></textHeight>
		<textWidth public="1" get="accessor" set="null"><x path="Float"/></textWidth>
		<type public="1" get="accessor" set="accessor"><x path="openfl.text.TextFieldType"/></type>
		<wordWrap public="1" get="accessor" set="accessor"><x path="Bool"/></wordWrap>
		<__bounds><c path="openfl.geom.Rectangle"/></__bounds>
		<__caretIndex><x path="Int"/></__caretIndex>
		<__cursorTimer><c path="haxe.Timer"/></__cursorTimer>
		<__dirty><x path="Bool"/></__dirty>
		<__inputEnabled><x path="Bool"/></__inputEnabled>
		<__isHTML><x path="Bool"/></__isHTML>
		<__layoutDirty><x path="Bool"/></__layoutDirty>
		<__selectionIndex><x path="Int"/></__selectionIndex>
		<__showCursor><x path="Bool"/></__showCursor>
		<__textEngine><c path="openfl._internal.text.TextEngine"/></__textEngine>
		<__textFormat><c path="openfl.text.TextFormat"/></__textFormat>
		<appendText public="1" set="method" line="119"><f a="text">
	<c path="String"/>
	<x path="Void"/>
</f></appendText>
		<getCharBoundaries public="1" set="method" line="130"><f a="charIndex">
	<x path="Int"/>
	<c path="openfl.geom.Rectangle"/>
</f></getCharBoundaries>
		<getCharIndexAtPoint public="1" set="method" line="159"><f a="x:y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Int"/>
</f></getCharIndexAtPoint>
		<getFirstCharInParagraph public="1" set="method" line="206"><f a="charIndex">
	<x path="Int"/>
	<x path="Int"/>
</f></getFirstCharInParagraph>
		<getLineIndexAtPoint public="1" set="method" line="234"><f a="x:y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Int"/>
</f></getLineIndexAtPoint>
		<getLineIndexOfChar public="1" set="method" line="261"><f a="charIndex">
	<x path="Int"/>
	<x path="Int"/>
</f></getLineIndexOfChar>
		<getLineLength public="1" set="method" line="282"><f a="lineIndex">
	<x path="Int"/>
	<x path="Int"/>
</f></getLineLength>
		<getLineMetrics public="1" set="method" line="312"><f a="lineIndex">
	<x path="Int"/>
	<c path="openfl.text.TextLineMetrics"/>
</f></getLineMetrics>
		<getLineOffset public="1" set="method" line="337"><f a="lineIndex">
	<x path="Int"/>
	<x path="Int"/>
</f></getLineOffset>
		<getLineText public="1" set="method" line="358"><f a="lineIndex">
	<x path="Int"/>
	<c path="String"/>
</f></getLineText>
		<getParagraphLength public="1" set="method" line="389"><f a="charIndex">
	<x path="Int"/>
	<x path="Int"/>
</f></getParagraphLength>
		<getTextFormat public="1" set="method" line="402">
			<f a="?beginIndex:?endIndex" v="0:0">
				<x path="Int"/>
				<x path="Int"/>
				<c path="openfl.text.TextFormat"/>
			</f>
			<meta><m n=":value"><e>{ endIndex : 0, beginIndex : 0 }</e></m></meta>
		</getTextFormat>
		<replaceSelectedText public="1" set="method" line="446"><f a="value">
	<c path="String"/>
	<x path="Void"/>
</f></replaceSelectedText>
		<replaceText public="1" set="method" line="461"><f a="beginIndex:endIndex:newText">
	<x path="Int"/>
	<x path="Int"/>
	<c path="String"/>
	<x path="Void"/>
</f></replaceText>
		<setSelection public="1" set="method" line="505"><f a="beginIndex:endIndex">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></setSelection>
		<setTextFormat public="1" set="method" line="513">
			<f a="format:?beginIndex:?endIndex" v=":0:0">
				<c path="openfl.text.TextFormat"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ endIndex : 0, beginIndex : 0 }</e></m></meta>
		</setTextFormat>
		<__getBounds set="method" line="540" override="1"><f a="rect:matrix">
	<c path="openfl.geom.Rectangle"/>
	<c path="openfl.geom.Matrix"/>
	<x path="Void"/>
</f></__getBounds>
		<__getCursor set="method" line="550" override="1"><f a=""><e path="lime.ui.MouseCursor"/></f></__getCursor>
		<__getPosition set="method" line="557"><f a="x:y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Int"/>
</f></__getPosition>
		<__hitTest set="method" line="635" override="1"><f a="x:y:shapeFlag:stack:interactiveOnly:hitObject">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Bool"/>
	<c path="Array"><c path="openfl.display.DisplayObject"/></c>
	<x path="Bool"/>
	<c path="openfl.display.DisplayObject"/>
	<x path="Bool"/>
</f></__hitTest>
		<__hitTestMask set="method" line="663" override="1"><f a="x:y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Bool"/>
</f></__hitTestMask>
		<__renderCairo public="1" set="method" line="682" override="1"><f a="renderSession">
	<c path="openfl._internal.renderer.RenderSession"/>
	<x path="Void"/>
</f></__renderCairo>
		<__renderCanvas public="1" set="method" line="690" override="1">
			<f a="renderSession">
				<c path="openfl._internal.renderer.RenderSession"/>
				<x path="Void"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</__renderCanvas>
		<__renderDOM public="1" set="method" line="727" override="1"><f a="renderSession">
	<c path="openfl._internal.renderer.RenderSession"/>
	<x path="Void"/>
</f></__renderDOM>
		<__renderGL public="1" set="method" line="734" override="1"><f a="renderSession">
	<c path="openfl._internal.renderer.RenderSession"/>
	<x path="Void"/>
</f></__renderGL>
		<__startCursorTimer set="method" line="764"><f a=""><x path="Void"/></f></__startCursorTimer>
		<__startTextInput set="method" line="773"><f a=""><x path="Void"/></f></__startTextInput>
		<__stopCursorTimer set="method" line="811"><f a=""><x path="Void"/></f></__stopCursorTimer>
		<__stopTextInput set="method" line="830"><f a=""><x path="Void"/></f></__stopTextInput>
		<__updateLayout set="method" line="850"><f a=""><x path="Void"/></f></__updateLayout>
		<get_antiAliasType set="method" line="916"><f a=""><x path="openfl.text.AntiAliasType"/></f></get_antiAliasType>
		<set_antiAliasType set="method" line="923"><f a="value">
	<x path="openfl.text.AntiAliasType"/>
	<x path="openfl.text.AntiAliasType"/>
</f></set_antiAliasType>
		<get_autoSize set="method" line="936"><f a=""><x path="openfl.text.TextFieldAutoSize"/></f></get_autoSize>
		<set_autoSize set="method" line="943"><f a="value">
	<x path="openfl.text.TextFieldAutoSize"/>
	<x path="openfl.text.TextFieldAutoSize"/>
</f></set_autoSize>
		<get_background set="method" line="957"><f a=""><x path="Bool"/></f></get_background>
		<set_background set="method" line="964"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_background>
		<get_backgroundColor set="method" line="977"><f a=""><x path="Int"/></f></get_backgroundColor>
		<set_backgroundColor set="method" line="984"><f a="value">
	<x path="Int"/>
	<x path="Int"/>
</f></set_backgroundColor>
		<get_border set="method" line="997"><f a=""><x path="Bool"/></f></get_border>
		<set_border set="method" line="1004"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_border>
		<get_borderColor set="method" line="1017"><f a=""><x path="Int"/></f></get_borderColor>
		<set_borderColor set="method" line="1024"><f a="value">
	<x path="Int"/>
	<x path="Int"/>
</f></set_borderColor>
		<get_bottomScrollV set="method" line="1037"><f a=""><x path="Int"/></f></get_bottomScrollV>
		<get_caretIndex set="method" line="1046"><f a=""><x path="Int"/></f></get_caretIndex>
		<get_defaultTextFormat set="method" line="1053"><f a=""><c path="openfl.text.TextFormat"/></f></get_defaultTextFormat>
		<set_defaultTextFormat set="method" line="1060"><f a="value">
	<c path="openfl.text.TextFormat"/>
	<c path="openfl.text.TextFormat"/>
</f></set_defaultTextFormat>
		<get_displayAsPassword set="method" line="1072"><f a=""><x path="Bool"/></f></get_displayAsPassword>
		<set_displayAsPassword set="method" line="1079"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_displayAsPassword>
		<get_embedFonts set="method" line="1093"><f a=""><x path="Bool"/></f></get_embedFonts>
		<set_embedFonts set="method" line="1100"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_embedFonts>
		<get_gridFitType set="method" line="1114"><f a=""><x path="openfl.text.GridFitType"/></f></get_gridFitType>
		<set_gridFitType set="method" line="1121"><f a="value">
	<x path="openfl.text.GridFitType"/>
	<x path="openfl.text.GridFitType"/>
</f></set_gridFitType>
		<get_height set="method" line="1135" override="1"><f a=""><x path="Float"/></f></get_height>
		<set_height set="method" line="1143" override="1"><f a="value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_height>
		<get_htmlText set="method" line="1159"><f a=""><c path="String"/></f></get_htmlText>
		<set_htmlText set="method" line="1166"><f a="value">
	<c path="String"/>
	<c path="String"/>
</f></set_htmlText>
		<get_length set="method" line="1277"><f a=""><x path="Int"/></f></get_length>
		<get_maxChars set="method" line="1290"><f a=""><x path="Int"/></f></get_maxChars>
		<set_maxChars set="method" line="1297"><f a="value">
	<x path="Int"/>
	<x path="Int"/>
</f></set_maxChars>
		<get_maxScrollH set="method" line="1311"><f a=""><x path="Int"/></f></get_maxScrollH>
		<get_maxScrollV set="method" line="1320"><f a=""><x path="Int"/></f></get_maxScrollV>
		<get_multiline set="method" line="1329"><f a=""><x path="Bool"/></f></get_multiline>
		<set_multiline set="method" line="1336"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_multiline>
		<get_numLines set="method" line="1350"><f a=""><x path="Int"/></f></get_numLines>
		<get_restrict set="method" line="1359"><f a=""><c path="String"/></f></get_restrict>
		<set_restrict set="method" line="1366"><f a="value">
	<c path="String"/>
	<c path="String"/>
</f></set_restrict>
		<get_scrollH set="method" line="1373"><f a=""><x path="Int"/></f></get_scrollH>
		<set_scrollH set="method" line="1380"><f a="value">
	<x path="Int"/>
	<x path="Int"/>
</f></set_scrollH>
		<get_scrollV set="method" line="1396"><f a=""><x path="Int"/></f></get_scrollV>
		<set_scrollV set="method" line="1403"><f a="value">
	<x path="Int"/>
	<x path="Int"/>
</f></set_scrollV>
		<get_selectable set="method" line="1419"><f a=""><x path="Bool"/></f></get_selectable>
		<set_selectable set="method" line="1426"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_selectable>
		<get_selectionBeginIndex set="method" line="1447"><f a=""><x path="Int"/></f></get_selectionBeginIndex>
		<get_selectionEndIndex set="method" line="1454"><f a=""><x path="Int"/></f></get_selectionEndIndex>
		<get_sharpness set="method" line="1461"><f a=""><x path="Float"/></f></get_sharpness>
		<set_sharpness set="method" line="1468"><f a="value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_sharpness>
		<get_text set="method" line="1481"><f a=""><c path="String"/></f></get_text>
		<set_text set="method" line="1488"><f a="value">
	<c path="String"/>
	<c path="String"/>
</f></set_text>
		<get_textColor set="method" line="1519"><f a=""><x path="Int"/></f></get_textColor>
		<set_textColor set="method" line="1526"><f a="value">
	<x path="Int"/>
	<x path="Int"/>
</f></set_textColor>
		<get_textWidth set="method" line="1540"><f a=""><x path="Float"/></f></get_textWidth>
		<get_textHeight set="method" line="1548"><f a=""><x path="Float"/></f></get_textHeight>
		<get_type set="method" line="1556"><f a=""><x path="openfl.text.TextFieldType"/></f></get_type>
		<set_type set="method" line="1563"><f a="value">
	<x path="openfl.text.TextFieldType"/>
	<x path="openfl.text.TextFieldType"/>
</f></set_type>
		<get_width set="method" line="1594" override="1"><f a=""><x path="Float"/></f></get_width>
		<set_width set="method" line="1602" override="1"><f a="value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_width>
		<get_wordWrap set="method" line="1618"><f a=""><x path="Bool"/></f></get_wordWrap>
		<set_wordWrap set="method" line="1625"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_wordWrap>
		<stage_onMouseMove set="method" line="1646"><f a="event">
	<c path="openfl.events.MouseEvent"/>
	<x path="Void"/>
</f></stage_onMouseMove>
		<stage_onMouseUp set="method" line="1668"><f a="event">
	<c path="openfl.events.MouseEvent"/>
	<x path="Void"/>
</f></stage_onMouseUp>
		<this_onAddedToStage set="method" line="1707"><f a="event">
	<c path="openfl.events.Event"/>
	<x path="Void"/>
</f></this_onAddedToStage>
		<this_onFocusIn set="method" line="1714"><f a="event">
	<c path="openfl.events.FocusEvent"/>
	<x path="Void"/>
</f></this_onFocusIn>
		<this_onFocusOut set="method" line="1725"><f a="event">
	<c path="openfl.events.FocusEvent"/>
	<x path="Void"/>
</f></this_onFocusOut>
		<this_onMouseDown set="method" line="1732"><f a="event">
	<c path="openfl.events.MouseEvent"/>
	<x path="Void"/>
</f></this_onMouseDown>
		<window_onKeyDown set="method" line="1748"><f a="key:modifier">
	<x path="lime.ui.KeyCode"/>
	<x path="lime.ui.KeyModifier"/>
	<x path="Void"/>
</f></window_onKeyDown>
		<window_onTextInput set="method" line="1904"><f a="value">
	<c path="String"/>
	<x path="Void"/>
</f></window_onTextInput>
		<new public="1" set="method" line="91"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":access"><e>openfl.display.Graphics</e></m>
			<m n=":access"><e>openfl.geom.Rectangle</e></m>
			<m n=":access"><e>openfl._internal.text.TextEngine</e></m>
			<m n=":access"><e>openfl.text.TextFormat</e></m>
		</meta>
	</class>
	<class path="flixel.system.debug.watch.EditableTextField" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/system/debug/watch/EditableTextField.hx">
		<extends path="openfl.text.TextField"/>
		<implements path="flixel.util.IFlxDestroyable"/>
		<isEditing public="1" set="null"><x path="Bool"/></isEditing>
		<allowEditing><x path="Bool"/></allowEditing>
		<submitValue><f a="">
	<d/>
	<x path="Void"/>
</f></submitValue>
		<expectedType><e path="ValueType"/></expectedType>
		<defaultFormat><c path="openfl.text.TextFormat"/></defaultFormat>
		<editFormat><c path="openfl.text.TextFormat"/></editFormat>
		<destroy public="1" set="method" line="44"><f a=""><x path="Void"/></f></destroy>
		<onMouseUp set="method" line="55"><f a="_">
	<unknown/>
	<x path="Void"/>
</f></onMouseUp>
		<onKeyUp set="method" line="60"><f a="e">
	<c path="openfl.events.KeyboardEvent"/>
	<x path="Void"/>
</f></onKeyUp>
		<onKeyDown set="method" line="71"><f a="e">
	<c path="openfl.events.KeyboardEvent"/>
	<x path="Void"/>
</f></onKeyDown>
		<cycleValue set="method" line="86"><f a="modifier:selection">
	<x path="Float"/>
	<x path="Int"/>
	<x path="Void"/>
</f></cycleValue>
		<selectEnd set="method" line="104"><f a=""><x path="Void"/></f></selectEnd>
		<cycleNumericValue set="method" line="109"><f a="modifier">
	<x path="Float"/>
	<x path="Void"/>
</f></cycleNumericValue>
		<cycleEnumValue set="method" line="120"><f a="e:modifier">
	<x path="Enum"><d/></x>
	<x path="Int"/>
	<x path="Void"/>
</f></cycleEnumValue>
		<onFocusLost set="method" line="134"><f a="_">
	<unknown/>
	<x path="Void"/>
</f></onFocusLost>
		<submit public="1" set="method" line="139"><f a=""><x path="Void"/></f></submit>
		<setIsEditing set="method" line="164"><f a="isEditing">
	<x path="Bool"/>
	<x path="Void"/>
</f></setIsEditing>
		<new public="1" set="method" line="25"><f a="allowEditing:defaultFormat:submitValue:expectedType">
	<x path="Bool"/>
	<c path="openfl.text.TextFormat"/>
	<f a="">
		<d/>
		<x path="Void"/>
	</f>
	<e path="ValueType"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="flixel.system.debug.watch.Watch" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/system/debug/watch/Watch.hx">
		<extends path="flixel.system.debug.Window"/>
		<LINE_HEIGHT get="inline" set="null" expr="15" line="17" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>15</e></m></meta>
		</LINE_HEIGHT>
		<entriesContainer><c path="openfl.display.Sprite"/></entriesContainer>
		<entriesContainerOffset expr="FlxPoint.get(2, 15)">
			<c path="flixel.math.FlxPoint"/>
			<meta><m n=":value"><e>FlxPoint.get(2, 15)</e></m></meta>
		</entriesContainerOffset>
		<entries expr="[]">
			<c path="Array"><c path="flixel.system.debug.watch.WatchEntry"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</entries>
		<add public="1" set="method" line="35"><f a="displayName:data">
	<c path="String"/>
	<e path="flixel.system.debug.watch.WatchEntryData"/>
	<x path="Void"/>
</f></add>
		<isInvalid set="method" line="55"><f a="displayName:data">
	<c path="String"/>
	<e path="flixel.system.debug.watch.WatchEntryData"/>
	<x path="Bool"/>
</f></isInvalid>
		<getExistingEntry set="method" line="68"><f a="displayName:data">
	<c path="String"/>
	<e path="flixel.system.debug.watch.WatchEntryData"/>
	<c path="flixel.system.debug.watch.WatchEntry"/>
</f></getExistingEntry>
		<addEntry set="method" line="83"><f a="displayName:data">
	<c path="String"/>
	<e path="flixel.system.debug.watch.WatchEntryData"/>
	<x path="Void"/>
</f></addEntry>
		<remove public="1" set="method" line="91"><f a="displayName:data">
	<c path="String"/>
	<e path="flixel.system.debug.watch.WatchEntryData"/>
	<x path="Void"/>
</f></remove>
		<removeEntry set="method" line="98"><f a="entry">
	<c path="flixel.system.debug.watch.WatchEntry"/>
	<x path="Void"/>
</f></removeEntry>
		<removeAll public="1" set="method" line="106"><f a=""><x path="Void"/></f></removeAll>
		<update public="1" set="method" line="118" override="1"><f a=""><x path="Void"/></f></update>
		<updateSize set="method" line="124" override="1"><f a=""><x path="Void"/></f></updateSize>
		<resetEntries set="method" line="133"><f a=""><x path="Void"/></f></resetEntries>
		<getMaxNameWidth set="method" line="143"><f a=""><x path="Float"/></f></getMaxNameWidth>
		<getMaxMinWidth set="method" line="148"><f a=""><x path="Float"/></f></getMaxMinWidth>
		<getMax set="method" line="153"><f a="getValue">
	<f a="">
		<c path="flixel.system.debug.watch.WatchEntry"/>
		<x path="Float"/>
	</f>
	<x path="Float"/>
</f></getMax>
		<new public="1" set="method" line="23">
			<f a="?closable" v="false">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ closable : false }</e></m></meta>
		</new>
		<haxe_doc>* A Visual Studio-style "watch" window, for use in the debugger overlay.
 * Track the values of any public variable in real-time, and/or edit their values on the fly.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="flixel.system.debug.watch.Tracker" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/system/debug/watch/Tracker.hx">
		<extends path="flixel.system.debug.watch.Watch"/>
		<profiles public="1" static="1">
			<c path="Array"><c path="flixel.system.debug.watch.TrackerProfile"/></c>
			<haxe_doc>* Order matters here, as the last profile is the most relevant - i.e., if the 
	 * FlxSprite profile were added before the one for FlxObject, it would never be selected.</haxe_doc>
		</profiles>
		<objectsBeingTracked public="1" expr="[]" line="50" static="1">
			<c path="Array"><d/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
			<haxe_doc>* Stores a reference to all objects for a which a tracker window exists
	 * to prevent the creation of two windows for the same object.</haxe_doc>
		</objectsBeingTracked>
		<_numTrackerWindows expr="0" line="52" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</_numTrackerWindows>
		<addProfile public="1" get="inline" set="null" line="54" static="1"><f a="Profile">
	<c path="flixel.system.debug.watch.TrackerProfile"/>
	<x path="Void"/>
</f></addProfile>
		<findProfile public="1" set="method" line="63" static="1"><f a="Object">
	<d/>
	<c path="flixel.system.debug.watch.TrackerProfile"/>
</f></findProfile>
		<onStateSwitch public="1" set="method" line="75" static="1"><f a=""><x path="Void"/></f></onStateSwitch>
		<initProfiles set="method" line="80" static="1"><f a=""><x path="Void"/></f></initProfiles>
		<_object><d/></_object>
		<destroy public="1" set="method" line="169" override="1"><f a=""><x path="Void"/></f></destroy>
		<findProfileByClass set="method" line="178"><f a="ObjectClass">
	<x path="Class"><d/></x>
	<c path="flixel.system.debug.watch.TrackerProfile"/>
</f></findProfileByClass>
		<initWatchEntries set="method" line="187"><f a="Profile">
	<c path="flixel.system.debug.watch.TrackerProfile"/>
	<x path="Void"/>
</f></initWatchEntries>
		<addExtensions set="method" line="196"><f a="Profile">
	<c path="flixel.system.debug.watch.TrackerProfile"/>
	<x path="Void"/>
</f></addExtensions>
		<addVariables set="method" line="215"><f a="Variables">
	<c path="Array"><c path="String"/></c>
	<x path="Void"/>
</f></addVariables>
		<new public="1" set="method" line="146"><f a="Profile:ObjectOrClass:?WindowTitle">
	<c path="flixel.system.debug.watch.TrackerProfile"/>
	<d/>
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="flixel.system.debug.watch.TrackerProfile" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/system/debug/watch/Tracker.hx" module="flixel.system.debug.watch.Tracker">
		<objectClass public="1"><x path="Class"><d/></x></objectClass>
		<variables public="1"><c path="Array"><c path="String"/></c></variables>
		<extensions public="1"><c path="Array"><x path="Class"><d/></x></c></extensions>
		<toString public="1" set="method" line="239"><f a=""><c path="String"/></f></toString>
		<new public="1" set="method" line="232"><f a="ObjectClass:?Variables:?Extensions">
	<x path="Class"><d/></x>
	<c path="Array"><c path="String"/></c>
	<c path="Array"><x path="Class"><d/></x></c>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="flixel.system.debug.watch.WatchEntry" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/system/debug/watch/WatchEntry.hx">
		<extends path="openfl.display.Sprite"/>
		<implements path="flixel.util.IFlxDestroyable"/>
		<GUTTER get="inline" set="null" expr="4" line="22" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>4</e></m></meta>
		</GUTTER>
		<TEXT_HEIGHT get="inline" set="null" expr="20" line="23" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>20</e></m></meta>
		</TEXT_HEIGHT>
		<MAX_NAME_WIDTH get="inline" set="null" expr="125" line="24" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>125</e></m></meta>
		</MAX_NAME_WIDTH>
		<data public="1"><e path="flixel.system.debug.watch.WatchEntryData"/></data>
		<displayName public="1" set="null"><c path="String"/></displayName>
		<nameText><c path="openfl.text.TextField"/></nameText>
		<valueText><c path="flixel.system.debug.watch.EditableTextField"/></valueText>
		<removeButton><c path="flixel.system.ui.FlxSystemButton"/></removeButton>
		<defaultFormat><c path="openfl.text.TextFormat"/></defaultFormat>
		<getTextColor set="method" line="54"><f a=""><x path="flixel.util.FlxColor"/></f></getTextColor>
		<initTextField params="T" set="method" line="64"><f a="textField">
	<c path="initTextField.T"/>
	<c path="initTextField.T"/>
</f></initTextField>
		<updateSize public="1" set="method" line="74"><f a="nameWidth:windowWidth">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></updateSize>
		<updateName set="method" line="84"><f a=""><x path="Void"/></f></updateName>
		<setNameText set="method" line="102"><f a="name">
	<c path="String"/>
	<x path="Void"/>
</f></setNameText>
		<getValue set="method" line="109"><f a=""><d/></f></getValue>
		<getFormattedValue set="method" line="126"><f a=""><c path="String"/></f></getFormattedValue>
		<submitValue set="method" line="134"><f a="value">
	<d/>
	<x path="Void"/>
</f></submitValue>
		<updateValue public="1" set="method" line="144"><f a=""><x path="Void"/></f></updateValue>
		<getNameWidth public="1" set="method" line="150"><f a=""><x path="Float"/></f></getNameWidth>
		<getMinWidth public="1" set="method" line="155"><f a=""><x path="Float"/></f></getMinWidth>
		<destroy public="1" set="method" line="160"><f a=""><x path="Void"/></f></destroy>
		<new public="1" set="method" line="34"><f a="displayName:data:removeEntry">
	<c path="String"/>
	<e path="flixel.system.debug.watch.WatchEntryData"/>
	<f a="">
		<c path="flixel.system.debug.watch.WatchEntry"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<enum path="flixel.system.debug.watch.WatchEntryData" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/system/debug/watch/WatchEntryData.hx">
		<FIELD a="object:field">
			<d/>
			<c path="String"/>
			<haxe_doc>* `object.field` resolved via `Reflect.getProperty()`.</haxe_doc>
		</FIELD>
		<QUICK a="value">
			<c path="String"/>
			<haxe_doc>* Manually updated values.</haxe_doc>
		</QUICK>
		<EXPRESSION a="expression:parsedExpr">
			<c path="String"/>
			<c path="String"/>
			<haxe_doc>* Haxe expression evaluated with hscript.</haxe_doc>
		</EXPRESSION>
		<meta><m n=":directlyUsed"/></meta>
	</enum>
	<class path="flixel.system.frontEnds.PluginFrontEnd" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/system/frontEnds/PluginFrontEnd.hx">
		<list public="1" set="null" expr="[]">
			<c path="Array"><c path="flixel.FlxBasic"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
			<haxe_doc>* An array container for plugins.</haxe_doc>
		</list>
		<add public="1" params="T" set="method" line="21">
			<f a="Plugin">
				<c path="add.T"/>
				<c path="add.T"/>
			</f>
			<meta><m n=":generic"/></meta>
			<haxe_doc>* Adds a new plugin to the global plugin array.
	 * 
	 * @param	Plugin	Any object that extends FlxPlugin. Useful for managers and other things. See flixel.plugin for some examples!
	 * @return	The same FlxPlugin-based plugin you passed in.</haxe_doc>
		</add>
		<get public="1" set="method" line="43">
			<f a="ClassType">
				<x path="Class"><c path="flixel.FlxBasic"/></x>
				<c path="flixel.FlxBasic"/>
			</f>
			<haxe_doc>* Retrieves a plugin based on its class name from the global plugin array.
	 * 
	 * @param	ClassType	The class name of the plugin you want to retrieve. See the FlxPath or FlxTimer constructors for example usage.
	 * @return	The plugin object, or null if no matching plugin was found.</haxe_doc>
		</get>
		<remove public="1" set="method" line="62">
			<f a="Plugin">
				<c path="flixel.FlxBasic"/>
				<c path="flixel.FlxBasic"/>
			</f>
			<haxe_doc>* Removes an instance of a plugin from the global plugin array.
	 * 
	 * @param	Plugin	The plugin instance you want to remove.
	 * @return	The same FlxPlugin-based plugin you passed in.</haxe_doc>
		</remove>
		<removeType public="1" set="method" line="86">
			<f a="ClassType">
				<x path="Class"><c path="flixel.FlxBasic"/></x>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Removes all instances of a plugin from the global plugin array.
	 * 
	 * @param	ClassType	The class name of the plugin type you want removed from the array.
	 * @return	Whether or not at least one instance of this plugin type was removed.</haxe_doc>
		</removeType>
		<update get="inline" set="null" line="116">
			<f a="elapsed">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":allow"><e>flixel.FlxGame</e></m></meta>
			<haxe_doc>* Used by the game object to call update() on all the plugins.</haxe_doc>
		</update>
		<draw get="inline" set="null" line="131">
			<f a=""><x path="Void"/></f>
			<meta><m n=":allow"><e>flixel.FlxGame</e></m></meta>
			<haxe_doc>* Used by the game object to call draw() on all the plugins.</haxe_doc>
		</draw>
		<new set="method" line="106">
			<f a=""><x path="Void"/></f>
			<meta><m n=":allow"><e>flixel.FlxG</e></m></meta>
		</new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="flixel.system.frontEnds.SoundFrontEnd" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/system/frontEnds/SoundFrontEnd.hx">
		<music public="1">
			<c path="flixel.system.FlxSound"/>
			<haxe_doc>* A handy container for a background music object.</haxe_doc>
		</music>
		<muted public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
			<haxe_doc>* Whether or not the game sounds are muted.</haxe_doc>
		</muted>
		<volumeHandler public="1">
			<f a="">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Set this hook to get a callback whenever the volume changes.
	 * Function should take the form myVolumeHandler(volume:Float).</haxe_doc>
		</volumeHandler>
		<volumeUpKeys public="1" expr="[PLUS, NUMPADPLUS]">
			<c path="Array"><x path="flixel.input.keyboard.FlxKey"/></c>
			<meta><m n=":value"><e>[PLUS, NUMPADPLUS]</e></m></meta>
			<haxe_doc>* The key codes used to increase volume (see FlxG.keys for the keys available).
	 * Default keys: + (and numpad +). Set to null to deactivate.</haxe_doc>
		</volumeUpKeys>
		<volumeDownKeys public="1" expr="[MINUS, NUMPADMINUS]">
			<c path="Array"><x path="flixel.input.keyboard.FlxKey"/></c>
			<meta><m n=":value"><e>[MINUS, NUMPADMINUS]</e></m></meta>
			<haxe_doc>* The keys to decrease volume (see FlxG.keys for the keys available).
	 * Default keys: - (and numpad -). Set to null to deactivate.</haxe_doc>
		</volumeDownKeys>
		<muteKeys public="1" expr="[ZERO, NUMPADZERO]">
			<c path="Array"><x path="flixel.input.keyboard.FlxKey"/></c>
			<meta><m n=":value"><e>[ZERO, NUMPADZERO]</e></m></meta>
			<haxe_doc>* The keys used to mute / unmute the game (see FlxG.keys for the keys available).
	 * Default keys: 0 (and numpad 0). Set to null to deactivate.</haxe_doc>
		</muteKeys>
		<soundTrayEnabled public="1" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
			<haxe_doc>* Whether or not the soundTray should be shown when any of the
	 * volumeUp-, volumeDown- or muteKeys is pressed.</haxe_doc>
		</soundTrayEnabled>
		<defaultMusicGroup public="1" expr="new FlxSoundGroup()">
			<c path="flixel.system.FlxSoundGroup"/>
			<meta><m n=":value"><e>new FlxSoundGroup()</e></m></meta>
			<haxe_doc>* The group sounds played via playMusic() are added to unless specified otherwise.</haxe_doc>
		</defaultMusicGroup>
		<defaultSoundGroup public="1" expr="new FlxSoundGroup()">
			<c path="flixel.system.FlxSoundGroup"/>
			<meta><m n=":value"><e>new FlxSoundGroup()</e></m></meta>
			<haxe_doc>* The group sounds in load() / play() / stream() are added to unless specified otherwise.</haxe_doc>
		</defaultSoundGroup>
		<list public="1" set="null" expr="new FlxTypedGroup&lt;FlxSound&gt;()">
			<c path="flixel.group.FlxTypedGroup"><c path="flixel.system.FlxSound"/></c>
			<meta><m n=":value"><e><![CDATA[new FlxTypedGroup<FlxSound>()]]></e></m></meta>
			<haxe_doc>* A list of all the sounds being played in the game.</haxe_doc>
		</list>
		<volume public="1" set="accessor" expr="1">
			<x path="Float"/>
			<meta><m n=":value"><e>1</e></m></meta>
			<haxe_doc>* Set this to a number between 0 and 1 to change the global volume.</haxe_doc>
		</volume>
		<playMusic public="1" set="method" line="81">
			<f a="Music:?Volume:?Looped:?Group" v=":1:true:">
				<t path="flixel.system.FlxSoundAsset"/>
				<x path="Float"/>
				<x path="Bool"/>
				<c path="flixel.system.FlxSoundGroup"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ Looped : true, Volume : 1 }</e></m></meta>
			<haxe_doc>* Set up and play a looping background soundtrack.
	 * 
	 * @param	Music		The sound file you want to loop in the background.
	 * @param	Volume		How loud the sound should be, from 0 to 1.
	 * @param	Looped		Whether to loop this music.
	 * @param	Group		The group to add this sound to.</haxe_doc>
		</playMusic>
		<load public="1" set="method" line="111">
			<f a="?EmbeddedSound:?Volume:?Looped:?Group:?AutoDestroy:?AutoPlay:?URL:?OnComplete" v=":1:false::false:false::">
				<t path="flixel.system.FlxSoundAsset"/>
				<x path="Float"/>
				<x path="Bool"/>
				<c path="flixel.system.FlxSoundGroup"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<c path="String"/>
				<f a=""><x path="Void"/></f>
				<c path="flixel.system.FlxSound"/>
			</f>
			<meta><m n=":value"><e>{ AutoPlay : false, AutoDestroy : false, Looped : false, Volume : 1 }</e></m></meta>
			<haxe_doc>* Creates a new FlxSound object. 
	 * 
	 * @param	EmbeddedSound	The embedded sound resource you want to play.  To stream, use the optional URL parameter instead.
	 * @param	Volume			How loud to play it (0 to 1).
	 * @param	Looped			Whether to loop this sound.
	 * @param	Group			The group to add this sound to.
	 * @param	AutoDestroy		Whether to destroy this sound when it finishes playing.  Leave this value set to "false" if you want to re-use this FlxSound instance.
	 * @param	AutoPlay		Whether to play the sound.
	 * @param	URL				Load a sound from an external web resource instead.  Only used if EmbeddedSound = null.
	 * @return	A FlxSound object.</haxe_doc>
		</load>
		<cache public="1" get="inline" set="null" line="149">
			<f a="EmbeddedSound">
				<c path="String"/>
				<t path="flash.media.Sound"/>
			</f>
			<haxe_doc>* Method for sound caching (especially useful on mobile targets). The game may freeze
	 * for some time the first time you try to play a sound if you don't use this method.
	 * 
	 * @param	EmbeddedSound	Name of sound assets specified in your .xml project file
	 * @return	Cached Sound object</haxe_doc>
		</cache>
		<cacheAll public="1" set="method" line="164">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Calls FlxG.sound.cache() on all sounds that are embedded.
	 * WARNING: can lead to high memory usage.</haxe_doc>
		</cacheAll>
		<play public="1" set="method" line="182">
			<f a="EmbeddedSound:?Volume:?Looped:?Group:?AutoDestroy:?OnComplete" v=":1:false::true:">
				<t path="flixel.system.FlxSoundAsset"/>
				<x path="Float"/>
				<x path="Bool"/>
				<c path="flixel.system.FlxSoundGroup"/>
				<x path="Bool"/>
				<f a=""><x path="Void"/></f>
				<c path="flixel.system.FlxSound"/>
			</f>
			<meta><m n=":value"><e>{ AutoDestroy : true, Looped : false, Volume : 1 }</e></m></meta>
			<haxe_doc>* Plays a sound from an embedded sound. Tries to recycle a cached sound first.
	 * 
	 * @param	EmbeddedSound	The sound you want to play.
	 * @param	Volume			How loud to play it (0 to 1).
	 * @param	Looped			Whether to loop this sound.
	 * @param	Group			The group to add this sound to.
	 * @param	AutoDestroy		Whether to destroy this sound when it finishes playing.  Leave this value set to "false" if you want to re-use this FlxSound instance.
	 * @return	The FlxSound object.</haxe_doc>
		</play>
		<stream public="1" get="inline" set="null" line="206">
			<f a="URL:?Volume:?Looped:?Group:?AutoDestroy:?OnComplete" v=":1:false::true:">
				<c path="String"/>
				<x path="Float"/>
				<x path="Bool"/>
				<c path="flixel.system.FlxSoundGroup"/>
				<x path="Bool"/>
				<f a=""><x path="Void"/></f>
				<c path="flixel.system.FlxSound"/>
			</f>
			<meta><m n=":value"><e>{ AutoDestroy : true, Looped : false, Volume : 1 }</e></m></meta>
			<haxe_doc>* Creates a new sound object from a URL.
	 * NOTE: Just calls FlxG.loadSound() with AutoPlay == true.
	 * 
	 * @param	URL		The URL of the sound you want to play.
	 * @param	Volume	How loud to play it (0 to 1).
	 * @param	Looped	Whether or not to loop this sound.
	 * @param	Group			The group to add this sound to.
	 * @param	AutoDestroy		Whether to destroy this sound when it finishes playing.  Leave this value set to "false" if you want to re-use this FlxSound instance.
	 * @return	A FlxSound object.</haxe_doc>
		</stream>
		<pause public="1" set="method" line="215">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Pause all sounds currently playing.</haxe_doc>
		</pause>
		<resume public="1" set="method" line="234">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Resume playing existing sounds.</haxe_doc>
		</resume>
		<destroy public="1" set="method" line="255">
			<f a="?ForceDestroy" v="false">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ ForceDestroy : false }</e></m></meta>
			<haxe_doc>* Called by FlxGame on state changes to stop and destroy sounds.
	 * 
	 * @param	ForceDestroy	Kill sounds even if persist is true.</haxe_doc>
		</destroy>
		<toggleMuted public="1" set="method" line="275">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Toggles muted, also activating the sound tray.</haxe_doc>
		</toggleMuted>
		<changeVolume public="1" set="method" line="290">
			<f a="Amount">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Changes the volume by a certain amount, also activating the sound tray.</haxe_doc>
		</changeVolume>
		<showSoundTray public="1" set="method" line="300">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Shows the sound tray if it is enabled.</haxe_doc>
		</showSoundTray>
		<update set="method" line="319">
			<f a="elapsed">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":allow"><e>flixel.FlxGame</e></m></meta>
			<haxe_doc>* Called by the game loop to make sure the sounds get updated each frame.</haxe_doc>
		</update>
		<onFocusLost set="method" line="338">
			<f a=""><x path="Void"/></f>
			<meta><m n=":allow"><e>flixel.FlxGame</e></m></meta>
		</onFocusLost>
		<onFocus set="method" line="355">
			<f a=""><x path="Void"/></f>
			<meta><m n=":allow"><e>flixel.FlxGame</e></m></meta>
		</onFocus>
		<loadSavedPrefs set="method" line="374">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Loads saved sound preferences if they exist.</haxe_doc>
		</loadSavedPrefs>
		<set_volume set="method" line="387"><f a="Volume">
	<x path="Float"/>
	<x path="Float"/>
</f></set_volume>
		<new set="method" line="310"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":allow"><e>flixel.FlxG</e></m>
		</meta>
	</class>
	<class path="flixel.system.frontEnds.VCRFrontEnd" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/system/frontEnds/VCRFrontEnd.hx">
		<paused public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
			<haxe_doc>* Whether the debugger has been paused.</haxe_doc>
		</paused>
		<stepRequested public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
			<haxe_doc>* Whether a "1 frame step forward" was requested.</haxe_doc>
		</stepRequested>
		<pause public="1" set="method" line="58">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Pause the main game loop</haxe_doc>
		</pause>
		<resume public="1" set="method" line="78">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Resume the main game loop from FlxG.vcr.pause();</haxe_doc>
		</resume>
		<new set="method" line="399">
			<f a=""><x path="Void"/></f>
			<meta><m n=":allow"><e>flixel.FlxG</e></m></meta>
		</new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="flixel.system.macros.FlxMacroUtil" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/system/macros/FlxMacroUtil.hx"><buildMap public="1" set="method" static="1">
	<f a="typePath:invert:?exclude">
		<d/>
		<d/>
		<d/>
		<d/>
	</f>
	<haxe_doc>* Builds a map from static uppercase inline variables in an abstract type.
	 * 
	 * @param	invert	Use the field value as the key and the name as the value</haxe_doc>
</buildMap></class>
	<class path="flixel.system.replay.CodeValuePair" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/system/replay/CodeValuePair.hx">
		<code public="1"><x path="Int"/></code>
		<value public="1"><x path="flixel.input.FlxInputState"/></value>
		<new public="1" set="method" line="10"><f a="code:value">
	<x path="Int"/>
	<x path="flixel.input.FlxInputState"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="flixel.system.replay.MouseRecord" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/system/replay/MouseRecord.hx">
		<x public="1" set="null"><x path="Int"/></x>
		<y public="1" set="null"><x path="Int"/></y>
		<button public="1" set="null">
			<x path="flixel.input.FlxInputState"/>
			<haxe_doc>* The state of the left mouse button.</haxe_doc>
		</button>
		<wheel public="1" set="null">
			<x path="Int"/>
			<haxe_doc>* The state of the mouse wheel.</haxe_doc>
		</wheel>
		<new public="1" set="method" line="29">
			<f a="x:y:button:wheel">
				<x path="Int"/>
				<x path="Int"/>
				<x path="flixel.input.FlxInputState"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Instantiate a new mouse input record.
	 * 
	 * @param   X        The main X value of the mouse in screen space.
	 * @param   Y        The main Y value of the mouse in screen space.
	 * @param   Button   The state of the left mouse button.
	 * @param   Wheel    The state of the mouse wheel.</haxe_doc>
		</new>
		<haxe_doc>* A helper class for the frame records, part of the replay/demo/recording system.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="flixel.system.ui.FlxFocusLostScreen" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/system/ui/FlxFocusLostScreen.hx">
		<extends path="openfl.display.Sprite"/>
		<draw public="1" set="method" line="29">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Redraws the big arrow on the focus lost screen.</haxe_doc>
		</draw>
		<new public="1" set="method" line="11">
			<f a=""><x path="Void"/></f>
			<meta><m n=":keep"/></meta>
		</new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="flixel.system.ui.FlxSoundTray" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/system/ui/FlxSoundTray.hx">
		<extends path="openfl.display.Sprite"/>
		<active public="1">
			<x path="Bool"/>
			<haxe_doc>* Because reading any data from DisplayObject is insanely expensive in hxcpp, keep track of whether we need to update it or not.</haxe_doc>
		</active>
		<_timer>
			<x path="Float"/>
			<haxe_doc>* Helps us auto-hide the sound tray after a volume change.</haxe_doc>
		</_timer>
		<_bars>
			<c path="Array"><t path="flash.display.Bitmap"/></c>
			<haxe_doc>* Helps display the volume bars on the sound tray.</haxe_doc>
		</_bars>
		<_width expr="80">
			<x path="Int"/>
			<meta><m n=":value"><e>80</e></m></meta>
			<haxe_doc>* How wide the sound tray background is.</haxe_doc>
		</_width>
		<_defaultScale expr="2.0">
			<x path="Float"/>
			<meta><m n=":value"><e>2.0</e></m></meta>
		</_defaultScale>
		<update public="1" set="method" line="103">
			<f a="MS">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* This function just updates the soundtray object.</haxe_doc>
		</update>
		<show public="1" set="method" line="132">
			<f a="?Silent" v="false">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ Silent : false }</e></m></meta>
			<haxe_doc>* Makes the little volume tray slide out.
	 * 
	 * @param	Silent	Whether or not it should beep.</haxe_doc>
		</show>
		<screenCenter public="1" set="method" line="165"><f a=""><x path="Void"/></f></screenCenter>
		<new public="1" set="method" line="49">
			<f a=""><x path="Void"/></f>
			<meta><m n=":keep"/></meta>
			<haxe_doc>* Sets up the "sound tray", the little volume meter that pops down sometimes.</haxe_doc>
		</new>
		<haxe_doc>* The flixel sound tray, the little volume meter that pops down sometimes.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="flixel.system.ui.FlxSystemButton" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/system/ui/FlxSystemButton.hx">
		<extends path="openfl.display.Sprite"/>
		<implements path="flixel.util.IFlxDestroyable"/>
		<upHandler public="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* The function to be called when the button is pressed.</haxe_doc>
		</upHandler>
		<enabled public="1" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
			<haxe_doc>* Whether or not the downHandler function will be called when 
	 * the button is clicked.</haxe_doc>
		</enabled>
		<toggleMode public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
			<haxe_doc>* Whether this is a toggle button or not. If so, a Boolean representing the current
	 * state will be passed to the callback function, and the alpha value will be lowered when toggled.</haxe_doc>
		</toggleMode>
		<toggled public="1" set="accessor" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
			<haxe_doc>* Whether the button has been toggled in toggleMode.</haxe_doc>
		</toggled>
		<_icon>
			<t path="flash.display.Bitmap"/>
			<haxe_doc>* The icon this button uses.</haxe_doc>
		</_icon>
		<_mouseDown expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
			<haxe_doc>* Whether the mouse has been pressed while over this button.</haxe_doc>
		</_mouseDown>
		<changeIcon public="1" set="method" line="76">
			<f a="Icon">
				<t path="flash.display.BitmapData"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Change the Icon of the button
	 * 
	 * @param	Icon	The new icon to use for the button.</haxe_doc>
		</changeIcon>
		<destroy public="1" set="method" line="86"><f a=""><x path="Void"/></f></destroy>
		<onMouseUp set="method" line="96"><f a="_">
	<unknown/>
	<x path="Void"/>
</f></onMouseUp>
		<onMouseDown set="method" line="108"><f a="_">
	<unknown/>
	<x path="Void"/>
</f></onMouseDown>
		<onMouseOver get="inline" set="null" line="113"><f a="_">
	<unknown/>
	<x path="Void"/>
</f></onMouseOver>
		<onMouseOut get="inline" set="null" line="119"><f a="_">
	<unknown/>
	<x path="Void"/>
</f></onMouseOut>
		<set_toggled set="method" line="125"><f a="Value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_toggled>
		<new public="1" set="method" line="51">
			<f a="Icon:?UpHandler:?ToggleMode" v="::false">
				<t path="flash.display.BitmapData"/>
				<f a=""><x path="Void"/></f>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ ToggleMode : false }</e></m></meta>
			<haxe_doc>* Create a new FlxSystemButton
	 * 
	 * @param	Icon		The icon to use for the button.
	 * @param	UpHandler	The function to be called when the button is pressed.
	 * @param	ToggleMode	Whether this is a toggle button or not.</haxe_doc>
		</new>
		<haxe_doc>* A basic button for the debugger, extends flash.display.Sprite.
* Cannot be used in a FlxState.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="flixel.text.FlxText" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/text/FlxText.hx">
		<extends path="flixel.FlxSprite"/>
		<VERTICAL_GUTTER get="inline" set="null" expr="4" line="41" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>4</e></m></meta>
			<haxe_doc>* 2px gutter on both top and bottom</haxe_doc>
		</VERTICAL_GUTTER>
		<text public="1" set="accessor" expr="&quot;&quot;">
			<c path="String"/>
			<meta><m n=":value"><e>""</e></m></meta>
			<haxe_doc>* The text being displayed.</haxe_doc>
		</text>
		<size public="1" get="accessor" set="accessor">
			<x path="Int"/>
			<haxe_doc>* The size of the text being displayed in pixels.</haxe_doc>
		</size>
		<font public="1" get="accessor" set="accessor">
			<c path="String"/>
			<haxe_doc>* The font used for this text (assuming that it's using embedded font).</haxe_doc>
		</font>
		<embedded public="1" get="accessor" set="null">
			<x path="Bool"/>
			<haxe_doc>* Whether this text field uses an embedded font (by default) or not. 
	 * Read-only - use `systemFont` to specify a system font to use, which then automatically sets this to `false`.</haxe_doc>
		</embedded>
		<systemFont public="1" get="accessor" set="accessor">
			<c path="String"/>
			<haxe_doc>* The system font for this text (not embedded). Setting this sets `embedded` to `false`.
	 * Passing an invalid font name (like `""` or `null`) causes a default font to be used.</haxe_doc>
		</systemFont>
		<bold public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<haxe_doc>* Whether to use bold text or not (`false` by default).</haxe_doc>
		</bold>
		<italic public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<haxe_doc>* Whether to use italic text or not (`false` by default). Only works on Flash.</haxe_doc>
		</italic>
		<wordWrap public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<haxe_doc>* Whether to use word wrapping and multiline or not (`true` by default).</haxe_doc>
		</wordWrap>
		<alignment public="1" get="accessor" set="accessor">
			<x path="flixel.text.FlxTextAlign"/>
			<haxe_doc>* The alignment of the font. Note: `autoSize` must be set to
	 * `false` or `alignment` won't show any visual differences.</haxe_doc>
		</alignment>
		<borderStyle public="1" set="accessor" expr="NONE">
			<e path="flixel.text.FlxTextBorderStyle"/>
			<meta><m n=":value"><e>NONE</e></m></meta>
			<haxe_doc>* The border style to use</haxe_doc>
		</borderStyle>
		<borderColor public="1" set="accessor" expr="FlxColor.TRANSPARENT">
			<x path="flixel.util.FlxColor"/>
			<meta><m n=":value"><e>FlxColor.TRANSPARENT</e></m></meta>
			<haxe_doc>* The color of the border in `0xAARRGGBB` format</haxe_doc>
		</borderColor>
		<borderSize public="1" set="accessor" expr="1">
			<x path="Float"/>
			<meta><m n=":value"><e>1</e></m></meta>
			<haxe_doc>* The size of the border, in pixels.</haxe_doc>
		</borderSize>
		<borderQuality public="1" set="accessor" expr="1">
			<x path="Float"/>
			<meta><m n=":value"><e>1</e></m></meta>
			<haxe_doc>* How many iterations do use when drawing the border. `0`: only 1 iteration, `1`: one iteration for every pixel in `borderSize`
	 * A value of `1` will have the best quality for large border sizes, but might reduce performance when changing text. 
	 * NOTE: If the `borderSize` is `1`, `borderQuality` of `0` or `1` will have the exact same effect (and performance).</haxe_doc>
		</borderQuality>
		<textField public="1" set="null">
			<t path="flash.text.TextField"/>
			<haxe_doc>* Reference to a `TextField` object used internally for rendering -
	 * be sure to know what you're doing if messing with its properties!</haxe_doc>
		</textField>
		<fieldWidth public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<haxe_doc><![CDATA[* The width of the `TextField` object used for bitmap generation for this `FlxText` object.
	 * Use it when you want to change the visible width of text. Enables `autoSize` if `<= 0`.]]></haxe_doc>
		</fieldWidth>
		<autoSize public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<haxe_doc>* Whether the `fieldWidth` should be determined automatically. Requires `wordWrap` to be `false`.</haxe_doc>
		</autoSize>
		<shadowOffset public="1" set="null">
			<c path="flixel.math.FlxPoint"/>
			<haxe_doc>* Offset that is applied to the shadow border style, if active. 
	 * `x` and `y` are multiplied by `borderSize`. Default is `(1, 1)`, or lower-right corner.</haxe_doc>
		</shadowOffset>
		<_defaultFormat><t path="flash.text.TextFormat"/></_defaultFormat>
		<_formatAdjusted><t path="flash.text.TextFormat"/></_formatAdjusted>
		<_formatRanges expr="[]">
			<c path="Array"><c path="flixel.text._FlxText.FlxTextFormatRange"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</_formatRanges>
		<_font><c path="String"/></_font>
		<_regen expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
			<haxe_doc>* Helper boolean which tells whether to update graphic of this text object or not.</haxe_doc>
		</_regen>
		<_borderPixels>
			<t path="flash.display.BitmapData"/>
			<haxe_doc>* Helper vars to draw border styles with transparency.</haxe_doc>
		</_borderPixels>
		<_borderColorTransform><t path="flash.geom.ColorTransform"/></_borderColorTransform>
		<_hasBorderAlpha expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</_hasBorderAlpha>
		<destroy public="1" set="method" line="218" override="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Clean up memory.</haxe_doc>
		</destroy>
		<drawFrame public="1" set="method" line="228" override="1">
			<f a="?Force" v="false">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ Force : false }</e></m></meta>
		</drawFrame>
		<stampOnAtlas public="1" set="method" line="242">
			<f a="atlas">
				<c path="flixel.graphics.atlas.FlxAtlas"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Stamps text onto specified atlas object and loads graphic from this atlas.
	 * WARNING: Changing text after stamping it on the atlas will break the atlas, so do it only for
	 * static texts and only after making all the text customizing (like `size`, `alignment`, `color`, etc.)
	 * 
	 * @param	atlas	atlas to stamp graphic to.
	 * @return	whether the graphic was stamped on the atlas successfully</haxe_doc>
		</stampOnAtlas>
		<applyMarkup public="1" set="method" line="281">
			<f a="input:rules">
				<c path="String"/>
				<c path="Array"><c path="flixel.text.FlxTextFormatMarkerPair"/></c>
				<c path="flixel.text.FlxText"/>
			</f>
			<haxe_doc><![CDATA[* Applies formats to text between marker characters, then removes those markers.
	 * NOTE: this will clear all `FlxTextFormat`s and return to the default format.
	 * 
	 * Usage: 
	 * 
	 * ```haxe
	 * text.applyMarkup(
	 * 	"show $green text$ between dollar-signs",
	 * 	[new FlxTextFormatMarkerPair(greenFormat, "$")]
	 * );
	 * ```
	 * 
	 * Even works for complex nested formats like this:
	 * 
	 * ```haxe
	 * var yellow = new FlxTextFormatMarkerPair(yellowFormat, "@");
	 * var green = new FlxTextFormatMarkerPair(greenFormat, "<g>");
	 * text.applyMarkup("Hey @Buddy@, what <g>is<g> going @on<g>?<g>@", [yellow, green]);
	 * ```
	 * 
	 * @param   input   The text you want to format
	 * @param   rules   `FlxTextFormat`s to selectively apply, paired with marker strings]]></haxe_doc>
		</applyMarkup>
		<addFormat public="1" set="method" line="390">
			<f a="Format:?Start:?End" v=":-1:-1">
				<c path="flixel.text.FlxTextFormat"/>
				<x path="Int"/>
				<x path="Int"/>
				<c path="flixel.text.FlxText"/>
			</f>
			<meta><m n=":value"><e>{ End : -1, Start : -1 }</e></m></meta>
			<haxe_doc>* Adds another format to this `FlxText`
	 * 
	 * @param	Format	The format to be added.
	 * @param	Start	The start index of the string where the format will be applied.
	 * @param	End		The end index of the string where the format will be applied.</haxe_doc>
		</addFormat>
		<removeFormat public="1" get="inline" set="null" line="407">
			<f a="Format:?Start:?End">
				<c path="flixel.text.FlxTextFormat"/>
				<x path="Int"/>
				<x path="Int"/>
				<c path="flixel.text.FlxText"/>
			</f>
			<haxe_doc>* Removes a specific `FlxTextFormat` from this text.
	 * If a range is specified, this only removes the format when it touches that range.</haxe_doc>
		</removeFormat>
		<clearFormats public="1" set="method" line="428">
			<f a=""><c path="flixel.text.FlxText"/></f>
			<haxe_doc>* Clears all the formats applied.</haxe_doc>
		</clearFormats>
		<setFormat public="1" set="method" line="448">
			<f a="?Font:?Size:?Color:?Alignment:?BorderStyle:?BorderColor:?EmbeddedFont" v=":8:FlxColor.WHITE:::FlxColor.TRANSPARENT:true">
				<c path="String"/>
				<x path="Int"/>
				<x path="flixel.util.FlxColor"/>
				<x path="flixel.text.FlxTextAlign"/>
				<e path="flixel.text.FlxTextBorderStyle"/>
				<x path="flixel.util.FlxColor"/>
				<x path="Bool"/>
				<c path="flixel.text.FlxText"/>
			</f>
			<meta><m n=":value"><e>{ EmbeddedFont : true, BorderColor : FlxColor.TRANSPARENT, Color : FlxColor.WHITE, Size : 8 }</e></m></meta>
			<haxe_doc>* You can use this if you have a lot of text parameters to set instead of the individual properties.
	 * 
	 * @param	Font			The name of the font face for the text display.
	 * @param	Size			The size of the font (in pixels essentially).
	 * @param	Color			The color of the text in `0xRRGGBB` format.
	 * @param	Alignment		The desired alignment
	 * @param	BorderStyle		Which border style to use
	 * @param	BorderColor 	Color for the border, `0xAARRGGBB` format
	 * @param	EmbeddedFont	Whether this text field uses embedded fonts or not
	 * @return	This `FlxText` instance (nice for chaining stuff together, if you're into that).</haxe_doc>
		</setFormat>
		<setBorderStyle public="1" get="inline" set="null" line="481">
			<f a="Style:?Color:?Size:?Quality" v=":0:1:1">
				<e path="flixel.text.FlxTextBorderStyle"/>
				<x path="flixel.util.FlxColor"/>
				<x path="Float"/>
				<x path="Float"/>
				<c path="flixel.text.FlxText"/>
			</f>
			<meta><m n=":value"><e>{ Quality : 1, Size : 1, Color : 0 }</e></m></meta>
			<haxe_doc>* Set border's style (shadow, outline, etc), color, and size all in one go!
	 * 
	 * @param	Style outline style
	 * @param	Color outline color in `0xAARRGGBB` format
	 * @param	Size outline size in pixels
	 * @param	Quality outline quality - # of iterations to use when drawing. `0`: just 1, `1`: equal number to `Size`</haxe_doc>
		</setBorderStyle>
		<set_fieldWidth set="method" line="491"><f a="value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_fieldWidth>
		<get_fieldWidth set="method" line="512"><f a=""><x path="Float"/></f></get_fieldWidth>
		<set_autoSize set="method" line="517"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_autoSize>
		<get_autoSize set="method" line="528"><f a=""><x path="Bool"/></f></get_autoSize>
		<set_text set="method" line="533"><f a="Text">
	<c path="String"/>
	<c path="String"/>
</f></set_text>
		<get_size get="inline" set="null" line="545"><f a=""><x path="Int"/></f></get_size>
		<set_size set="method" line="550"><f a="Size">
	<x path="Int"/>
	<x path="Int"/>
</f></set_size>
		<set_color set="method" line="557" override="1"><f a="Color">
	<x path="flixel.util.FlxColor"/>
	<x path="Int"/>
</f></set_color>
		<get_font get="inline" set="null" line="569"><f a=""><c path="String"/></f></get_font>
		<set_font set="method" line="574"><f a="Font">
	<c path="String"/>
	<c path="String"/>
</f></set_font>
		<get_embedded get="inline" set="null" line="597"><f a=""><x path="Bool"/></f></get_embedded>
		<get_systemFont get="inline" set="null" line="602"><f a=""><c path="String"/></f></get_systemFont>
		<set_systemFont set="method" line="607"><f a="Font">
	<c path="String"/>
	<c path="String"/>
</f></set_systemFont>
		<get_bold get="inline" set="null" line="615"><f a=""><x path="Bool"/></f></get_bold>
		<set_bold set="method" line="620"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_bold>
		<get_italic get="inline" set="null" line="630"><f a=""><x path="Bool"/></f></get_italic>
		<set_italic set="method" line="635"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_italic>
		<get_wordWrap get="inline" set="null" line="645"><f a=""><x path="Bool"/></f></get_wordWrap>
		<set_wordWrap set="method" line="650"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_wordWrap>
		<get_alignment get="inline" set="null" line="660"><f a=""><x path="flixel.text.FlxTextAlign"/></f></get_alignment>
		<set_alignment set="method" line="665"><f a="Alignment">
	<x path="flixel.text.FlxTextAlign"/>
	<x path="flixel.text.FlxTextAlign"/>
</f></set_alignment>
		<set_borderStyle set="method" line="672"><f a="style">
	<e path="flixel.text.FlxTextBorderStyle"/>
	<e path="flixel.text.FlxTextBorderStyle"/>
</f></set_borderStyle>
		<set_borderColor set="method" line="680"><f a="Color">
	<x path="flixel.util.FlxColor"/>
	<x path="flixel.util.FlxColor"/>
</f></set_borderColor>
		<set_borderSize set="method" line="688"><f a="Value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_borderSize>
		<set_borderQuality set="method" line="696"><f a="Value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_borderQuality>
		<set_graphic set="method" line="705" override="1"><f a="Value">
	<c path="flixel.graphics.FlxGraphic"/>
	<c path="flixel.graphics.FlxGraphic"/>
</f></set_graphic>
		<get_width set="method" line="713" override="1"><f a=""><x path="Float"/></f></get_width>
		<get_height set="method" line="719" override="1"><f a=""><x path="Float"/></f></get_height>
		<updateColorTransform set="method" line="725" override="1"><f a=""><x path="Void"/></f></updateColorTransform>
		<regenGraphic set="method" line="744"><f a=""><x path="Void"/></f></regenGraphic>
		<drawTextFieldTo set="method" line="817">
			<f a="graphic">
				<t path="flash.display.BitmapData"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Internal function to draw textField to a BitmapData, if flash it calculates every line x to avoid blurry lines.</haxe_doc>
		</drawTextFieldTo>
		<draw public="1" set="method" line="867" override="1"><f a=""><x path="Void"/></f></draw>
		<calcFrame set="method" line="878" override="1">
			<f a="?RunOnCpp" v="false">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ RunOnCpp : false }</e></m></meta>
			<haxe_doc>* Internal function to update the current animation frame.
	 * 
	 * @param	RunOnCpp	Whether the frame should also be recalculated if we're on a non-flash target</haxe_doc>
		</calcFrame>
		<applyBorderStyle set="method" line="890"><f a=""><x path="Void"/></f></applyBorderStyle>
		<applyBorderTransparency get="inline" set="null" line="956"><f a=""><x path="Void"/></f></applyBorderTransparency>
		<copyTextWithOffset get="inline" set="null" line="972">
			<f a="x:y">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Helper function for `applyBorderStyle()`</haxe_doc>
		</copyTextWithOffset>
		<applyFormats set="method" line="979">
			<f a="FormatAdjusted:?UseBorderColor" v=":false">
				<t path="flash.text.TextFormat"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ UseBorderColor : false }</e></m></meta>
		</applyFormats>
		<copyTextFormat set="method" line="1006">
			<f a="from:to:?withAlign" v="::true">
				<t path="flash.text.TextFormat"/>
				<t path="flash.text.TextFormat"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ withAlign : true }</e></m></meta>
		</copyTextFormat>
		<dtfCopy set="method" line="1022">
			<f a=""><t path="flash.text.TextFormat"/></f>
			<haxe_doc>* A helper function for updating the TextField that we use for rendering.
	 * 
	 * @return	A writable copy of `TextField.defaultTextFormat`.</haxe_doc>
		</dtfCopy>
		<updateDefaultFormat get="inline" set="null" line="1028"><f a=""><x path="Void"/></f></updateDefaultFormat>
		<set_frames set="method" line="1035" override="1"><f a="Frames">
	<c path="flixel.graphics.frames.FlxFramesCollection"/>
	<c path="flixel.graphics.frames.FlxFramesCollection"/>
</f></set_frames>
		<new public="1" set="method" line="173">
			<f a="?X:?Y:?FieldWidth:?Text:?Size:?EmbeddedFont" v="0:0:0::8:true">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<c path="String"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ EmbeddedFont : true, Size : 8, FieldWidth : 0, Y : 0, X : 0 }</e></m></meta>
			<haxe_doc><![CDATA[* Creates a new `FlxText` object at the specified position.
	 * 
	 * @param   X              The x position of the text.
	 * @param   Y              The y position of the text.
	 * @param   FieldWidth     The `width` of the text object. Enables `autoSize` if `<= 0`.
	 *                         (`height` is determined automatically).
	 * @param   Text           The actual text you would like to display initially.
	 * @param   Size           The font size for this text object.
	 * @param   EmbeddedFont   Whether this text field uses embedded fonts or not.]]></haxe_doc>
		</new>
		<haxe_doc>* Extends FlxSprite to support rendering text. Can tint, fade, rotate and scale just like a sprite. Doesn't really animate 
 * though. Also does nice pixel-perfect centering on pixel fonts as long as they are only one-liners.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="flixel.text.FlxTextFormat" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/text/FlxText.hx" module="flixel.text.FlxText">
		<borderColor>
			<x path="flixel.util.FlxColor"/>
			<haxe_doc>* The border color if the text has a shadow or a border</haxe_doc>
		</borderColor>
		<format set="null"><t path="flash.text.TextFormat"/></format>
		<new public="1" set="method" line="1058">
			<f a="?FontColor:?Bold:?Italic:?BorderColor">
				<x path="flixel.util.FlxColor"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="flixel.util.FlxColor"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* @param   FontColor     Font color, in `0xRRGGBB` format. Inherits from the default format by default.
	 * @param   Bold          Whether the text should be bold (must be supported by the font). `false` by default.
	 * @param   Italic        Whether the text should be in italics (must be supported by the font). Only works on Flash. `false` by default.  
	 * @param   BorderColor   Border color, in `0xAARRGGBB` format. By default, no border (`null` / transparent).</haxe_doc>
		</new>
		<meta><m n=":allow"><e>flixel.text.FlxText.applyFormats</e></m></meta>
	</class>
	<class path="flixel.text._FlxText.FlxTextFormatRange" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/text/FlxText.hx" private="1" module="flixel.text.FlxText">
		<range public="1" set="null"><c path="flixel.util.helpers.FlxRange"><x path="Int"/></c></range>
		<format public="1" set="null"><c path="flixel.text.FlxTextFormat"/></format>
		<new public="1" set="method" line="1070"><f a="format:start:end">
	<c path="flixel.text.FlxTextFormat"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="flixel.text.FlxTextFormatMarkerPair" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/text/FlxText.hx" module="flixel.text.FlxText">
		<format public="1"><c path="flixel.text.FlxTextFormat"/></format>
		<marker public="1"><c path="String"/></marker>
		<new public="1" set="method" line="1082"><f a="format:marker">
	<c path="flixel.text.FlxTextFormat"/>
	<c path="String"/>
	<x path="Void"/>
</f></new>
	</class>
	<enum path="flixel.text.FlxTextBorderStyle" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/text/FlxText.hx" module="flixel.text.FlxText">
		<NONE/>
		<SHADOW><haxe_doc>* A simple shadow to the lower-right.
	 * Use `FlxText.shadowOffset` for custom placement.</haxe_doc></SHADOW>
		<OUTLINE><haxe_doc>* Outline on all 8 sides</haxe_doc></OUTLINE>
		<OUTLINE_FAST><haxe_doc>* Outline, optimized using only 4 draw calls (might not work for narrow and/or 1-pixel fonts)</haxe_doc></OUTLINE_FAST>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<abstract path="flixel.text.FlxTextAlign" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/text/FlxText.hx" module="flixel.text.FlxText">
		<from><icast><c path="String"/></icast></from>
		<this><c path="String"/></this>
		<meta><m n=":enum"/></meta>
		<impl><class path="flixel.text._FlxText.FlxTextAlign_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/text/FlxText.hx" private="1" module="flixel.text.FlxText">
	<LEFT public="1" get="inline" set="null" expr="cast &quot;left&quot;" line="1110" static="1">
		<x path="flixel.text.FlxTextAlign"/>
		<meta>
			<m n=":value"><e>cast "left"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</LEFT>
	<CENTER public="1" get="inline" set="null" expr="cast &quot;center&quot;" line="1117" static="1">
		<x path="flixel.text.FlxTextAlign"/>
		<meta>
			<m n=":value"><e>cast "center"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
		<haxe_doc>* Warning: on Flash, this can have a negative impact on performance
	 * of multiline texts that are frequently regenerated (especially with
	 * `borderStyle == OUTLINE`) due to a workaround for blurry rendering.</haxe_doc>
	</CENTER>
	<RIGHT public="1" get="inline" set="null" expr="cast &quot;right&quot;" line="1119" static="1">
		<x path="flixel.text.FlxTextAlign"/>
		<meta>
			<m n=":value"><e>cast "right"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</RIGHT>
	<JUSTIFY public="1" get="inline" set="null" expr="cast &quot;justify&quot;" line="1121" static="1">
		<x path="flixel.text.FlxTextAlign"/>
		<meta>
			<m n=":value"><e>cast "justify"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</JUSTIFY>
	<fromOpenFL public="1" set="method" line="1123" static="1"><f a="align">
	<t path="flixel.text._FlxText.AlignType"/>
	<x path="flixel.text.FlxTextAlign"/>
</f></fromOpenFL>
	<toOpenFL public="1" set="method" line="1135" static="1"><f a="align">
	<x path="flixel.text.FlxTextAlign"/>
	<t path="flixel.text._FlxText.AlignType"/>
</f></toOpenFL>
	<meta>
		<m n=":directlyUsed"/>
		<m n=":final"/>
		<m n=":enum"/>
	</meta>
</class></impl>
	</abstract>
	<class path="flixel.text._FlxText.FlxTextAlign_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/text/FlxText.hx" private="1" module="flixel.text.FlxText">
		<LEFT public="1" get="inline" set="null" expr="cast &quot;left&quot;" line="1110" static="1">
			<x path="flixel.text.FlxTextAlign"/>
			<meta>
				<m n=":value"><e>cast "left"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</LEFT>
		<CENTER public="1" get="inline" set="null" expr="cast &quot;center&quot;" line="1117" static="1">
			<x path="flixel.text.FlxTextAlign"/>
			<meta>
				<m n=":value"><e>cast "center"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
			<haxe_doc>* Warning: on Flash, this can have a negative impact on performance
	 * of multiline texts that are frequently regenerated (especially with
	 * `borderStyle == OUTLINE`) due to a workaround for blurry rendering.</haxe_doc>
		</CENTER>
		<RIGHT public="1" get="inline" set="null" expr="cast &quot;right&quot;" line="1119" static="1">
			<x path="flixel.text.FlxTextAlign"/>
			<meta>
				<m n=":value"><e>cast "right"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</RIGHT>
		<JUSTIFY public="1" get="inline" set="null" expr="cast &quot;justify&quot;" line="1121" static="1">
			<x path="flixel.text.FlxTextAlign"/>
			<meta>
				<m n=":value"><e>cast "justify"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</JUSTIFY>
		<fromOpenFL public="1" set="method" line="1123" static="1"><f a="align">
	<t path="flixel.text._FlxText.AlignType"/>
	<x path="flixel.text.FlxTextAlign"/>
</f></fromOpenFL>
		<toOpenFL public="1" set="method" line="1135" static="1"><f a="align">
	<x path="flixel.text.FlxTextAlign"/>
	<t path="flixel.text._FlxText.AlignType"/>
</f></toOpenFL>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":final"/>
			<m n=":enum"/>
		</meta>
	</class>
	<typedef path="flixel.text._FlxText.AlignType" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/text/FlxText.hx" private="1" module="flixel.text.FlxText"><t path="flash.text.TextFormatAlign"/></typedef>
	<class path="flixel.tile.FlxBaseTilemap" params="Tile" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/tile/FlxBaseTilemap.hx">
		<extends path="flixel.FlxObject"/>
		<auto public="1" expr="OFF">
			<e path="flixel.tile.FlxTilemapAutoTiling"/>
			<meta><m n=":value"><e>OFF</e></m></meta>
			<haxe_doc>* Set this flag to use one of the 16-tile binary auto-tile algorithms (OFF, AUTO, or ALT).</haxe_doc>
		</auto>
		<widthInTiles public="1" set="null" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</widthInTiles>
		<heightInTiles public="1" set="null" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</heightInTiles>
		<totalTiles public="1" set="null" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</totalTiles>
		<customTileRemap public="1">
			<c path="Array"><x path="Int"/></c>
			<haxe_doc>* Set this to create your own image index remapper, so you can create your own tile layouts.
	 * Mostly useful in combination with the auto-tilers.
	 * 
	 * Normally, each tile's value in _data corresponds to the index of a 
	 * tile frame in the tilesheet. With this active, each value in _data
	 * is a lookup value to that index in customTileRemap.
	 * 
	 * Example:
	 *  customTileRemap = [10,9,8,7,6]
	 *  means: 0=10, 1=9, 2=8, 3=7, 4=6</haxe_doc>
		</customTileRemap>
		<_randomIndices>
			<c path="Array"><x path="Int"/></c>
			<haxe_doc>* If these next two arrays are not null, you're telling FlxTilemap to 
	 * draw random tiles in certain places. 
	 * 
	 * _randomIndices is a list of tilemap values that should be replaced
	 * by a randomly selected value. The available values are chosen from
	 * the corresponding array in randomize_choices
	 * 
	 * So if you have:
	 *   randomIndices = [12,14]
	 *   randomChoices = [[0,1,2],[3,4,5,6,7]]
	 * 
	 * Everywhere the tilemap has a value of 12 it will be replaced by 0, 1, or, 2
	 * Everywhere the tilemap has a value of 14 it will be replaced by 3, 4, 5, 6, 7</haxe_doc>
		</_randomIndices>
		<_randomChoices><c path="Array"><c path="Array"><x path="Int"/></c></c></_randomChoices>
		<_randomLambda>
			<f a=""><x path="Float"/></f>
			<haxe_doc>* Setting this function allows you to control which choice will be selected for each element within _randomIndices array.
	 * Must return a 0-1 value that gets multiplied by _randomChoices[randIndex].length;</haxe_doc>
		</_randomLambda>
		<_tileObjects expr="[]">
			<c path="Array"><c path="flixel.tile.FlxBaseTilemap.Tile"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
			<haxe_doc>* Internal collection of tile objects, one for each type of tile in the map (NOT one for every single tile in the whole map).</haxe_doc>
		</_tileObjects>
		<_startingIndex expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* Internal, used to sort of insert blank tiles in front of the tiles in the provided graphic.</haxe_doc>
		</_startingIndex>
		<_data>
			<c path="Array"><x path="Int"/></c>
			<haxe_doc>* Internal representation of the actual tile data, as a large 1D array of integers.</haxe_doc>
		</_data>
		<_drawIndex expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</_drawIndex>
		<_collideIndex expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</_collideIndex>
		<updateTile set="method" line="86">
			<f a="Index">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Virtual methods, must be implemented in each renderers</haxe_doc>
		</updateTile>
		<cacheGraphics set="method" line="91"><f a="TileWidth:TileHeight:TileGraphic">
	<x path="Int"/>
	<x path="Int"/>
	<t path="flixel.system.FlxTilemapGraphicAsset"/>
	<x path="Void"/>
</f></cacheGraphics>
		<initTileObjects set="method" line="96"><f a=""><x path="Void"/></f></initTileObjects>
		<updateMap set="method" line="101"><f a=""><x path="Void"/></f></updateMap>
		<computeDimensions set="method" line="106"><f a=""><x path="Void"/></f></computeDimensions>
		<getTileIndexByCoords public="1" set="method" line="111"><f a="Coord">
	<c path="flixel.math.FlxPoint"/>
	<x path="Int"/>
</f></getTileIndexByCoords>
		<getTileCoordsByIndex public="1" set="method" line="117">
			<f a="Index:?Midpoint" v=":true">
				<x path="Int"/>
				<x path="Bool"/>
				<c path="flixel.math.FlxPoint"/>
			</f>
			<meta><m n=":value"><e>{ Midpoint : true }</e></m></meta>
		</getTileCoordsByIndex>
		<ray public="1" set="method" line="123">
			<f a="Start:End:?Result:?Resolution" v=":::1">
				<c path="flixel.math.FlxPoint"/>
				<c path="flixel.math.FlxPoint"/>
				<c path="flixel.math.FlxPoint"/>
				<x path="Float"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":value"><e>{ Resolution : 1 }</e></m></meta>
		</ray>
		<overlapsWithCallback public="1" set="method" line="129">
			<f a="Object:?Callback:?FlipCallbackParams:?Position" v="::false:">
				<c path="flixel.FlxObject"/>
				<f a=":">
					<c path="flixel.FlxObject"/>
					<c path="flixel.FlxObject"/>
					<x path="Bool"/>
				</f>
				<x path="Bool"/>
				<c path="flixel.math.FlxPoint"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":value"><e>{ FlipCallbackParams : false }</e></m></meta>
		</overlapsWithCallback>
		<setDirty public="1" set="method" line="135">
			<f a="?Dirty" v="true">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ Dirty : true }</e></m></meta>
		</setDirty>
		<destroy public="1" set="method" line="149" override="1"><f a=""><x path="Void"/></f></destroy>
		<loadMapFromCSV public="1" set="method" line="173">
			<f a="MapData:TileGraphic:?TileWidth:?TileHeight:?AutoTile:?StartingIndex:?DrawIndex:?CollideIndex" v="::0:0::0:1:1">
				<c path="String"/>
				<t path="flixel.system.FlxTilemapGraphicAsset"/>
				<x path="Int"/>
				<x path="Int"/>
				<e path="flixel.tile.FlxTilemapAutoTiling"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<c path="flixel.tile.FlxBaseTilemap"><c path="flixel.tile.FlxBaseTilemap.Tile"/></c>
			</f>
			<meta><m n=":value"><e>{ CollideIndex : 1, DrawIndex : 1, StartingIndex : 0, TileHeight : 0, TileWidth : 0 }</e></m></meta>
			<haxe_doc>* Load the tilemap with string data and a tile graphic.
	 * 
	 * @param   MapData         A csv-formatted string indicating what order the tiles should go in (or the path to that file)
	 * @param   TileGraphic     All the tiles you want to use, arranged in a strip corresponding to the numbers in MapData.
	 * @param   TileWidth       The width of your tiles (e.g. 8) - defaults to height of the tile graphic if unspecified.
	 * @param   TileHeight      The height of your tiles (e.g. 8) - defaults to width if unspecified.
	 * @param   AutoTile        Whether to load the map using an automatic tile placement algorithm (requires 16 tiles!).
	 *                          Setting this to either AUTO or ALT will override any values you put for StartingIndex, DrawIndex, or CollideIndex.
	 * @param   StartingIndex   Used to sort of insert empty tiles in front of the provided graphic.
	 *                          Default is 0, usually safest ot leave it at that.  Ignored if AutoTile is set.
	 * @param   DrawIndex       Initializes all tile objects equal to and after this index as visible.
	 *                          Default value is 1. Ignored if AutoTile is set.
	 * @param   CollideIndex    Initializes all tile objects equal to and after this index as allowCollisions = ANY.
	 *                          Default value is 1.  Ignored if AutoTile is set.  
	 *                          Can override and customize per-tile-type collision behavior using setTileProperties().
	 * @return  A reference to this instance of FlxTilemap, for chaining as usual :)</haxe_doc>
		</loadMapFromCSV>
		<loadMapFromArray public="1" set="method" line="256">
			<f a="MapData:WidthInTiles:HeightInTiles:TileGraphic:?TileWidth:?TileHeight:?AutoTile:?StartingIndex:?DrawIndex:?CollideIndex" v="::::0:0::0:1:1">
				<c path="Array"><x path="Int"/></c>
				<x path="Int"/>
				<x path="Int"/>
				<t path="flixel.system.FlxTilemapGraphicAsset"/>
				<x path="Int"/>
				<x path="Int"/>
				<e path="flixel.tile.FlxTilemapAutoTiling"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<c path="flixel.tile.FlxBaseTilemap"><c path="flixel.tile.FlxBaseTilemap.Tile"/></c>
			</f>
			<meta><m n=":value"><e>{ CollideIndex : 1, DrawIndex : 1, StartingIndex : 0, TileHeight : 0, TileWidth : 0 }</e></m></meta>
			<haxe_doc>* Load the tilemap with string data and a tile graphic.
	 * 
	 * @param   MapData         An array containing the tile indices
	 * @param   WidthInTiles    The width of the tilemap in tiles
	 * @param   HeightInTiles   The height of the tilemap in tiles
	 * @param   TileGraphic     All the tiles you want to use, arranged in a strip corresponding to the numbers in MapData.
	 * @param   TileWidth       The width of your tiles (e.g. 8) - defaults to height of the tile graphic if unspecified.
	 * @param   TileHeight      The height of your tiles (e.g. 8) - defaults to width if unspecified.
	 * @param   AutoTile        Whether to load the map using an automatic tile placement algorithm (requires 16 tiles!).
	 *                          Setting this to either AUTO or ALT will override any values you put for StartingIndex, DrawIndex, or CollideIndex.
	 * @param   StartingIndex   Used to sort of insert empty tiles in front of the provided graphic.
	 *                          Default is 0, usually safest ot leave it at that.  Ignored if AutoTile is set.
	 * @param   DrawIndex       Initializes all tile objects equal to and after this index as visible.
	 *                          Default value is 1. Ignored if AutoTile is set.
	 * @param   CollideIndex    Initializes all tile objects equal to and after this index as allowCollisions = ANY.
	 *                          Default value is 1.  Ignored if AutoTile is set.  
	 *                          Can override and customize per-tile-type collision behavior using setTileProperties().
	 * @return  A reference to this instance of FlxTilemap, for chaining as usual :)</haxe_doc>
		</loadMapFromArray>
		<loadMapFrom2DArray public="1" set="method" line="285">
			<f a="MapData:TileGraphic:?TileWidth:?TileHeight:?AutoTile:?StartingIndex:?DrawIndex:?CollideIndex" v="::0:0::0:1:1">
				<c path="Array"><c path="Array"><x path="Int"/></c></c>
				<t path="flixel.system.FlxTilemapGraphicAsset"/>
				<x path="Int"/>
				<x path="Int"/>
				<e path="flixel.tile.FlxTilemapAutoTiling"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<c path="flixel.tile.FlxBaseTilemap"><c path="flixel.tile.FlxBaseTilemap.Tile"/></c>
			</f>
			<meta><m n=":value"><e>{ CollideIndex : 1, DrawIndex : 1, StartingIndex : 0, TileHeight : 0, TileWidth : 0 }</e></m></meta>
			<haxe_doc>* Load the tilemap with string data and a tile graphic.
	 * 
	 * @param   MapData         A 2D array containing the tile indices. The length of the inner arrays should be consistent.
	 * @param   TileGraphic     All the tiles you want to use, arranged in a strip corresponding to the numbers in MapData.
	 * @param   TileWidth       The width of your tiles (e.g. 8) - defaults to height of the tile graphic if unspecified.
	 * @param   TileHeight      The height of your tiles (e.g. 8) - defaults to width if unspecified.
	 * @param   AutoTile        Whether to load the map using an automatic tile placement algorithm (requires 16 tiles!).
	 *                          Setting this to either AUTO or ALT will override any values you put for StartingIndex, DrawIndex, or CollideIndex.
	 * @param   StartingIndex   Used to sort of insert empty tiles in front of the provided graphic.
	 *                          Default is 0, usually safest ot leave it at that.  Ignored if AutoTile is set.
	 * @param   DrawIndex       Initializes all tile objects equal to and after this index as visible.
	 *                          Default value is 1. Ignored if AutoTile is set.
	 * @param   CollideIndex    Initializes all tile objects equal to and after this index as allowCollisions = ANY.
	 *                          Default value is 1.  Ignored if AutoTile is set.  
	 *                          Can override and customize per-tile-type collision behavior using setTileProperties().
	 * @return  A reference to this instance of FlxTilemap, for chaining as usual :)</haxe_doc>
		</loadMapFrom2DArray>
		<loadMapFromGraphic public="1" set="method" line="318">
			<f a="MapGraphic:?Invert:?Scale:?ColorMap:TileGraphic:?TileWidth:?TileHeight:?AutoTile:?StartingIndex:?DrawIndex:?CollideIndex" v=":false:1:::0:0::0:1:1">
				<t path="flixel.system.FlxGraphicSource"/>
				<x path="Bool"/>
				<x path="Int"/>
				<c path="Array"><x path="flixel.util.FlxColor"/></c>
				<t path="flixel.system.FlxTilemapGraphicAsset"/>
				<x path="Int"/>
				<x path="Int"/>
				<e path="flixel.tile.FlxTilemapAutoTiling"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<c path="flixel.tile.FlxBaseTilemap"><c path="flixel.tile.FlxBaseTilemap.Tile"/></c>
			</f>
			<meta><m n=":value"><e>{ CollideIndex : 1, DrawIndex : 1, StartingIndex : 0, TileHeight : 0, TileWidth : 0, Scale : 1, Invert : false }</e></m></meta>
			<haxe_doc>* Load the tilemap with image data and a tile graphic. 
	 * Black pixels are flagged as 'solid' by default, non-black pixels are set as non-colliding. Black pixels must be PURE BLACK.
	 * @param   MapGraphic      The image you want to use as a source of map data, where each pixel is a tile (or more than one tile if you change Scale's default value). Preferably black and white.
	 * @param   Invert          Load white pixels as solid instead.
	 * @param   Scale           Default is 1. Scale of 2 means each pixel forms a 2x2 block of tiles, and so on.
	 * @param   ColorMap        An array of color values (alpha values are ignored) in the order they're intended to be assigned as indices
	 * @param   TileGraphic     All the tiles you want to use, arranged in a strip corresponding to the numbers in MapData.
	 * @param   TileWidth       The width of your tiles (e.g. 8) - defaults to height of the tile graphic if unspecified.
	 * @param   TileHeight      The height of your tiles (e.g. 8) - defaults to width if unspecified.
	 * @param   AutoTile        Whether to load the map using an automatic tile placement algorithm (requires 16 tiles!).
	 *                          Setting this to either AUTO or ALT will override any values you put for StartingIndex, DrawIndex, or CollideIndex.
	 * @param   StartingIndex   Used to sort of insert empty tiles in front of the provided graphic.
	 *                          Default is 0, usually safest ot leave it at that.  Ignored if AutoTile is set.
	 * @param   DrawIndex       Initializes all tile objects equal to and after this index as visible.
	 *                          Default value is 1. Ignored if AutoTile is set.
	 * @param   CollideIndex    Initializes all tile objects equal to and after this index as allowCollisions = ANY.
	 *                          Default value is 1.  Ignored if AutoTile is set.  
	 *                          Can override and customize per-tile-type collision behavior using setTileProperties().
	 * @return  A reference to this instance of FlxTilemap, for chaining as usual :)
	 * @since   4.1.0</haxe_doc>
		</loadMapFromGraphic>
		<loadMapHelper set="method" line="327">
			<f a="TileGraphic:?TileWidth:?TileHeight:?AutoTile:?StartingIndex:?DrawIndex:?CollideIndex" v=":0:0::0:1:1">
				<t path="flixel.system.FlxTilemapGraphicAsset"/>
				<x path="Int"/>
				<x path="Int"/>
				<e path="flixel.tile.FlxTilemapAutoTiling"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ CollideIndex : 1, DrawIndex : 1, StartingIndex : 0, TileHeight : 0, TileWidth : 0 }</e></m></meta>
		</loadMapHelper>
		<postGraphicLoad set="method" line="351"><f a=""><x path="Void"/></f></postGraphicLoad>
		<applyAutoTile set="method" line="358"><f a=""><x path="Void"/></f></applyAutoTile>
		<applyCustomRemap set="method" line="371"><f a=""><x path="Void"/></f></applyCustomRemap>
		<randomizeIndices set="method" line="391"><f a=""><x path="Void"/></f></randomizeIndices>
		<autoTile set="method" line="427">
			<f a="Index">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* An internal function used by the binary auto-tilers.
	 * 
	 * @param	Index		The index of the tile you want to analyze.</haxe_doc>
		</autoTile>
		<setCustomTileMappings public="1" set="method" line="494">
			<f a="mappings:?randomIndices:?randomChoices:?randomLambda">
				<c path="Array"><x path="Int"/></c>
				<c path="Array"><x path="Int"/></c>
				<c path="Array"><c path="Array"><x path="Int"/></c></c>
				<f a=""><x path="Float"/></f>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Set custom tile mapping and/or randomization rules prior to loading. This MUST be called BEFORE loadMap().
	 * WARNING: Using this will cause your maps to take longer to load. Be careful using this in very large tilemaps.
	 * 
	 * @param	mappings		Array of ints for remapping tiles. Ex: [7,4,12] means "0-->7, 1-->4, 2-->12"
	 * @param	randomIndices	Array of ints indicating which tile indices should be randomized. Ex: [7,4,12] means "replace tile index of 7, 4, or 12 with a randomized value"
	 * @param	randomChoices	A list of int-arrays that serve as the corresponding choices to randomly choose from. Ex: indices = [7,4], choices = [[1,2],[3,4,5]], 7 will be replaced by either 1 or 2, 4 will be replaced by 3, 4, or 5.
	 * @param	randomLambda	A custom randomizer function, should return value between 0.0 and 1.0. Initialize your random seed before passing this in! If not defined, will default to unseeded Math.random() calls.]]></haxe_doc>
		</setCustomTileMappings>
		<getTile public="1" set="method" line="515">
			<f a="X:Y">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>* Check the value of a particular tile.
	 * 
	 * @param	X		The X coordinate of the tile (in tiles, not pixels).
	 * @param	Y		The Y coordinate of the tile (in tiles, not pixels).
	 * @return	An integer containing the value of the tile at this spot in the array.</haxe_doc>
		</getTile>
		<getTileByIndex public="1" set="method" line="526">
			<f a="Index">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>* Get the value of a tile in the tilemap by index.
	 * 
	 * @param	Index	The slot in the data array (Y * widthInTiles + X) where this tile is stored.
	 * @return	An integer containing the value of the tile at this spot in the array.</haxe_doc>
		</getTileByIndex>
		<getTileCollisions public="1" set="method" line="537">
			<f a="Index">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>* Gets the collision flags of tile by index.
	 * 
	 * @param	Index	Tile index returned by getTile or getTileByIndex
	 * @return	The internal collision flag for the requested tile.</haxe_doc>
		</getTileCollisions>
		<getTileInstances public="1" set="method" line="548">
			<f a="Index">
				<x path="Int"/>
				<c path="Array"><x path="Int"/></c>
			</f>
			<haxe_doc>* Returns a new array full of every map index of the requested tile type.
	 * 
	 * @param	Index	The requested tile type.
	 * @return	An Array with a list of all map indices of that tile type.</haxe_doc>
		</getTileInstances>
		<setTile public="1" set="method" line="579">
			<f a="X:Y:Tile:?UpdateGraphics" v=":::true">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":value"><e>{ UpdateGraphics : true }</e></m></meta>
			<haxe_doc>* Change the data and graphic of a tile in the tilemap.
	 * 
	 * @param	X				The X coordinate of the tile (in tiles, not pixels).
	 * @param	Y				The Y coordinate of the tile (in tiles, not pixels).
	 * @param	Tile			The new integer data you wish to inject.
	 * @param	UpdateGraphics	Whether the graphical representation of this tile should change.
	 * @return	Whether or not the tile was actually changed.</haxe_doc>
		</setTile>
		<setTileByIndex public="1" set="method" line="597">
			<f a="Index:Tile:?UpdateGraphics" v="::true">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":value"><e>{ UpdateGraphics : true }</e></m></meta>
			<haxe_doc>* Change the data and graphic of a tile in the tilemap.
	 * 
	 * @param	Index			The slot in the data array (Y * widthInTiles + X) where this tile is stored.
	 * @param	Tile			The new integer data you wish to inject.
	 * @param	UpdateGraphics	Whether the graphical representation of this tile should change.
	 * @return	Whether or not the tile was actually changed.</haxe_doc>
		</setTileByIndex>
		<setTileProperties public="1" set="method" line="657">
			<f a="Tile:?AllowCollisions:?Callback:?CallbackFilter:?Range" v=":FlxObject.ANY:::1">
				<x path="Int"/>
				<x path="Int"/>
				<f a=":">
					<c path="flixel.FlxObject"/>
					<c path="flixel.FlxObject"/>
					<x path="Void"/>
				</f>
				<x path="Class"><c path="flixel.FlxObject"/></x>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ Range : 1, AllowCollisions : FlxObject.ANY }</e></m></meta>
			<haxe_doc>* Adjust collision settings and/or bind a callback function to a range of tiles.
	 * This callback function, if present, is triggered by calls to overlap() or overlapsWithCallback().
	 * 
	 * @param	Tile				The tile or tiles you want to adjust.
	 * @param	AllowCollisions		Modify the tile or tiles to only allow collisions from certain directions, use FlxObject constants NONE, ANY, LEFT, RIGHT, etc. Default is "ANY".
	 * @param	Callback			The function to trigger, e.g. lavaCallback(Tile:FlxObject, Object:FlxObject).
	 * @param	CallbackFilter		If you only want the callback to go off for certain classes or objects based on a certain class, set that class here.
	 * @param	Range				If you want this callback to work for a bunch of different tiles, input the range here. Default value is 1.</haxe_doc>
		</setTileProperties>
		<getData public="1" set="method" line="690">
			<f a="?Simple" v="false">
				<x path="Bool"/>
				<c path="Array"><x path="Int"/></c>
			</f>
			<meta><m n=":value"><e>{ Simple : false }</e></m></meta>
			<haxe_doc>* Fetches the tilemap data array.
	 * 
	 * @param   Simple   If true, returns the data as copy, as a series of 1s and 0s (useful for auto-tiling stuff).
	 *                   Default value is false, meaning it will return the actual data array (NOT a copy).
	 * @return  An array the size of the tilemap full of integers indicating tile placement.</haxe_doc>
		</getData>
		<findPath public="1" set="method" line="722">
			<f a="Start:End:?Simplify:?RaySimplify:?DiagonalPolicy" v="::true:false:WIDE">
				<c path="flixel.math.FlxPoint"/>
				<c path="flixel.math.FlxPoint"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="flixel.tile.FlxTilemapDiagonalPolicy"/>
				<c path="Array"><c path="flixel.math.FlxPoint"/></c>
			</f>
			<meta><m n=":value"><e>{ DiagonalPolicy : WIDE, RaySimplify : false, Simplify : true }</e></m></meta>
			<haxe_doc>* Find a path through the tilemap.  Any tile with any collision flags set is treated as impassable.
	 * If no path is discovered then a null reference is returned.
	 * 
	 * @param	Start		The start point in world coordinates.
	 * @param	End			The end point in world coordinates.
	 * @param	Simplify	Whether to run a basic simplification algorithm over the path data, removing extra points that are on the same line.  Default value is true.
	 * @param	RaySimplify	Whether to run an extra raycasting simplification algorithm over the remaining path data.  This can result in some close corners being cut, and should be used with care if at all (yet).  Default value is false.
	 * @param	DiagonalPolicy	How to treat diagonal movement. (Default is WIDE, count +1 tile for diagonal movement)
	 * @return	An Array of FlxPoints, containing all waypoints from the start to the end.  If no path could be found, then a null reference is returned.</haxe_doc>
		</findPath>
		<computePathDistance public="1" set="method" line="794">
			<f a="StartIndex:EndIndex:DiagonalPolicy:?StopOnEnd" v=":::true">
				<x path="Int"/>
				<x path="Int"/>
				<x path="flixel.tile.FlxTilemapDiagonalPolicy"/>
				<x path="Bool"/>
				<c path="Array"><x path="Int"/></c>
			</f>
			<meta><m n=":value"><e>{ StopOnEnd : true }</e></m></meta>
			<haxe_doc>* Pathfinding helper function, floods a grid with distance information until it finds the end point.
	 * NOTE: Currently this process does NOT use any kind of fancy heuristic! It's pretty brute.
	 * 
	 * @param	StartIndex		The starting tile's map index.
	 * @param	EndIndex		The ending tile's map index.
	 * @param	DiagonalPolicy	How to treat diagonal movement.
	 * @param	StopOnEnd		Whether to stop at the end or not (default true)
	 * @return	An array of FlxPoint nodes. If the end tile could not be found, then a null Array is returned instead.</haxe_doc>
		</computePathDistance>
		<walkPath set="method" line="989">
			<f a="Data:Start:Points">
				<c path="Array"><x path="Int"/></c>
				<x path="Int"/>
				<c path="Array"><c path="flixel.math.FlxPoint"/></c>
				<x path="Void"/>
			</f>
			<haxe_doc>* Pathfinding helper function, recursively walks the grid and finds a shortest path back to the start.
	 * 
	 * @param	Data	An array of distance information.
	 * @param	Start	The tile we're on in our walk backward.
	 * @param	Points	An array of FlxPoint nodes composing the path from the start to the end, compiled in reverse order.</haxe_doc>
		</walkPath>
		<simplifyPath set="method" line="1088">
			<f a="Points">
				<c path="Array"><c path="flixel.math.FlxPoint"/></c>
				<x path="Void"/>
			</f>
			<haxe_doc>* Pathfinding helper function, strips out extra points on the same line.
	 * 
	 * @param	Points		An array of FlxPoint nodes.</haxe_doc>
		</simplifyPath>
		<raySimplifyPath set="method" line="1121">
			<f a="Points">
				<c path="Array"><c path="flixel.math.FlxPoint"/></c>
				<x path="Void"/>
			</f>
			<haxe_doc>* Pathfinding helper function, strips out even more points by raycasting from one point to the next and dropping unnecessary points.
	 * 
	 * @param	Points		An array of FlxPoint nodes.</haxe_doc>
		</raySimplifyPath>
		<overlaps public="1" set="method" line="1165" override="1">
			<f a="ObjectOrGroup:?InScreenSpace:?Camera" v=":false:">
				<c path="flixel.FlxBasic"/>
				<x path="Bool"/>
				<c path="flixel.FlxCamera"/>
				<x path="Bool"/>
			</f>
			<meta>
				<m n=":value"><e>{ InScreenSpace : false }</e></m>
				<m n=":access"><e>flixel.group.FlxTypedGroup</e></m>
			</meta>
			<haxe_doc>* Checks to see if some FlxObject overlaps this FlxObject object in world space.
	 * If the group has a LOT of things in it, it might be faster to use FlxG.overlaps().
	 * WARNING: Currently tilemaps do NOT support screen space overlap checks!
	 * 
	 * @param	Object			The object being tested.
	 * @param	InScreenSpace	Whether to take scroll factors into account when checking for overlap.
	 * @param	Camera			Specify which game camera you want. If null, getScreenPosition() will just grab the first global camera.
	 * @return	Whether or not the two objects overlap.</haxe_doc>
		</overlaps>
		<tilemapOverlapsCallback get="inline" set="null" line="1179">
			<f a="ObjectOrGroup:?X:?Y:?InScreenSpace:?Camera" v=":0:0:false:">
				<c path="flixel.FlxBasic"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Bool"/>
				<c path="flixel.FlxCamera"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":value"><e>{ InScreenSpace : false, Y : 0, X : 0 }</e></m></meta>
		</tilemapOverlapsCallback>
		<overlapsAt public="1" set="method" line="1204" override="1">
			<f a="X:Y:ObjectOrGroup:?InScreenSpace:?Camera" v=":::false:">
				<x path="Float"/>
				<x path="Float"/>
				<c path="flixel.FlxBasic"/>
				<x path="Bool"/>
				<c path="flixel.FlxCamera"/>
				<x path="Bool"/>
			</f>
			<meta>
				<m n=":value"><e>{ InScreenSpace : false }</e></m>
				<m n=":access"><e>flixel.group.FlxTypedGroup</e></m>
			</meta>
			<haxe_doc>* Checks to see if this FlxObject were located at the given position, would it overlap the FlxObject or FlxGroup?
	 * This is distinct from overlapsPoint(), which just checks that point, rather than taking the object's size into account.
	 * WARNING: Currently tilemaps do NOT support screen space overlap checks! 
	 * 
	 * @param	X				The X position you want to check.  Pretends this object (the caller, not the parameter) is located here.
	 * @param	Y				The Y position you want to check.  Pretends this object (the caller, not the parameter) is located here.
	 * @param	ObjectOrGroup	The object or group being tested.
	 * @param	InScreenSpace	Whether to take scroll factors into account when checking for overlap.  Default is false, or "only compare in world space."
	 * @param	Camera			Specify which game camera you want.  If null getScreenPosition() will just grab the first global camera.
	 * @return	Whether or not the two objects overlap.</haxe_doc>
		</overlapsAt>
		<tilemapOverlapsAtCallback get="inline" set="null" line="1219"><f a="ObjectOrGroup:X:Y:InScreenSpace:Camera">
	<c path="flixel.FlxBasic"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Bool"/>
	<c path="flixel.FlxCamera"/>
	<x path="Bool"/>
</f></tilemapOverlapsAtCallback>
		<overlapsPoint public="1" set="method" line="1239" override="1">
			<f a="WorldPoint:?InScreenSpace:?Camera" v=":false:">
				<c path="flixel.math.FlxPoint"/>
				<x path="Bool"/>
				<c path="flixel.FlxCamera"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":value"><e>{ InScreenSpace : false }</e></m></meta>
			<haxe_doc>* Checks to see if a point in 2D world space overlaps this FlxObject object.
	 * 
	 * @param	WorldPoint		The point in world space you want to check.
	 * @param	InScreenSpace	Whether to take scroll factors into account when checking for overlap.
	 * @param	Camera			Specify which game camera you want.  If null getScreenPosition() will just grab the first global camera.
	 * @return	Whether or not the point overlaps this object.</haxe_doc>
		</overlapsPoint>
		<tileAtPointAllowsCollisions set="method" line="1253"><f a="point">
	<c path="flixel.math.FlxPoint"/>
	<x path="Bool"/>
</f></tileAtPointAllowsCollisions>
		<getBounds public="1" set="method" line="1267">
			<f a="?Bounds">
				<c path="flixel.math.FlxRect"/>
				<c path="flixel.math.FlxRect"/>
			</f>
			<haxe_doc>* Get the world coordinates and size of the entire tilemap as a FlxRect.
	 * 
	 * @param	Bounds		Optional, pass in a pre-existing FlxRect to prevent instantiation of a new object.
	 * @return	A FlxRect containing the world coordinates and size of the entire tilemap.</haxe_doc>
		</getBounds>
		<new set="method" line="140"><f a=""><x path="Void"/></f></new>
	</class>
	<enum path="flixel.tile.FlxTilemapAutoTiling" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/tile/FlxBaseTilemap.hx" module="flixel.tile.FlxBaseTilemap">
		<OFF/>
		<AUTO><haxe_doc>* Good for levels with thin walls that don't need interior corner art.</haxe_doc></AUTO>
		<ALT><haxe_doc>* Better for levels with thick walls that look better with interior corner art.</haxe_doc></ALT>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<abstract path="flixel.tile.FlxTilemapDiagonalPolicy" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/tile/FlxBaseTilemap.hx" module="flixel.tile.FlxBaseTilemap">
		<this><x path="Int"/></this>
		<meta><m n=":enum"/></meta>
		<impl><class path="flixel.tile._FlxBaseTilemap.FlxTilemapDiagonalPolicy_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/tile/FlxBaseTilemap.hx" private="1" module="flixel.tile.FlxBaseTilemap" extern="1">
	<NONE public="1" get="inline" set="null" expr="cast 0" line="1295" static="1">
		<x path="flixel.tile.FlxTilemapDiagonalPolicy"/>
		<meta>
			<m n=":value"><e>cast 0</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
		<haxe_doc>* No diagonal movement allowed when calculating the path</haxe_doc>
	</NONE>
	<NORMAL public="1" get="inline" set="null" expr="cast 1" line="1299" static="1">
		<x path="flixel.tile.FlxTilemapDiagonalPolicy"/>
		<meta>
			<m n=":value"><e>cast 1</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
		<haxe_doc>* Diagonal movement costs the same as orthogonal movement</haxe_doc>
	</NORMAL>
	<WIDE public="1" get="inline" set="null" expr="cast 2" line="1303" static="1">
		<x path="flixel.tile.FlxTilemapDiagonalPolicy"/>
		<meta>
			<m n=":value"><e>cast 2</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
		<haxe_doc>* Diagonal movement costs one more than orthogonal movement</haxe_doc>
	</WIDE>
	<meta>
		<m n=":final"/>
		<m n=":enum"/>
	</meta>
</class></impl>
	</abstract>
	<class path="flixel.tile._FlxBaseTilemap.FlxTilemapDiagonalPolicy_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/tile/FlxBaseTilemap.hx" private="1" module="flixel.tile.FlxBaseTilemap" extern="1">
		<NONE public="1" get="inline" set="null" expr="cast 0" line="1295" static="1">
			<x path="flixel.tile.FlxTilemapDiagonalPolicy"/>
			<meta>
				<m n=":value"><e>cast 0</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
			<haxe_doc>* No diagonal movement allowed when calculating the path</haxe_doc>
		</NONE>
		<NORMAL public="1" get="inline" set="null" expr="cast 1" line="1299" static="1">
			<x path="flixel.tile.FlxTilemapDiagonalPolicy"/>
			<meta>
				<m n=":value"><e>cast 1</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
			<haxe_doc>* Diagonal movement costs the same as orthogonal movement</haxe_doc>
		</NORMAL>
		<WIDE public="1" get="inline" set="null" expr="cast 2" line="1303" static="1">
			<x path="flixel.tile.FlxTilemapDiagonalPolicy"/>
			<meta>
				<m n=":value"><e>cast 2</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
			<haxe_doc>* Diagonal movement costs one more than orthogonal movement</haxe_doc>
		</WIDE>
		<meta>
			<m n=":final"/>
			<m n=":enum"/>
		</meta>
	</class>
	<class path="flixel.tile.FlxTile" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/tile/FlxTile.hx">
		<extends path="flixel.FlxObject"/>
		<callbackFunction public="1" expr="null">
			<f a=":">
				<c path="flixel.FlxObject"/>
				<c path="flixel.FlxObject"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>null</e></m></meta>
			<haxe_doc>* This function is called whenever an object hits a tile of this type.
	 * This function should take the form myFunction(Tile:FlxTile,Object:FlxObject):void.
	 * Defaults to null, set through FlxTilemap.setTileProperties().</haxe_doc>
		</callbackFunction>
		<filter public="1">
			<x path="Class"><c path="flixel.FlxObject"/></x>
			<haxe_doc>* Each tile can store its own filter class for their callback functions.
	 * That is, the callback will only be triggered if an object with a class
	 * type matching the filter touched it.
	 * Defaults to null, set through FlxTilemap.setTileProperties().</haxe_doc>
		</filter>
		<tilemap public="1">
			<c path="flixel.tile.FlxTilemap"/>
			<haxe_doc>* A reference to the tilemap this tile object belongs to.</haxe_doc>
		</tilemap>
		<index public="1">
			<x path="Int"/>
			<haxe_doc>* The index of this tile type in the core map data.
	 * For example, if your map only has 16 kinds of tiles in it,
	 * this number is usually between 0 and 15.</haxe_doc>
		</index>
		<mapIndex public="1" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* The current map index of this tile object at this moment.
	 * You can think of tile objects as moving around the tilemap helping with collisions.
	 * This value is only reliable and useful if used from the callback function.</haxe_doc>
		</mapIndex>
		<frame public="1">
			<c path="flixel.graphics.frames.FlxFrame"/>
			<haxe_doc>* Frame graphic for this tile.</haxe_doc>
		</frame>
		<destroy public="1" set="method" line="74" override="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Clean up memory.</haxe_doc>
		</destroy>
		<new public="1" set="method" line="58">
			<f a="Tilemap:Index:Width:Height:Visible:AllowCollisions">
				<c path="flixel.tile.FlxTilemap"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Instantiate this new tile object.  This is usually called from FlxTilemap.loadMap().
	 * 
	 * @param 	Tilemap			A reference to the tilemap object creating the tile.
	 * @param 	Index			The actual core map data index for this tile type.
	 * @param 	Width			The width of the tile.
	 * @param 	Height			The height of the tile.
	 * @param 	Visible			Whether the tile is visible or not.
	 * @param 	AllowCollisions	The collision flags for the object.  By default this value is ANY or NONE depending on the parameters sent to loadMap().</haxe_doc>
		</new>
		<haxe_doc>* A simple helper object for FlxTilemap that helps expand collision opportunities and control.
 * You can use FlxTilemap.setTileProperties() to alter the collision properties and
 * callback functions and filters for this object to do things like one-way tiles or whatever.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="flixel.tile.FlxTileblock" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/tile/FlxTileblock.hx">
		<extends path="flixel.FlxSprite"/>
		<tileSprite><c path="flixel.FlxSprite"/></tileSprite>
		<destroy public="1" set="method" line="38" override="1"><f a=""><x path="Void"/></f></destroy>
		<loadFrames public="1" set="method" line="51">
			<f a="tileFrames:?empties" v=":0">
				<c path="flixel.graphics.frames.FlxTileFrames"/>
				<x path="Int"/>
				<c path="flixel.tile.FlxTileblock"/>
			</f>
			<meta><m n=":value"><e>{ empties : 0 }</e></m></meta>
			<haxe_doc>* Fills the block with a randomly arranged selection of frames.
	 * 
	 * @param	TileFrames		The frames that should fill this block.
	 * @param	Empties			The number of "empty" tiles to add to the auto-fill algorithm (e.g. 8 tiles + 4 empties = 1/3 of block will be open holes).
	 * @return	This tile block.</haxe_doc>
		</loadFrames>
		<loadTiles public="1" set="method" line="132">
			<f a="TileGraphic:?TileWidth:?TileHeight:?Empties" v=":0:0:0">
				<t path="flixel.system.FlxGraphicAsset"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<c path="flixel.tile.FlxTileblock"/>
			</f>
			<meta><m n=":value"><e>{ Empties : 0, TileHeight : 0, TileWidth : 0 }</e></m></meta>
			<haxe_doc>* Fills the block with a randomly arranged selection of graphics from the image provided.
	 * 
	 * @param	TileGraphic 	The graphic class that contains the tiles that should fill this block.
	 * @param	TileWidth		The width of a single tile in the graphic.
	 * @param	TileHeight		The height of a single tile in the graphic.
	 * @param	Empties			The number of "empty" tiles to add to the auto-fill algorithm (e.g. 8 tiles + 4 empties = 1/3 of block will be open holes).
	 * @return	This tile block.</haxe_doc>
		</loadTiles>
		<setTile public="1" set="method" line="161"><f a="x:y:index">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></setTile>
		<new public="1" set="method" line="29">
			<f a="X:Y:Width:Height">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Creates a new FlxBlock object with the specified position and size.
	 * 
	 * @param	X			The X position of the block.
	 * @param	Y			The Y position of the block.
	 * @param	Width		The width of the block.
	 * @param	Height		The height of the block.</haxe_doc>
		</new>
		<haxe_doc>* This is a basic "environment object" class, used to create simple walls and floors.
 * It can be filled with a random selection of tiles to quickly add detail.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="flixel.tile.GraphicAuto" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/tile/FlxTilemap.hx" module="flixel.tile.FlxTilemap">
		<extends path="openfl.display.BitmapData"/>
		<resourceName expr="&quot;__ASSET__:bitmap_flixel_tile_GraphicAuto&quot;" line="1" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"__ASSET__:bitmap_flixel_tile_GraphicAuto"</e></m></meta>
		</resourceName>
		<new public="1" set="method" line="1">
			<f a="width:height:?transparent:?fillRGBA" v="::true:0xFFFFFFFF">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ fillRGBA : 0xFFFFFFFF, transparent : true }</e></m></meta>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>openfl.Assets.embedBitmap()</e></m>
			<m n=":autoBuild"><e>openfl.Assets.embedBitmap()</e></m>
			<m n=":keep"/>
			<m n=":bitmap"><e>"assets/images/tile/autotiles.png"</e></m>
		</meta>
	</class>
	<class path="flixel.tile.GraphicAutoAlt" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/tile/FlxTilemap.hx" module="flixel.tile.FlxTilemap">
		<extends path="openfl.display.BitmapData"/>
		<resourceName expr="&quot;__ASSET__:bitmap_flixel_tile_GraphicAutoAlt&quot;" line="1" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"__ASSET__:bitmap_flixel_tile_GraphicAutoAlt"</e></m></meta>
		</resourceName>
		<new public="1" set="method" line="1">
			<f a="width:height:?transparent:?fillRGBA" v="::true:0xFFFFFFFF">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ fillRGBA : 0xFFFFFFFF, transparent : true }</e></m></meta>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>openfl.Assets.embedBitmap()</e></m>
			<m n=":autoBuild"><e>openfl.Assets.embedBitmap()</e></m>
			<m n=":keep"/>
			<m n=":bitmap"><e>"assets/images/tile/autotiles_alt.png"</e></m>
		</meta>
	</class>
	<class path="flixel.tile.FlxTilemap" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/tile/FlxTilemap.hx">
		<extends path="flixel.tile.FlxBaseTilemap"><c path="flixel.tile.FlxTile"/></extends>
		<useScaleHack public="1" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
			<haxe_doc>* Try to eliminate 1 px gap between tiles in tile render mode by increasing tile scale, 
	 * so the tile will look one pixel wider than it is.</haxe_doc>
		</useScaleHack>
		<scale public="1" set="null">
			<c path="flixel.math.FlxPoint"/>
			<haxe_doc>* Changes the size of this tilemap. Default is (1, 1). 
	 * Anything other than the default is very slow with blitting!</haxe_doc>
		</scale>
		<antialiasing public="1" set="accessor" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
			<haxe_doc>* Controls whether the object is smoothed when rotated, affects performance.
	 * @since 4.1.0</haxe_doc>
		</antialiasing>
		<offset public="1" set="null" expr="FlxPoint.get()">
			<c path="flixel.math.FlxPoint"/>
			<meta><m n=":value"><e>FlxPoint.get()</e></m></meta>
			<haxe_doc>* Use to offset the drawing position of the tilemap,
	 * just like FlxSprite.</haxe_doc>
		</offset>
		<frames public="1" set="accessor">
			<c path="flixel.graphics.frames.FlxFramesCollection"/>
			<haxe_doc>* Rendering variables.</haxe_doc>
		</frames>
		<graphic public="1" set="accessor"><c path="flixel.graphics.FlxGraphic"/></graphic>
		<color public="1" set="accessor" expr="0xffffff">
			<x path="flixel.util.FlxColor"/>
			<meta><m n=":value"><e>0xffffff</e></m></meta>
			<haxe_doc>* Tints the whole sprite to a color (0xRRGGBB format) - similar to OpenGL vertex colors. You can use
	 * 0xAARRGGBB colors, but the alpha value will simply be ignored. To change the opacity use alpha.</haxe_doc>
		</color>
		<alpha public="1" set="accessor" expr="1.0">
			<x path="Float"/>
			<meta><m n=":value"><e>1.0</e></m></meta>
			<haxe_doc>* Set alpha to a number between 0 and 1 to change the opacity of the sprite.</haxe_doc>
		</alpha>
		<colorTransform public="1" set="null" expr="new ColorTransform()">
			<c path="openfl.geom.ColorTransform"/>
			<meta><m n=":value"><e>new ColorTransform()</e></m></meta>
		</colorTransform>
		<blend public="1" set="accessor" expr="null">
			<x path="openfl.display.BlendMode"/>
			<meta><m n=":value"><e>null</e></m></meta>
			<haxe_doc>* Blending modes, just like Photoshop or whatever, e.g. "multiply", "screen", etc.</haxe_doc>
		</blend>
		<shader public="1">
			<t path="flixel.system.FlxShader"/>
			<haxe_doc>* GLSL shader for this tilemap. Only works with OpenFL Next or WebGL.
	 * Avoid changing it frequently as this is a costly operation.
	 * @since 4.1.0</haxe_doc>
		</shader>
		<_flashPoint expr="new Point()">
			<t path="flash.geom.Point"/>
			<meta><m n=":value"><e>new Point()</e></m></meta>
			<haxe_doc>* Rendering helper, minimize new object instantiation on repetitive methods.</haxe_doc>
		</_flashPoint>
		<_flashRect expr="new Rectangle()">
			<t path="flash.geom.Rectangle"/>
			<meta><m n=":value"><e>new Rectangle()</e></m></meta>
			<haxe_doc>* Rendering helper, minimize new object instantiation on repetitive methods.</haxe_doc>
		</_flashRect>
		<_buffers expr="[]">
			<c path="Array"><c path="flixel.tile.FlxTilemapBuffer"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
			<haxe_doc>* Internal list of buffers, one for each camera, used for drawing the tilemaps.</haxe_doc>
		</_buffers>
		<_tileWidth expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* Internal, the width of a single tile.</haxe_doc>
		</_tileWidth>
		<_tileHeight expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* Internal, the height of a single tile.</haxe_doc>
		</_tileHeight>
		<_scaledTileWidth expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</_scaledTileWidth>
		<_scaledTileHeight expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</_scaledTileHeight>
		<_debugTileNotSolid><t path="flash.display.BitmapData"/></_debugTileNotSolid>
		<_debugTilePartial><t path="flash.display.BitmapData"/></_debugTilePartial>
		<_debugTileSolid><t path="flash.display.BitmapData"/></_debugTileSolid>
		<_debugRect><t path="flash.geom.Rectangle"/></_debugRect>
		<_helperPoint>
			<t path="flash.geom.Point"/>
			<haxe_doc>* Rendering helper, minimize new object instantiation on repetitive methods. Used only in tile rendering mode</haxe_doc>
		</_helperPoint>
		<_matrix>
			<c path="flixel.math.FlxMatrix"/>
			<haxe_doc>* Rendering helper, used for tile's frame transformations (only in tile rendering mode).</haxe_doc>
		</_matrix>
		<_checkBufferChanges expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
			<haxe_doc>* Whether buffers need to be checked again next draw().</haxe_doc>
		</_checkBufferChanges>
		<destroy public="1" set="method" line="179" override="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Clean up memory.</haxe_doc>
		</destroy>
		<set_frames set="method" line="226"><f a="value">
	<c path="flixel.graphics.frames.FlxFramesCollection"/>
	<c path="flixel.graphics.frames.FlxFramesCollection"/>
</f></set_frames>
		<onGameResized set="method" line="242"><f a="_:_">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></onGameResized>
		<onCameraChanged set="method" line="247"><f a="_">
	<c path="flixel.FlxCamera"/>
	<x path="Void"/>
</f></onCameraChanged>
		<cacheGraphics set="method" line="252" override="1"><f a="TileWidth:TileHeight:TileGraphic">
	<x path="Int"/>
	<x path="Int"/>
	<t path="flixel.system.FlxTilemapGraphicAsset"/>
	<x path="Void"/>
</f></cacheGraphics>
		<initTileObjects set="method" line="276" override="1"><f a=""><x path="Void"/></f></initTileObjects>
		<updateDebugTileBoundingBoxSolid set="method" line="300"><f a=""><x path="Void"/></f></updateDebugTileBoundingBoxSolid>
		<updateDebugTileBoundingBoxNotSolid set="method" line="305"><f a=""><x path="Void"/></f></updateDebugTileBoundingBoxNotSolid>
		<updateDebugTileBoundingBoxPartial set="method" line="310"><f a=""><x path="Void"/></f></updateDebugTileBoundingBoxPartial>
		<updateDebugTile set="method" line="315"><f a="tileBitmap:color">
	<t path="flash.display.BitmapData"/>
	<x path="flixel.util.FlxColor"/>
	<t path="flash.display.BitmapData"/>
</f></updateDebugTile>
		<computeDimensions set="method" line="339" override="1"><f a=""><x path="Void"/></f></computeDimensions>
		<updateMap set="method" line="349" override="1"><f a=""><x path="Void"/></f></updateMap>
		<drawDebugOnCamera public="1" set="method" line="362" override="1"><f a="Camera">
	<c path="flixel.FlxCamera"/>
	<x path="Void"/>
</f></drawDebugOnCamera>
		<isOnScreen public="1" set="method" line="440" override="1">
			<f a="?Camera">
				<c path="flixel.FlxCamera"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Check and see if this object is currently on screen. Differs from `FlxObject`'s implementation
	 * in that it takes the actual graphic into account, not just the hitbox or bounding box or whatever.
	 * 
	 * @param   Camera  Specify which game camera you want. If `null`, it will just grab the first global camera.
	 * @return  Whether the object is on screen or not.</haxe_doc>
		</isOnScreen>
		<draw public="1" set="method" line="455" override="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Draws the tilemap buffers to the cameras.</haxe_doc>
		</draw>
		<refreshBuffers set="method" line="507"><f a=""><x path="Void"/></f></refreshBuffers>
		<setDirty public="1" set="method" line="528" override="1">
			<f a="?Dirty" v="true">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ Dirty : true }</e></m></meta>
			<haxe_doc>* Set the dirty flag on all the tilemap buffers.
	 * Basically forces a reset of the drawn tilemaps, even if it wasn't necessary.
	 * 
	 * @param	Dirty		Whether to flag the tilemap buffers as dirty or not.</haxe_doc>
		</setDirty>
		<overlapsWithCallback public="1" set="method" line="549" override="1">
			<f a="Object:?Callback:?FlipCallbackParams:?Position" v="::false:">
				<c path="flixel.FlxObject"/>
				<f a=":">
					<c path="flixel.FlxObject"/>
					<c path="flixel.FlxObject"/>
					<x path="Bool"/>
				</f>
				<x path="Bool"/>
				<c path="flixel.math.FlxPoint"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":value"><e>{ FlipCallbackParams : false }</e></m></meta>
			<haxe_doc>* Checks if the Object overlaps any tiles with any collision flags set,
	 * and calls the specified callback function (if there is one).
	 * Also calls the tile's registered callback if the filter matches.
	 * 
	 * @param	Object				The FlxObject you are checking for overlaps against.
	 * @param	Callback			An optional function that takes the form "myCallback(Object1:FlxObject,Object2:FlxObject)", where Object1 is a FlxTile object, and Object2 is the object passed in in the first parameter of this method.
	 * @param	FlipCallbackParams	Used to preserve A-B list ordering from FlxObject.separate() - returns the FlxTile object as the second parameter instead.
	 * @param	Position			Optional, specify a custom position for the tilemap (useful for overlapsAt()-type functionality).
	 * @return	Whether there were overlaps, or if a callback was specified, whatever the return value of the callback was.</haxe_doc>
		</overlapsWithCallback>
		<getTileIndexByCoords public="1" set="method" line="650" override="1"><f a="Coord">
	<c path="flixel.math.FlxPoint"/>
	<x path="Int"/>
</f></getTileIndexByCoords>
		<getTileCoordsByIndex public="1" set="method" line="662" override="1">
			<f a="Index:?Midpoint" v=":true">
				<x path="Int"/>
				<x path="Bool"/>
				<c path="flixel.math.FlxPoint"/>
			</f>
			<meta><m n=":value"><e>{ Midpoint : true }</e></m></meta>
		</getTileCoordsByIndex>
		<getTileCoords public="1" set="method" line="680">
			<f a="Index:?Midpoint" v=":true">
				<x path="Int"/>
				<x path="Bool"/>
				<c path="Array"><c path="flixel.math.FlxPoint"/></c>
			</f>
			<meta><m n=":value"><e>{ Midpoint : true }</e></m></meta>
			<haxe_doc>* Returns a new array full of every coordinate of the requested tile type.
	 * 
	 * @param	Index		The requested tile type.
	 * @param	Midpoint	Whether to return the coordinates of the tile midpoint, or upper left corner. Default is true, return midpoint.
	 * @return	An Array with a list of all the coordinates of that tile type.</haxe_doc>
		</getTileCoords>
		<follow public="1" set="method" line="717">
			<f a="?Camera:?Border:?UpdateWorld" v=":0:true">
				<c path="flixel.FlxCamera"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ UpdateWorld : true, Border : 0 }</e></m></meta>
			<haxe_doc>* Call this function to lock the automatic camera to the map's edges.
	 * 
	 * @param	Camera			Specify which game camera you want.  If null getScreenPosition() will just grab the first global camera.
	 * @param	Border			Adjusts the camera follow boundary by whatever number of tiles you specify here.  Handy for blocking off deadends that are offscreen, etc.  Use a negative number to add padding instead of hiding the edges.
	 * @param	UpdateWorld		Whether to update the collision system's world size, default value is true.</haxe_doc>
		</follow>
		<ray public="1" set="method" line="735" override="1">
			<f a="Start:End:?Result:?Resolution" v=":::1">
				<c path="flixel.math.FlxPoint"/>
				<c path="flixel.math.FlxPoint"/>
				<c path="flixel.math.FlxPoint"/>
				<x path="Float"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":value"><e>{ Resolution : 1 }</e></m></meta>
			<haxe_doc>* Shoots a ray from the start point to the end point.
	 * If/when it passes through a tile, it stores that point and returns false.
	 * 
	 * @param	Start		The world coordinates of the start of the ray.
	 * @param	End			The world coordinates of the end of the ray.
	 * @param	Result		An optional point containing the first wall impact if there was one. Null otherwise.
	 * @param	Resolution	Defaults to 1, meaning check every tile or so.  Higher means more checks!
	 * @return	Returns true if the ray made it from Start to End without hitting anything. Returns false and fills Result if a tile was hit.</haxe_doc>
		</ray>
		<tileToSprite public="1" set="method" line="845">
			<f a="X:Y:?NewTile:?SpriteFactory" v="::0:">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<f a="">
					<t path="flixel.tile.FlxTileProperties"/>
					<c path="flixel.FlxSprite"/>
				</f>
				<c path="flixel.FlxSprite"/>
			</f>
			<meta><m n=":value"><e>{ NewTile : 0 }</e></m></meta>
			<haxe_doc>* Change a particular tile to FlxSprite. Or just copy the graphic if you dont want any changes to map data itself.
	 * 
	 * @link http://forums.flixel.org/index.php/topic,5398.0.html
	 * @param	X				The X coordinate of the tile (in tiles, not pixels).
	 * @param	Y				The Y coordinate of the tile (in tiles, not pixels).
	 * @param	NewTile			New tile for the map data. Use -1 if you dont want any changes. Default = 0 (empty)
	 * @param	SpriteFactory	Method for converting FlxTile to FlxSprite. If null then will be used defaultTileToSprite() method.
	 * @return	FlxSprite.</haxe_doc>
		</tileToSprite>
		<updateBuffers public="1" set="method" line="872">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Use this method so the tilemap buffers are updated, e.g. when resizing your game</haxe_doc>
		</updateBuffers>
		<drawTilemap set="method" line="885">
			<f a="Buffer:Camera">
				<c path="flixel.tile.FlxTilemapBuffer"/>
				<c path="flixel.FlxCamera"/>
				<x path="Void"/>
			</f>
			<meta><m n=":access"><e>flixel.FlxCamera</e></m></meta>
			<haxe_doc>* Internal function that actually renders the tilemap to the tilemap buffer. Called by draw().
	 * 
	 * @param	Buffer		The FlxTilemapBuffer you are rendering to.
	 * @param	Camera		The related FlxCamera, mainly for scroll values.</haxe_doc>
		</drawTilemap>
		<makeDebugTile set="method" line="1033">
			<f a="color">
				<x path="flixel.util.FlxColor"/>
				<t path="flash.display.BitmapData"/>
			</f>
			<haxe_doc>* Internal function to clean up the map loading code.
	 * Just generates a wireframe box the size of a tile with the specified color.</haxe_doc>
		</makeDebugTile>
		<drawDebugTile set="method" line="1043"><f a="debugTile:color">
	<t path="flash.display.BitmapData"/>
	<x path="flixel.util.FlxColor"/>
	<x path="Void"/>
</f></drawDebugTile>
		<onDrawDebugChanged set="method" line="1060"><f a=""><x path="Void"/></f></onDrawDebugChanged>
		<updateTile set="method" line="1071" override="1">
			<f a="Index">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Internal function used in setTileByIndex() and the constructor to update the map.
	 * 
	 * @param	Index		The index of the tile object in _tileObjects internal array you want to update.</haxe_doc>
		</updateTile>
		<createBuffer get="inline" set="null" line="1080"><f a="camera">
	<c path="flixel.FlxCamera"/>
	<c path="flixel.tile.FlxTilemapBuffer"/>
</f></createBuffer>
		<set_antialiasing set="method" line="1088"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_antialiasing>
		<set_graphic set="method" line="1099">
			<f a="Value">
				<c path="flixel.graphics.FlxGraphic"/>
				<c path="flixel.graphics.FlxGraphic"/>
			</f>
			<haxe_doc>* Internal function for setting graphic property for this object. 
	 * It changes graphic' useCount also for better memory tracking.</haxe_doc>
		</set_graphic>
		<set_pixelPerfectRender set="method" line="1116" override="1"><f a="Value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_pixelPerfectRender>
		<set_alpha set="method" line="1125"><f a="Alpha">
	<x path="Float"/>
	<x path="Float"/>
</f></set_alpha>
		<set_color set="method" line="1132"><f a="Color">
	<x path="flixel.util.FlxColor"/>
	<x path="Int"/>
</f></set_color>
		<updateColorTransform set="method" line="1142"><f a=""><x path="Void"/></f></updateColorTransform>
		<set_blend set="method" line="1155"><f a="Value">
	<x path="openfl.display.BlendMode"/>
	<x path="openfl.display.BlendMode"/>
</f></set_blend>
		<setScaleXYCallback set="method" line="1161"><f a="Scale">
	<c path="flixel.math.FlxPoint"/>
	<x path="Void"/>
</f></setScaleXYCallback>
		<setScaleXCallback set="method" line="1167"><f a="Scale">
	<c path="flixel.math.FlxPoint"/>
	<x path="Void"/>
</f></setScaleXCallback>
		<setScaleYCallback set="method" line="1180"><f a="Scale">
	<c path="flixel.math.FlxPoint"/>
	<x path="Void"/>
</f></setScaleYCallback>
		<defaultTileToSprite set="method" line="1199">
			<f a="TileProperties">
				<t path="flixel.tile.FlxTileProperties"/>
				<c path="flixel.FlxSprite"/>
			</f>
			<haxe_doc>* Default method for generating FlxSprite from FlxTile
	 * 
	 * @param	TileProperties	properties for new sprite
	 * @return	New FlxSprite with specified graphic</haxe_doc>
		</defaultTileToSprite>
		<set_allowCollisions set="method" line="1210" override="1"><f a="Value">
	<x path="Int"/>
	<x path="Int"/>
</f></set_allowCollisions>
		<set_debugBoundingBoxColorSolid set="method" line="1220" override="1"><f a="color">
	<x path="flixel.util.FlxColor"/>
	<x path="flixel.util.FlxColor"/>
</f></set_debugBoundingBoxColorSolid>
		<set_debugBoundingBoxColorNotSolid set="method" line="1227" override="1"><f a="color">
	<x path="flixel.util.FlxColor"/>
	<x path="flixel.util.FlxColor"/>
</f></set_debugBoundingBoxColorNotSolid>
		<set_debugBoundingBoxColorPartial set="method" line="1234" override="1"><f a="color">
	<x path="flixel.util.FlxColor"/>
	<x path="flixel.util.FlxColor"/>
</f></set_debugBoundingBoxColorPartial>
		<new public="1" set="method" line="148"><f a=""><x path="Void"/></f></new>
		<haxe_doc>* This is a traditional tilemap display and collision class. It takes a string of comma-separated numbers and then associates
 * those values with tiles from the sheet you pass in. It also includes some handy static parsers that can convert
 * arrays or images into strings that can be loaded.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<typedef path="flixel.tile.FlxTileProperties" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/tile/FlxTilemap.hx" module="flixel.tile.FlxTilemap"><a>
	<y><x path="Float"/></y>
	<x><x path="Float"/></x>
	<scale><c path="flixel.math.FlxPoint"/></scale>
	<graphic><c path="flixel.graphics.frames.FlxImageFrame"/></graphic>
	<blend><x path="openfl.display.BlendMode"/></blend>
	<alpha><x path="Float"/></alpha>
</a></typedef>
	<class path="flixel.tile.FlxTilemapBuffer" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/tile/FlxTilemapBuffer.hx">
		<implements path="flixel.util.IFlxDestroyable"/>
		<x public="1" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* The current X position of the buffer.</haxe_doc>
		</x>
		<y public="1" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* The current Y position of the buffer.</haxe_doc>
		</y>
		<width public="1" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* The width of the buffer (usually just a few tiles wider than the camera).</haxe_doc>
		</width>
		<height public="1" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* The height of the buffer (usually just a few tiles taller than the camera).</haxe_doc>
		</height>
		<dirty public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
			<haxe_doc>* Whether the buffer needs to be redrawn.</haxe_doc>
		</dirty>
		<rows public="1" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* How many rows of tiles fit in this buffer.</haxe_doc>
		</rows>
		<columns public="1" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* How many columns of tiles fit in this buffer.</haxe_doc>
		</columns>
		<pixelPerfectRender public="1">
			<t path="Null"><x path="Bool"/></t>
			<haxe_doc>* Whether or not the coordinates should be rounded during draw(), true by default (recommended for pixel art). 
	 * Only affects tilesheet rendering and rendering using BitmapData.draw() in blitting.
	 * (copyPixels() only renders on whole pixels by nature). Causes draw() to be used if false, which is more expensive.</haxe_doc>
		</pixelPerfectRender>
		<pixels public="1" set="null">
			<t path="flash.display.BitmapData"/>
			<haxe_doc>* The actual buffer BitmapData. (Only used if FlxG.renderBlit == true)</haxe_doc>
		</pixels>
		<blend public="1"><x path="openfl.display.BlendMode"/></blend>
		<antialiasing public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</antialiasing>
		<_flashRect><t path="flash.geom.Rectangle"/></_flashRect>
		<_matrix><c path="flixel.math.FlxMatrix"/></_matrix>
		<_prevTilemapX>
			<x path="Float"/>
			<haxe_doc>* Variables related to calculation of dirty value</haxe_doc>
		</_prevTilemapX>
		<_prevTilemapY><x path="Float"/></_prevTilemapY>
		<_prevTilemapScaleX><x path="Float"/></_prevTilemapScaleX>
		<_prevTilemapScaleY><x path="Float"/></_prevTilemapScaleY>
		<_prevTilemapScrollX><x path="Float"/></_prevTilemapScrollX>
		<_prevTilemapScrollY><x path="Float"/></_prevTilemapScrollY>
		<_prevCameraScrollX><x path="Float"/></_prevCameraScrollX>
		<_prevCameraScrollY><x path="Float"/></_prevCameraScrollY>
		<_prevCameraScaleX><x path="Float"/></_prevCameraScaleX>
		<_prevCameraScaleY><x path="Float"/></_prevCameraScaleY>
		<_prevCameraWidth><x path="Int"/></_prevCameraWidth>
		<_prevCameraHeight><x path="Int"/></_prevCameraHeight>
		<resize public="1" set="method" line="98">
			<f a="TileWidth:TileHeight:WidthInTiles:HeightInTiles:?Camera:?ScaleX:?ScaleY" v=":::::1.0:1.0">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<c path="flixel.FlxCamera"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ ScaleY : 1.0, ScaleX : 1.0 }</e></m></meta>
		</resize>
		<destroy public="1" set="method" line="129">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Clean up memory.</haxe_doc>
		</destroy>
		<fill public="1" set="method" line="146">
			<f a="?Color" v="FlxColor.TRANSPARENT">
				<x path="flixel.util.FlxColor"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ Color : FlxColor.TRANSPARENT }</e></m></meta>
			<haxe_doc>* Fill the buffer with the specified color.
	 * Default value is transparent.
	 * 
	 * @param	Color	What color to fill with, in 0xAARRGGBB hex format.</haxe_doc>
		</fill>
		<draw public="1" set="method" line="160">
			<f a="Camera:FlashPoint:?ScaleX:?ScaleY" v="::1.0:1.0">
				<c path="flixel.FlxCamera"/>
				<t path="flash.geom.Point"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ ScaleY : 1.0, ScaleX : 1.0 }</e></m></meta>
			<haxe_doc>* Just stamps this buffer onto the specified camera at the specified location.
	 * 
	 * @param	Camera		Which camera to draw the buffer onto.
	 * @param	FlashPoint	Where to draw the buffer at in camera coordinates.</haxe_doc>
		</draw>
		<colorTransform public="1" set="method" line="181"><f a="Transform">
	<c path="openfl.geom.ColorTransform"/>
	<x path="Void"/>
</f></colorTransform>
		<updateColumns public="1" set="method" line="187">
			<f a="TileWidth:WidthInTiles:?ScaleX:?Camera" v="::1.0:">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Float"/>
				<c path="flixel.FlxCamera"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":value"><e>{ ScaleX : 1.0 }</e></m>
				<m n=":access"><e>flixel.FlxCamera.viewWidth</e></m>
			</meta>
		</updateColumns>
		<updateRows public="1" set="method" line="206">
			<f a="TileHeight:HeightInTiles:?ScaleY:?Camera" v="::1.0:">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Float"/>
				<c path="flixel.FlxCamera"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":value"><e>{ ScaleY : 1.0 }</e></m>
				<m n=":access"><e>flixel.FlxCamera.viewHeight</e></m>
			</meta>
		</updateRows>
		<isPixelPerfectRender public="1" set="method" line="227">
			<f a="?Camera">
				<c path="flixel.FlxCamera"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Check if object is rendered pixel perfect on a specific camera.</haxe_doc>
		</isPixelPerfectRender>
		<isDirty public="1" set="method" line="242">
			<f a="Tilemap:Camera">
				<c path="flixel.tile.FlxTilemap"/>
				<c path="flixel.FlxCamera"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Check if tilemap or camera has changed (scrolled, moved, resized or scaled) since the previous frame.
	 * If so, then it means that we need to redraw this buffer.
	 * @param	Tilemap	Tilemap to check against. It's a tilemap this buffer belongs to.
	 * @param	Camera	Camera to check against. It's a camera this buffer is used for drawing on.
	 * @return	The value of dirty flag.</haxe_doc>
		</isDirty>
		<new public="1" set="method" line="92">
			<f a="TileWidth:TileHeight:WidthInTiles:HeightInTiles:?Camera:?ScaleX:?ScaleY" v=":::::1.0:1.0">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<c path="flixel.FlxCamera"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ ScaleY : 1.0, ScaleX : 1.0 }</e></m></meta>
			<haxe_doc>* Instantiates a new camera-specific buffer for storing the visual tilemap data.
	 * 
	 * @param   TileWidth       The width of the tiles in this tilemap.
	 * @param   TileHeight      The height of the tiles in this tilemap.
	 * @param   WidthInTiles    How many tiles wide the tilemap is.
	 * @param   HeightInTiles   How many tiles tall the tilemap is.
	 * @param   Camera          Which camera this buffer relates to.</haxe_doc>
		</new>
		<haxe_doc>* A helper object to keep tilemap drawing performance decent across the new multi-camera system.
 * Pretty much don't even have to think about this class unless you are doing some crazy hacking.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="flixel.tweens.FlxEase" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/tweens/FlxEase.hx">
		<PI2 expr="Math.PI / 2" line="20" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>Math.PI / 2</e></m></meta>
			<haxe_doc>* Easing constants.</haxe_doc>
		</PI2>
		<EL expr="2 * Math.PI / .45" line="21" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>2 * Math.PI / .45</e></m></meta>
		</EL>
		<B1 expr="1 / 2.75" line="22" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>1 / 2.75</e></m></meta>
		</B1>
		<B2 expr="2 / 2.75" line="23" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>2 / 2.75</e></m></meta>
		</B2>
		<B3 expr="1.5 / 2.75" line="24" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>1.5 / 2.75</e></m></meta>
		</B3>
		<B4 expr="2.5 / 2.75" line="25" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>2.5 / 2.75</e></m></meta>
		</B4>
		<B5 expr="2.25 / 2.75" line="26" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>2.25 / 2.75</e></m></meta>
		</B5>
		<B6 expr="2.625 / 2.75" line="27" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>2.625 / 2.75</e></m></meta>
		</B6>
		<ELASTIC_AMPLITUDE expr="1" line="28" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</ELASTIC_AMPLITUDE>
		<ELASTIC_PERIOD expr="0.4" line="29" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>0.4</e></m></meta>
		</ELASTIC_PERIOD>
		<linear public="1" get="inline" set="null" line="32" static="1">
			<f a="t">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>@since 4.3.0</haxe_doc>
		</linear>
		<quadIn public="1" get="inline" set="null" line="37" static="1"><f a="t">
	<x path="Float"/>
	<x path="Float"/>
</f></quadIn>
		<quadOut public="1" get="inline" set="null" line="42" static="1"><f a="t">
	<x path="Float"/>
	<x path="Float"/>
</f></quadOut>
		<quadInOut public="1" get="inline" set="null" line="47" static="1"><f a="t">
	<x path="Float"/>
	<x path="Float"/>
</f></quadInOut>
		<cubeIn public="1" get="inline" set="null" line="52" static="1"><f a="t">
	<x path="Float"/>
	<x path="Float"/>
</f></cubeIn>
		<cubeOut public="1" get="inline" set="null" line="57" static="1"><f a="t">
	<x path="Float"/>
	<x path="Float"/>
</f></cubeOut>
		<cubeInOut public="1" get="inline" set="null" line="62" static="1"><f a="t">
	<x path="Float"/>
	<x path="Float"/>
</f></cubeInOut>
		<quartIn public="1" get="inline" set="null" line="67" static="1"><f a="t">
	<x path="Float"/>
	<x path="Float"/>
</f></quartIn>
		<quartOut public="1" get="inline" set="null" line="72" static="1"><f a="t">
	<x path="Float"/>
	<x path="Float"/>
</f></quartOut>
		<quartInOut public="1" get="inline" set="null" line="77" static="1"><f a="t">
	<x path="Float"/>
	<x path="Float"/>
</f></quartInOut>
		<quintIn public="1" get="inline" set="null" line="82" static="1"><f a="t">
	<x path="Float"/>
	<x path="Float"/>
</f></quintIn>
		<quintOut public="1" get="inline" set="null" line="87" static="1"><f a="t">
	<x path="Float"/>
	<x path="Float"/>
</f></quintOut>
		<quintInOut public="1" get="inline" set="null" line="92" static="1"><f a="t">
	<x path="Float"/>
	<x path="Float"/>
</f></quintInOut>
		<smoothStepIn public="1" get="inline" set="null" line="98" static="1">
			<f a="t">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>@since 4.3.0</haxe_doc>
		</smoothStepIn>
		<smoothStepOut public="1" get="inline" set="null" line="104" static="1">
			<f a="t">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>@since 4.3.0</haxe_doc>
		</smoothStepOut>
		<smoothStepInOut public="1" get="inline" set="null" line="110" static="1">
			<f a="t">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>@since 4.3.0</haxe_doc>
		</smoothStepInOut>
		<smootherStepIn public="1" get="inline" set="null" line="116" static="1">
			<f a="t">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>@since 4.3.0</haxe_doc>
		</smootherStepIn>
		<smootherStepOut public="1" get="inline" set="null" line="122" static="1">
			<f a="t">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>@since 4.3.0</haxe_doc>
		</smootherStepOut>
		<smootherStepInOut public="1" get="inline" set="null" line="128" static="1">
			<f a="t">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>@since 4.3.0</haxe_doc>
		</smootherStepInOut>
		<sineIn public="1" get="inline" set="null" line="133" static="1"><f a="t">
	<x path="Float"/>
	<x path="Float"/>
</f></sineIn>
		<sineOut public="1" get="inline" set="null" line="138" static="1"><f a="t">
	<x path="Float"/>
	<x path="Float"/>
</f></sineOut>
		<sineInOut public="1" get="inline" set="null" line="143" static="1"><f a="t">
	<x path="Float"/>
	<x path="Float"/>
</f></sineInOut>
		<bounceIn public="1" set="method" line="148" static="1"><f a="t">
	<x path="Float"/>
	<x path="Float"/>
</f></bounceIn>
		<bounceOut public="1" set="method" line="157" static="1"><f a="t">
	<x path="Float"/>
	<x path="Float"/>
</f></bounceOut>
		<bounceInOut public="1" set="method" line="165" static="1"><f a="t">
	<x path="Float"/>
	<x path="Float"/>
</f></bounceInOut>
		<circIn public="1" get="inline" set="null" line="182" static="1"><f a="t">
	<x path="Float"/>
	<x path="Float"/>
</f></circIn>
		<circOut public="1" get="inline" set="null" line="187" static="1"><f a="t">
	<x path="Float"/>
	<x path="Float"/>
</f></circOut>
		<circInOut public="1" set="method" line="192" static="1"><f a="t">
	<x path="Float"/>
	<x path="Float"/>
</f></circInOut>
		<expoIn public="1" get="inline" set="null" line="197" static="1"><f a="t">
	<x path="Float"/>
	<x path="Float"/>
</f></expoIn>
		<expoOut public="1" get="inline" set="null" line="202" static="1"><f a="t">
	<x path="Float"/>
	<x path="Float"/>
</f></expoOut>
		<expoInOut public="1" set="method" line="207" static="1"><f a="t">
	<x path="Float"/>
	<x path="Float"/>
</f></expoInOut>
		<backIn public="1" get="inline" set="null" line="212" static="1"><f a="t">
	<x path="Float"/>
	<x path="Float"/>
</f></backIn>
		<backOut public="1" get="inline" set="null" line="217" static="1"><f a="t">
	<x path="Float"/>
	<x path="Float"/>
</f></backOut>
		<backInOut public="1" set="method" line="222" static="1"><f a="t">
	<x path="Float"/>
	<x path="Float"/>
</f></backInOut>
		<elasticIn public="1" get="inline" set="null" line="230" static="1"><f a="t">
	<x path="Float"/>
	<x path="Float"/>
</f></elasticIn>
		<elasticOut public="1" get="inline" set="null" line="235" static="1"><f a="t">
	<x path="Float"/>
	<x path="Float"/>
</f></elasticOut>
		<elasticInOut public="1" set="method" line="240" static="1"><f a="t">
	<x path="Float"/>
	<x path="Float"/>
</f></elasticInOut>
		<haxe_doc><![CDATA[* Static class with useful easer functions that can be used by Tweens.
 * 
 * Operation of in/out easers:
 * 
 * in(t)
 * 	return t;
 * out(t)
 * 		return 1 - in(1 - t);
 * inOut(t)
 * 		return (t <= .5) ? in(t * 2) / 2 : out(t * 2 - 1) / 2 + .5;]]></haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<typedef path="flixel.tweens.EaseFunction" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/tweens/FlxEase.hx" module="flixel.tweens.FlxEase"><f a="">
	<x path="Float"/>
	<x path="Float"/>
</f></typedef>
	<class path="flixel.tweens.FlxTween" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/tweens/FlxTween.hx">
		<implements path="flixel.util.IFlxDestroyable"/>
		<PERSIST public="1" get="inline" set="null" expr="1" line="28" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>1</e></m></meta>
			<haxe_doc>* Persistent Tween type, will stop when it finishes.</haxe_doc>
		</PERSIST>
		<LOOPING public="1" get="inline" set="null" expr="2" line="32" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>2</e></m></meta>
			<haxe_doc>* Looping Tween type, will restart immediately when it finishes.</haxe_doc>
		</LOOPING>
		<PINGPONG public="1" get="inline" set="null" expr="4" line="36" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>4</e></m></meta>
			<haxe_doc>* "To and from" Tween type, will play tween hither and thither</haxe_doc>
		</PINGPONG>
		<ONESHOT public="1" get="inline" set="null" expr="8" line="40" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>8</e></m></meta>
			<haxe_doc>* Oneshot Tween type, will stop and remove itself from its core container when it finishes.</haxe_doc>
		</ONESHOT>
		<BACKWARD public="1" get="inline" set="null" expr="16" line="44" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>16</e></m></meta>
			<haxe_doc>* Backward Tween type, will play tween in reverse direction</haxe_doc>
		</BACKWARD>
		<globalManager public="1" static="1">
			<c path="flixel.tweens.FlxTweenManager"/>
			<haxe_doc>* The global tweening manager that handles global tweens
	 * @since 4.2.0</haxe_doc>
		</globalManager>
		<tween public="1" set="method" line="64" static="1">
			<f a="Object:Values:?Duration:?Options" v="::1:">
				<d/>
				<d/>
				<x path="Float"/>
				<t path="flixel.tweens.TweenOptions"/>
				<c path="flixel.tweens.misc.VarTween"/>
			</f>
			<meta><m n=":value"><e>{ Duration : 1 }</e></m></meta>
			<haxe_doc>* Tweens numeric public properties of an Object. Shorthand for creating a VarTween, starting it and adding it to the TweenManager.
	 * 
	 * ```haxe
	 * FlxTween.tween(Object, { x: 500, y: 350 }, 2.0, { ease: easeFunction, onStart: onStart, onUpdate: onUpdate, onComplete: onComplete, type: FlxTween.ONESHOT });
	 * ```
	 * 
	 * @param	Object		The object containing the properties to tween.
	 * @param	Values		An object containing key/value pairs of properties and target values.
	 * @param	Duration	Duration of the tween in seconds.
	 * @param	Options		A structure with tween options.
	 * @return	The added VarTween object.</haxe_doc>
		</tween>
		<num public="1" set="method" line="89" static="1">
			<f a="FromValue:ToValue:?Duration:?Options:?TweenFunction" v="::1::">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<t path="flixel.tweens.TweenOptions"/>
				<f a="">
					<x path="Float"/>
					<x path="Void"/>
				</f>
				<c path="flixel.tweens.misc.NumTween"/>
			</f>
			<meta><m n=":value"><e>{ Duration : 1 }</e></m></meta>
			<haxe_doc>* Tweens some numeric value. Shorthand for creating a NumTween, starting it and adding it to the TweenManager. Using it in 
	 * conjunction with a TweenFunction requires more setup, but is faster than VarTween because it doesn't use Reflection.
	 * 
	 * ```haxe
	 * private function tweenFunction(s:FlxSprite, v:Float) { s.alpha = v; }
	 * FlxTween.num(1, 0, 2.0, { ease: easeFunction, onStart: onStart, onUpdate: onUpdate, onComplete: onComplete, type: FlxTween.ONESHOT }, tweenFunction.bind(mySprite));
	 * ```
	 * 
	 * Trivia: For historical reasons, you can use either onUpdate or TweenFunction to accomplish the same thing, but TweenFunction
	 * gives you the updated Float as a direct argument.
	 * 
	 * @param	FromValue	Start value.
	 * @param	ToValue		End value.
	 * @param	Duration	Duration of the tween.
	 * @param	Options		A structure with tween options.
	 * @param	TweenFunction	A function to be called when the tweened value updates.  It is recommended not to use an anonymous 
	 *							function if you are maximizing performance, as those will be compiled to Dynamics on cpp.
	 * @return	The added NumTween object.</haxe_doc>
		</num>
		<angle public="1" set="method" line="108" static="1">
			<f a="?Sprite:FromAngle:ToAngle:?Duration:?Options" v=":::1:">
				<c path="flixel.FlxSprite"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<t path="flixel.tweens.TweenOptions"/>
				<c path="flixel.tweens.misc.AngleTween"/>
			</f>
			<meta><m n=":value"><e>{ Duration : 1 }</e></m></meta>
			<haxe_doc>* Tweens numeric value which represents angle. Shorthand for creating a AngleTween object, starting it and adding it to the TweenManager.
	 * 
	 * ```haxe
	 * FlxTween.angle(Sprite, -90, 90, 2.0, { ease: easeFunction, onStart: onStart, onUpdate: onUpdate, onComplete: onComplete, type: FlxTween.ONESHOT });
	 * ```
	 * 
	 * @param	Sprite		Optional Sprite whose angle should be tweened.
	 * @param	FromAngle	Start angle.
	 * @param	ToAngle		End angle.
	 * @param	Duration	Duration of the tween.
	 * @param	Options		A structure with tween options.
	 * @return	The added AngleTween object.</haxe_doc>
		</angle>
		<color public="1" set="method" line="127" static="1">
			<f a="?Sprite:?Duration:FromColor:ToColor:?Options" v=":1:::">
				<c path="flixel.FlxSprite"/>
				<x path="Float"/>
				<x path="flixel.util.FlxColor"/>
				<x path="flixel.util.FlxColor"/>
				<t path="flixel.tweens.TweenOptions"/>
				<c path="flixel.tweens.misc.ColorTween"/>
			</f>
			<meta><m n=":value"><e>{ Duration : 1 }</e></m></meta>
			<haxe_doc>* Tweens numeric value which represents color. Shorthand for creating a ColorTween object, starting it and adding it to a TweenPlugin.
	 * 
	 * ```haxe
	 * FlxTween.color(Sprite, 2.0, 0x000000, 0xffffff, 0.0, 1.0, { ease: easeFunction, onStart: onStart, onUpdate: onUpdate, onComplete: onComplete, type: FlxTween.ONESHOT });
	 * ```
	 * 
	 * @param	Sprite		Optional Sprite whose color should be tweened.
	 * @param	Duration	Duration of the tween in seconds.
	 * @param	FromColor	Start color.
	 * @param	ToColor		End color.
	 * @param	Options		A structure with tween options.
	 * @return	The added ColorTween object.</haxe_doc>
		</color>
		<linearMotion public="1" set="method" line="149" static="1">
			<f a="Object:FromX:FromY:ToX:ToY:?DurationOrSpeed:?UseDuration:?Options" v=":::::1:true:">
				<c path="flixel.FlxObject"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Bool"/>
				<t path="flixel.tweens.TweenOptions"/>
				<c path="flixel.tweens.motion.LinearMotion"/>
			</f>
			<meta><m n=":value"><e>{ UseDuration : true, DurationOrSpeed : 1 }</e></m></meta>
			<haxe_doc>* Create a new LinearMotion tween.
	 * 
	 * ```haxe
	 * FlxTween.linearMotion(Object, 0, 0, 500, 20, 5, false, { ease: easeFunction, onStart: onStart, onUpdate: onUpdate, onComplete: onComplete, type: FlxTween.ONESHOT });
	 * ```
	 * 
	 * @param	Object			The object to move (FlxObject or FlxSpriteGroup)
	 * @param	FromX			X start.
	 * @param	FromY			Y start.
	 * @param	ToX				X finish.
	 * @param	ToY				Y finish.
	 * @param	DurationOrSpeed	Duration (in seconds) or speed of the movement.
	 * @param	UseDuration		Whether to use the previous param as duration or speed.
	 * @param	Options			A structure with tween options.
	 * @return The LinearMotion object.</haxe_doc>
		</linearMotion>
		<quadMotion public="1" set="method" line="173" static="1">
			<f a="Object:FromX:FromY:ControlX:ControlY:ToX:ToY:?DurationOrSpeed:?UseDuration:?Options" v=":::::::1:true:">
				<c path="flixel.FlxObject"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Bool"/>
				<t path="flixel.tweens.TweenOptions"/>
				<c path="flixel.tweens.motion.QuadMotion"/>
			</f>
			<meta><m n=":value"><e>{ UseDuration : true, DurationOrSpeed : 1 }</e></m></meta>
			<haxe_doc>* Create a new QuadMotion tween.
	 * 
	 * ```haxe
	 * FlxTween.quadMotion(Object, 0, 100, 300, 500, 100, 2, 5, false, { ease: easeFunction, onStart: onStart, onUpdate: onUpdate, onComplete: onComplete, type: FlxTween.ONESHOT });
	 * ```
	 * 
	 * @param	Object			The object to move (FlxObject or FlxSpriteGroup)
	 * @param	FromX			X start.
	 * @param	FromY			Y start.
	 * @param	ControlX		X control, used to determine the curve.
	 * @param	ControlY		Y control, used to determine the curve.
	 * @param	ToX				X finish.
	 * @param	ToY				Y finish.
	 * @param	DurationOrSpeed	Duration (in seconds) or speed of the movement.
	 * @param	UseDuration		Whether to use the previous param as duration or speed.
	 * @param	Options			A structure with tween options.
	 * @return The QuadMotion object.</haxe_doc>
		</quadMotion>
		<cubicMotion public="1" set="method" line="198" static="1">
			<f a="Object:FromX:FromY:aX:aY:bX:bY:ToX:ToY:?Duration:?Options" v=":::::::::1:">
				<c path="flixel.FlxObject"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<t path="flixel.tweens.TweenOptions"/>
				<c path="flixel.tweens.motion.CubicMotion"/>
			</f>
			<meta><m n=":value"><e>{ Duration : 1 }</e></m></meta>
			<haxe_doc>* Create a new CubicMotion tween.
	 * 
	 * ```haxe
	 * FlxTween.cubicMotion(_sprite, 0, 0, 500, 100, 400, 200, 100, 100, 2, { ease: easeFunction, onStart: onStart, onUpdate: onUpdate, onComplete: onComplete, type: FlxTween.ONESHOT });
	 * ```
	 * 
	 * @param	Object 		The object to move (FlxObject or FlxSpriteGroup)
	 * @param	FromX		X start.
	 * @param	FromY		Y start.
	 * @param	aX			First control x.
	 * @param	aY			First control y.
	 * @param	bX			Second control x.
	 * @param	bY			Second control y.
	 * @param	ToX			X finish.
	 * @param	ToY			Y finish.
	 * @param	Duration	Duration of the movement in seconds.
	 * @param	Options		A structure with tween options.
	 * @return The CubicMotion object.</haxe_doc>
		</cubicMotion>
		<circularMotion public="1" set="method" line="222" static="1">
			<f a="Object:CenterX:CenterY:Radius:Angle:Clockwise:?DurationOrSpeed:?UseDuration:?Options" v="::::::1:true:">
				<c path="flixel.FlxObject"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Float"/>
				<x path="Bool"/>
				<t path="flixel.tweens.TweenOptions"/>
				<c path="flixel.tweens.motion.CircularMotion"/>
			</f>
			<meta><m n=":value"><e>{ UseDuration : true, DurationOrSpeed : 1 }</e></m></meta>
			<haxe_doc>* Create a new CircularMotion tween.
	 * 
	 * ```haxe
	 * FlxTween.circularMotion(Object, 250, 250, 50, 0, true, 2, true, { ease: easeFunction, onStart: onStart, onUpdate: onUpdate, onComplete: onComplete, type: FlxTween.ONESHOT });
	 * ```
	 * 
	 * @param	Object			The object to move (FlxObject or FlxSpriteGroup)
	 * @param	CenterX			X position of the circle's center.
	 * @param	CenterY			Y position of the circle's center.
	 * @param	Radius			Radius of the circle.
	 * @param	Angle			Starting position on the circle.
	 * @param	Clockwise		If the motion is clockwise.
	 * @param	DurationOrSpeed	Duration of the movement in seconds.
	 * @param	UseDuration		Duration of the movement.
	 * @param	Ease			Optional easer function.
	 * @param	Options			A structure with tween options.
	 * @return The CircularMotion object.</haxe_doc>
		</circularMotion>
		<linearPath public="1" set="method" line="241" static="1">
			<f a="Object:Points:?DurationOrSpeed:?UseDuration:?Options" v="::1:true:">
				<c path="flixel.FlxObject"/>
				<c path="Array"><c path="flixel.math.FlxPoint"/></c>
				<x path="Float"/>
				<x path="Bool"/>
				<t path="flixel.tweens.TweenOptions"/>
				<c path="flixel.tweens.motion.LinearPath"/>
			</f>
			<meta><m n=":value"><e>{ UseDuration : true, DurationOrSpeed : 1 }</e></m></meta>
			<haxe_doc>* Create a new LinearPath tween.
	 * 
	 * ```haxe
	 * FlxTween.linearPath(Object, [FlxPoint.get(0, 0), FlxPoint.get(100, 100)], 2, true, { ease: easeFunction, onStart: onStart, onUpdate: onUpdate, onComplete: onComplete, type: FlxTween.ONESHOT });
	 * ```
	 * 
	 * @param	Object 			The object to move (FlxObject or FlxSpriteGroup)
	 * @param	Points			An array of at least 2 FlxPoints defining the path
	 * @param	DurationOrSpeed	Duration (in seconds) or speed of the movement.
	 * @param	UseDuration		Whether to use the previous param as duration or speed.
	 * @param	Options			A structure with tween options.
	 * @return	The LinearPath object.</haxe_doc>
		</linearPath>
		<quadPath public="1" set="method" line="260" static="1">
			<f a="Object:Points:?DurationOrSpeed:?UseDuration:?Options" v="::1:true:">
				<c path="flixel.FlxObject"/>
				<c path="Array"><c path="flixel.math.FlxPoint"/></c>
				<x path="Float"/>
				<x path="Bool"/>
				<t path="flixel.tweens.TweenOptions"/>
				<c path="flixel.tweens.motion.QuadPath"/>
			</f>
			<meta><m n=":value"><e>{ UseDuration : true, DurationOrSpeed : 1 }</e></m></meta>
			<haxe_doc>* Create a new QuadPath tween.
	 * 
	 * ```haxe
	 * FlxTween.quadPath(Object, [FlxPoint.get(0, 0), FlxPoint.get(200, 200), FlxPoint.get(400, 0)], 2, true, { ease: easeFunction, onStart: onStart, onUpdate: onUpdate, onComplete: onComplete, type: FlxTween.ONESHOT });
	 * ```
	 * 
	 * @param	Object			The object to move (FlxObject or FlxSpriteGroup)
	 * @param	Points			An array of at least 3 FlxPoints defining the path
	 * @param	DurationOrSpeed	Duration (in seconds) or speed of the movement.
	 * @param	UseDuration		Whether to use the previous param as duration or speed.
	 * @param	Options			A structure with tween options.
	 * @return	The QuadPath object.</haxe_doc>
		</quadPath>
		<manager public="1">
			<c path="flixel.tweens.FlxTweenManager"/>
			<haxe_doc>* The manager to which this tween belongs
	 * @since 4.2.0</haxe_doc>
		</manager>
		<active public="1" set="accessor" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</active>
		<duration public="1" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</duration>
		<ease public="1"><t path="flixel.tweens.EaseFunction"/></ease>
		<onStart public="1"><t path="flixel.tweens.TweenCallback"/></onStart>
		<onUpdate public="1"><t path="flixel.tweens.TweenCallback"/></onUpdate>
		<onComplete public="1"><t path="flixel.tweens.TweenCallback"/></onComplete>
		<type public="1" set="accessor"><x path="Int"/></type>
		<percent public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<haxe_doc>* Value between `0` and `1` that indicates how far along this tween is in its completion.
	 * A value of `0.33` means that the tween is `33%` complete.</haxe_doc>
		</percent>
		<finished public="1" set="null"><x path="Bool"/></finished>
		<scale public="1" set="null" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</scale>
		<backward public="1" set="null"><x path="Bool"/></backward>
		<executions public="1" set="null" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* How many times this tween has been executed / has finished so far - useful to 
	 * stop the `LOOPING` and `PINGPONG` types after a certain amount of time</haxe_doc>
		</executions>
		<startDelay public="1" set="accessor" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* Seconds to wait until starting this tween, 0 by default</haxe_doc>
		</startDelay>
		<loopDelay public="1" set="accessor" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* Seconds to wait between loops of this tween, 0 by default</haxe_doc>
		</loopDelay>
		<_secondsSinceStart expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</_secondsSinceStart>
		<_delayToUse expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</_delayToUse>
		<_running expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</_running>
		<_waitingForRestart expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</_waitingForRestart>
		<_chainedTweens><c path="Array"><c path="flixel.tweens.FlxTween"/></c></_chainedTweens>
		<_nextTweenInChain><c path="flixel.tweens.FlxTween"/></_nextTweenInChain>
		<resolveTweenOptions set="method" line="327"><f a="Options">
	<t path="flixel.tweens.TweenOptions"/>
	<t path="flixel.tweens.TweenOptions"/>
</f></resolveTweenOptions>
		<destroy public="1" set="method" line="338"><f a=""><x path="Void"/></f></destroy>
		<then public="1" set="method" line="353">
			<f a="tween">
				<c path="flixel.tweens.FlxTween"/>
				<c path="flixel.tweens.FlxTween"/>
			</f>
			<haxe_doc>* Specify a tween to be executed when this one has finished
	 * (useful for creating "tween chains").</haxe_doc>
		</then>
		<wait public="1" set="method" line="361">
			<f a="delay">
				<x path="Float"/>
				<c path="flixel.tweens.FlxTween"/>
			</f>
			<haxe_doc>* How many seconds to delay the execution of the next tween in a tween chain.</haxe_doc>
		</wait>
		<addChainedTween set="method" line="366"><f a="tween">
	<c path="flixel.tweens.FlxTween"/>
	<c path="flixel.tweens.FlxTween"/>
</f></addChainedTween>
		<update set="method" line="378"><f a="elapsed">
	<x path="Float"/>
	<x path="Void"/>
</f></update>
		<start public="1" set="method" line="416">
			<f a=""><c path="flixel.tweens.FlxTween"/></f>
			<haxe_doc>* Starts the Tween, or restarts it if it's currently running.</haxe_doc>
		</start>
		<cancel public="1" set="method" line="438">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Immediately stops the Tween and removes it from its 
	 * `manager` without calling the `onComplete` callback.
	 *
	 * Yields control to the next chained Tween if one exists.</haxe_doc>
		</cancel>
		<cancelChain public="1" set="method" line="456">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Immediately stops the Tween and removes it from its
	 * `manager` without calling the `onComplete` callback
	 * or yielding control to the next chained Tween if one exists.
	 *
	 * If control has already been passed on, forwards the cancellation
	 * request along the chain to the currently active Tween.
	 *
	 * @since 4.3.0</haxe_doc>
		</cancelChain>
		<finish set="method" line="469"><f a=""><x path="Void"/></f></finish>
		<onEnd set="method" line="515">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Called when the tween ends, either via finish() or cancel().</haxe_doc>
		</onEnd>
		<setVarsOnEnd set="method" line="521"><f a=""><x path="Void"/></f></setVarsOnEnd>
		<processTweenChain set="method" line="528"><f a=""><x path="Void"/></f></processTweenChain>
		<doNextTween set="method" line="540"><f a="tween">
	<c path="flixel.tweens.FlxTween"/>
	<x path="Void"/>
</f></doNextTween>
		<setChain set="method" line="551"><f a="previousChain">
	<c path="Array"><c path="flixel.tweens.FlxTween"/></c>
	<x path="Void"/>
</f></setChain>
		<restart set="method" line="566">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* In case the tween.active was set to false in onComplete(),
	 * the tween should not be restarted yet.</haxe_doc>
		</restart>
		<setDelays set="method" line="584">
			<f a="?StartDelay:?LoopDelay">
				<x path="Float"/>
				<x path="Float"/>
				<c path="flixel.tweens.FlxTween"/>
			</f>
			<haxe_doc>* Set both type of delays for this tween.
	 * 
	 * @param	startDelay	Seconds to wait until starting this tween, 0 by default.
	 * @param	loopDelay	Seconds to wait between loops of this tween, 0 by default.</haxe_doc>
		</setDelays>
		<set_startDelay set="method" line="591"><f a="value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_startDelay>
		<set_loopDelay set="method" line="602"><f a="value">
	<t path="Null"><x path="Float"/></t>
	<x path="Float"/>
</f></set_loopDelay>
		<get_percent get="inline" set="null" line="613"><f a=""><x path="Float"/></f></get_percent>
		<set_percent set="method" line="618"><f a="value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_percent>
		<set_type set="method" line="623"><f a="value">
	<x path="Int"/>
	<x path="Int"/>
</f></set_type>
		<set_active set="method" line="638"><f a="active">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_active>
		<new set="method" line="314">
			<f a="Options:?manager">
				<t path="flixel.tweens.TweenOptions"/>
				<c path="flixel.tweens.FlxTweenManager"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* This function is called when tween is created, or recycled.</haxe_doc>
		</new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<typedef path="flixel.tweens.TweenCallback" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/tweens/FlxTween.hx" module="flixel.tweens.FlxTween"><f a="">
	<c path="flixel.tweens.FlxTween"/>
	<x path="Void"/>
</f></typedef>
	<typedef path="flixel.tweens.TweenOptions" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/tweens/FlxTween.hx" module="flixel.tweens.FlxTween"><a>
	<type>
		<t path="Null"><x path="Int"/></t>
		<meta><m n=":optional"/></meta>
		<haxe_doc>* Tween type - bit field of `FlxTween`'s static type constants.</haxe_doc>
	</type>
	<startDelay>
		<t path="Null"><x path="Float"/></t>
		<meta><m n=":optional"/></meta>
		<haxe_doc>* Seconds to wait until starting this tween, `0` by default.</haxe_doc>
	</startDelay>
	<onUpdate>
		<t path="Null"><t path="flixel.tweens.TweenCallback"/></t>
		<meta><m n=":optional"/></meta>
		<haxe_doc>* Optional update callback function.</haxe_doc>
	</onUpdate>
	<onStart>
		<t path="Null"><t path="flixel.tweens.TweenCallback"/></t>
		<meta><m n=":optional"/></meta>
		<haxe_doc>* Optional start callback function.</haxe_doc>
	</onStart>
	<onComplete>
		<t path="Null"><t path="flixel.tweens.TweenCallback"/></t>
		<meta><m n=":optional"/></meta>
		<haxe_doc>* Optional complete callback function.</haxe_doc>
	</onComplete>
	<loopDelay>
		<t path="Null"><x path="Float"/></t>
		<meta><m n=":optional"/></meta>
		<haxe_doc>* Seconds to wait between loops of this tween, `0` by default.</haxe_doc>
	</loopDelay>
	<ease>
		<t path="Null"><t path="flixel.tweens.EaseFunction"/></t>
		<meta><m n=":optional"/></meta>
		<haxe_doc>* Optional easer function (see `FlxEase`).</haxe_doc>
	</ease>
</a></typedef>
	<class path="flixel.tweens.FlxTweenManager" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/tweens/FlxTween.hx" module="flixel.tweens.FlxTween">
		<extends path="flixel.FlxBasic"/>
		<_tweens set="null" expr="[]">
			<c path="Array"><c path="flixel.tweens.FlxTween"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
			<haxe_doc>* A list of all FlxTween objects.</haxe_doc>
		</_tweens>
		<tween public="1" set="method" line="716">
			<f a="Object:Values:?Duration:?Options" v="::1:">
				<d/>
				<d/>
				<x path="Float"/>
				<t path="flixel.tweens.TweenOptions"/>
				<c path="flixel.tweens.misc.VarTween"/>
			</f>
			<meta><m n=":value"><e>{ Duration : 1 }</e></m></meta>
			<haxe_doc>* Tweens numeric public properties of an Object. Shorthand for creating a VarTween, starting it and adding it to the TweenManager.
	 * 
	 * ```haxe
	 * FlxTween.tween(Object, { x: 500, y: 350 }, 2.0, { ease: easeFunction, onStart: onStart, onUpdate: onUpdate, onComplete: onComplete, type: FlxTween.ONESHOT });
	 * ```
	 * 
	 * @param	Object		The object containing the properties to tween.
	 * @param	Values		An object containing key/value pairs of properties and target values.
	 * @param	Duration	Duration of the tween in seconds.
	 * @param	Options		A structure with tween options.
	 * @return	The added VarTween object.
	 * @since   4.2.0</haxe_doc>
		</tween>
		<num public="1" set="method" line="744">
			<f a="FromValue:ToValue:?Duration:?Options:?TweenFunction" v="::1::">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<t path="flixel.tweens.TweenOptions"/>
				<f a="">
					<x path="Float"/>
					<x path="Void"/>
				</f>
				<c path="flixel.tweens.misc.NumTween"/>
			</f>
			<meta><m n=":value"><e>{ Duration : 1 }</e></m></meta>
			<haxe_doc>* Tweens some numeric value. Shorthand for creating a NumTween, starting it and adding it to the TweenManager. Using it in 
	 * conjunction with a TweenFunction requires more setup, but is faster than VarTween because it doesn't use Reflection.
	 * 
	 * ```haxe
	 * private function tweenFunction(s:FlxSprite, v:Float) { s.alpha = v; }
	 * FlxTween.num(1, 0, 2.0, { ease: easeFunction, onStart: onStart, onUpdate: onUpdate, onComplete: onComplete, type: FlxTween.ONESHOT }, tweenFunction.bind(mySprite));
	 * ```
	 * 
	 * Trivia: For historical reasons, you can use either onUpdate or TweenFunction to accomplish the same thing, but TweenFunction
	 * gives you the updated Float as a direct argument.
	 * 
	 * @param	FromValue	Start value.
	 * @param	ToValue		End value.
	 * @param	Duration	Duration of the tween.
	 * @param	Options		A structure with tween options.
	 * @param	TweenFunction	A function to be called when the tweened value updates.  It is recommended not to use an anonymous 
	 *							function if you are maximizing performance, as those will be compiled to Dynamics on cpp.
	 * @return	The added NumTween object.
	 * @since   4.2.0</haxe_doc>
		</num>
		<angle public="1" set="method" line="766">
			<f a="?Sprite:FromAngle:ToAngle:?Duration:?Options" v=":::1:">
				<c path="flixel.FlxSprite"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<t path="flixel.tweens.TweenOptions"/>
				<c path="flixel.tweens.misc.AngleTween"/>
			</f>
			<meta><m n=":value"><e>{ Duration : 1 }</e></m></meta>
			<haxe_doc>* Tweens numeric value which represents angle. Shorthand for creating a AngleTween object, starting it and adding it to the TweenManager.
	 * 
	 * ```haxe
	 * FlxTween.angle(Sprite, -90, 90, 2.0, { ease: easeFunction, onStart: onStart, onUpdate: onUpdate, onComplete: onComplete, type: FlxTween.ONESHOT });
	 * ```
	 * 
	 * @param	Sprite		Optional Sprite whose angle should be tweened.
	 * @param	FromAngle	Start angle.
	 * @param	ToAngle		End angle.
	 * @param	Duration	Duration of the tween.
	 * @param	Options		A structure with tween options.
	 * @return	The added AngleTween object.
	 * @since   4.2.0</haxe_doc>
		</angle>
		<color public="1" set="method" line="788">
			<f a="?Sprite:?Duration:FromColor:ToColor:?Options" v=":1:::">
				<c path="flixel.FlxSprite"/>
				<x path="Float"/>
				<x path="flixel.util.FlxColor"/>
				<x path="flixel.util.FlxColor"/>
				<t path="flixel.tweens.TweenOptions"/>
				<c path="flixel.tweens.misc.ColorTween"/>
			</f>
			<meta><m n=":value"><e>{ Duration : 1 }</e></m></meta>
			<haxe_doc>* Tweens numeric value which represents color. Shorthand for creating a ColorTween object, starting it and adding it to a TweenPlugin.
	 * 
	 * ```haxe
	 * FlxTween.color(Sprite, 2.0, 0x000000, 0xffffff, 0.0, 1.0, { ease: easeFunction, onStart: onStart, onUpdate: onUpdate, onComplete: onComplete, type: FlxTween.ONESHOT });
	 * ```
	 * 
	 * @param	Sprite		Optional Sprite whose color should be tweened.
	 * @param	Duration	Duration of the tween in seconds.
	 * @param	FromColor	Start color.
	 * @param	ToColor		End color.
	 * @param	Options		A structure with tween options.
	 * @return	The added ColorTween object.
	 * @since   4.2.0</haxe_doc>
		</color>
		<linearMotion public="1" set="method" line="813">
			<f a="Object:FromX:FromY:ToX:ToY:?DurationOrSpeed:?UseDuration:?Options" v=":::::1:true:">
				<c path="flixel.FlxObject"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Bool"/>
				<t path="flixel.tweens.TweenOptions"/>
				<c path="flixel.tweens.motion.LinearMotion"/>
			</f>
			<meta><m n=":value"><e>{ UseDuration : true, DurationOrSpeed : 1 }</e></m></meta>
			<haxe_doc>* Create a new LinearMotion tween.
	 * 
	 * ```haxe
	 * FlxTween.linearMotion(Object, 0, 0, 500, 20, 5, false, { ease: easeFunction, onStart: onStart, onUpdate: onUpdate, onComplete: onComplete, type: FlxTween.ONESHOT });
	 * ```
	 * 
	 * @param	Object			The object to move (FlxObject or FlxSpriteGroup)
	 * @param	FromX			X start.
	 * @param	FromY			Y start.
	 * @param	ToX				X finish.
	 * @param	ToY				Y finish.
	 * @param	DurationOrSpeed	Duration (in seconds) or speed of the movement.
	 * @param	UseDuration		Whether to use the previous param as duration or speed.
	 * @param	Options			A structure with tween options.
	 * @return The LinearMotion object.
	 * @since  4.2.0</haxe_doc>
		</linearMotion>
		<quadMotion public="1" set="method" line="841">
			<f a="Object:FromX:FromY:ControlX:ControlY:ToX:ToY:?DurationOrSpeed:?UseDuration:?Options" v=":::::::1:true:">
				<c path="flixel.FlxObject"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Bool"/>
				<t path="flixel.tweens.TweenOptions"/>
				<c path="flixel.tweens.motion.QuadMotion"/>
			</f>
			<meta><m n=":value"><e>{ UseDuration : true, DurationOrSpeed : 1 }</e></m></meta>
			<haxe_doc>* Create a new QuadMotion tween.
	 * 
	 * ```haxe
	 * FlxTween.quadMotion(Object, 0, 100, 300, 500, 100, 2, 5, false, { ease: easeFunction, onStart: onStart, onUpdate: onUpdate, onComplete: onComplete, type: FlxTween.ONESHOT });
	 * ```
	 * 
	 * @param	Object			The object to move (FlxObject or FlxSpriteGroup)
	 * @param	FromX			X start.
	 * @param	FromY			Y start.
	 * @param	ControlX		X control, used to determine the curve.
	 * @param	ControlY		Y control, used to determine the curve.
	 * @param	ToX				X finish.
	 * @param	ToY				Y finish.
	 * @param	DurationOrSpeed	Duration (in seconds) or speed of the movement.
	 * @param	UseDuration		Whether to use the previous param as duration or speed.
	 * @param	Options			A structure with tween options.
	 * @return The QuadMotion object.
	 * @since  4.2.0</haxe_doc>
		</quadMotion>
		<cubicMotion public="1" set="method" line="870">
			<f a="Object:FromX:FromY:aX:aY:bX:bY:ToX:ToY:?Duration:?Options" v=":::::::::1:">
				<c path="flixel.FlxObject"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<t path="flixel.tweens.TweenOptions"/>
				<c path="flixel.tweens.motion.CubicMotion"/>
			</f>
			<meta><m n=":value"><e>{ Duration : 1 }</e></m></meta>
			<haxe_doc>* Create a new CubicMotion tween.
	 * 
	 * ```haxe
	 * FlxTween.cubicMotion(_sprite, 0, 0, 500, 100, 400, 200, 100, 100, 2, { ease: easeFunction, onStart: onStart, onUpdate: onUpdate, onComplete: onComplete, type: FlxTween.ONESHOT });
	 * ```
	 * 
	 * @param	Object 		The object to move (FlxObject or FlxSpriteGroup)
	 * @param	FromX		X start.
	 * @param	FromY		Y start.
	 * @param	aX			First control x.
	 * @param	aY			First control y.
	 * @param	bX			Second control x.
	 * @param	bY			Second control y.
	 * @param	ToX			X finish.
	 * @param	ToY			Y finish.
	 * @param	Duration	Duration of the movement in seconds.
	 * @param	Options		A structure with tween options.
	 * @return The CubicMotion object.
	 * @since  4.2.0</haxe_doc>
		</cubicMotion>
		<circularMotion public="1" set="method" line="898">
			<f a="Object:CenterX:CenterY:Radius:Angle:Clockwise:?DurationOrSpeed:?UseDuration:?Options" v="::::::1:true:">
				<c path="flixel.FlxObject"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Float"/>
				<x path="Bool"/>
				<t path="flixel.tweens.TweenOptions"/>
				<c path="flixel.tweens.motion.CircularMotion"/>
			</f>
			<meta><m n=":value"><e>{ UseDuration : true, DurationOrSpeed : 1 }</e></m></meta>
			<haxe_doc>* Create a new CircularMotion tween.
	 * 
	 * ```haxe
	 * FlxTween.circularMotion(Object, 250, 250, 50, 0, true, 2, true, { ease: easeFunction, onStart: onStart, onUpdate: onUpdate, onComplete: onComplete, type: FlxTween.ONESHOT });
	 * ```
	 * 
	 * @param	Object			The object to move (FlxObject or FlxSpriteGroup)
	 * @param	CenterX			X position of the circle's center.
	 * @param	CenterY			Y position of the circle's center.
	 * @param	Radius			Radius of the circle.
	 * @param	Angle			Starting position on the circle.
	 * @param	Clockwise		If the motion is clockwise.
	 * @param	DurationOrSpeed	Duration of the movement in seconds.
	 * @param	UseDuration		Duration of the movement.
	 * @param	Ease			Optional easer function.
	 * @param	Options			A structure with tween options.
	 * @return The CircularMotion object.
	 * @since  4.2.0</haxe_doc>
		</circularMotion>
		<linearPath public="1" set="method" line="921">
			<f a="Object:Points:?DurationOrSpeed:?UseDuration:?Options" v="::1:true:">
				<c path="flixel.FlxObject"/>
				<c path="Array"><c path="flixel.math.FlxPoint"/></c>
				<x path="Float"/>
				<x path="Bool"/>
				<t path="flixel.tweens.TweenOptions"/>
				<c path="flixel.tweens.motion.LinearPath"/>
			</f>
			<meta><m n=":value"><e>{ UseDuration : true, DurationOrSpeed : 1 }</e></m></meta>
			<haxe_doc>* Create a new LinearPath tween.
	 * 
	 * ```haxe
	 * FlxTween.linearPath(Object, [FlxPoint.get(0, 0), FlxPoint.get(100, 100)], 2, true, { ease: easeFunction, onStart: onStart, onUpdate: onUpdate, onComplete: onComplete, type: FlxTween.ONESHOT });
	 * ```
	 * 
	 * @param	Object 			The object to move (FlxObject or FlxSpriteGroup)
	 * @param	Points			An array of at least 2 FlxPoints defining the path
	 * @param	DurationOrSpeed	Duration (in seconds) or speed of the movement.
	 * @param	UseDuration		Whether to use the previous param as duration or speed.
	 * @param	Options			A structure with tween options.
	 * @return	The LinearPath object.
	 * @since   4.2.0</haxe_doc>
		</linearPath>
		<quadPath public="1" set="method" line="953">
			<f a="Object:Points:?DurationOrSpeed:?UseDuration:?Options" v="::1:true:">
				<c path="flixel.FlxObject"/>
				<c path="Array"><c path="flixel.math.FlxPoint"/></c>
				<x path="Float"/>
				<x path="Bool"/>
				<t path="flixel.tweens.TweenOptions"/>
				<c path="flixel.tweens.motion.QuadPath"/>
			</f>
			<meta><m n=":value"><e>{ UseDuration : true, DurationOrSpeed : 1 }</e></m></meta>
			<haxe_doc>* Create a new QuadPath tween.
	 * 
	 * ```haxe
	 * FlxTween.quadPath(Object, [FlxPoint.get(0, 0), FlxPoint.get(200, 200), FlxPoint.get(400, 0)], 2, true, { ease: easeFunction, onStart: onStart, onUpdate: onUpdate, onComplete: onComplete, type: FlxTween.ONESHOT });
	 * ```
	 * 
	 * @param	Object			The object to move (FlxObject or FlxSpriteGroup)
	 * @param	Points			An array of at least 3 FlxPoints defining the path
	 * @param	DurationOrSpeed	Duration (in seconds) or speed of the movement.
	 * @param	UseDuration		Whether to use the previous param as duration or speed.
	 * @param	Options			A structure with tween options.
	 * @return	The QuadPath object.
	 * @since   4.2.0</haxe_doc>
		</quadPath>
		<destroy public="1" set="method" line="970" override="1"><f a=""><x path="Void"/></f></destroy>
		<update public="1" set="method" line="976" override="1"><f a="elapsed">
	<x path="Float"/>
	<x path="Void"/>
</f></update>
		<add params="T" set="method" line="1013">
			<f a="Tween:?Start" v=":false">
				<c path="add.T"/>
				<x path="Bool"/>
				<c path="add.T"/>
			</f>
			<meta>
				<m n=":value"><e>{ Start : false }</e></m>
				<m n=":generic"/>
				<m n=":allow"><e>flixel.tweens.FlxTween</e></m>
			</meta>
			<haxe_doc>* Add a FlxTween.
	 * 
	 * @param	Tween	The FlxTween to add.
	 * @param	Start	Whether you want it to start right away.
	 * @return	The added FlxTween object.</haxe_doc>
		</add>
		<remove set="method" line="1034">
			<f a="Tween:?Destroy" v=":true">
				<c path="flixel.tweens.FlxTween"/>
				<x path="Bool"/>
				<c path="flixel.tweens.FlxTween"/>
			</f>
			<meta>
				<m n=":value"><e>{ Destroy : true }</e></m>
				<m n=":allow"><e>flixel.tweens.FlxTween</e></m>
			</meta>
			<haxe_doc>* Remove a FlxTween.
	 * 
	 * @param	Tween		The FlxTween to remove.
	 * @param	Destroy		Whether you want to destroy the FlxTween
	 * @return	The removed FlxTween object.</haxe_doc>
		</remove>
		<clear public="1" set="method" line="1052">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Removes all FlxTweens.</haxe_doc>
		</clear>
		<completeAll public="1" set="method" line="1079">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Immediately updates all tweens that are not looping (type `FlxTween.LOOPING` or `FlxTween.PINGPONG`)
	 * and `active` through their endings, triggering their `onComplete` callbacks.
	 * 
	 * Note: if they haven't yet begun, this will first trigger their `onStart` callback.
	 * 
	 * Note: their `onComplete` callbacks are triggered in the next frame. 
	 * To trigger them immediately, call `FlxTween.manager.update(0);` after this function.
	 * 
	 * In no case should it trigger an `onUpdate` callback.
	 * 
	 * @since 4.2.0</haxe_doc>
		</completeAll>
		<forEach public="1" set="method" line="1092">
			<f a="Function">
				<f a="">
					<c path="flixel.tweens.FlxTween"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<haxe_doc>* Applies a function to all tweens
	 * 
	 * @param   Function   A function that modifies one tween at a time
	 * @since   4.2.0</haxe_doc>
		</forEach>
		<new public="1" set="method" line="695"><f a=""><x path="Void"/></f></new>
		<haxe_doc>* A simple manager for tracking and updating game tween objects.
 * Normally accessed via the static `FlxTween.manager` rather than being created separately.</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":access"><e>flixel.tweens.FlxTween</e></m>
		</meta>
	</class>
	<class path="flixel.tweens.misc.AngleTween" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/tweens/misc/AngleTween.hx">
		<extends path="flixel.tweens.FlxTween"/>
		<angle public="1" set="null"><x path="Float"/></angle>
		<sprite public="1" set="null">
			<c path="flixel.FlxSprite"/>
			<haxe_doc>* Optional sprite object whose angle to tween</haxe_doc>
		</sprite>
		<_start><x path="Float"/></_start>
		<_range><x path="Float"/></_range>
		<destroy public="1" set="method" line="24" override="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Clean up references</haxe_doc>
		</destroy>
		<tween public="1" set="method" line="37">
			<f a="FromAngle:ToAngle:Duration:?Sprite">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<c path="flixel.FlxSprite"/>
				<c path="flixel.tweens.misc.AngleTween"/>
			</f>
			<haxe_doc>* Tweens the value from one angle to another.
	 * 
	 * @param	FromAngle		Start angle.
	 * @param	ToAngle			End angle.
	 * @param	Duration		Duration of the tween.</haxe_doc>
		</tween>
		<update set="method" line="51" override="1"><f a="elapsed">
	<x path="Float"/>
	<x path="Void"/>
</f></update>
		<new set="method" line="9"><f a="Options:?manager">
	<t path="flixel.tweens.TweenOptions"/>
	<c path="flixel.tweens.FlxTweenManager"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>* Tweens from one angle to another.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="flixel.tweens.misc.ColorTween" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/tweens/misc/ColorTween.hx">
		<extends path="flixel.tweens.FlxTween"/>
		<color public="1" set="null"><x path="flixel.util.FlxColor"/></color>
		<startColor><x path="flixel.util.FlxColor"/></startColor>
		<endColor><x path="flixel.util.FlxColor"/></endColor>
		<sprite public="1" set="null">
			<c path="flixel.FlxSprite"/>
			<haxe_doc>* Optional sprite object whose color to tween</haxe_doc>
		</sprite>
		<destroy public="1" set="method" line="25" override="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Clean up references</haxe_doc>
		</destroy>
		<tween public="1" set="method" line="40">
			<f a="Duration:FromColor:ToColor:?Sprite">
				<x path="Float"/>
				<x path="flixel.util.FlxColor"/>
				<x path="flixel.util.FlxColor"/>
				<c path="flixel.FlxSprite"/>
				<c path="flixel.tweens.misc.ColorTween"/>
			</f>
			<haxe_doc>* Tweens the color to a new color and an alpha to a new alpha.
	 * 
	 * @param	Duration		Duration of the tween.
	 * @param	FromColor		Start color.
	 * @param	ToColor			End color.
	 * @param	Sprite			Optional sprite object whose color to tween.
	 * @return	The ColorTween.</haxe_doc>
		</tween>
		<update set="method" line="50" override="1"><f a="elapsed">
	<x path="Float"/>
	<x path="Void"/>
</f></update>
		<new set="method" line="11"><f a="Options:?manager">
	<t path="flixel.tweens.TweenOptions"/>
	<c path="flixel.tweens.FlxTweenManager"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>* Tweens a color's red, green, and blue properties
 * independently. Can also tween an alpha value.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="flixel.tweens.misc.NumTween" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/tweens/misc/NumTween.hx">
		<extends path="flixel.tweens.FlxTween"/>
		<value public="1" set="null">
			<x path="Float"/>
			<haxe_doc>* The current value.</haxe_doc>
		</value>
		<_tweenFunction><f a="">
	<x path="Float"/>
	<x path="Void"/>
</f></_tweenFunction>
		<_start><x path="Float"/></_start>
		<_range><x path="Float"/></_range>
		<destroy public="1" set="method" line="23" override="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Clean up references</haxe_doc>
		</destroy>
		<tween public="1" set="method" line="37">
			<f a="fromValue:toValue:duration:?tweenFunction">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<f a="">
					<x path="Float"/>
					<x path="Void"/>
				</f>
				<c path="flixel.tweens.misc.NumTween"/>
			</f>
			<haxe_doc>* Tweens the value from one value to another.
	 * 
	 * @param	fromValue		Start value.
	 * @param	toValue			End value.
	 * @param	duration		Duration of the tween.
	 * @param	tweenFunction	Optional tween function. See FlxTween.num()</haxe_doc>
		</tween>
		<update set="method" line="47" override="1"><f a="elapsed">
	<x path="Float"/>
	<x path="Void"/>
</f></update>
		<new set="method" line="8"><f a="Options:?manager">
	<t path="flixel.tweens.TweenOptions"/>
	<c path="flixel.tweens.FlxTweenManager"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>* Tweens a numeric value. See FlxTween.num()</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="flixel.tweens.misc.VarTween" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/tweens/misc/VarTween.hx">
		<extends path="flixel.tweens.FlxTween"/>
		<_object><d/></_object>
		<_properties><d/></_properties>
		<_propertyInfos expr="[]">
			<c path="Array"><t path="flixel.tweens.misc.VarTweenProperty"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</_propertyInfos>
		<destroy public="1" set="method" line="17" override="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Clean up references</haxe_doc>
		</destroy>
		<tween public="1" set="method" line="36">
			<f a="object:properties:duration">
				<d/>
				<d/>
				<x path="Float"/>
				<c path="flixel.tweens.misc.VarTween"/>
			</f>
			<haxe_doc>* Tweens multiple numeric public properties.
	 * 
	 * @param	object		The object containing the properties.
	 * @param	properties	An object containing key/value pairs of properties and target values.
	 * @param	duration	Duration of the tween.</haxe_doc>
		</tween>
		<update set="method" line="56" override="1"><f a="elapsed">
	<x path="Float"/>
	<x path="Void"/>
</f></update>
		<initializeVars set="method" line="83"><f a=""><x path="Void"/></f></initializeVars>
		<new set="method" line="24"><f a="Options:?manager">
	<t path="flixel.tweens.TweenOptions"/>
	<c path="flixel.tweens.FlxTweenManager"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>* Tweens multiple numeric public properties of an Object simultaneously.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<typedef path="flixel.tweens.misc.VarTweenProperty" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/tweens/misc/VarTween.hx" module="flixel.tweens.misc.VarTween"><a>
	<startValue><x path="Float"/></startValue>
	<range><x path="Float"/></range>
	<name><c path="String"/></name>
</a></typedef>
	<class path="flixel.tweens.motion.Motion" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/tweens/motion/Motion.hx">
		<extends path="flixel.tweens.FlxTween"/>
		<x public="1" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* Current x position of the Tween.</haxe_doc>
		</x>
		<y public="1" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* Current y position of the Tween.</haxe_doc>
		</y>
		<_object><c path="flixel.FlxObject"/></_object>
		<_wasObjectImmovable><x path="Bool"/></_wasObjectImmovable>
		<destroy public="1" set="method" line="23" override="1"><f a=""><x path="Void"/></f></destroy>
		<setObject public="1" set="method" line="29"><f a="object">
	<c path="flixel.FlxObject"/>
	<c path="flixel.tweens.motion.Motion"/>
</f></setObject>
		<update set="method" line="37" override="1"><f a="elapsed">
	<x path="Float"/>
	<x path="Void"/>
</f></update>
		<onEnd set="method" line="43" override="1"><f a=""><x path="Void"/></f></onEnd>
		<postUpdate set="method" line="49"><f a=""><x path="Void"/></f></postUpdate>
		<new set="method" line="9"><f a="Options:?manager">
	<t path="flixel.tweens.TweenOptions"/>
	<c path="flixel.tweens.FlxTweenManager"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>* Base class for motion Tweens.</haxe_doc>
	</class>
	<class path="flixel.tweens.motion.CircularMotion" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/tweens/motion/CircularMotion.hx">
		<extends path="flixel.tweens.motion.Motion"/>
		<angle public="1" set="null" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* The current position on the circle.</haxe_doc>
		</angle>
		<circumference public="1" get="accessor" set="null">
			<x path="Float"/>
			<haxe_doc>* The circumference of the current circle motion.</haxe_doc>
		</circumference>
		<_centerX expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</_centerX>
		<_centerY expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</_centerY>
		<_radius expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</_radius>
		<_angleStart expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</_angleStart>
		<_angleFinish expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</_angleFinish>
		<setMotion public="1" set="method" line="36">
			<f a="CenterX:CenterY:Radius:Angle:Clockwise:DurationOrSpeed:?UseDuration" v="::::::true">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Float"/>
				<x path="Bool"/>
				<c path="flixel.tweens.motion.CircularMotion"/>
			</f>
			<meta><m n=":value"><e>{ UseDuration : true }</e></m></meta>
			<haxe_doc>* Starts moving along a circle.
	 * 
	 * @param	CenterX			X position of the circle's center.
	 * @param	CenterY			Y position of the circle's center.
	 * @param	Radius			Radius of the circle.
	 * @param	Angle			Starting position on the circle.
	 * @param	Clockwise		If the motion is clockwise.
	 * @param	DurationOrSpeed	Duration of the movement.
	 * @param	UseDuration		Duration of the movement.</haxe_doc>
		</setMotion>
		<update set="method" line="57" override="1"><f a="elapsed">
	<x path="Float"/>
	<x path="Void"/>
</f></update>
		<get_circumference set="method" line="69"><f a=""><x path="Float"/></f></get_circumference>
		<new set="method" line="6"><f a="Options:?manager">
	<t path="flixel.tweens.TweenOptions"/>
	<c path="flixel.tweens.FlxTweenManager"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>* Determines a circular motion.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="flixel.tweens.motion.CubicMotion" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/tweens/motion/CubicMotion.hx">
		<extends path="flixel.tweens.motion.Motion"/>
		<_fromX expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</_fromX>
		<_fromY expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</_fromY>
		<_toX expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</_toX>
		<_toY expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</_toY>
		<_aX expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</_aX>
		<_aY expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</_aY>
		<_bX expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</_bX>
		<_bY expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</_bY>
		<_ttt expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</_ttt>
		<_tt expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</_tt>
		<setMotion public="1" set="method" line="33">
			<f a="fromX:fromY:aX:aY:bX:bY:toX:toY:duration">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<c path="flixel.tweens.motion.CubicMotion"/>
			</f>
			<haxe_doc>* Starts moving along the curve.
	 * 
	 * @param	fromX		X start.
	 * @param	fromY		Y start.
	 * @param	aX			First control x.
	 * @param	aY			First control y.
	 * @param	bX			Second control x.
	 * @param	bY			Second control y.
	 * @param	toX			X finish.
	 * @param	toY			Y finish.
	 * @param	duration	Duration of the movement.</haxe_doc>
		</setMotion>
		<update set="method" line="48" override="1"><f a="elapsed">
	<x path="Float"/>
	<x path="Void"/>
</f></update>
		<new set="method" line="6"><f a="Options:?manager">
	<t path="flixel.tweens.TweenOptions"/>
	<c path="flixel.tweens.FlxTweenManager"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>* Determines motion along a cubic curve.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="flixel.tweens.motion.LinearMotion" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/tweens/motion/LinearMotion.hx">
		<extends path="flixel.tweens.motion.Motion"/>
		<distance public="1" get="accessor" set="null">
			<x path="Float"/>
			<haxe_doc>* Length of the current line of movement.</haxe_doc>
		</distance>
		<_fromX expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</_fromX>
		<_fromY expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</_fromY>
		<_moveX expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</_moveX>
		<_moveY expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</_moveY>
		<_distance expr="-1">
			<x path="Float"/>
			<meta><m n=":value"><e>-1</e></m></meta>
		</_distance>
		<setMotion public="1" set="method" line="30">
			<f a="FromX:FromY:ToX:ToY:DurationOrSpeed:?UseDuration" v=":::::true">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Bool"/>
				<c path="flixel.tweens.motion.LinearMotion"/>
			</f>
			<meta><m n=":value"><e>{ UseDuration : true }</e></m></meta>
			<haxe_doc>* Starts moving along a line.
	 * 
	 * @param	FromX			X start.
	 * @param	FromY			Y start.
	 * @param	ToX				X finish.
	 * @param	ToY				Y finish.
	 * @param	DurationOrSpeed	Duration or speed of the movement.
	 * @param	UseDuration		Whether to use the previous param as duration or speed.</haxe_doc>
		</setMotion>
		<update set="method" line="52" override="1"><f a="elapsed">
	<x path="Float"/>
	<x path="Void"/>
</f></update>
		<get_distance set="method" line="69"><f a=""><x path="Float"/></f></get_distance>
		<new set="method" line="6"><f a="Options:?manager">
	<t path="flixel.tweens.TweenOptions"/>
	<c path="flixel.tweens.FlxTweenManager"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>* Determines motion along a line, from one point to another.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="flixel.tweens.motion.LinearPath" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/tweens/motion/LinearPath.hx">
		<extends path="flixel.tweens.motion.Motion"/>
		<distance public="1" set="null" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* The full length of the path.</haxe_doc>
		</distance>
		<points public="1"><c path="Array"><c path="flixel.math.FlxPoint"/></c></points>
		<_pointD><c path="Array"><x path="Float"/></c></_pointD>
		<_pointT><c path="Array"><x path="Float"/></c></_pointT>
		<_speed expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</_speed>
		<_index expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</_index>
		<_last><c path="flixel.math.FlxPoint"/></_last>
		<_prevPoint><c path="flixel.math.FlxPoint"/></_prevPoint>
		<_nextPoint><c path="flixel.math.FlxPoint"/></_nextPoint>
		<destroy public="1" set="method" line="40" override="1"><f a=""><x path="Void"/></f></destroy>
		<setMotion public="1" set="method" line="59">
			<f a="DurationOrSpeed:?UseDuration" v=":true">
				<x path="Float"/>
				<x path="Bool"/>
				<c path="flixel.tweens.motion.LinearPath"/>
			</f>
			<meta><m n=":value"><e>{ UseDuration : true }</e></m></meta>
			<haxe_doc>* Starts moving along the path.
	 * 
	 * @param	DurationOrSpeed		Duration or speed of the movement.
	 * @param	UseDuration			Whether to use the previous param as duration or speed.</haxe_doc>
		</setMotion>
		<addPoint public="1" set="method" line="78">
			<f a="?x:?y" v="0:0">
				<x path="Float"/>
				<x path="Float"/>
				<c path="flixel.tweens.motion.LinearPath"/>
			</f>
			<meta><m n=":value"><e>{ y : 0, x : 0 }</e></m></meta>
		</addPoint>
		<getPoint public="1" set="method" line="89">
			<f a="?index" v="0">
				<x path="Int"/>
				<c path="flixel.math.FlxPoint"/>
			</f>
			<meta><m n=":value"><e>{ index : 0 }</e></m></meta>
		</getPoint>
		<start public="1" set="method" line="98" override="1"><f a=""><c path="flixel.tweens.motion.LinearPath"/></f></start>
		<update set="method" line="105" override="1"><f a="elapsed">
	<x path="Float"/>
	<x path="Void"/>
</f></update>
		<updatePath set="method" line="167">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Updates the path, preparing it for motion.</haxe_doc>
		</updatePath>
		<new set="method" line="31"><f a="Options:?manager">
	<t path="flixel.tweens.TweenOptions"/>
	<c path="flixel.tweens.FlxTweenManager"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>* Determines linear motion along a set of points.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="flixel.tweens.motion.QuadMotion" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/tweens/motion/QuadMotion.hx">
		<extends path="flixel.tweens.motion.Motion"/>
		<distance public="1" get="accessor" set="null">
			<x path="Float"/>
			<haxe_doc>* The distance of the entire curve.</haxe_doc>
		</distance>
		<_distance expr="-1">
			<x path="Float"/>
			<meta><m n=":value"><e>-1</e></m></meta>
		</_distance>
		<_fromX expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</_fromX>
		<_fromY expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</_fromY>
		<_toX expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</_toX>
		<_toY expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</_toY>
		<_controlX expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</_controlX>
		<_controlY expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</_controlY>
		<setMotion public="1" set="method" line="36">
			<f a="FromX:FromY:ControlX:ControlY:ToX:ToY:DurationOrSpeed:?UseDuration" v=":::::::true">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Bool"/>
				<c path="flixel.tweens.motion.QuadMotion"/>
			</f>
			<meta><m n=":value"><e>{ UseDuration : true }</e></m></meta>
			<haxe_doc>* Starts moving along the curve.
	 * 
	 * @param	FromX			X start.
	 * @param	FromY			Y start.
	 * @param	ControlX		X control, used to determine the curve.
	 * @param	ControlY		Y control, used to determine the curve.
	 * @param	ToX				X finish.
	 * @param	ToY				Y finish.
	 * @param	DurationOrSpeed	Duration or speed of the movement.
	 * @param	UseDuration		Duration of the movement.</haxe_doc>
		</setMotion>
		<update set="method" line="60" override="1"><f a="elapsed">
	<x path="Float"/>
	<x path="Void"/>
</f></update>
		<get_distance set="method" line="71"><f a=""><x path="Float"/></f></get_distance>
		<new set="method" line="8"><f a="Options:?manager">
	<t path="flixel.tweens.TweenOptions"/>
	<c path="flixel.tweens.FlxTweenManager"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>* Determines motion along p1 quadratic curve.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="flixel.tweens.motion.QuadPath" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/tweens/motion/QuadPath.hx">
		<extends path="flixel.tweens.motion.Motion"/>
		<_points><c path="Array"><c path="flixel.math.FlxPoint"/></c></_points>
		<_distance expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</_distance>
		<_speed expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</_speed>
		<_index expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</_index>
		<_numSegs expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</_numSegs>
		<_updateCurve expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</_updateCurve>
		<_curveT><c path="Array"><x path="Float"/></c></_curveT>
		<_curveD><c path="Array"><x path="Float"/></c></_curveD>
		<_a><c path="flixel.math.FlxPoint"/></_a>
		<_b><c path="flixel.math.FlxPoint"/></_b>
		<_c><c path="flixel.math.FlxPoint"/></_c>
		<destroy public="1" set="method" line="40" override="1"><f a=""><x path="Void"/></f></destroy>
		<setMotion public="1" set="method" line="59">
			<f a="DurationOrSpeed:?UseDuration" v=":true">
				<x path="Float"/>
				<x path="Bool"/>
				<c path="flixel.tweens.motion.QuadPath"/>
			</f>
			<meta><m n=":value"><e>{ UseDuration : true }</e></m></meta>
			<haxe_doc>* Starts moving along the path.
	 * 
	 * @param	DurationOrSpeed		Duration or speed of the movement.
	 * @param	UseDuration			Whether to use the previous param as duration or speed.</haxe_doc>
		</setMotion>
		<addPoint public="1" set="method" line="81">
			<f a="?x:?y" v="0:0">
				<x path="Float"/>
				<x path="Float"/>
				<c path="flixel.tweens.motion.QuadPath"/>
			</f>
			<meta><m n=":value"><e>{ y : 0, x : 0 }</e></m></meta>
			<haxe_doc>* Adds the point to the path.</haxe_doc>
		</addPoint>
		<getPoint public="1" set="method" line="91">
			<f a="?index" v="0">
				<x path="Int"/>
				<c path="flixel.math.FlxPoint"/>
			</f>
			<meta><m n=":value"><e>{ index : 0 }</e></m></meta>
			<haxe_doc>* Gets the point on the path.</haxe_doc>
		</getPoint>
		<start public="1" set="method" line="100" override="1"><f a=""><c path="flixel.tweens.motion.QuadPath"/></f></start>
		<update set="method" line="107" override="1"><f a="elapsed">
	<x path="Float"/>
	<x path="Void"/>
</f></update>
		<updatePath set="method" line="164"><f a=""><x path="Void"/></f></updatePath>
		<getCurveLength set="method" line="200"><f a="start:control:finish">
	<c path="flixel.math.FlxPoint"/>
	<c path="flixel.math.FlxPoint"/>
	<c path="flixel.math.FlxPoint"/>
	<x path="Float"/>
</f></getCurveLength>
		<new set="method" line="31"><f a="Options:?manager">
	<t path="flixel.tweens.TweenOptions"/>
	<c path="flixel.tweens.FlxTweenManager"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>* A series of points which will determine a path from the
 * beginning point to the end point using quadratic curves.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="flixel.ui.FlxBar" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/ui/FlxBar.hx">
		<extends path="flixel.FlxSprite"/>
		<fixedPosition public="1" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
			<haxe_doc>* If false, the bar is tracking its parent
	 * (the position is synchronized with the parent's position).</haxe_doc>
		</fixedPosition>
		<pxPerPercent public="1" set="null">
			<x path="Float"/>
			<haxe_doc>* How many pixels = 1% of the bar (barWidth (or barHeight) / 100)</haxe_doc>
		</pxPerPercent>
		<positionOffset public="1" set="null">
			<c path="flixel.math.FlxPoint"/>
			<haxe_doc>* The positionOffset controls how far offset the FlxBar is from the parent sprite (if at all)</haxe_doc>
		</positionOffset>
		<killOnEmpty public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
			<haxe_doc>* If this FlxBar should be killed when its empty</haxe_doc>
		</killOnEmpty>
		<percent public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<haxe_doc>* The percentage of how full the bar is (a value between 0 and 100)</haxe_doc>
		</percent>
		<value public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<meta><m n=":isVar"/></meta>
			<haxe_doc>* The current value - must always be between min and max</haxe_doc>
		</value>
		<min public="1" set="null">
			<x path="Float"/>
			<haxe_doc><![CDATA[* The minimum value the bar can be (can never be >= max)]]></haxe_doc>
		</min>
		<max public="1" set="null">
			<x path="Float"/>
			<haxe_doc><![CDATA[* The maximum value the bar can be (can never be <= min)]]></haxe_doc>
		</max>
		<range public="1" set="null">
			<x path="Float"/>
			<haxe_doc>* How wide is the range of this bar? (max - min)</haxe_doc>
		</range>
		<pct public="1" set="null">
			<x path="Float"/>
			<haxe_doc>* What 1% of the bar is equal to in terms of value (range / 100)</haxe_doc>
		</pct>
		<numDivisions public="1" set="accessor" expr="100">
			<x path="Int"/>
			<meta><m n=":value"><e>100</e></m></meta>
			<haxe_doc>* Number of frames FlxBar will have. Default value is 100.
	 * The bigger value you set then visual will change smoother.
	 * @since 4.1.0</haxe_doc>
		</numDivisions>
		<emptyCallback public="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* This function will be called when value will hit it's minimum</haxe_doc>
		</emptyCallback>
		<filledCallback public="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* This function will be called when value will hit it's maximum</haxe_doc>
		</filledCallback>
		<parent public="1">
			<d/>
			<haxe_doc>* Object to track value from/</haxe_doc>
		</parent>
		<parentVariable public="1">
			<c path="String"/>
			<haxe_doc>* Property of parent object to track.</haxe_doc>
		</parentVariable>
		<barWidth public="1" set="null"><x path="Int"/></barWidth>
		<barHeight public="1" set="null"><x path="Int"/></barHeight>
		<frontFrames public="1" get="accessor" set="accessor">
			<c path="flixel.graphics.frames.FlxImageFrame"/>
			<meta><m n=":isVar"/></meta>
			<haxe_doc>* BarFrames which will be used for filled bar rendering.
	 * It is recommended to use this property in tile render mode
	 * (although it will work in blit render mode also).</haxe_doc>
		</frontFrames>
		<backFrames public="1" get="accessor" set="accessor"><c path="flixel.graphics.frames.FlxImageFrame"/></backFrames>
		<fillDirection public="1" set="accessor">
			<e path="flixel.ui.FlxBarFillDirection"/>
			<haxe_doc>* The direction from which the health bar will fill-up. Default is from left to right. Change takes effect immediately.</haxe_doc>
		</fillDirection>
		<_fillHorizontal><x path="Bool"/></_fillHorizontal>
		<_frontFrame>
			<c path="flixel.graphics.frames.FlxFrame"/>
			<haxe_doc>* FlxSprite which is used for rendering front graphics of bar (showing value) in tile render mode.</haxe_doc>
		</_frontFrame>
		<_filledFlxRect><c path="flixel.math.FlxRect"/></_filledFlxRect>
		<_emptyBar><t path="flash.display.BitmapData"/></_emptyBar>
		<_emptyBarRect><t path="flash.geom.Rectangle"/></_emptyBarRect>
		<_filledBar><t path="flash.display.BitmapData"/></_filledBar>
		<_zeroOffset><t path="flash.geom.Point"/></_zeroOffset>
		<_filledBarRect><t path="flash.geom.Rectangle"/></_filledBarRect>
		<_filledBarPoint><t path="flash.geom.Point"/></_filledBarPoint>
		<_maxPercent expr="100">
			<x path="Int"/>
			<meta><m n=":value"><e>100</e></m></meta>
		</_maxPercent>
		<destroy public="1" set="method" line="180" override="1"><f a=""><x path="Void"/></f></destroy>
		<trackParent public="1" set="method" line="216">
			<f a="offsetX:offsetY">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Track the parent FlxSprites x/y coordinates. For example if you wanted your sprite to have a floating health-bar above their head.
	 * If your health bar is 10px tall and you wanted it to appear above your sprite, then set offsetY to be -10
	 * If you wanted it to appear below your sprite, and your sprite was 32px tall, then set offsetY to be 32. Same applies to offsetX.
	 * 
	 * @param	offsetX		The offset on X in relation to the origin x/y of the parent
	 * @param	offsetY		The offset on Y in relation to the origin x/y of the parent
	 * @see		stopTrackingParent</haxe_doc>
		</trackParent>
		<setParent public="1" set="method" line="237">
			<f a="parentRef:variable:?track:?offsetX:?offsetY" v="::false:0:0">
				<d/>
				<c path="String"/>
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ offsetY : 0, offsetX : 0, track : false }</e></m></meta>
			<haxe_doc>* Sets a parent for this FlxBar. Instantly replaces any previously set parent and refreshes the bar.
	 * 
	 * @param	parentRef	A reference to an object in your game that you wish the bar to track
	 * @param	variable	The variable of the object that is used to determine the bar position. For example if the parent was an FlxSprite this could be "health" to track the health value
	 * @param	track		If you wish the FlxBar to track the x/y coordinates of parent set to true (default false)
	 * @param	offsetX		The offset on X in relation to the origin x/y of the parent
	 * @param	offsetY		The offset on Y in relation to the origin x/y of the parent</haxe_doc>
		</setParent>
		<stopTrackingParent public="1" set="method" line="256">
			<f a="posX:posY">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Tells the health bar to stop following the parent sprite. The given posX and posY values are where it will remain on-screen.
	 * 
	 * @param	posX	X coordinate of the health bar now it's no longer tracking the parent sprite
	 * @param	posY	Y coordinate of the health bar now it's no longer tracking the parent sprite</haxe_doc>
		</stopTrackingParent>
		<setCallbacks public="1" set="method" line="272">
			<f a="onEmpty:onFilled:?killOnEmpty" v="::false">
				<f a=""><x path="Void"/></f>
				<f a=""><x path="Void"/></f>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ killOnEmpty : false }</e></m></meta>
			<haxe_doc>* Sets callbacks which will be triggered when the value of this FlxBar reaches min or max.
	 * Functions will only be called once and not again until the value changes.
	 * Optionally the FlxBar can be killed if it reaches min, but if will fire the empty callback first (if set)
	 * 
	 * @param	onEmpty			The function that is called if the value of this FlxBar reaches min
	 * @param	onFilled		The function that is called if the value of this FlxBar reaches max
	 * @param	killOnEmpty		If set it will call FlxBar.kill() if the value reaches min</haxe_doc>
		</setCallbacks>
		<setRange public="1" set="method" line="285">
			<f a="min:max">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Set the minimum and maximum allowed values for the FlxBar
	 * 
	 * @param	min			The minimum value. I.e. for a progress bar this would be zero (nothing loaded yet)
	 * @param	max			The maximum value the bar can reach. I.e. for a progress bar this would typically be 100.</haxe_doc>
		</setRange>
		<createFilledBar public="1" set="method" line="320">
			<f a="empty:fill:?showBorder:?border" v="::false:FlxColor.WHITE">
				<x path="flixel.util.FlxColor"/>
				<x path="flixel.util.FlxColor"/>
				<x path="Bool"/>
				<x path="flixel.util.FlxColor"/>
				<c path="flixel.ui.FlxBar"/>
			</f>
			<meta><m n=":value"><e>{ border : FlxColor.WHITE, showBorder : false }</e></m></meta>
			<haxe_doc>* Creates a solid-colour filled health bar in the given colours, with optional 1px thick border.
	 * All colour values are in 0xAARRGGBB format, so if you want a slightly transparent health bar give it lower AA values.
	 * 
	 * @param	empty		The color of the bar when empty in 0xAARRGGBB format (the background colour)
	 * @param	fill		The color of the bar when full in 0xAARRGGBB format (the foreground colour)
	 * @param	showBorder	Should the bar be outlined with a 1px solid border?
	 * @param	border		The border colour in 0xAARRGGBB format
	 * @return	This FlxBar object with generated images for front and background.</haxe_doc>
		</createFilledBar>
		<createColoredEmptyBar public="1" set="method" line="335">
			<f a="empty:?showBorder:?border" v=":false:FlxColor.WHITE">
				<x path="flixel.util.FlxColor"/>
				<x path="Bool"/>
				<x path="flixel.util.FlxColor"/>
				<c path="flixel.ui.FlxBar"/>
			</f>
			<meta><m n=":value"><e>{ border : FlxColor.WHITE, showBorder : false }</e></m></meta>
			<haxe_doc>* Creates a solid-colour filled background for health bar in the given colour, with optional 1px thick border.
	 * 
	 * @param	empty			The color of the bar when empty in 0xAARRGGBB format (the background colour)
	 * @param	showBorder		Should the bar be outlined with a 1px solid border?
	 * @param	border			The border colour in 0xAARRGGBB format
	 * @return	This FlxBar object with generated image for rendering health bar background.</haxe_doc>
		</createColoredEmptyBar>
		<createColoredFilledBar public="1" set="method" line="388">
			<f a="fill:?showBorder:?border" v=":false:FlxColor.WHITE">
				<x path="flixel.util.FlxColor"/>
				<x path="Bool"/>
				<x path="flixel.util.FlxColor"/>
				<c path="flixel.ui.FlxBar"/>
			</f>
			<meta><m n=":value"><e>{ border : FlxColor.WHITE, showBorder : false }</e></m></meta>
			<haxe_doc>* Creates a solid-colour filled foreground for health bar in the given colour, with optional 1px thick border.
	 * @param	fill		The color of the bar when full in 0xAARRGGBB format (the foreground colour)
	 * @param	showBorder	Should the bar be outlined with a 1px solid border?
	 * @param	border		The border colour in 0xAARRGGBB format
	 * @return	This FlxBar object with generated image for rendering actual values.</haxe_doc>
		</createColoredFilledBar>
		<createGradientBar public="1" set="method" line="445">
			<f a="empty:fill:?chunkSize:?rotation:?showBorder:?border" v="::1:180:false:FlxColor.WHITE">
				<c path="Array"><x path="flixel.util.FlxColor"/></c>
				<c path="Array"><x path="flixel.util.FlxColor"/></c>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="flixel.util.FlxColor"/>
				<c path="flixel.ui.FlxBar"/>
			</f>
			<meta><m n=":value"><e>{ border : FlxColor.WHITE, showBorder : false, rotation : 180, chunkSize : 1 }</e></m></meta>
			<haxe_doc>* Creates a gradient filled health bar using the given colour ranges, with optional 1px thick border.
	 * All colour values are in 0xAARRGGBB format, so if you want a slightly transparent health bar give it lower AA values.
	 * 
	 * @param	empty		Array of colour values used to create the gradient of the health bar when empty, each colour must be in 0xAARRGGBB format (the background colour)
	 * @param	fill		Array of colour values used to create the gradient of the health bar when full, each colour must be in 0xAARRGGBB format (the foreground colour)
	 * @param	chunkSize	If you want a more old-skool looking chunky gradient, increase this value!
	 * @param	rotation	Angle of the gradient in degrees. 90 = top to bottom, 180 = left to right. Any angle is valid
	 * @param	showBorder	Should the bar be outlined with a 1px solid border?
	 * @param	border		The border colour in 0xAARRGGBB format
	 * @return 	This FlxBar object with generated images for front and background.</haxe_doc>
		</createGradientBar>
		<createGradientEmptyBar public="1" set="method" line="462">
			<f a="empty:?chunkSize:?rotation:?showBorder:?border" v=":1:180:false:FlxColor.WHITE">
				<c path="Array"><x path="flixel.util.FlxColor"/></c>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="flixel.util.FlxColor"/>
				<c path="flixel.ui.FlxBar"/>
			</f>
			<meta><m n=":value"><e>{ border : FlxColor.WHITE, showBorder : false, rotation : 180, chunkSize : 1 }</e></m></meta>
			<haxe_doc>* Creates a gradient filled background for health bar using the given colour range, with optional 1px thick border.
	 * 
	 * @param	empty			Array of colour values used to create the gradient of the health bar when empty, each colour must be in 0xAARRGGBB format (the background colour)
	 * @param	chunkSize		If you want a more old-skool looking chunky gradient, increase this value!
	 * @param	rotation		Angle of the gradient in degrees. 90 = top to bottom, 180 = left to right. Any angle is valid
	 * @param	showBorder		Should the bar be outlined with a 1px solid border?
	 * @param	border			The border colour in 0xAARRGGBB format
	 * @return 	This FlxBar object with generated image for background rendering.</haxe_doc>
		</createGradientEmptyBar>
		<createGradientFilledBar public="1" set="method" line="526">
			<f a="fill:?chunkSize:?rotation:?showBorder:?border" v=":1:180:false:FlxColor.WHITE">
				<c path="Array"><x path="flixel.util.FlxColor"/></c>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="flixel.util.FlxColor"/>
				<c path="flixel.ui.FlxBar"/>
			</f>
			<meta><m n=":value"><e>{ border : FlxColor.WHITE, showBorder : false, rotation : 180, chunkSize : 1 }</e></m></meta>
			<haxe_doc>* Creates a gradient filled foreground for health bar using the given colour range, with optional 1px thick border.
	 * 
	 * @param	fill		Array of colour values used to create the gradient of the health bar when full, each colour must be in 0xAARRGGBB format (the foreground colour)
	 * @param	chunkSize	If you want a more old-skool looking chunky gradient, increase this value!
	 * @param	rotation	Angle of the gradient in degrees. 90 = top to bottom, 180 = left to right. Any angle is valid
	 * @param	showBorder	Should the bar be outlined with a 1px solid border?
	 * @param	border		The border colour in 0xAARRGGBB format
	 * @return 	This FlxBar object with generated image for rendering actual values.</haxe_doc>
		</createGradientFilledBar>
		<createImageBar public="1" set="method" line="592">
			<f a="?empty:?fill:?emptyBackground:?fillBackground" v="::FlxColor.BLACK:FlxColor.LIME">
				<t path="flixel.system.FlxGraphicAsset"/>
				<t path="flixel.system.FlxGraphicAsset"/>
				<x path="flixel.util.FlxColor"/>
				<x path="flixel.util.FlxColor"/>
				<c path="flixel.ui.FlxBar"/>
			</f>
			<meta><m n=":value"><e>{ fillBackground : FlxColor.LIME, emptyBackground : FlxColor.BLACK }</e></m></meta>
			<haxe_doc>* Creates a health bar filled using the given bitmap images.
	 * You can provide "empty" (background) and "fill" (foreground) images. either one or both images (empty / fill), and use the optional empty/fill colour values 
	 * All colour values are in 0xAARRGGBB format, so if you want a slightly transparent health bar give it lower AA values.
	 * NOTE: This method doesn't check if the empty image doesn't have the same size as fill image.
	 * 
	 * @param	empty				Bitmap image used as the background (empty part) of the health bar, if null the emptyBackground colour is used
	 * @param	fill				Bitmap image used as the foreground (filled part) of the health bar, if null the fillBackground colour is used
	 * @param	emptyBackground		If no background (empty) image is given, use this colour value instead. 0xAARRGGBB format
	 * @param	fillBackground		If no foreground (fill) image is given, use this colour value instead. 0xAARRGGBB format
	 * @return	This FlxBar object with generated images for front and background.</haxe_doc>
		</createImageBar>
		<createImageEmptyBar public="1" set="method" line="606">
			<f a="?empty:?emptyBackground" v=":FlxColor.BLACK">
				<t path="flixel.system.FlxGraphicAsset"/>
				<x path="flixel.util.FlxColor"/>
				<c path="flixel.ui.FlxBar"/>
			</f>
			<meta><m n=":value"><e>{ emptyBackground : FlxColor.BLACK }</e></m></meta>
			<haxe_doc>* Loads given bitmap image for health bar background.
	 * 
	 * @param	empty				Bitmap image used as the background (empty part) of the health bar, if null the emptyBackground colour is used
	 * @param	emptyBackground		If no background (empty) image is given, use this colour value instead. 0xAARRGGBB format
	 * @return	This FlxBar object with generated image for background rendering.</haxe_doc>
		</createImageEmptyBar>
		<createImageFilledBar public="1" set="method" line="648">
			<f a="?fill:?fillBackground" v=":FlxColor.LIME">
				<t path="flixel.system.FlxGraphicAsset"/>
				<x path="flixel.util.FlxColor"/>
				<c path="flixel.ui.FlxBar"/>
			</f>
			<meta><m n=":value"><e>{ fillBackground : FlxColor.LIME }</e></m></meta>
			<haxe_doc>* Loads given bitmap image for health bar foreground.
	 * 
	 * @param	fill				Bitmap image used as the foreground (filled part) of the health bar, if null the fillBackground colour is used
	 * @param	fillBackground		If no foreground (fill) image is given, use this colour value instead. 0xAARRGGBB format
	 * @return	This FlxBar object with generated image for rendering actual values.</haxe_doc>
		</createImageFilledBar>
		<set_fillDirection set="method" line="681"><f a="direction">
	<e path="flixel.ui.FlxBarFillDirection"/>
	<e path="flixel.ui.FlxBarFillDirection"/>
</f></set_fillDirection>
		<updateValueFromParent set="method" line="697"><f a=""><x path="Void"/></f></updateValueFromParent>
		<updateBar public="1" set="method" line="706">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Updates health bar view according its current value.
	 * Called when the health bar detects a change in the health of the parent.</haxe_doc>
		</updateBar>
		<updateEmptyBar public="1" set="method" line="715">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Stamps health bar background on its pixels</haxe_doc>
		</updateEmptyBar>
		<updateFilledBar public="1" set="method" line="727">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Stamps health bar foreground on its pixels</haxe_doc>
		</updateFilledBar>
		<update public="1" set="method" line="802" override="1"><f a="elapsed">
	<x path="Float"/>
	<x path="Void"/>
</f></update>
		<draw public="1" set="method" line="821" override="1"><f a=""><x path="Void"/></f></draw>
		<set_pixels set="method" line="864" override="1"><f a="Pixels">
	<t path="flash.display.BitmapData"/>
	<t path="flash.display.BitmapData"/>
</f></set_pixels>
		<toString public="1" set="method" line="876" override="1"><f a=""><c path="String"/></f></toString>
		<get_percent set="method" line="887"><f a=""><x path="Float"/></f></get_percent>
		<set_percent set="method" line="897"><f a="newPct">
	<x path="Float"/>
	<x path="Float"/>
</f></set_percent>
		<set_value set="method" line="906"><f a="newValue">
	<x path="Float"/>
	<x path="Float"/>
</f></set_value>
		<get_value set="method" line="929"><f a=""><x path="Float"/></f></get_value>
		<set_numDivisions set="method" line="941"><f a="newValue">
	<x path="Int"/>
	<x path="Int"/>
</f></set_numDivisions>
		<get_frontFrames set="method" line="948"><f a=""><c path="flixel.graphics.frames.FlxImageFrame"/></f></get_frontFrames>
		<set_frontFrames set="method" line="957"><f a="value">
	<c path="flixel.graphics.frames.FlxImageFrame"/>
	<c path="flixel.graphics.frames.FlxImageFrame"/>
</f></set_frontFrames>
		<get_backFrames set="method" line="971"><f a=""><c path="flixel.graphics.frames.FlxImageFrame"/></f></get_backFrames>
		<set_backFrames set="method" line="980"><f a="value">
	<c path="flixel.graphics.frames.FlxImageFrame"/>
	<c path="flixel.graphics.frames.FlxImageFrame"/>
</f></set_backFrames>
		<new public="1" set="method" line="147">
			<f a="?x:?y:?direction:?width:?height:?parentRef:?variable:?min:?max:?showBorder" v="0:0::100:10::&quot;&quot;:0:100:false">
				<x path="Float"/>
				<x path="Float"/>
				<e path="flixel.ui.FlxBarFillDirection"/>
				<x path="Int"/>
				<x path="Int"/>
				<d/>
				<c path="String"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ showBorder : false, max : 100, min : 0, variable : "", height : 10, width : 100, y : 0, x : 0 }</e></m></meta>
			<haxe_doc>* Create a new FlxBar Object
	 * 
	 * @param	x			The x coordinate location of the resulting bar (in world pixels)
	 * @param	y			The y coordinate location of the resulting bar (in world pixels)
	 * @param	direction 	The fill direction, LEFT_TO_RIGHT by default
	 * @param	width		The width of the bar in pixels
	 * @param	height		The height of the bar in pixels
	 * @param	parentRef	A reference to an object in your game that you wish the bar to track
	 * @param	variable	The variable of the object that is used to determine the bar position. For example if the parent was an FlxSprite this could be "health" to track the health value
	 * @param	min			The minimum value. I.e. for a progress bar this would be zero (nothing loaded yet)
	 * @param	max			The maximum value the bar can reach. I.e. for a progress bar this would typically be 100.
	 * @param	showBorder	Include a 1px border around the bar? (if true it adds +2 to width and height to accommodate it)</haxe_doc>
		</new>
		<haxe_doc>* FlxBar is a quick and easy way to create a graphical bar which can
 * be used as part of your UI/HUD, or positioned next to a sprite. 
 * It could represent a loader, progress or health bar.
 * 
 * @link http://www.photonstorm.com
 * @author Richard Davey / Photon Storm</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<enum path="flixel.ui.FlxBarFillDirection" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/ui/FlxBar.hx" module="flixel.ui.FlxBar">
		<LEFT_TO_RIGHT/>
		<RIGHT_TO_LEFT/>
		<TOP_TO_BOTTOM/>
		<BOTTOM_TO_TOP/>
		<HORIZONTAL_INSIDE_OUT/>
		<HORIZONTAL_OUTSIDE_IN/>
		<VERTICAL_INSIDE_OUT/>
		<VERTICAL_OUTSIDE_IN/>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<class path="flixel.ui.FlxButton" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/ui/FlxButton.hx">
		<extends path="flixel.ui.FlxTypedButton_flixel_text_FlxText"/>
		<NORMAL public="1" get="inline" set="null" expr="0" line="30" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* Used with public variable status, means not highlighted or pressed.</haxe_doc>
		</NORMAL>
		<HIGHLIGHT public="1" get="inline" set="null" expr="1" line="34" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>1</e></m></meta>
			<haxe_doc>* Used with public variable status, means highlighted (usually from mouse over).</haxe_doc>
		</HIGHLIGHT>
		<PRESSED public="1" get="inline" set="null" expr="2" line="38" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>2</e></m></meta>
			<haxe_doc>* Used with public variable status, means pressed (usually from mouse click).</haxe_doc>
		</PRESSED>
		<text public="1" get="accessor" set="accessor">
			<c path="String"/>
			<haxe_doc>* Shortcut to setting label.text</haxe_doc>
		</text>
		<resetHelpers set="method" line="67" override="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Updates the size of the text field to match the button.</haxe_doc>
		</resetHelpers>
		<initLabel get="inline" set="null" line="78"><f a="Text">
	<c path="String"/>
	<x path="Void"/>
</f></initLabel>
		<get_text get="inline" set="null" line="89"><f a=""><c path="String"/></f></get_text>
		<set_text get="inline" set="null" line="94"><f a="Text">
	<c path="String"/>
	<c path="String"/>
</f></set_text>
		<new public="1" set="method" line="54">
			<f a="?X:?Y:?Text:?OnClick" v="0:0::">
				<x path="Float"/>
				<x path="Float"/>
				<c path="String"/>
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ Y : 0, X : 0 }</e></m></meta>
			<haxe_doc>* Creates a new `FlxButton` object with a gray background
	 * and a callback function on the UI thread.
	 * 
	 * @param   X         The x position of the button.
	 * @param   Y         The y position of the button.
	 * @param   Text      The text that you want to appear on the button.
	 * @param   OnClick   The function to call whenever the button is clicked.</haxe_doc>
		</new>
		<haxe_doc>* A simple button class that calls a function when clicked by the mouse.</haxe_doc>
	</class>
	<class path="flixel.ui.FlxTypedButton" params="T" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/ui/FlxButton.hx" module="flixel.ui.FlxButton">
		<extends path="flixel.FlxSprite"/>
		<implements path="flixel.input.IFlxInput"/>
		<label public="1" set="accessor">
			<c path="flixel.ui.FlxTypedButton.T"/>
			<haxe_doc>* The label that appears on the button. Can be any `FlxSprite`.</haxe_doc>
		</label>
		<labelOffsets public="1" expr="[FlxPoint.get(), FlxPoint.get(), FlxPoint.get(0, 1)]">
			<c path="Array"><c path="flixel.math.FlxPoint"/></c>
			<meta><m n=":value"><e>[FlxPoint.get(), FlxPoint.get(), FlxPoint.get(0, 1)]</e></m></meta>
			<haxe_doc>* What offsets the `label` should have for each status.</haxe_doc>
		</labelOffsets>
		<labelAlphas public="1" expr="[0.8, 1.0, 0.5]">
			<c path="Array"><x path="Float"/></c>
			<meta><m n=":value"><e>[0.8, 1.0, 0.5]</e></m></meta>
			<haxe_doc>* What alpha value the label should have for each status. Default is `[0.8, 1.0, 0.5]`.
	 * Multiplied with the button's `alpha`.</haxe_doc>
		</labelAlphas>
		<statusAnimations public="1" expr="[&quot;normal&quot;, &quot;highlight&quot;, &quot;pressed&quot;]">
			<c path="Array"><c path="String"/></c>
			<meta><m n=":value"><e>["normal", "highlight", "pressed"]</e></m></meta>
			<haxe_doc>* What animation should be played for each status.
	 * Default is ["normal", "highlight", "pressed"].</haxe_doc>
		</statusAnimations>
		<allowSwiping public="1" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
			<haxe_doc>* Whether you can press the button simply by releasing the touch / mouse button over it (default).
	 * If false, the input has to be pressed while hovering over the button.</haxe_doc>
		</allowSwiping>
		<mouseButtons public="1" expr="[FlxMouseButtonID.LEFT]">
			<c path="Array"><x path="flixel.input.mouse.FlxMouseButtonID"/></c>
			<meta><m n=":value"><e>[FlxMouseButtonID.LEFT]</e></m></meta>
			<haxe_doc>* Which mouse buttons can trigger the button - by default only the left mouse button.</haxe_doc>
		</mouseButtons>
		<maxInputMovement public="1" expr="Math.POSITIVE_INFINITY">
			<x path="Float"/>
			<meta><m n=":value"><e>Math.POSITIVE_INFINITY</e></m></meta>
			<haxe_doc>* Maximum distance a pointer can move to still trigger event handlers.
	 * If it moves beyond this limit, onOut is triggered.
	 * Defaults to `Math.POSITIVE_INFINITY` (i.e. no limit).</haxe_doc>
		</maxInputMovement>
		<status public="1" set="accessor">
			<x path="Int"/>
			<haxe_doc>* Shows the current state of the button, either `FlxButton.NORMAL`,
	 * `FlxButton.HIGHLIGHT` or `FlxButton.PRESSED`.</haxe_doc>
		</status>
		<onUp public="1" set="null">
			<c path="flixel.ui._FlxButton.FlxButtonEvent"/>
			<haxe_doc>* The properties of this button's `onUp` event (callback function, sound).</haxe_doc>
		</onUp>
		<onDown public="1" set="null">
			<c path="flixel.ui._FlxButton.FlxButtonEvent"/>
			<haxe_doc>* The properties of this button's `onDown` event (callback function, sound).</haxe_doc>
		</onDown>
		<onOver public="1" set="null">
			<c path="flixel.ui._FlxButton.FlxButtonEvent"/>
			<haxe_doc>* The properties of this button's `onOver` event (callback function, sound).</haxe_doc>
		</onOver>
		<onOut public="1" set="null">
			<c path="flixel.ui._FlxButton.FlxButtonEvent"/>
			<haxe_doc>* The properties of this button's `onOut` event (callback function, sound).</haxe_doc>
		</onOut>
		<justReleased public="1" get="accessor" set="null"><x path="Bool"/></justReleased>
		<released public="1" get="accessor" set="null"><x path="Bool"/></released>
		<pressed public="1" get="accessor" set="null"><x path="Bool"/></pressed>
		<justPressed public="1" get="accessor" set="null"><x path="Bool"/></justPressed>
		<_spriteLabel>
			<c path="flixel.FlxSprite"/>
			<haxe_doc>* We cast label to a `FlxSprite` for internal operations to avoid Dynamic casts in C++</haxe_doc>
		</_spriteLabel>
		<input>
			<c path="flixel.input.FlxInput"><x path="Int"/></c>
			<haxe_doc>* We don't need an ID here, so let's just use `Int` as the type.</haxe_doc>
		</input>
		<currentInput>
			<c path="flixel.input.IFlxInput"/>
			<haxe_doc>* The input currently pressing this button, if none, it's `null`. Needed to check for its release.</haxe_doc>
		</currentInput>
		<lastStatus expr="-1">
			<x path="Int"/>
			<meta><m n=":value"><e>-1</e></m></meta>
		</lastStatus>
		<graphicLoaded public="1" set="method" line="230" override="1"><f a=""><x path="Void"/></f></graphicLoaded>
		<loadDefaultGraphic set="method" line="239"><f a=""><x path="Void"/></f></loadDefaultGraphic>
		<setupAnimation set="method" line="244"><f a="animationName:frameIndex">
	<c path="String"/>
	<x path="Int"/>
	<x path="Void"/>
</f></setupAnimation>
		<destroy public="1" set="method" line="254" override="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Called by the game state when state is changed (if this object belongs to the state)</haxe_doc>
		</destroy>
		<update public="1" set="method" line="280" override="1">
			<f a="elapsed">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Called by the game loop automatically, handles mouseover and click detection.</haxe_doc>
		</update>
		<updateStatusAnimation set="method" line="302"><f a=""><x path="Void"/></f></updateStatusAnimation>
		<draw public="1" set="method" line="310" override="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Just draws the button graphic and text label to the screen.</haxe_doc>
		</draw>
		<drawDebug public="1" set="method" line="325" override="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Helper function to draw the debug graphic for the label as well.</haxe_doc>
		</drawDebug>
		<stampOnAtlas public="1" set="method" line="344">
			<f a="atlas">
				<c path="flixel.graphics.atlas.FlxAtlas"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Stamps button's graphic and label onto specified atlas object and loads graphic from this atlas.
	 * This method assumes that you're using whole image for button's graphic and image has no spaces between frames.
	 * And it assumes that label is a single frame sprite.
	 * 
	 * @param   atlas   Atlas to stamp graphic to.
	 * @return  Whether the button's graphic and label's graphic were stamped on the atlas successfully.</haxe_doc>
		</stampOnAtlas>
		<updateButton set="method" line="373">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Basic button update logic - searches for overlaps with touches and
	 * the mouse cursor and calls `updateStatus()`.</haxe_doc>
		</updateButton>
		<checkMouseOverlap set="method" line="394"><f a=""><x path="Bool"/></f></checkMouseOverlap>
		<checkTouchOverlap set="method" line="413"><f a=""><x path="Bool"/></f></checkTouchOverlap>
		<checkInput set="method" line="431"><f a="pointer:input:justPressedPosition:camera">
	<c path="flixel.input.FlxPointer"/>
	<c path="flixel.input.IFlxInput"/>
	<c path="flixel.math.FlxPoint"/>
	<c path="flixel.FlxCamera"/>
	<x path="Bool"/>
</f></checkInput>
		<updateStatus set="method" line="451">
			<f a="input">
				<c path="flixel.input.IFlxInput"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Updates the button status by calling the respective event handler function.</haxe_doc>
		</updateStatus>
		<updateLabelPosition set="method" line="472"><f a=""><x path="Void"/></f></updateLabelPosition>
		<updateLabelAlpha set="method" line="481"><f a=""><x path="Void"/></f></updateLabelAlpha>
		<onUpEventListener set="method" line="494">
			<f a="_">
				<unknown/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Using an event listener is necessary for security reasons on flash - 
	 * certain things like opening a new window are only allowed when they are user-initiated.</haxe_doc>
		</onUpEventListener>
		<onUpHandler set="method" line="506">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Internal function that handles the onUp event.</haxe_doc>
		</onUpHandler>
		<onDownHandler set="method" line="518">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Internal function that handles the onDown event.</haxe_doc>
		</onDownHandler>
		<onOverHandler set="method" line="529">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Internal function that handles the onOver event.</haxe_doc>
		</onOverHandler>
		<onOutHandler set="method" line="539">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Internal function that handles the onOut event.</haxe_doc>
		</onOutHandler>
		<set_label set="method" line="547"><f a="Value">
	<c path="flixel.ui.FlxTypedButton.T"/>
	<c path="flixel.ui.FlxTypedButton.T"/>
</f></set_label>
		<set_status set="method" line="564"><f a="Value">
	<x path="Int"/>
	<x path="Int"/>
</f></set_status>
		<set_alpha set="method" line="571" override="1"><f a="Value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_alpha>
		<set_x set="method" line="578" override="1"><f a="Value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_x>
		<set_y set="method" line="585" override="1"><f a="Value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_y>
		<get_justReleased get="inline" set="null" line="592"><f a=""><x path="Bool"/></f></get_justReleased>
		<get_released get="inline" set="null" line="597"><f a=""><x path="Bool"/></f></get_released>
		<get_pressed get="inline" set="null" line="602"><f a=""><x path="Bool"/></f></get_pressed>
		<get_justPressed get="inline" set="null" line="607"><f a=""><x path="Bool"/></f></get_justPressed>
		<new public="1" set="method" line="202">
			<f a="?X:?Y:?OnClick" v="0:0:">
				<x path="Float"/>
				<x path="Float"/>
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ Y : 0, X : 0 }</e></m></meta>
			<haxe_doc>* Creates a new `FlxTypedButton` object with a gray background.
	 * 
	 * @param   X         The x position of the button.
	 * @param   Y         The y position of the button.
	 * @param   OnClick   The function to call whenever the button is clicked.</haxe_doc>
		</new>
		<haxe_doc>* A simple button class that calls a function when clicked by the mouse.</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":generic"/>
		</meta>
	</class>
	<class path="flixel.ui._FlxButton.FlxButtonEvent" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/ui/FlxButton.hx" private="1" module="flixel.ui.FlxButton">
		<implements path="flixel.util.IFlxDestroyable"/>
		<callback public="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* The callback function to call when this even fires.</haxe_doc>
		</callback>
		<sound public="1">
			<c path="flixel.system.FlxSound"/>
			<haxe_doc>* The sound to play when this event fires.</haxe_doc>
		</sound>
		<destroy public="1" get="inline" set="null" line="646">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Cleans up memory.</haxe_doc>
		</destroy>
		<fire public="1" get="inline" set="null" line="658">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Fires this event (calls the callback and plays the sound)</haxe_doc>
		</fire>
		<new public="1" set="method" line="634">
			<f a="?Callback:?sound">
				<f a=""><x path="Void"/></f>
				<c path="flixel.system.FlxSound"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* @param   Callback   The callback function to call when this even fires.
	 * @param   sound      The sound to play when this event fires.</haxe_doc>
		</new>
		<haxe_doc>* Helper function for `FlxButton` which handles its events.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="flixel.util.FlxArrayUtil" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/util/FlxArrayUtil.hx">
		<setLength public="1" params="T" set="method" line="15" static="1">
			<f a="array:newLength">
				<c path="Array"><c path="setLength.T"/></c>
				<x path="Int"/>
				<c path="Array"><c path="setLength.T"/></c>
			</f>
			<meta><m n=":generic"/></meta>
			<haxe_doc>* Sets the length of an array.
	 * 
	 * @param	array		The array.
	 * @param	newLength	The length you want the array to have.</haxe_doc>
		</setLength>
		<fastSplice public="1" params="T" get="inline" set="null" line="46" static="1">
			<f a="array:element">
				<c path="Array"><c path="fastSplice.T"/></c>
				<c path="fastSplice.T"/>
				<c path="Array"><c path="fastSplice.T"/></c>
			</f>
			<meta><m n=":generic"/></meta>
			<haxe_doc>* Safely removes an element from an array by swapping it with the last element and calling `pop()`
	 * (won't do anything if the element is not in the array). This is a lot faster than regular `splice()`, 
	 * but it can only be used on arrays where order doesn't matter.
	 * 
	 * @param	array	The array to remove the element from
	 * @param 	element	The element to remove from the array
	 * @return	The array</haxe_doc>
		</fastSplice>
		<swapAndPop public="1" params="T" get="inline" set="null" line="78" static="1">
			<f a="array:index">
				<c path="Array"><c path="swapAndPop.T"/></c>
				<x path="Int"/>
				<c path="Array"><c path="swapAndPop.T"/></c>
			</f>
			<meta><m n=":generic"/></meta>
			<haxe_doc><![CDATA[* Removes an element from an array by swapping it with the last element and calling `pop()`.
	 * This is a lot faster than regular `splice()`, but it can only be used on arrays where order doesn't matter.
	 * 
	 * IMPORTANT: always count down from length to zero if removing elements from within a loop
	 * 
	 * ```haxe
	 * using flixel.util.FlxArrayUtil;
	 *
	 * var i = array.length;
	 * while (i-- > 0)
	 * {
	 *      if (array[i].shouldRemove)
	 *      {
	 *           array.swapAndPop(i);
	 *      }
	 * }
	 * ```
	 * 
	 * @param	array	The array to remove the element from
	 * @param 	index	The index of the element to be removed from the array
	 * @return	The array]]></haxe_doc>
		</swapAndPop>
		<clearArray public="1" params="T" set="method" line="93" static="1">
			<f a="array:?recursive" v=":false">
				<c path="Array"><c path="clearArray.T"/></c>
				<x path="Bool"/>
				<c path="Array"><c path="clearArray.T"/></c>
			</f>
			<meta><m n=":value"><e>{ recursive : false }</e></m></meta>
			<haxe_doc>* Clears an array structure, but leaves the object data untouched
	 * Useful for cleaning up temporary references to data you want to preserve.
	 * WARNING: Can lead to memory leaks.
	 *
	 * @param	array		The array to clear out
	 * @param	Recursive	Whether to search for arrays inside of arr and clear them out, too</haxe_doc>
		</clearArray>
		<flatten2DArray public="1" params="T" set="method" line="121" static="1">
			<f a="array">
				<c path="Array"><c path="Array"><c path="flatten2DArray.T"/></c></c>
				<c path="Array"><c path="flatten2DArray.T"/></c>
			</f>
			<meta><m n=":generic"/></meta>
			<haxe_doc><![CDATA[* Flattens 2D arrays into 1D arrays.
	 * Example: `[[1, 2], [3, 2], [1, 1]]` -> `[1, 2, 3, 2, 1, 1]`]]></haxe_doc>
		</flatten2DArray>
		<equals public="1" params="T" set="method" line="134" static="1">
			<f a="array1:array2">
				<c path="Array"><c path="equals.T"/></c>
				<c path="Array"><c path="equals.T"/></c>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Compares the contents with `==` to see if the two arrays are the same.
	 * Also takes null arrays and the length of the arrays into account.</haxe_doc>
		</equals>
		<last public="1" params="T" set="method" line="155" static="1">
			<f a="array">
				<c path="Array"><c path="last.T"/></c>
				<t path="Null"><c path="last.T"/></t>
			</f>
			<haxe_doc>* Returns the last element of an array or `null` if the array is `null` / empty.</haxe_doc>
		</last>
		<contains public="1" params="T" get="inline" set="null" line="162" static="1"><f a="array:element">
	<c path="Array"><c path="contains.T"/></c>
	<c path="contains.T"/>
	<x path="Bool"/>
</f></contains>
		<haxe_doc>* A set of functions for array manipulation.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<enum path="flixel.util.FlxAxes" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/util/FlxAxes.hx">
		<X/>
		<Y/>
		<XY/>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<class path="openfl.geom.Rectangle" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/geom/Rectangle.hx">
		<__temp expr="new Rectangle()" line="10" static="1">
			<c path="openfl.geom.Rectangle"/>
			<meta><m n=":value"><e>new Rectangle()</e></m></meta>
		</__temp>
		<bottom public="1" get="accessor" set="accessor"><x path="Float"/></bottom>
		<bottomRight public="1" get="accessor" set="accessor"><c path="openfl.geom.Point"/></bottomRight>
		<height public="1"><x path="Float"/></height>
		<left public="1" get="accessor" set="accessor"><x path="Float"/></left>
		<right public="1" get="accessor" set="accessor"><x path="Float"/></right>
		<size public="1" get="accessor" set="accessor"><c path="openfl.geom.Point"/></size>
		<top public="1" get="accessor" set="accessor"><x path="Float"/></top>
		<topLeft public="1" get="accessor" set="accessor"><c path="openfl.geom.Point"/></topLeft>
		<width public="1"><x path="Float"/></width>
		<x public="1"><x path="Float"/></x>
		<y public="1"><x path="Float"/></y>
		<clone public="1" set="method" line="35"><f a=""><c path="openfl.geom.Rectangle"/></f></clone>
		<contains public="1" set="method" line="42"><f a="x:y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Bool"/>
</f></contains>
		<containsPoint public="1" set="method" line="49"><f a="point">
	<c path="openfl.geom.Point"/>
	<x path="Bool"/>
</f></containsPoint>
		<containsRect public="1" set="method" line="56"><f a="rect">
	<c path="openfl.geom.Rectangle"/>
	<x path="Bool"/>
</f></containsRect>
		<copyFrom public="1" set="method" line="71"><f a="sourceRect">
	<c path="openfl.geom.Rectangle"/>
	<x path="Void"/>
</f></copyFrom>
		<equals public="1" set="method" line="81"><f a="toCompare">
	<c path="openfl.geom.Rectangle"/>
	<x path="Bool"/>
</f></equals>
		<inflate public="1" set="method" line="88"><f a="dx:dy">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></inflate>
		<inflatePoint public="1" set="method" line="96"><f a="point">
	<c path="openfl.geom.Point"/>
	<x path="Void"/>
</f></inflatePoint>
		<intersection public="1" set="method" line="103"><f a="toIntersect">
	<c path="openfl.geom.Rectangle"/>
	<c path="openfl.geom.Rectangle"/>
</f></intersection>
		<intersects public="1" set="method" line="128"><f a="toIntersect">
	<c path="openfl.geom.Rectangle"/>
	<x path="Bool"/>
</f></intersects>
		<isEmpty public="1" set="method" line="147"><f a=""><x path="Bool"/></f></isEmpty>
		<offset public="1" set="method" line="154"><f a="dx:dy">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></offset>
		<offsetPoint public="1" set="method" line="162"><f a="point">
	<c path="openfl.geom.Point"/>
	<x path="Void"/>
</f></offsetPoint>
		<setEmpty public="1" set="method" line="170"><f a=""><x path="Void"/></f></setEmpty>
		<setTo public="1" set="method" line="177"><f a="xa:ya:widtha:heighta">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></setTo>
		<toString public="1" set="method" line="187"><f a=""><c path="String"/></f></toString>
		<union public="1" set="method" line="194"><f a="toUnion">
	<c path="openfl.geom.Rectangle"/>
	<c path="openfl.geom.Rectangle"/>
</f></union>
		<__contract public="1" set="method" line="216"><f a="x:y:width:height">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></__contract>
		<__expand public="1" set="method" line="235"><f a="x:y:width:height">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></__expand>
		<__toLimeRectangle set="method" line="266"><f a=""><t path="lime.math._Rectangle.LimeRectangle"/></f></__toLimeRectangle>
		<__transform set="method" line="273"><f a="rect:m">
	<c path="openfl.geom.Rectangle"/>
	<c path="openfl.geom.Matrix"/>
	<x path="Void"/>
</f></__transform>
		<get_bottom set="method" line="316"><f a=""><x path="Float"/></f></get_bottom>
		<set_bottom set="method" line="317"><f a="b">
	<x path="Float"/>
	<x path="Float"/>
</f></set_bottom>
		<get_bottomRight set="method" line="318"><f a=""><c path="openfl.geom.Point"/></f></get_bottomRight>
		<set_bottomRight set="method" line="319"><f a="p">
	<c path="openfl.geom.Point"/>
	<c path="openfl.geom.Point"/>
</f></set_bottomRight>
		<get_left set="method" line="320"><f a=""><x path="Float"/></f></get_left>
		<set_left set="method" line="321"><f a="l">
	<x path="Float"/>
	<x path="Float"/>
</f></set_left>
		<get_right set="method" line="322"><f a=""><x path="Float"/></f></get_right>
		<set_right set="method" line="323"><f a="r">
	<x path="Float"/>
	<x path="Float"/>
</f></set_right>
		<get_size set="method" line="324"><f a=""><c path="openfl.geom.Point"/></f></get_size>
		<set_size set="method" line="325"><f a="p">
	<c path="openfl.geom.Point"/>
	<c path="openfl.geom.Point"/>
</f></set_size>
		<get_top set="method" line="326"><f a=""><x path="Float"/></f></get_top>
		<set_top set="method" line="327"><f a="t">
	<x path="Float"/>
	<x path="Float"/>
</f></set_top>
		<get_topLeft set="method" line="328"><f a=""><c path="openfl.geom.Point"/></f></get_topLeft>
		<set_topLeft set="method" line="329"><f a="p">
	<c path="openfl.geom.Point"/>
	<c path="openfl.geom.Point"/>
</f></set_topLeft>
		<new public="1" set="method" line="25">
			<f a="?x:?y:?width:?height" v="0:0:0:0">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ height : 0, width : 0, y : 0, x : 0 }</e></m></meta>
		</new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="flixel.util.FlxBitmapDataPool" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/util/FlxBitmapDataPool.hx">
		<maxLength public="1" set="accessor" expr="8" line="21" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>8</e></m></meta>
			<haxe_doc>* Maximum number of BitmapData to hold in the pool.</haxe_doc>
		</maxLength>
		<length public="1" set="null" expr="0" line="26" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* Current number of BitmapData present in the pool.</haxe_doc>
		</length>
		<_head expr="null" line="28" static="1">
			<c path="flixel.util._FlxBitmapDataPool.FlxBitmapDataPoolNode"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</_head>
		<_tail expr="null" line="29" static="1">
			<c path="flixel.util._FlxBitmapDataPool.FlxBitmapDataPoolNode"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</_tail>
		<_rect expr="new Rectangle()" line="31" static="1">
			<t path="flash.geom.Rectangle"/>
			<meta><m n=":value"><e>new Rectangle()</e></m></meta>
		</_rect>
		<get public="1" set="method" line="40" static="1">
			<f a="w:h:?transparent:?fillColor:?exactSize" v="::true::false">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="flixel.util.FlxColor"/>
				<x path="Bool"/>
				<t path="flash.display.BitmapData"/>
			</f>
			<meta><m n=":value"><e>{ exactSize : false, transparent : true }</e></m></meta>
			<haxe_doc><![CDATA[* Returns a BitmapData with the specified parameters. 
	 * If a suitable BitmapData cannot be found in the pool a new one will be created.
	 * If fillColor is specified the returned BitmapData will also be cleared with it.
	 * 
	 * @param exactSize	If false a BitmapData with size >= [w, h] may be returned.]]></haxe_doc>
		</get>
		<put public="1" set="method" line="88" static="1">
			<f a="bmd">
				<t path="flash.display.BitmapData"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Adds bmd to the pool for future use.</haxe_doc>
		</put>
		<clear public="1" set="method" line="120" static="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Disposes of all the BitmapData in the pool.</haxe_doc>
		</clear>
		<set_maxLength set="method" line="134" static="1"><f a="value">
	<x path="Int"/>
	<x path="Int"/>
</f></set_maxLength>
		<haxe_doc>* BitmapData pool class.
 * 
 * Notes on implementation:
 *     get() starts searching for a suitable BitmapData from the start of the pool list
 *     put() adds the BitmapData to the start of the pool list (removing the last one if the pool exceeds maxLength)
 * 
 * @author azrafe7</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":access"><e>FlxBitmapDataPoolNode</e></m>
		</meta>
	</class>
	<class path="flixel.util._FlxBitmapDataPool.FlxBitmapDataPoolNode" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/util/FlxBitmapDataPool.hx" private="1" module="flixel.util.FlxBitmapDataPool">
		<bmd public="1"><t path="flash.display.BitmapData"/></bmd>
		<prev public="1"><c path="flixel.util._FlxBitmapDataPool.FlxBitmapDataPoolNode"/></prev>
		<next public="1"><c path="flixel.util._FlxBitmapDataPool.FlxBitmapDataPoolNode"/></next>
		<new public="1" set="method" line="158"><f a="?bmd:?prev:?next">
	<t path="flash.display.BitmapData"/>
	<c path="flixel.util._FlxBitmapDataPool.FlxBitmapDataPoolNode"/>
	<c path="flixel.util._FlxBitmapDataPool.FlxBitmapDataPoolNode"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="flixel.util.FlxBitmapDataUtil" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/util/FlxBitmapDataUtil.hx">
		<matrix expr="new FlxMatrix()" line="17" static="1">
			<c path="flixel.math.FlxMatrix"/>
			<meta><m n=":value"><e>new FlxMatrix()</e></m></meta>
		</matrix>
		<merge public="1" set="method" line="31" static="1">
			<f a="sourceBitmapData:sourceRect:destBitmapData:destPoint:redMultiplier:greenMultiplier:blueMultiplier:alphaMultiplier">
				<t path="flash.display.BitmapData"/>
				<t path="flash.geom.Rectangle"/>
				<t path="flash.display.BitmapData"/>
				<t path="flash.geom.Point"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Performs per-channel blending from a source image to a destination image.
	 * 
	 * @param	sourceBitmapData	The input bitmap image to use. The source image can be a different BitmapData object, or it can refer to the current BitmapData object.
	 * @param	sourceRect			A rectangle that defines the area of the source image to use as input. 
	 * @param	destBitmapData		The output bitmap image to use.
	 * @param	destPoint			The point within the destination image (the current BitmapData instance) that corresponds to the upper-left corner of the source rectangle.
	 * @param	redMultiplier		A hexadecimal uint value by which to multiply the red channel value.
	 * @param	greenMultiplier		A hexadecimal uint value by which to multiply the green channel value.
	 * @param	blueMultiplier		A hexadecimal uint value by which to multiply the blue channel value.
	 * @param	alphaMultiplier		A hexadecimal uint value by which to multiply the alpha transparency value.</haxe_doc>
		</merge>
		<mergeColorComponent get="inline" set="null" line="147" static="1"><f a="source:dest:multiplier">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></mergeColorComponent>
		<compare public="1" set="method" line="163" static="1">
			<f a="Bitmap1:Bitmap2">
				<t path="flash.display.BitmapData"/>
				<t path="flash.display.BitmapData"/>
				<d/>
			</f>
			<haxe_doc>* Compares two BitmapData objects.
	 * 
	 * @param	Bitmap1		The source BitmapData object to compare with.
	 * @param	Bitmap2		The BitmapData object to compare with the source BitmapData object.
	 * @return	If the two BitmapData objects have the same dimensions (width and height), 
	 * the method returns a new BitmapData object that has the difference between the two objects. 
	 * If the BitmapData objects are equivalent, the method returns the number 0.
	 * If the widths of the BitmapData objects are not equal, the method returns the number -3. 
	 * If the heights of the BitmapData objects are not equal, the method returns the number -4.</haxe_doc>
		</compare>
		<getDiff get="inline" set="null" line="231" static="1"><f a="value1:value2">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></getDiff>
		<getMemorySize public="1" get="inline" set="null" line="240" static="1">
			<f a="bitmapData">
				<t path="flash.display.BitmapData"/>
				<x path="Float"/>
			</f>
			<haxe_doc>* Returns the amount of bytes a bitmapData occupies in memory.</haxe_doc>
		</getMemorySize>
		<replaceColor public="1" set="method" line="256" static="1">
			<f a="bitmapData:color:newColor:?fetchPositions:?rect" v=":::false:">
				<t path="flash.display.BitmapData"/>
				<x path="flixel.util.FlxColor"/>
				<x path="flixel.util.FlxColor"/>
				<x path="Bool"/>
				<c path="flixel.math.FlxRect"/>
				<c path="Array"><c path="flixel.math.FlxPoint"/></c>
			</f>
			<meta><m n=":value"><e>{ fetchPositions : false }</e></m></meta>
			<haxe_doc>* Replaces all BitmapData's pixels with specified color with newColor pixels. 
	 * WARNING: very expensive (especially on big graphics) as it iterates over every single pixel.
	 * 
	 * @param	bitmapData			BitmapData to change
	 * @param	color				Color to replace
	 * @param	newColor			New color
	 * @param	fetchPositions		Whether we need to store positions of pixels which colors were replaced
	 * @param	rect				area to apply color replacement. Optional, uses whole image area if the rect is null
	 * @return	Array replaced pixels positions</haxe_doc>
		</replaceColor>
		<addSpacesAndBorders public="1" set="method" line="325" static="1">
			<f a="bitmapData:?frameSize:?spacing:?border:?region">
				<t path="flash.display.BitmapData"/>
				<c path="flixel.math.FlxPoint"/>
				<c path="flixel.math.FlxPoint"/>
				<c path="flixel.math.FlxPoint"/>
				<c path="flixel.math.FlxRect"/>
				<t path="flash.display.BitmapData"/>
			</f>
			<haxe_doc>* Gets image without spaces between tiles and generates new one with spaces and adds borders around them.
	 * @param	bitmapData	original image without spaces between tiles.
	 * @param	frameSize	the size of tile in spritesheet.
	 * @param	spacing		spaces between tiles to add.
	 * @param	border		how many times to copy border of tiles.
	 * @param	region		region of image to use as a source graphics for spritesheet. Default value is null, which means that whole image will be used.
	 * @return	Image for spritesheet with inserted spaces between tiles.</haxe_doc>
		</addSpacesAndBorders>
		<copyBorderPixels public="1" set="method" line="408" static="1">
			<f a="bitmapData:frameWidth:frameHeight:spaceX:spaceY:borderX:borderY:horizontalFrames:verticalFrames">
				<t path="flash.display.BitmapData"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<t path="flash.display.BitmapData"/>
			</f>
			<haxe_doc>* Helper method for copying border pixels around tiles.
	 * It modifies provided image, and assumes that there are spaces between tile images already.
	 * 
	 * @param	bitmapData 			image with spaces between tiles to fill with border pixels
	 * @param	frameWidth			tile width
	 * @param	frameHeight			tile height
	 * @param	spaceX				horizontal spacing between tiles
	 * @param	spaceY				vertical spacing between tiles
	 * @param	borderX				how many times to copy border of tiles on horizontal axis.
	 * @param	borderY				how many times to copy border of tiles on vertical axis.
	 * @param	horizontalFrames	how many columns of tiles on provided image.
	 * @param	verticalFrames		how many rows of tiles on provided image.
	 * @return	Modified spritesheet with copied pixels around tile images.
	 * @since   4.1.0</haxe_doc>
		</copyBorderPixels>
		<generateRotations public="1" set="method" line="468" static="1">
			<f a="brush:?rotations:?antiAliasing:?autoBuffer" v=":16:false:false">
				<t path="flash.display.BitmapData"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<t path="flash.display.BitmapData"/>
			</f>
			<meta><m n=":value"><e>{ autoBuffer : false, antiAliasing : false, rotations : 16 }</e></m></meta>
			<haxe_doc>* Generates BitmapData with prerotated brush stamped on it
	 * 
	 * @param	brush			The image you want to rotate and stamp.
	 * @param	rotations		The number of rotation frames the final sprite should have. For small sprites this can be quite a large number (360 even) without any problems.
	 * @param	antiAliasing	Whether to use high quality rotations when creating the graphic.  Default is false.
	 * @param	autoBuffer		Whether to automatically increase the image size to accommodate rotated corners.  Default is false.  Will create frames that are 150% larger on each axis than the original frame or graphic.
	 * @return	Created BitmapData with stamped prerotations on it.</haxe_doc>
		</generateRotations>
		<haxe_doc>* Just a collection of BitmapData utility methods.
 * Just for cross-platform stuff, since not all methods are implemented across all targets.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="flixel.util.FlxCollision" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/util/FlxCollision.hx">
		<pointA expr="new FlxVector()" line="25" static="1">
			<c path="flixel.math.FlxVector"/>
			<meta><m n=":value"><e>new FlxVector()</e></m></meta>
		</pointA>
		<pointB expr="new FlxVector()" line="26" static="1">
			<c path="flixel.math.FlxVector"/>
			<meta><m n=":value"><e>new FlxVector()</e></m></meta>
		</pointB>
		<centerA expr="new FlxVector()" line="27" static="1">
			<c path="flixel.math.FlxVector"/>
			<meta><m n=":value"><e>new FlxVector()</e></m></meta>
		</centerA>
		<centerB expr="new FlxVector()" line="28" static="1">
			<c path="flixel.math.FlxVector"/>
			<meta><m n=":value"><e>new FlxVector()</e></m></meta>
		</centerB>
		<matrixA expr="new FlxMatrix()" line="29" static="1">
			<c path="flixel.math.FlxMatrix"/>
			<meta><m n=":value"><e>new FlxMatrix()</e></m></meta>
		</matrixA>
		<matrixB expr="new FlxMatrix()" line="30" static="1">
			<c path="flixel.math.FlxMatrix"/>
			<meta><m n=":value"><e>new FlxMatrix()</e></m></meta>
		</matrixB>
		<testMatrix expr="new FlxMatrix()" line="31" static="1">
			<c path="flixel.math.FlxMatrix"/>
			<meta><m n=":value"><e>new FlxMatrix()</e></m></meta>
		</testMatrix>
		<boundsA expr="new FlxRect()" line="32" static="1">
			<c path="flixel.math.FlxRect"/>
			<meta><m n=":value"><e>new FlxRect()</e></m></meta>
		</boundsA>
		<boundsB expr="new FlxRect()" line="33" static="1">
			<c path="flixel.math.FlxRect"/>
			<meta><m n=":value"><e>new FlxRect()</e></m></meta>
		</boundsB>
		<intersect expr="new FlxRect()" line="34" static="1">
			<c path="flixel.math.FlxRect"/>
			<meta><m n=":value"><e>new FlxRect()</e></m></meta>
		</intersect>
		<flashRect expr="new Rectangle()" line="35" static="1">
			<t path="flash.geom.Rectangle"/>
			<meta><m n=":value"><e>new Rectangle()</e></m></meta>
		</flashRect>
		<pixelPerfectCheck public="1" set="method" line="47" static="1">
			<f a="Contact:Target:?AlphaTolerance:?Camera" v="::1:">
				<c path="flixel.FlxSprite"/>
				<c path="flixel.FlxSprite"/>
				<x path="Int"/>
				<c path="flixel.FlxCamera"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":value"><e>{ AlphaTolerance : 1 }</e></m></meta>
			<haxe_doc>* A Pixel Perfect Collision check between two FlxSprites. It will do a bounds check first, and if that passes it will run a 
	 * pixel perfect match on the intersecting area. Works with rotated and animated sprites. May be slow, so use it sparingly.
	 * 
	 * @param	Contact			The first FlxSprite to test against
	 * @param	Target			The second FlxSprite to test again, sprite order is irrelevant
	 * @param	AlphaTolerance	The tolerance value above which alpha pixels are included. Default to 1 (anything that is not fully invisible).
	 * @param	Camera			If the collision is taking place in a camera other than FlxG.camera (the default/current) then pass it here
	 * @return	Whether the sprites collide</haxe_doc>
		</pixelPerfectCheck>
		<pixelPerfectPointCheck public="1" set="method" line="222" static="1">
			<f a="PointX:PointY:Target:?AlphaTolerance" v=":::1">
				<x path="Int"/>
				<x path="Int"/>
				<c path="flixel.FlxSprite"/>
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":value"><e>{ AlphaTolerance : 1 }</e></m></meta>
			<haxe_doc>* A Pixel Perfect Collision check between a given x/y coordinate and an FlxSprite
	 * 
	 * @param	PointX			The x coordinate of the point given in local space (relative to the FlxSprite, not game world coordinates)
	 * @param	PointY			The y coordinate of the point given in local space (relative to the FlxSprite, not game world coordinates)
	 * @param	Target			The FlxSprite to check the point against
	 * @param	AlphaTolerance	The alpha tolerance level above which pixels are counted as colliding. Default to 1 (anything that is not fully invisible).
	 * @return	Boolean True if the x/y point collides with the FlxSprite, false if not</haxe_doc>
		</pixelPerfectPointCheck>
		<createCameraWall public="1" set="method" line="259" static="1">
			<f a="Camera:?PlaceOutside:Thickness:?AdjustWorldBounds" v=":true::false">
				<c path="flixel.FlxCamera"/>
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Bool"/>
				<t path="flixel.group.FlxGroup"/>
			</f>
			<meta><m n=":value"><e>{ AdjustWorldBounds : false, PlaceOutside : true }</e></m></meta>
			<haxe_doc>* Creates a "wall" around the given camera which can be used for FlxSprite collision
	 * 
	 * @param	Camera				The FlxCamera to use for the wall bounds (can be FlxG.camera for the current one)
	 * @param	Placement			Whether to place the camera wall outside or inside
	 * @param	Thickness			The thickness of the wall in pixels
	 * @param	AdjustWorldBounds	Adjust the FlxG.worldBounds based on the wall (true) or leave alone (false)
	 * @return	FlxGroup The 4 FlxTileblocks that are created are placed into this FlxGroup which should be added to your State</haxe_doc>
		</createCameraWall>
		<haxe_doc>* FlxCollision
 *
 * @link http://www.photonstorm.com
 * @author Richard Davey / Photon Storm</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<abstract path="flixel.util.FlxColor" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/util/FlxColor.hx">
		<from>
			<icast><x path="UInt"/></icast>
			<icast><x path="Int"/></icast>
		</from>
		<this><x path="Int"/></this>
		<to>
			<icast><x path="UInt"/></icast>
			<icast><x path="Int"/></icast>
		</to>
		<haxe_doc>* Class representing a color, based on Int. Provides a variety of methods for creating and converting colors.
 * 
 * FlxColors can be written as Ints. This means you can pass a hex value such as
 * 0xff123456 to a function expecting a FlxColor, and it will automatically become a FlxColor "object".
 * Similarly, FlxColors may be treated as Ints.
 * 
 * Note that when using properties of a FlxColor other than ARGB, the values are ultimately stored as
 * ARGB values, so repeatedly manipulating HSB/HSL/CMYK values may result in a gradual loss of precision.
 * 
 * @author Joe Williamson (JoeCreates)</haxe_doc>
		<impl><class path="flixel.util._FlxColor.FlxColor_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/util/FlxColor.hx" private="1" module="flixel.util.FlxColor">
	<TRANSPARENT public="1" get="inline" set="null" expr="0x00000000" line="20" static="1">
		<x path="flixel.util.FlxColor"/>
		<meta><m n=":value"><e>0x00000000</e></m></meta>
	</TRANSPARENT>
	<WHITE public="1" get="inline" set="null" expr="0xFFFFFFFF" line="21" static="1">
		<x path="flixel.util.FlxColor"/>
		<meta><m n=":value"><e>0xFFFFFFFF</e></m></meta>
	</WHITE>
	<GRAY public="1" get="inline" set="null" expr="0xFF808080" line="22" static="1">
		<x path="flixel.util.FlxColor"/>
		<meta><m n=":value"><e>0xFF808080</e></m></meta>
	</GRAY>
	<BLACK public="1" get="inline" set="null" expr="0xFF000000" line="23" static="1">
		<x path="flixel.util.FlxColor"/>
		<meta><m n=":value"><e>0xFF000000</e></m></meta>
	</BLACK>
	<GREEN public="1" get="inline" set="null" expr="0xFF008000" line="25" static="1">
		<x path="flixel.util.FlxColor"/>
		<meta><m n=":value"><e>0xFF008000</e></m></meta>
	</GREEN>
	<LIME public="1" get="inline" set="null" expr="0xFF00FF00" line="26" static="1">
		<x path="flixel.util.FlxColor"/>
		<meta><m n=":value"><e>0xFF00FF00</e></m></meta>
	</LIME>
	<YELLOW public="1" get="inline" set="null" expr="0xFFFFFF00" line="27" static="1">
		<x path="flixel.util.FlxColor"/>
		<meta><m n=":value"><e>0xFFFFFF00</e></m></meta>
	</YELLOW>
	<ORANGE public="1" get="inline" set="null" expr="0xFFFFA500" line="28" static="1">
		<x path="flixel.util.FlxColor"/>
		<meta><m n=":value"><e>0xFFFFA500</e></m></meta>
	</ORANGE>
	<RED public="1" get="inline" set="null" expr="0xFFFF0000" line="29" static="1">
		<x path="flixel.util.FlxColor"/>
		<meta><m n=":value"><e>0xFFFF0000</e></m></meta>
	</RED>
	<PURPLE public="1" get="inline" set="null" expr="0xFF800080" line="30" static="1">
		<x path="flixel.util.FlxColor"/>
		<meta><m n=":value"><e>0xFF800080</e></m></meta>
	</PURPLE>
	<BLUE public="1" get="inline" set="null" expr="0xFF0000FF" line="31" static="1">
		<x path="flixel.util.FlxColor"/>
		<meta><m n=":value"><e>0xFF0000FF</e></m></meta>
	</BLUE>
	<BROWN public="1" get="inline" set="null" expr="0xFF8B4513" line="32" static="1">
		<x path="flixel.util.FlxColor"/>
		<meta><m n=":value"><e>0xFF8B4513</e></m></meta>
	</BROWN>
	<PINK public="1" get="inline" set="null" expr="0xFFFFC0CB" line="33" static="1">
		<x path="flixel.util.FlxColor"/>
		<meta><m n=":value"><e>0xFFFFC0CB</e></m></meta>
	</PINK>
	<MAGENTA public="1" get="inline" set="null" expr="0xFFFF00FF" line="34" static="1">
		<x path="flixel.util.FlxColor"/>
		<meta><m n=":value"><e>0xFFFF00FF</e></m></meta>
	</MAGENTA>
	<CYAN public="1" get="inline" set="null" expr="0xFF00FFFF" line="35" static="1">
		<x path="flixel.util.FlxColor"/>
		<meta><m n=":value"><e>0xFF00FFFF</e></m></meta>
	</CYAN>
	<colorLookup public="1" set="null" expr="FlxMacroUtil.buildMap(&quot;flixel.util.FlxColor&quot;)" line="53" static="1">
		<x path="Map">
			<c path="String"/>
			<x path="Int"/>
		</x>
		<meta><m n=":value"><e>FlxMacroUtil.buildMap("flixel.util.FlxColor")</e></m></meta>
		<haxe_doc><![CDATA[* A `Map<String, Int>` whose values are the static colors of `FlxColor`.
	 * You can add more colors for `FlxColor.fromString(String)` if you need.]]></haxe_doc>
	</colorLookup>
	<red public="1" get="accessor" set="accessor" static="1">
		<x path="Int"/>
		<meta><m n=":impl"/></meta>
	</red>
	<blue public="1" get="accessor" set="accessor" static="1">
		<x path="Int"/>
		<meta><m n=":impl"/></meta>
	</blue>
	<green public="1" get="accessor" set="accessor" static="1">
		<x path="Int"/>
		<meta><m n=":impl"/></meta>
	</green>
	<alpha public="1" get="accessor" set="accessor" static="1">
		<x path="Int"/>
		<meta><m n=":impl"/></meta>
	</alpha>
	<redFloat public="1" get="accessor" set="accessor" static="1">
		<x path="Float"/>
		<meta><m n=":impl"/></meta>
	</redFloat>
	<blueFloat public="1" get="accessor" set="accessor" static="1">
		<x path="Float"/>
		<meta><m n=":impl"/></meta>
	</blueFloat>
	<greenFloat public="1" get="accessor" set="accessor" static="1">
		<x path="Float"/>
		<meta><m n=":impl"/></meta>
	</greenFloat>
	<alphaFloat public="1" get="accessor" set="accessor" static="1">
		<x path="Float"/>
		<meta><m n=":impl"/></meta>
	</alphaFloat>
	<cyan public="1" get="accessor" set="accessor" static="1">
		<x path="Float"/>
		<meta><m n=":impl"/></meta>
	</cyan>
	<magenta public="1" get="accessor" set="accessor" static="1">
		<x path="Float"/>
		<meta><m n=":impl"/></meta>
	</magenta>
	<yellow public="1" get="accessor" set="accessor" static="1">
		<x path="Float"/>
		<meta><m n=":impl"/></meta>
	</yellow>
	<black public="1" get="accessor" set="accessor" static="1">
		<x path="Float"/>
		<meta><m n=":impl"/></meta>
	</black>
	<hue public="1" get="accessor" set="accessor" static="1">
		<x path="Float"/>
		<meta><m n=":impl"/></meta>
		<haxe_doc>* The hue of the color in degrees (from 0 to 359)</haxe_doc>
	</hue>
	<saturation public="1" get="accessor" set="accessor" static="1">
		<x path="Float"/>
		<meta><m n=":impl"/></meta>
		<haxe_doc>* The saturation of the color (from 0 to 1)</haxe_doc>
	</saturation>
	<brightness public="1" get="accessor" set="accessor" static="1">
		<x path="Float"/>
		<meta><m n=":impl"/></meta>
		<haxe_doc>* The brightness (aka value) of the color (from 0 to 1)</haxe_doc>
	</brightness>
	<lightness public="1" get="accessor" set="accessor" static="1">
		<x path="Float"/>
		<meta><m n=":impl"/></meta>
		<haxe_doc>* The lightness of the color (from 0 to 1)</haxe_doc>
	</lightness>
	<COLOR_REGEX expr="~/^(0x|#)(([A-F0-9]{2}){3,4})$/" line="76" static="1">
		<c path="EReg"/>
		<meta><m n=":value"><e>~/^(0x|#)(([A-F0-9]{2}){3,4})$/</e></m></meta>
	</COLOR_REGEX>
	<fromInt public="1" get="inline" set="null" line="84" static="1">
		<f a="Value">
			<x path="Int"/>
			<x path="flixel.util.FlxColor"/>
		</f>
		<haxe_doc>* Create a color from the least significant four bytes of an Int
	 * 
	 * @param	Value And Int with bytes in the format 0xAARRGGBB
	 * @return	The color as a FlxColor</haxe_doc>
	</fromInt>
	<fromRGB public="1" get="inline" set="null" line="98" static="1">
		<f a="Red:Green:Blue:?Alpha" v=":::255">
			<x path="Int"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="flixel.util.FlxColor"/>
		</f>
		<meta><m n=":value"><e>{ Alpha : 255 }</e></m></meta>
		<haxe_doc>* Generate a color from integer RGB values (0 to 255)
	 * 
	 * @param Red	The red value of the color from 0 to 255
	 * @param Green	The green value of the color from 0 to 255
	 * @param Blue	The green value of the color from 0 to 255
	 * @param Alpha	How opaque the color should be, from 0 to 255
	 * @return The color as a FlxColor</haxe_doc>
	</fromRGB>
	<fromRGBFloat public="1" get="inline" set="null" line="113" static="1">
		<f a="Red:Green:Blue:?Alpha" v=":::1">
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="flixel.util.FlxColor"/>
		</f>
		<meta><m n=":value"><e>{ Alpha : 1 }</e></m></meta>
		<haxe_doc>* Generate a color from float RGB values (0 to 1)
	 * 
	 * @param Red	The red value of the color from 0 to 1
	 * @param Green	The green value of the color from 0 to 1
	 * @param Blue	The green value of the color from 0 to 1
	 * @param Alpha	How opaque the color should be, from 0 to 1
	 * @return The color as a FlxColor</haxe_doc>
	</fromRGBFloat>
	<fromCMYK public="1" get="inline" set="null" line="129" static="1">
		<f a="Cyan:Magenta:Yellow:Black:?Alpha" v="::::1">
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="flixel.util.FlxColor"/>
		</f>
		<meta><m n=":value"><e>{ Alpha : 1 }</e></m></meta>
		<haxe_doc>* Generate a color from CMYK values (0 to 1)
	 * 
	 * @param Cyan		The cyan value of the color from 0 to 1
	 * @param Magenta	The magenta value of the color from 0 to 1
	 * @param Yellow	The yellow value of the color from 0 to 1
	 * @param Black		The black value of the color from 0 to 1
	 * @param Alpha		How opaque the color should be, from 0 to 1
	 * @return The color as a FlxColor</haxe_doc>
	</fromCMYK>
	<fromHSB public="1" set="method" line="144" static="1">
		<f a="Hue:Saturation:Brightness:?Alpha" v=":::1">
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="flixel.util.FlxColor"/>
		</f>
		<meta><m n=":value"><e>{ Alpha : 1 }</e></m></meta>
		<haxe_doc>* Generate a color from HSB (aka HSV) components.
	 * 
	 * @param	Hue			A number between 0 and 360, indicating position on a color strip or wheel.
	 * @param	Saturation	A number between 0 and 1, indicating how colorful or gray the color should be.  0 is gray, 1 is vibrant.
	 * @param	Brightness	(aka Value) A number between 0 and 1, indicating how bright the color should be.  0 is black, 1 is full bright.
	 * @param	Alpha		How opaque the color should be, either between 0 and 1 or 0 and 255.
	 * @return	The color as a FlxColor</haxe_doc>
	</fromHSB>
	<fromHSL public="1" get="inline" set="null" line="159" static="1">
		<f a="Hue:Saturation:Lightness:?Alpha" v=":::1">
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="flixel.util.FlxColor"/>
		</f>
		<meta><m n=":value"><e>{ Alpha : 1 }</e></m></meta>
		<haxe_doc>* Generate a color from HSL components.
	 * 
	 * @param	Hue			A number between 0 and 360, indicating position on a color strip or wheel.
	 * @param	Saturation	A number between 0 and 1, indicating how colorful or gray the color should be.  0 is gray, 1 is vibrant.
	 * @param	Lightness	A number between 0 and 1, indicating the lightness of the color
	 * @param	Alpha		How opaque the color should be, either between 0 and 1 or 0 and 255.
	 * @return	The color as a FlxColor</haxe_doc>
	</fromHSL>
	<fromString public="1" set="method" line="180" static="1">
		<f a="str">
			<c path="String"/>
			<t path="Null"><x path="flixel.util.FlxColor"/></t>
		</f>
		<haxe_doc><![CDATA[* Parses a `String` and returns a `FlxColor` or `null` if the `String` couldn't be parsed.
	 * 
	 * Examples (input -> output in hex):
	 * 
	 * - `0x00FF00`    -> `0xFF00FF00`
	 * - `0xAA4578C2`  -> `0xAA4578C2`
	 * - `#0000FF`     -> `0xFF0000FF`
	 * - `#3F000011`   -> `0x3F000011`
	 * - `GRAY`        -> `0xFF808080`
	 * - `blue`        -> `0xFF0000FF`
	 * 
	 * @param	str 	The string to be parsed
	 * @return	A `FlxColor` or `null` if the `String` couldn't be parsed]]></haxe_doc>
	</fromString>
	<getHSBColorWheel public="1" set="method" line="216" static="1">
		<f a="?Alpha" v="255">
			<x path="Int"/>
			<c path="Array"><x path="flixel.util.FlxColor"/></c>
		</f>
		<meta><m n=":value"><e>{ Alpha : 255 }</e></m></meta>
		<haxe_doc>* Get HSB color wheel values in an array which will be 360 elements in size
	 * 
	 * @param	Alpha Alpha value for each color of the color wheel, between 0 (transparent) and 255 (opaque)
	 * @return	HSB color wheel as Array of FlxColors</haxe_doc>
	</getHSBColorWheel>
	<interpolate public="1" get="inline" set="null" line="229" static="1">
		<f a="Color1:Color2:?Factor" v="::0.5">
			<x path="flixel.util.FlxColor"/>
			<x path="flixel.util.FlxColor"/>
			<x path="Float"/>
			<x path="flixel.util.FlxColor"/>
		</f>
		<meta><m n=":value"><e>{ Factor : 0.5 }</e></m></meta>
		<haxe_doc>* Get an interpolated color based on two different colors.
	 * 
	 * @param 	Color1 The first color
	 * @param 	Color2 The second color
	 * @param 	Factor Value from 0 to 1 representing how much to shift Color1 toward Color2
	 * @return	The interpolated color</haxe_doc>
	</interpolate>
	<gradient public="1" set="method" line="248" static="1">
		<f a="Color1:Color2:Steps:?Ease">
			<x path="flixel.util.FlxColor"/>
			<x path="flixel.util.FlxColor"/>
			<x path="Int"/>
			<f a="">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<c path="Array"><x path="flixel.util.FlxColor"/></c>
		</f>
		<haxe_doc>* Create a gradient from one color to another
	 * 
	 * @param Color1 The color to shift from
	 * @param Color2 The color to shift to
	 * @param Steps How many colors the gradient should have
	 * @param Ease An optional easing function, such as those provided in FlxEase
	 * @return An array of colors of length Steps, shifting from Color1 to Color2</haxe_doc>
	</gradient>
	<multiply public="1" get="inline" set="null" line="272" static="1">
		<f a="lhs:rhs">
			<x path="flixel.util.FlxColor"/>
			<x path="flixel.util.FlxColor"/>
			<x path="flixel.util.FlxColor"/>
		</f>
		<meta><m n=":op"><e>A * B</e></m></meta>
		<haxe_doc>* Multiply the RGB channels of two FlxColors</haxe_doc>
	</multiply>
	<add public="1" get="inline" set="null" line="281" static="1">
		<f a="lhs:rhs">
			<x path="flixel.util.FlxColor"/>
			<x path="flixel.util.FlxColor"/>
			<x path="flixel.util.FlxColor"/>
		</f>
		<meta><m n=":op"><e>A + B</e></m></meta>
		<haxe_doc>* Add the RGB channels of two FlxColors</haxe_doc>
	</add>
	<subtract public="1" get="inline" set="null" line="290" static="1">
		<f a="lhs:rhs">
			<x path="flixel.util.FlxColor"/>
			<x path="flixel.util.FlxColor"/>
			<x path="flixel.util.FlxColor"/>
		</f>
		<meta><m n=":op"><e>A - B</e></m></meta>
		<haxe_doc>* Subtract the RGB channels of one FlxColor from another</haxe_doc>
	</subtract>
	<getComplementHarmony public="1" get="inline" set="null" line="301" static="1">
		<f a="this">
			<x path="Int"/>
			<x path="flixel.util.FlxColor"/>
		</f>
		<meta><m n=":impl"/></meta>
		<haxe_doc>* Returns a Complementary Color Harmony of this color.
	 * A complementary hue is one directly opposite the color given on the color wheel
	 * 
	 * @return	The complimentary color</haxe_doc>
	</getComplementHarmony>
	<getAnalogousHarmony public="1" get="inline" set="null" line="313" static="1">
		<f a="this:?Threshold" v=":30">
			<x path="Int"/>
			<x path="Int"/>
			<t path="flixel.util.Harmony"/>
		</f>
		<meta>
			<m n=":value"><e>{ Threshold : 30 }</e></m>
			<m n=":impl"/>
		</meta>
		<haxe_doc>* Returns an Analogous Color Harmony for the given color.
	 * An Analogous harmony are hues adjacent to each other on the color wheel
	 * 
	 * @param	Threshold Control how adjacent the colors will be (default +- 30 degrees)
	 * @return 	Object containing 3 properties: original (the original color), warmer (the warmer analogous color) and colder (the colder analogous color)</haxe_doc>
	</getAnalogousHarmony>
	<getSplitComplementHarmony public="1" get="inline" set="null" line="328" static="1">
		<f a="this:?Threshold" v=":30">
			<x path="Int"/>
			<x path="Int"/>
			<t path="flixel.util.Harmony"/>
		</f>
		<meta>
			<m n=":value"><e>{ Threshold : 30 }</e></m>
			<m n=":impl"/>
		</meta>
		<haxe_doc>* Returns an Split Complement Color Harmony for this color.
	 * A Split Complement harmony are the two hues on either side of the color's Complement
	 * 
	 * @param	Threshold Control how adjacent the colors will be to the Complement (default +- 30 degrees)
	 * @return 	Object containing 3 properties: original (the original color), warmer (the warmer analogous color) and colder (the colder analogous color)</haxe_doc>
	</getSplitComplementHarmony>
	<getTriadicHarmony public="1" get="inline" set="null" line="343" static="1">
		<f a="this">
			<x path="Int"/>
			<t path="flixel.util.TriadicHarmony"/>
		</f>
		<meta><m n=":impl"/></meta>
		<haxe_doc>* Returns a Triadic Color Harmony for this color. A Triadic harmony are 3 hues equidistant 
	 * from each other on the color wheel.
	 * 
	 * @return 	Object containing 3 properties: color1 (the original color), color2 and color3 (the equidistant colors)</haxe_doc>
	</getTriadicHarmony>
	<to24Bit public="1" get="inline" set="null" line="356" static="1">
		<f a="this">
			<x path="Int"/>
			<x path="flixel.util.FlxColor"/>
		</f>
		<meta><m n=":impl"/></meta>
		<haxe_doc>* Return a 24 bit version of this color (i.e. without an alpha value)
	 * 
	 * @return A 24 bit version of this color</haxe_doc>
	</to24Bit>
	<toHexString public="1" get="inline" set="null" line="368" static="1">
		<f a="this:?Alpha:?Prefix" v=":true:true">
			<x path="Int"/>
			<x path="Bool"/>
			<x path="Bool"/>
			<c path="String"/>
		</f>
		<meta>
			<m n=":value"><e>{ Prefix : true, Alpha : true }</e></m>
			<m n=":impl"/>
		</meta>
		<haxe_doc>* Return a String representation of the color in the format
	 * 
	 * @param Alpha Whether to include the alpha value in the hes string
	 * @param Prefix Whether to include "0x" prefix at start of string
	 * @return	A string of length 10 in the format 0xAARRGGBB</haxe_doc>
	</toHexString>
	<toWebString public="1" get="inline" set="null" line="379" static="1">
		<f a="this">
			<x path="Int"/>
			<c path="String"/>
		</f>
		<meta><m n=":impl"/></meta>
		<haxe_doc>* Return a String representation of the color in the format #RRGGBB
	 * 
	 * @return	A string of length 7 in the format #RRGGBB</haxe_doc>
	</toWebString>
	<getColorInfo public="1" set="method" line="389" static="1">
		<f a="this">
			<x path="Int"/>
			<c path="String"/>
		</f>
		<meta><m n=":impl"/></meta>
		<haxe_doc>* Get a string of color information about this color
	 * 
	 * @return A string containing information about this color</haxe_doc>
	</getColorInfo>
	<getDarkened public="1" set="method" line="408" static="1">
		<f a="this:?Factor" v=":0.2">
			<x path="Int"/>
			<x path="Float"/>
			<x path="flixel.util.FlxColor"/>
		</f>
		<meta>
			<m n=":value"><e>{ Factor : 0.2 }</e></m>
			<m n=":impl"/>
		</meta>
		<haxe_doc>* Get a darkened version of this color
	 * 
	 * @param	Factor Value from 0 to 1 of how much to progress toward black.
	 * @return 	A darkened version of this color</haxe_doc>
	</getDarkened>
	<getLightened public="1" get="inline" set="null" line="422" static="1">
		<f a="this:?Factor" v=":0.2">
			<x path="Int"/>
			<x path="Float"/>
			<x path="flixel.util.FlxColor"/>
		</f>
		<meta>
			<m n=":value"><e>{ Factor : 0.2 }</e></m>
			<m n=":impl"/>
		</meta>
		<haxe_doc>* Get a lightened version of this color
	 * 
	 * @param	Factor Value from 0 to 1 of how much to progress toward white.
	 * @return 	A lightened version of this color</haxe_doc>
	</getLightened>
	<getInverted public="1" get="inline" set="null" line="435" static="1">
		<f a="this">
			<x path="Int"/>
			<x path="flixel.util.FlxColor"/>
		</f>
		<meta><m n=":impl"/></meta>
		<haxe_doc>* Get the inversion of this color
	 * 
	 * @return The inversion of this color</haxe_doc>
	</getInverted>
	<setRGB public="1" get="inline" set="null" line="452" static="1">
		<f a="this:Red:Green:Blue:?Alpha" v="::::255">
			<x path="Int"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="flixel.util.FlxColor"/>
		</f>
		<meta>
			<m n=":value"><e>{ Alpha : 255 }</e></m>
			<m n=":impl"/>
		</meta>
		<haxe_doc>* Set RGB values as integers (0 to 255)
	 * 
	 * @param Red	The red value of the color from 0 to 255
	 * @param Green	The green value of the color from 0 to 255
	 * @param Blue	The green value of the color from 0 to 255
	 * @param Alpha	How opaque the color should be, from 0 to 255
	 * @return This color</haxe_doc>
	</setRGB>
	<setRGBFloat public="1" get="inline" set="null" line="470" static="1">
		<f a="this:Red:Green:Blue:?Alpha" v="::::1">
			<x path="Int"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="flixel.util.FlxColor"/>
		</f>
		<meta>
			<m n=":value"><e>{ Alpha : 1 }</e></m>
			<m n=":impl"/>
		</meta>
		<haxe_doc>* Set RGB values as floats (0 to 1)
	 * 
	 * @param Red	The red value of the color from 0 to 1
	 * @param Green	The green value of the color from 0 to 1
	 * @param Blue	The green value of the color from 0 to 1
	 * @param Alpha	How opaque the color should be, from 0 to 1
	 * @return This color</haxe_doc>
	</setRGBFloat>
	<setCMYK public="1" get="inline" set="null" line="489" static="1">
		<f a="this:Cyan:Magenta:Yellow:Black:?Alpha" v=":::::1">
			<x path="Int"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="flixel.util.FlxColor"/>
		</f>
		<meta>
			<m n=":value"><e>{ Alpha : 1 }</e></m>
			<m n=":impl"/>
		</meta>
		<haxe_doc>* Set CMYK values as floats (0 to 1)
	 * 
	 * @param Cyan		The cyan value of the color from 0 to 1
	 * @param Magenta	The magenta value of the color from 0 to 1
	 * @param Yellow	The yellow value of the color from 0 to 1
	 * @param Black		The black value of the color from 0 to 1
	 * @param Alpha		How opaque the color should be, from 0 to 1
	 * @return This color</haxe_doc>
	</setCMYK>
	<setHSB public="1" get="inline" set="null" line="507" static="1">
		<f a="this:Hue:Saturation:Brightness:Alpha">
			<x path="Int"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="flixel.util.FlxColor"/>
		</f>
		<meta><m n=":impl"/></meta>
		<haxe_doc>* Set HSB (aka HSV) components
	 * 
	 * @param	Hue			A number between 0 and 360, indicating position on a color strip or wheel.
	 * @param	Saturation	A number between 0 and 1, indicating how colorful or gray the color should be.  0 is gray, 1 is vibrant.
	 * @param	Brightness	(aka Value) A number between 0 and 1, indicating how bright the color should be.  0 is black, 1 is full bright.
	 * @param	Alpha		How opaque the color should be, either between 0 and 1 or 0 and 255.
	 * @return	This color</haxe_doc>
	</setHSB>
	<setHSL public="1" get="inline" set="null" line="523" static="1">
		<f a="this:Hue:Saturation:Lightness:Alpha">
			<x path="Int"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="flixel.util.FlxColor"/>
		</f>
		<meta><m n=":impl"/></meta>
		<haxe_doc>* Set HSL components.
	 * 
	 * @param	Hue			A number between 0 and 360, indicating position on a color strip or wheel.
	 * @param	Saturation	A number between 0 and 1, indicating how colorful or gray the color should be.  0 is gray, 1 is vibrant.
	 * @param	Lightness	A number between 0 and 1, indicating the lightness of the color
	 * @param	Alpha		How opaque the color should be, either between 0 and 1 or 0 and 255
	 * @return	This color</haxe_doc>
	</setHSL>
	<setHSChromaMatch get="inline" set="null" line="533" static="1">
		<f a="this:Hue:Saturation:Chroma:Match:Alpha">
			<x path="Int"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="flixel.util.FlxColor"/>
		</f>
		<meta><m n=":impl"/></meta>
		<haxe_doc>* Private utility function to perform common operations between setHSB and setHSL</haxe_doc>
	</setHSChromaMatch>
	<_new public="1" set="method" line="553" static="1">
		<f a="?Value" v="0">
			<x path="Int"/>
			<x path="flixel.util.FlxColor"/>
		</f>
		<meta>
			<m n=":value"><e>{ Value : 0 }</e></m>
			<m n=":impl"/>
		</meta>
	</_new>
	<getThis get="inline" set="null" line="558" static="1">
		<f a="this">
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<meta><m n=":impl"/></meta>
	</getThis>
	<validate get="inline" set="null" line="567" static="1">
		<f a="this">
			<x path="Int"/>
			<x path="Void"/>
		</f>
		<meta><m n=":impl"/></meta>
	</validate>
	<get_red get="inline" set="null" line="574" static="1">
		<f a="this">
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_red>
	<get_green get="inline" set="null" line="579" static="1">
		<f a="this">
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_green>
	<get_blue get="inline" set="null" line="584" static="1">
		<f a="this">
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_blue>
	<get_alpha get="inline" set="null" line="589" static="1">
		<f a="this">
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_alpha>
	<get_redFloat get="inline" set="null" line="594" static="1">
		<f a="this">
			<x path="Int"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_redFloat>
	<get_greenFloat get="inline" set="null" line="599" static="1">
		<f a="this">
			<x path="Int"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_greenFloat>
	<get_blueFloat get="inline" set="null" line="604" static="1">
		<f a="this">
			<x path="Int"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_blueFloat>
	<get_alphaFloat get="inline" set="null" line="609" static="1">
		<f a="this">
			<x path="Int"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_alphaFloat>
	<set_red get="inline" set="null" line="614" static="1">
		<f a="this:Value">
			<x path="Int"/>
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<meta><m n=":impl"/></meta>
	</set_red>
	<set_green get="inline" set="null" line="622" static="1">
		<f a="this:Value">
			<x path="Int"/>
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<meta><m n=":impl"/></meta>
	</set_green>
	<set_blue get="inline" set="null" line="630" static="1">
		<f a="this:Value">
			<x path="Int"/>
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<meta><m n=":impl"/></meta>
	</set_blue>
	<set_alpha get="inline" set="null" line="638" static="1">
		<f a="this:Value">
			<x path="Int"/>
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<meta><m n=":impl"/></meta>
	</set_alpha>
	<set_redFloat get="inline" set="null" line="646" static="1">
		<f a="this:Value">
			<x path="Int"/>
			<x path="Float"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</set_redFloat>
	<set_greenFloat get="inline" set="null" line="652" static="1">
		<f a="this:Value">
			<x path="Int"/>
			<x path="Float"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</set_greenFloat>
	<set_blueFloat get="inline" set="null" line="658" static="1">
		<f a="this:Value">
			<x path="Int"/>
			<x path="Float"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</set_blueFloat>
	<set_alphaFloat get="inline" set="null" line="664" static="1">
		<f a="this:Value">
			<x path="Int"/>
			<x path="Float"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</set_alphaFloat>
	<get_cyan get="inline" set="null" line="670" static="1">
		<f a="this">
			<x path="Int"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_cyan>
	<get_magenta get="inline" set="null" line="675" static="1">
		<f a="this">
			<x path="Int"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_magenta>
	<get_yellow get="inline" set="null" line="680" static="1">
		<f a="this">
			<x path="Int"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_yellow>
	<get_black get="inline" set="null" line="685" static="1">
		<f a="this">
			<x path="Int"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_black>
	<set_cyan get="inline" set="null" line="690" static="1">
		<f a="this:Value">
			<x path="Int"/>
			<x path="Float"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</set_cyan>
	<set_magenta get="inline" set="null" line="696" static="1">
		<f a="this:Value">
			<x path="Int"/>
			<x path="Float"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</set_magenta>
	<set_yellow get="inline" set="null" line="702" static="1">
		<f a="this:Value">
			<x path="Int"/>
			<x path="Float"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</set_yellow>
	<set_black get="inline" set="null" line="708" static="1">
		<f a="this:Value">
			<x path="Int"/>
			<x path="Float"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</set_black>
	<get_hue set="method" line="714" static="1">
		<f a="this">
			<x path="Int"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_hue>
	<get_brightness get="inline" set="null" line="726" static="1">
		<f a="this">
			<x path="Int"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_brightness>
	<get_saturation get="inline" set="null" line="731" static="1">
		<f a="this">
			<x path="Int"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_saturation>
	<get_lightness get="inline" set="null" line="736" static="1">
		<f a="this">
			<x path="Int"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_lightness>
	<set_hue get="inline" set="null" line="741" static="1">
		<f a="this:Value">
			<x path="Int"/>
			<x path="Float"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</set_hue>
	<set_saturation get="inline" set="null" line="747" static="1">
		<f a="this:Value">
			<x path="Int"/>
			<x path="Float"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</set_saturation>
	<set_brightness get="inline" set="null" line="753" static="1">
		<f a="this:Value">
			<x path="Int"/>
			<x path="Float"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</set_brightness>
	<set_lightness get="inline" set="null" line="759" static="1">
		<f a="this:Value">
			<x path="Int"/>
			<x path="Float"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</set_lightness>
	<maxColor get="inline" set="null" line="765" static="1">
		<f a="this">
			<x path="Int"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</maxColor>
	<minColor get="inline" set="null" line="770" static="1">
		<f a="this">
			<x path="Int"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</minColor>
	<boundChannel get="inline" set="null" line="775" static="1">
		<f a="this:Value">
			<x path="Int"/>
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<meta><m n=":impl"/></meta>
	</boundChannel>
	<meta>
		<m n=":directlyUsed"/>
		<m n=":final"/>
	</meta>
</class></impl>
	</abstract>
	<class path="flixel.util._FlxColor.FlxColor_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/util/FlxColor.hx" private="1" module="flixel.util.FlxColor">
		<TRANSPARENT public="1" get="inline" set="null" expr="0x00000000" line="20" static="1">
			<x path="flixel.util.FlxColor"/>
			<meta><m n=":value"><e>0x00000000</e></m></meta>
		</TRANSPARENT>
		<WHITE public="1" get="inline" set="null" expr="0xFFFFFFFF" line="21" static="1">
			<x path="flixel.util.FlxColor"/>
			<meta><m n=":value"><e>0xFFFFFFFF</e></m></meta>
		</WHITE>
		<GRAY public="1" get="inline" set="null" expr="0xFF808080" line="22" static="1">
			<x path="flixel.util.FlxColor"/>
			<meta><m n=":value"><e>0xFF808080</e></m></meta>
		</GRAY>
		<BLACK public="1" get="inline" set="null" expr="0xFF000000" line="23" static="1">
			<x path="flixel.util.FlxColor"/>
			<meta><m n=":value"><e>0xFF000000</e></m></meta>
		</BLACK>
		<GREEN public="1" get="inline" set="null" expr="0xFF008000" line="25" static="1">
			<x path="flixel.util.FlxColor"/>
			<meta><m n=":value"><e>0xFF008000</e></m></meta>
		</GREEN>
		<LIME public="1" get="inline" set="null" expr="0xFF00FF00" line="26" static="1">
			<x path="flixel.util.FlxColor"/>
			<meta><m n=":value"><e>0xFF00FF00</e></m></meta>
		</LIME>
		<YELLOW public="1" get="inline" set="null" expr="0xFFFFFF00" line="27" static="1">
			<x path="flixel.util.FlxColor"/>
			<meta><m n=":value"><e>0xFFFFFF00</e></m></meta>
		</YELLOW>
		<ORANGE public="1" get="inline" set="null" expr="0xFFFFA500" line="28" static="1">
			<x path="flixel.util.FlxColor"/>
			<meta><m n=":value"><e>0xFFFFA500</e></m></meta>
		</ORANGE>
		<RED public="1" get="inline" set="null" expr="0xFFFF0000" line="29" static="1">
			<x path="flixel.util.FlxColor"/>
			<meta><m n=":value"><e>0xFFFF0000</e></m></meta>
		</RED>
		<PURPLE public="1" get="inline" set="null" expr="0xFF800080" line="30" static="1">
			<x path="flixel.util.FlxColor"/>
			<meta><m n=":value"><e>0xFF800080</e></m></meta>
		</PURPLE>
		<BLUE public="1" get="inline" set="null" expr="0xFF0000FF" line="31" static="1">
			<x path="flixel.util.FlxColor"/>
			<meta><m n=":value"><e>0xFF0000FF</e></m></meta>
		</BLUE>
		<BROWN public="1" get="inline" set="null" expr="0xFF8B4513" line="32" static="1">
			<x path="flixel.util.FlxColor"/>
			<meta><m n=":value"><e>0xFF8B4513</e></m></meta>
		</BROWN>
		<PINK public="1" get="inline" set="null" expr="0xFFFFC0CB" line="33" static="1">
			<x path="flixel.util.FlxColor"/>
			<meta><m n=":value"><e>0xFFFFC0CB</e></m></meta>
		</PINK>
		<MAGENTA public="1" get="inline" set="null" expr="0xFFFF00FF" line="34" static="1">
			<x path="flixel.util.FlxColor"/>
			<meta><m n=":value"><e>0xFFFF00FF</e></m></meta>
		</MAGENTA>
		<CYAN public="1" get="inline" set="null" expr="0xFF00FFFF" line="35" static="1">
			<x path="flixel.util.FlxColor"/>
			<meta><m n=":value"><e>0xFF00FFFF</e></m></meta>
		</CYAN>
		<colorLookup public="1" set="null" expr="FlxMacroUtil.buildMap(&quot;flixel.util.FlxColor&quot;)" line="53" static="1">
			<x path="Map">
				<c path="String"/>
				<x path="Int"/>
			</x>
			<meta><m n=":value"><e>FlxMacroUtil.buildMap("flixel.util.FlxColor")</e></m></meta>
			<haxe_doc><![CDATA[* A `Map<String, Int>` whose values are the static colors of `FlxColor`.
	 * You can add more colors for `FlxColor.fromString(String)` if you need.]]></haxe_doc>
		</colorLookup>
		<red public="1" get="accessor" set="accessor" static="1">
			<x path="Int"/>
			<meta><m n=":impl"/></meta>
		</red>
		<blue public="1" get="accessor" set="accessor" static="1">
			<x path="Int"/>
			<meta><m n=":impl"/></meta>
		</blue>
		<green public="1" get="accessor" set="accessor" static="1">
			<x path="Int"/>
			<meta><m n=":impl"/></meta>
		</green>
		<alpha public="1" get="accessor" set="accessor" static="1">
			<x path="Int"/>
			<meta><m n=":impl"/></meta>
		</alpha>
		<redFloat public="1" get="accessor" set="accessor" static="1">
			<x path="Float"/>
			<meta><m n=":impl"/></meta>
		</redFloat>
		<blueFloat public="1" get="accessor" set="accessor" static="1">
			<x path="Float"/>
			<meta><m n=":impl"/></meta>
		</blueFloat>
		<greenFloat public="1" get="accessor" set="accessor" static="1">
			<x path="Float"/>
			<meta><m n=":impl"/></meta>
		</greenFloat>
		<alphaFloat public="1" get="accessor" set="accessor" static="1">
			<x path="Float"/>
			<meta><m n=":impl"/></meta>
		</alphaFloat>
		<cyan public="1" get="accessor" set="accessor" static="1">
			<x path="Float"/>
			<meta><m n=":impl"/></meta>
		</cyan>
		<magenta public="1" get="accessor" set="accessor" static="1">
			<x path="Float"/>
			<meta><m n=":impl"/></meta>
		</magenta>
		<yellow public="1" get="accessor" set="accessor" static="1">
			<x path="Float"/>
			<meta><m n=":impl"/></meta>
		</yellow>
		<black public="1" get="accessor" set="accessor" static="1">
			<x path="Float"/>
			<meta><m n=":impl"/></meta>
		</black>
		<hue public="1" get="accessor" set="accessor" static="1">
			<x path="Float"/>
			<meta><m n=":impl"/></meta>
			<haxe_doc>* The hue of the color in degrees (from 0 to 359)</haxe_doc>
		</hue>
		<saturation public="1" get="accessor" set="accessor" static="1">
			<x path="Float"/>
			<meta><m n=":impl"/></meta>
			<haxe_doc>* The saturation of the color (from 0 to 1)</haxe_doc>
		</saturation>
		<brightness public="1" get="accessor" set="accessor" static="1">
			<x path="Float"/>
			<meta><m n=":impl"/></meta>
			<haxe_doc>* The brightness (aka value) of the color (from 0 to 1)</haxe_doc>
		</brightness>
		<lightness public="1" get="accessor" set="accessor" static="1">
			<x path="Float"/>
			<meta><m n=":impl"/></meta>
			<haxe_doc>* The lightness of the color (from 0 to 1)</haxe_doc>
		</lightness>
		<COLOR_REGEX expr="~/^(0x|#)(([A-F0-9]{2}){3,4})$/" line="76" static="1">
			<c path="EReg"/>
			<meta><m n=":value"><e>~/^(0x|#)(([A-F0-9]{2}){3,4})$/</e></m></meta>
		</COLOR_REGEX>
		<fromInt public="1" get="inline" set="null" line="84" static="1">
			<f a="Value">
				<x path="Int"/>
				<x path="flixel.util.FlxColor"/>
			</f>
			<haxe_doc>* Create a color from the least significant four bytes of an Int
	 * 
	 * @param	Value And Int with bytes in the format 0xAARRGGBB
	 * @return	The color as a FlxColor</haxe_doc>
		</fromInt>
		<fromRGB public="1" get="inline" set="null" line="98" static="1">
			<f a="Red:Green:Blue:?Alpha" v=":::255">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="flixel.util.FlxColor"/>
			</f>
			<meta><m n=":value"><e>{ Alpha : 255 }</e></m></meta>
			<haxe_doc>* Generate a color from integer RGB values (0 to 255)
	 * 
	 * @param Red	The red value of the color from 0 to 255
	 * @param Green	The green value of the color from 0 to 255
	 * @param Blue	The green value of the color from 0 to 255
	 * @param Alpha	How opaque the color should be, from 0 to 255
	 * @return The color as a FlxColor</haxe_doc>
		</fromRGB>
		<fromRGBFloat public="1" get="inline" set="null" line="113" static="1">
			<f a="Red:Green:Blue:?Alpha" v=":::1">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="flixel.util.FlxColor"/>
			</f>
			<meta><m n=":value"><e>{ Alpha : 1 }</e></m></meta>
			<haxe_doc>* Generate a color from float RGB values (0 to 1)
	 * 
	 * @param Red	The red value of the color from 0 to 1
	 * @param Green	The green value of the color from 0 to 1
	 * @param Blue	The green value of the color from 0 to 1
	 * @param Alpha	How opaque the color should be, from 0 to 1
	 * @return The color as a FlxColor</haxe_doc>
		</fromRGBFloat>
		<fromCMYK public="1" get="inline" set="null" line="129" static="1">
			<f a="Cyan:Magenta:Yellow:Black:?Alpha" v="::::1">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="flixel.util.FlxColor"/>
			</f>
			<meta><m n=":value"><e>{ Alpha : 1 }</e></m></meta>
			<haxe_doc>* Generate a color from CMYK values (0 to 1)
	 * 
	 * @param Cyan		The cyan value of the color from 0 to 1
	 * @param Magenta	The magenta value of the color from 0 to 1
	 * @param Yellow	The yellow value of the color from 0 to 1
	 * @param Black		The black value of the color from 0 to 1
	 * @param Alpha		How opaque the color should be, from 0 to 1
	 * @return The color as a FlxColor</haxe_doc>
		</fromCMYK>
		<fromHSB public="1" set="method" line="144" static="1">
			<f a="Hue:Saturation:Brightness:?Alpha" v=":::1">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="flixel.util.FlxColor"/>
			</f>
			<meta><m n=":value"><e>{ Alpha : 1 }</e></m></meta>
			<haxe_doc>* Generate a color from HSB (aka HSV) components.
	 * 
	 * @param	Hue			A number between 0 and 360, indicating position on a color strip or wheel.
	 * @param	Saturation	A number between 0 and 1, indicating how colorful or gray the color should be.  0 is gray, 1 is vibrant.
	 * @param	Brightness	(aka Value) A number between 0 and 1, indicating how bright the color should be.  0 is black, 1 is full bright.
	 * @param	Alpha		How opaque the color should be, either between 0 and 1 or 0 and 255.
	 * @return	The color as a FlxColor</haxe_doc>
		</fromHSB>
		<fromHSL public="1" get="inline" set="null" line="159" static="1">
			<f a="Hue:Saturation:Lightness:?Alpha" v=":::1">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="flixel.util.FlxColor"/>
			</f>
			<meta><m n=":value"><e>{ Alpha : 1 }</e></m></meta>
			<haxe_doc>* Generate a color from HSL components.
	 * 
	 * @param	Hue			A number between 0 and 360, indicating position on a color strip or wheel.
	 * @param	Saturation	A number between 0 and 1, indicating how colorful or gray the color should be.  0 is gray, 1 is vibrant.
	 * @param	Lightness	A number between 0 and 1, indicating the lightness of the color
	 * @param	Alpha		How opaque the color should be, either between 0 and 1 or 0 and 255.
	 * @return	The color as a FlxColor</haxe_doc>
		</fromHSL>
		<fromString public="1" set="method" line="180" static="1">
			<f a="str">
				<c path="String"/>
				<t path="Null"><x path="flixel.util.FlxColor"/></t>
			</f>
			<haxe_doc><![CDATA[* Parses a `String` and returns a `FlxColor` or `null` if the `String` couldn't be parsed.
	 * 
	 * Examples (input -> output in hex):
	 * 
	 * - `0x00FF00`    -> `0xFF00FF00`
	 * - `0xAA4578C2`  -> `0xAA4578C2`
	 * - `#0000FF`     -> `0xFF0000FF`
	 * - `#3F000011`   -> `0x3F000011`
	 * - `GRAY`        -> `0xFF808080`
	 * - `blue`        -> `0xFF0000FF`
	 * 
	 * @param	str 	The string to be parsed
	 * @return	A `FlxColor` or `null` if the `String` couldn't be parsed]]></haxe_doc>
		</fromString>
		<getHSBColorWheel public="1" set="method" line="216" static="1">
			<f a="?Alpha" v="255">
				<x path="Int"/>
				<c path="Array"><x path="flixel.util.FlxColor"/></c>
			</f>
			<meta><m n=":value"><e>{ Alpha : 255 }</e></m></meta>
			<haxe_doc>* Get HSB color wheel values in an array which will be 360 elements in size
	 * 
	 * @param	Alpha Alpha value for each color of the color wheel, between 0 (transparent) and 255 (opaque)
	 * @return	HSB color wheel as Array of FlxColors</haxe_doc>
		</getHSBColorWheel>
		<interpolate public="1" get="inline" set="null" line="229" static="1">
			<f a="Color1:Color2:?Factor" v="::0.5">
				<x path="flixel.util.FlxColor"/>
				<x path="flixel.util.FlxColor"/>
				<x path="Float"/>
				<x path="flixel.util.FlxColor"/>
			</f>
			<meta><m n=":value"><e>{ Factor : 0.5 }</e></m></meta>
			<haxe_doc>* Get an interpolated color based on two different colors.
	 * 
	 * @param 	Color1 The first color
	 * @param 	Color2 The second color
	 * @param 	Factor Value from 0 to 1 representing how much to shift Color1 toward Color2
	 * @return	The interpolated color</haxe_doc>
		</interpolate>
		<gradient public="1" set="method" line="248" static="1">
			<f a="Color1:Color2:Steps:?Ease">
				<x path="flixel.util.FlxColor"/>
				<x path="flixel.util.FlxColor"/>
				<x path="Int"/>
				<f a="">
					<x path="Float"/>
					<x path="Float"/>
				</f>
				<c path="Array"><x path="flixel.util.FlxColor"/></c>
			</f>
			<haxe_doc>* Create a gradient from one color to another
	 * 
	 * @param Color1 The color to shift from
	 * @param Color2 The color to shift to
	 * @param Steps How many colors the gradient should have
	 * @param Ease An optional easing function, such as those provided in FlxEase
	 * @return An array of colors of length Steps, shifting from Color1 to Color2</haxe_doc>
		</gradient>
		<multiply public="1" get="inline" set="null" line="272" static="1">
			<f a="lhs:rhs">
				<x path="flixel.util.FlxColor"/>
				<x path="flixel.util.FlxColor"/>
				<x path="flixel.util.FlxColor"/>
			</f>
			<meta><m n=":op"><e>A * B</e></m></meta>
			<haxe_doc>* Multiply the RGB channels of two FlxColors</haxe_doc>
		</multiply>
		<add public="1" get="inline" set="null" line="281" static="1">
			<f a="lhs:rhs">
				<x path="flixel.util.FlxColor"/>
				<x path="flixel.util.FlxColor"/>
				<x path="flixel.util.FlxColor"/>
			</f>
			<meta><m n=":op"><e>A + B</e></m></meta>
			<haxe_doc>* Add the RGB channels of two FlxColors</haxe_doc>
		</add>
		<subtract public="1" get="inline" set="null" line="290" static="1">
			<f a="lhs:rhs">
				<x path="flixel.util.FlxColor"/>
				<x path="flixel.util.FlxColor"/>
				<x path="flixel.util.FlxColor"/>
			</f>
			<meta><m n=":op"><e>A - B</e></m></meta>
			<haxe_doc>* Subtract the RGB channels of one FlxColor from another</haxe_doc>
		</subtract>
		<getComplementHarmony public="1" get="inline" set="null" line="301" static="1">
			<f a="this">
				<x path="Int"/>
				<x path="flixel.util.FlxColor"/>
			</f>
			<meta><m n=":impl"/></meta>
			<haxe_doc>* Returns a Complementary Color Harmony of this color.
	 * A complementary hue is one directly opposite the color given on the color wheel
	 * 
	 * @return	The complimentary color</haxe_doc>
		</getComplementHarmony>
		<getAnalogousHarmony public="1" get="inline" set="null" line="313" static="1">
			<f a="this:?Threshold" v=":30">
				<x path="Int"/>
				<x path="Int"/>
				<t path="flixel.util.Harmony"/>
			</f>
			<meta>
				<m n=":value"><e>{ Threshold : 30 }</e></m>
				<m n=":impl"/>
			</meta>
			<haxe_doc>* Returns an Analogous Color Harmony for the given color.
	 * An Analogous harmony are hues adjacent to each other on the color wheel
	 * 
	 * @param	Threshold Control how adjacent the colors will be (default +- 30 degrees)
	 * @return 	Object containing 3 properties: original (the original color), warmer (the warmer analogous color) and colder (the colder analogous color)</haxe_doc>
		</getAnalogousHarmony>
		<getSplitComplementHarmony public="1" get="inline" set="null" line="328" static="1">
			<f a="this:?Threshold" v=":30">
				<x path="Int"/>
				<x path="Int"/>
				<t path="flixel.util.Harmony"/>
			</f>
			<meta>
				<m n=":value"><e>{ Threshold : 30 }</e></m>
				<m n=":impl"/>
			</meta>
			<haxe_doc>* Returns an Split Complement Color Harmony for this color.
	 * A Split Complement harmony are the two hues on either side of the color's Complement
	 * 
	 * @param	Threshold Control how adjacent the colors will be to the Complement (default +- 30 degrees)
	 * @return 	Object containing 3 properties: original (the original color), warmer (the warmer analogous color) and colder (the colder analogous color)</haxe_doc>
		</getSplitComplementHarmony>
		<getTriadicHarmony public="1" get="inline" set="null" line="343" static="1">
			<f a="this">
				<x path="Int"/>
				<t path="flixel.util.TriadicHarmony"/>
			</f>
			<meta><m n=":impl"/></meta>
			<haxe_doc>* Returns a Triadic Color Harmony for this color. A Triadic harmony are 3 hues equidistant 
	 * from each other on the color wheel.
	 * 
	 * @return 	Object containing 3 properties: color1 (the original color), color2 and color3 (the equidistant colors)</haxe_doc>
		</getTriadicHarmony>
		<to24Bit public="1" get="inline" set="null" line="356" static="1">
			<f a="this">
				<x path="Int"/>
				<x path="flixel.util.FlxColor"/>
			</f>
			<meta><m n=":impl"/></meta>
			<haxe_doc>* Return a 24 bit version of this color (i.e. without an alpha value)
	 * 
	 * @return A 24 bit version of this color</haxe_doc>
		</to24Bit>
		<toHexString public="1" get="inline" set="null" line="368" static="1">
			<f a="this:?Alpha:?Prefix" v=":true:true">
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<c path="String"/>
			</f>
			<meta>
				<m n=":value"><e>{ Prefix : true, Alpha : true }</e></m>
				<m n=":impl"/>
			</meta>
			<haxe_doc>* Return a String representation of the color in the format
	 * 
	 * @param Alpha Whether to include the alpha value in the hes string
	 * @param Prefix Whether to include "0x" prefix at start of string
	 * @return	A string of length 10 in the format 0xAARRGGBB</haxe_doc>
		</toHexString>
		<toWebString public="1" get="inline" set="null" line="379" static="1">
			<f a="this">
				<x path="Int"/>
				<c path="String"/>
			</f>
			<meta><m n=":impl"/></meta>
			<haxe_doc>* Return a String representation of the color in the format #RRGGBB
	 * 
	 * @return	A string of length 7 in the format #RRGGBB</haxe_doc>
		</toWebString>
		<getColorInfo public="1" set="method" line="389" static="1">
			<f a="this">
				<x path="Int"/>
				<c path="String"/>
			</f>
			<meta><m n=":impl"/></meta>
			<haxe_doc>* Get a string of color information about this color
	 * 
	 * @return A string containing information about this color</haxe_doc>
		</getColorInfo>
		<getDarkened public="1" set="method" line="408" static="1">
			<f a="this:?Factor" v=":0.2">
				<x path="Int"/>
				<x path="Float"/>
				<x path="flixel.util.FlxColor"/>
			</f>
			<meta>
				<m n=":value"><e>{ Factor : 0.2 }</e></m>
				<m n=":impl"/>
			</meta>
			<haxe_doc>* Get a darkened version of this color
	 * 
	 * @param	Factor Value from 0 to 1 of how much to progress toward black.
	 * @return 	A darkened version of this color</haxe_doc>
		</getDarkened>
		<getLightened public="1" get="inline" set="null" line="422" static="1">
			<f a="this:?Factor" v=":0.2">
				<x path="Int"/>
				<x path="Float"/>
				<x path="flixel.util.FlxColor"/>
			</f>
			<meta>
				<m n=":value"><e>{ Factor : 0.2 }</e></m>
				<m n=":impl"/>
			</meta>
			<haxe_doc>* Get a lightened version of this color
	 * 
	 * @param	Factor Value from 0 to 1 of how much to progress toward white.
	 * @return 	A lightened version of this color</haxe_doc>
		</getLightened>
		<getInverted public="1" get="inline" set="null" line="435" static="1">
			<f a="this">
				<x path="Int"/>
				<x path="flixel.util.FlxColor"/>
			</f>
			<meta><m n=":impl"/></meta>
			<haxe_doc>* Get the inversion of this color
	 * 
	 * @return The inversion of this color</haxe_doc>
		</getInverted>
		<setRGB public="1" get="inline" set="null" line="452" static="1">
			<f a="this:Red:Green:Blue:?Alpha" v="::::255">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="flixel.util.FlxColor"/>
			</f>
			<meta>
				<m n=":value"><e>{ Alpha : 255 }</e></m>
				<m n=":impl"/>
			</meta>
			<haxe_doc>* Set RGB values as integers (0 to 255)
	 * 
	 * @param Red	The red value of the color from 0 to 255
	 * @param Green	The green value of the color from 0 to 255
	 * @param Blue	The green value of the color from 0 to 255
	 * @param Alpha	How opaque the color should be, from 0 to 255
	 * @return This color</haxe_doc>
		</setRGB>
		<setRGBFloat public="1" get="inline" set="null" line="470" static="1">
			<f a="this:Red:Green:Blue:?Alpha" v="::::1">
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="flixel.util.FlxColor"/>
			</f>
			<meta>
				<m n=":value"><e>{ Alpha : 1 }</e></m>
				<m n=":impl"/>
			</meta>
			<haxe_doc>* Set RGB values as floats (0 to 1)
	 * 
	 * @param Red	The red value of the color from 0 to 1
	 * @param Green	The green value of the color from 0 to 1
	 * @param Blue	The green value of the color from 0 to 1
	 * @param Alpha	How opaque the color should be, from 0 to 1
	 * @return This color</haxe_doc>
		</setRGBFloat>
		<setCMYK public="1" get="inline" set="null" line="489" static="1">
			<f a="this:Cyan:Magenta:Yellow:Black:?Alpha" v=":::::1">
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="flixel.util.FlxColor"/>
			</f>
			<meta>
				<m n=":value"><e>{ Alpha : 1 }</e></m>
				<m n=":impl"/>
			</meta>
			<haxe_doc>* Set CMYK values as floats (0 to 1)
	 * 
	 * @param Cyan		The cyan value of the color from 0 to 1
	 * @param Magenta	The magenta value of the color from 0 to 1
	 * @param Yellow	The yellow value of the color from 0 to 1
	 * @param Black		The black value of the color from 0 to 1
	 * @param Alpha		How opaque the color should be, from 0 to 1
	 * @return This color</haxe_doc>
		</setCMYK>
		<setHSB public="1" get="inline" set="null" line="507" static="1">
			<f a="this:Hue:Saturation:Brightness:Alpha">
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="flixel.util.FlxColor"/>
			</f>
			<meta><m n=":impl"/></meta>
			<haxe_doc>* Set HSB (aka HSV) components
	 * 
	 * @param	Hue			A number between 0 and 360, indicating position on a color strip or wheel.
	 * @param	Saturation	A number between 0 and 1, indicating how colorful or gray the color should be.  0 is gray, 1 is vibrant.
	 * @param	Brightness	(aka Value) A number between 0 and 1, indicating how bright the color should be.  0 is black, 1 is full bright.
	 * @param	Alpha		How opaque the color should be, either between 0 and 1 or 0 and 255.
	 * @return	This color</haxe_doc>
		</setHSB>
		<setHSL public="1" get="inline" set="null" line="523" static="1">
			<f a="this:Hue:Saturation:Lightness:Alpha">
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="flixel.util.FlxColor"/>
			</f>
			<meta><m n=":impl"/></meta>
			<haxe_doc>* Set HSL components.
	 * 
	 * @param	Hue			A number between 0 and 360, indicating position on a color strip or wheel.
	 * @param	Saturation	A number between 0 and 1, indicating how colorful or gray the color should be.  0 is gray, 1 is vibrant.
	 * @param	Lightness	A number between 0 and 1, indicating the lightness of the color
	 * @param	Alpha		How opaque the color should be, either between 0 and 1 or 0 and 255
	 * @return	This color</haxe_doc>
		</setHSL>
		<setHSChromaMatch get="inline" set="null" line="533" static="1">
			<f a="this:Hue:Saturation:Chroma:Match:Alpha">
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="flixel.util.FlxColor"/>
			</f>
			<meta><m n=":impl"/></meta>
			<haxe_doc>* Private utility function to perform common operations between setHSB and setHSL</haxe_doc>
		</setHSChromaMatch>
		<_new public="1" set="method" line="553" static="1">
			<f a="?Value" v="0">
				<x path="Int"/>
				<x path="flixel.util.FlxColor"/>
			</f>
			<meta>
				<m n=":value"><e>{ Value : 0 }</e></m>
				<m n=":impl"/>
			</meta>
		</_new>
		<getThis get="inline" set="null" line="558" static="1">
			<f a="this">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":impl"/></meta>
		</getThis>
		<validate get="inline" set="null" line="567" static="1">
			<f a="this">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":impl"/></meta>
		</validate>
		<get_red get="inline" set="null" line="574" static="1">
			<f a="this">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_red>
		<get_green get="inline" set="null" line="579" static="1">
			<f a="this">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_green>
		<get_blue get="inline" set="null" line="584" static="1">
			<f a="this">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_blue>
		<get_alpha get="inline" set="null" line="589" static="1">
			<f a="this">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_alpha>
		<get_redFloat get="inline" set="null" line="594" static="1">
			<f a="this">
				<x path="Int"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_redFloat>
		<get_greenFloat get="inline" set="null" line="599" static="1">
			<f a="this">
				<x path="Int"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_greenFloat>
		<get_blueFloat get="inline" set="null" line="604" static="1">
			<f a="this">
				<x path="Int"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_blueFloat>
		<get_alphaFloat get="inline" set="null" line="609" static="1">
			<f a="this">
				<x path="Int"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_alphaFloat>
		<set_red get="inline" set="null" line="614" static="1">
			<f a="this:Value">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":impl"/></meta>
		</set_red>
		<set_green get="inline" set="null" line="622" static="1">
			<f a="this:Value">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":impl"/></meta>
		</set_green>
		<set_blue get="inline" set="null" line="630" static="1">
			<f a="this:Value">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":impl"/></meta>
		</set_blue>
		<set_alpha get="inline" set="null" line="638" static="1">
			<f a="this:Value">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":impl"/></meta>
		</set_alpha>
		<set_redFloat get="inline" set="null" line="646" static="1">
			<f a="this:Value">
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</set_redFloat>
		<set_greenFloat get="inline" set="null" line="652" static="1">
			<f a="this:Value">
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</set_greenFloat>
		<set_blueFloat get="inline" set="null" line="658" static="1">
			<f a="this:Value">
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</set_blueFloat>
		<set_alphaFloat get="inline" set="null" line="664" static="1">
			<f a="this:Value">
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</set_alphaFloat>
		<get_cyan get="inline" set="null" line="670" static="1">
			<f a="this">
				<x path="Int"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_cyan>
		<get_magenta get="inline" set="null" line="675" static="1">
			<f a="this">
				<x path="Int"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_magenta>
		<get_yellow get="inline" set="null" line="680" static="1">
			<f a="this">
				<x path="Int"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_yellow>
		<get_black get="inline" set="null" line="685" static="1">
			<f a="this">
				<x path="Int"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_black>
		<set_cyan get="inline" set="null" line="690" static="1">
			<f a="this:Value">
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</set_cyan>
		<set_magenta get="inline" set="null" line="696" static="1">
			<f a="this:Value">
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</set_magenta>
		<set_yellow get="inline" set="null" line="702" static="1">
			<f a="this:Value">
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</set_yellow>
		<set_black get="inline" set="null" line="708" static="1">
			<f a="this:Value">
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</set_black>
		<get_hue set="method" line="714" static="1">
			<f a="this">
				<x path="Int"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_hue>
		<get_brightness get="inline" set="null" line="726" static="1">
			<f a="this">
				<x path="Int"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_brightness>
		<get_saturation get="inline" set="null" line="731" static="1">
			<f a="this">
				<x path="Int"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_saturation>
		<get_lightness get="inline" set="null" line="736" static="1">
			<f a="this">
				<x path="Int"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_lightness>
		<set_hue get="inline" set="null" line="741" static="1">
			<f a="this:Value">
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</set_hue>
		<set_saturation get="inline" set="null" line="747" static="1">
			<f a="this:Value">
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</set_saturation>
		<set_brightness get="inline" set="null" line="753" static="1">
			<f a="this:Value">
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</set_brightness>
		<set_lightness get="inline" set="null" line="759" static="1">
			<f a="this:Value">
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</set_lightness>
		<maxColor get="inline" set="null" line="765" static="1">
			<f a="this">
				<x path="Int"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</maxColor>
		<minColor get="inline" set="null" line="770" static="1">
			<f a="this">
				<x path="Int"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</minColor>
		<boundChannel get="inline" set="null" line="775" static="1">
			<f a="this:Value">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":impl"/></meta>
		</boundChannel>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":final"/>
		</meta>
	</class>
	<typedef path="flixel.util.Harmony" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/util/FlxColor.hx" module="flixel.util.FlxColor"><a>
	<warmer><x path="flixel.util.FlxColor"/></warmer>
	<original><x path="flixel.util.FlxColor"/></original>
	<colder><x path="flixel.util.FlxColor"/></colder>
</a></typedef>
	<typedef path="flixel.util.TriadicHarmony" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/util/FlxColor.hx" module="flixel.util.FlxColor"><a>
	<color3><x path="flixel.util.FlxColor"/></color3>
	<color2><x path="flixel.util.FlxColor"/></color2>
	<color1><x path="flixel.util.FlxColor"/></color1>
</a></typedef>
	<class path="flixel.util.FlxColorTransformUtil" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/util/FlxColorTransformUtil.hx">
		<setMultipliers public="1" set="method" line="7" static="1"><f a="transform:red:green:blue:alpha">
	<c path="openfl.geom.ColorTransform"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<c path="openfl.geom.ColorTransform"/>
</f></setMultipliers>
		<setOffsets public="1" set="method" line="18" static="1"><f a="transform:red:green:blue:alpha">
	<c path="openfl.geom.ColorTransform"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<c path="openfl.geom.ColorTransform"/>
</f></setOffsets>
		<hasRGBMultipliers public="1" set="method" line="32" static="1">
			<f a="transform">
				<c path="openfl.geom.ColorTransform"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Returns whether red, green, or blue multipliers are set to anything other than 1.</haxe_doc>
		</hasRGBMultipliers>
		<hasRGBAMultipliers public="1" set="method" line="40" static="1">
			<f a="transform">
				<c path="openfl.geom.ColorTransform"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Returns whether red, green, blue, or alpha multipliers are set to anything other than 1.</haxe_doc>
		</hasRGBAMultipliers>
		<hasRGBOffsets public="1" set="method" line="48" static="1">
			<f a="transform">
				<c path="openfl.geom.ColorTransform"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Returns whether red, green, or blue offsets are set to anything other than 0.</haxe_doc>
		</hasRGBOffsets>
		<hasRGBAOffsets public="1" set="method" line="56" static="1">
			<f a="transform">
				<c path="openfl.geom.ColorTransform"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Returns whether red, green, blue, or alpha offsets are set to anything other than 0.</haxe_doc>
		</hasRGBAOffsets>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="flixel.util.FlxDestroyUtil" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/util/FlxDestroyUtil.hx">
		<destroy public="1" params="T" set="method" line="16" static="1">
			<f a="object">
				<t path="Null"><c path="flixel.util.IFlxDestroyable"/></t>
				<c path="destroy.T"/>
			</f>
			<haxe_doc>* Checks if an object is not null before calling destroy(), always returns null.
	 * 
	 * @param	object	An IFlxDestroyable object that will be destroyed if it's not null.
	 * @return	null</haxe_doc>
		</destroy>
		<destroyArray public="1" params="T" set="method" line="31" static="1">
			<f a="array">
				<c path="Array"><c path="destroyArray.T"/></c>
				<c path="Array"><c path="destroyArray.T"/></c>
			</f>
			<haxe_doc>* Destroy every element of an array of IFlxDestroyables
	 *
	 * @param	array	An Array of IFlxDestroyable objects
	 * @return	null</haxe_doc>
		</destroyArray>
		<put public="1" params="T" set="method" line="48" static="1">
			<f a="object">
				<c path="flixel.util.IFlxPooled"/>
				<c path="put.T"/>
			</f>
			<haxe_doc>* Checks if an object is not null before putting it back into the pool, always returns null.
	 * 
	 * @param	object	An IFlxPooled object that will be put back into the pool if it's not null
	 * @return	null</haxe_doc>
		</put>
		<putArray public="1" params="T" set="method" line="64" static="1">
			<f a="array">
				<c path="Array"><c path="putArray.T"/></c>
				<c path="Array"><c path="putArray.T"/></c>
			</f>
			<haxe_doc>* Puts all objects in an Array of IFlxPooled objects back into 
	 * the pool by calling FlxDestroyUtil.put() on them
	 *
	 * @param	array	An Array of IFlxPooled objects
	 * @return	null</haxe_doc>
		</putArray>
		<dispose public="1" set="method" line="82" static="1">
			<f a="bitmapData">
				<t path="flash.display.BitmapData"/>
				<t path="flash.display.BitmapData"/>
			</f>
			<haxe_doc>* Checks if a BitmapData object is not null before calling dispose() on it, always returns null.
	 * 
	 * @param	Bitmap	A BitmapData to be disposed if not null
	 * @return 	null</haxe_doc>
		</dispose>
		<disposeIfNotEqual public="1" set="method" line="94" static="1">
			<f a="bitmapData:width:height">
				<t path="flash.display.BitmapData"/>
				<x path="Float"/>
				<x path="Float"/>
				<t path="flash.display.BitmapData"/>
			</f>
			<haxe_doc>* Checks if a BitmapData object is not null and it's size isn't equal to specified one before calling dispose() on it.</haxe_doc>
		</disposeIfNotEqual>
		<removeChild public="1" params="T" set="method" line="109" static="1"><f a="parent:child">
	<t path="flash.display.DisplayObjectContainer"/>
	<c path="removeChild.T"/>
	<c path="removeChild.T"/>
</f></removeChild>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="flixel.util.FlxGradient" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/util/FlxGradient.hx">
		<createGradientMatrix public="1" set="method" line="24" static="1">
			<f a="width:height:colors:?chunkSize:?rotation" v=":::1:90">
				<x path="Int"/>
				<x path="Int"/>
				<c path="Array"><x path="flixel.util.FlxColor"/></c>
				<x path="UInt"/>
				<x path="Int"/>
				<t path="flixel.util.GradientMatrix"/>
			</f>
			<meta><m n=":value"><e>{ rotation : 90, chunkSize : 1 }</e></m></meta>
		</createGradientMatrix>
		<createGradientArray public="1" set="method" line="68" static="1">
			<f a="width:height:colors:?chunkSize:?rotation:?interpolate" v=":::1:90:true">
				<x path="Int"/>
				<x path="Int"/>
				<c path="Array"><x path="flixel.util.FlxColor"/></c>
				<x path="UInt"/>
				<x path="Int"/>
				<x path="Bool"/>
				<c path="Array"><x path="flixel.util.FlxColor"/></c>
			</f>
			<meta><m n=":value"><e>{ interpolate : true, rotation : 90, chunkSize : 1 }</e></m></meta>
		</createGradientArray>
		<createGradientFlxSprite public="1" set="method" line="93" static="1">
			<f a="width:height:colors:?chunkSize:?rotation:?interpolate" v=":::1:90:true">
				<x path="Int"/>
				<x path="Int"/>
				<c path="Array"><x path="flixel.util.FlxColor"/></c>
				<x path="UInt"/>
				<x path="Int"/>
				<x path="Bool"/>
				<c path="flixel.FlxSprite"/>
			</f>
			<meta><m n=":value"><e>{ interpolate : true, rotation : 90, chunkSize : 1 }</e></m></meta>
			<haxe_doc>* Creates a FlxSprite of the given width/height with a colour gradient flowing through it.
	 * 
	 * @param   width         The width of the FlxSprite (and therefore gradient)
	 * @param   height        The height of the FlxSprite (and therefore gradient)
	 * @param   colors        An array of colour values for the gradient to cycle through
	 * @param   chunkSize     If you want a more old-skool looking chunky gradient, increase this value!
	 * @param   rotation      Angle of the gradient in degrees. 90 = top to bottom, 180 = left to right. Any angle is valid
	 * @param   interpolate   Interpolate the colours? True uses RGB interpolation, false uses linear RGB
	 * @return  A FlxSprite containing your gradient (if valid parameters given!)</haxe_doc>
		</createGradientFlxSprite>
		<createGradientBitmapData public="1" set="method" line="102" static="1">
			<f a="width:height:colors:?chunkSize:?rotation:?interpolate" v=":::1:90:true">
				<x path="UInt"/>
				<x path="UInt"/>
				<c path="Array"><x path="flixel.util.FlxColor"/></c>
				<x path="UInt"/>
				<x path="Int"/>
				<x path="Bool"/>
				<t path="flash.display.BitmapData"/>
			</f>
			<meta><m n=":value"><e>{ interpolate : true, rotation : 90, chunkSize : 1 }</e></m></meta>
		</createGradientBitmapData>
		<overlayGradientOnFlxSprite public="1" set="method" line="161" static="1">
			<f a="dest:width:height:colors:?destX:?destY:?chunkSize:?rotation:?interpolate" v="::::0:0:1:90:true">
				<c path="flixel.FlxSprite"/>
				<x path="Int"/>
				<x path="Int"/>
				<c path="Array"><x path="flixel.util.FlxColor"/></c>
				<x path="Int"/>
				<x path="Int"/>
				<x path="UInt"/>
				<x path="Int"/>
				<x path="Bool"/>
				<c path="flixel.FlxSprite"/>
			</f>
			<meta><m n=":value"><e>{ interpolate : true, rotation : 90, chunkSize : 1, destY : 0, destX : 0 }</e></m></meta>
			<haxe_doc>* Creates a new gradient and overlays that on-top of the given FlxSprite at the destX/destY coordinates (default 0,0)
	 * Use low alpha values in the colours to have the gradient overlay and not destroy the image below
	 * 
	 * @param   dest          The FlxSprite to overlay the gradient onto
	 * @param   width         The width of the FlxSprite (and therefore gradient)
	 * @param   height        The height of the FlxSprite (and therefore gradient)
	 * @param   colors        An array of colour values for the gradient to cycle through
	 * @param   destX         The X offset the gradient is drawn at (default 0)
	 * @param   destY         The Y offset the gradient is drawn at (default 0)
	 * @param   chunkSize     If you want a more old-skool looking chunky gradient, increase this value!
	 * @param   rotation      Angle of the gradient in degrees. 90 = top to bottom, 180 = left to right. Any angle is valid
	 * @param   interpolate   Interpolate the colours? True uses RGB interpolation, false uses linear RGB
	 * @return  The composited FlxSprite (for chaining, if you need)</haxe_doc>
		</overlayGradientOnFlxSprite>
		<overlayGradientOnBitmapData public="1" set="method" line="195" static="1">
			<f a="dest:width:height:colors:?destX:?destY:?chunkSize:?rotation:?interpolate" v="::::0:0:1:90:true">
				<t path="flash.display.BitmapData"/>
				<x path="Int"/>
				<x path="Int"/>
				<c path="Array"><x path="flixel.util.FlxColor"/></c>
				<x path="Int"/>
				<x path="Int"/>
				<x path="UInt"/>
				<x path="Int"/>
				<x path="Bool"/>
				<t path="flash.display.BitmapData"/>
			</f>
			<meta><m n=":value"><e>{ interpolate : true, rotation : 90, chunkSize : 1, destY : 0, destX : 0 }</e></m></meta>
			<haxe_doc>* Creates a new gradient and overlays that on-top of the given BitmapData at the destX/destY coordinates (default 0,0)
	 * Use low alpha values in the colours to have the gradient overlay and not destroy the image below
	 * 
	 * @param   dest          The BitmapData to overlay the gradient onto
	 * @param   width         The width of the FlxSprite (and therefore gradient)
	 * @param   height        The height of the FlxSprite (and therefore gradient)
	 * @param   colors        An array of colour values for the gradient to cycle through
	 * @param   destX         The X offset the gradient is drawn at (default 0)
	 * @param   destY         The Y offset the gradient is drawn at (default 0)
	 * @param   chunkSize     If you want a more old-skool looking chunky gradient, increase this value!
	 * @param   rotation      Angle of the gradient in degrees. 90 = top to bottom, 180 = left to right. Any angle is valid
	 * @param   interpolate   Interpolate the colours? True uses RGB interpolation, false uses linear RGB
	 * @return  The composited BitmapData</haxe_doc>
		</overlayGradientOnBitmapData>
		<haxe_doc>* Adds a set of color gradient creation / rendering functions
 * 
 * @version 1.6 - May 9th 2011
 * @link http://www.photonstorm.com
 * @author Richard Davey / Photon Storm
 * @see Requires FlxMath</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<typedef path="flixel.util.GradientMatrix" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/util/FlxGradient.hx" module="flixel.util.FlxGradient"><a>
	<ratio><c path="Array"><x path="Int"/></c></ratio>
	<matrix><t path="flash.geom.Matrix"/></matrix>
	<alpha><c path="Array"><x path="Float"/></c></alpha>
</a></typedef>
	<enum path="flixel.util.FlxHorizontalAlign" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/util/FlxHorizontalAlign.hx">
		<LEFT/>
		<CENTER/>
		<RIGHT/>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<class path="flixel.util.FlxPath" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/util/FlxPath.hx">
		<implements path="flixel.util.IFlxDestroyable"/>
		<FORWARD public="1" get="inline" set="null" expr="0x000000" line="49" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x000000</e></m></meta>
			<haxe_doc>* Path behavior controls: move from the start of the path to the end then stop.</haxe_doc>
		</FORWARD>
		<BACKWARD public="1" get="inline" set="null" expr="0x000001" line="53" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x000001</e></m></meta>
			<haxe_doc>* Path behavior controls: move from the end of the path to the start then stop.</haxe_doc>
		</BACKWARD>
		<LOOP_FORWARD public="1" get="inline" set="null" expr="0x000010" line="57" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x000010</e></m></meta>
			<haxe_doc>* Path behavior controls: move from the start of the path to the end then directly back to the start, and start over.</haxe_doc>
		</LOOP_FORWARD>
		<LOOP_BACKWARD public="1" get="inline" set="null" expr="0x000100" line="61" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x000100</e></m></meta>
			<haxe_doc>* Path behavior controls: move from the end of the path to the start then directly back to the end, and start over.</haxe_doc>
		</LOOP_BACKWARD>
		<YOYO public="1" get="inline" set="null" expr="0x001000" line="65" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x001000</e></m></meta>
			<haxe_doc>* Path behavior controls: move from the start of the path to the end then turn around and go back to the start, over and over.</haxe_doc>
		</YOYO>
		<HORIZONTAL_ONLY public="1" get="inline" set="null" expr="0x010000" line="69" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x010000</e></m></meta>
			<haxe_doc>* Path behavior controls: ignores any vertical component to the path data, only follows side to side.</haxe_doc>
		</HORIZONTAL_ONLY>
		<VERTICAL_ONLY public="1" get="inline" set="null" expr="0x100000" line="73" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x100000</e></m></meta>
			<haxe_doc>* Path behavior controls: ignores any horizontal component to the path data, only follows up and down.</haxe_doc>
		</VERTICAL_ONLY>
		<_point expr="FlxPoint.get()" line="78" static="1">
			<c path="flixel.math.FlxPoint"/>
			<meta><m n=":value"><e>FlxPoint.get()</e></m></meta>
			<haxe_doc>* Internal helper for keeping new variable instantiations under control.</haxe_doc>
		</_point>
		<nodes public="1" get="accessor" set="accessor">
			<c path="Array"><c path="flixel.math.FlxPoint"/></c>
			<haxe_doc>* The list of FlxPoints that make up the path data.</haxe_doc>
		</nodes>
		<_nodes>
			<c path="Array"><c path="flixel.math.FlxPoint"/></c>
			<haxe_doc>* An actual array, which holds all the path points.</haxe_doc>
		</_nodes>
		<speed public="1" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* The speed at which the object is moving on the path.
	 * When an object completes a non-looping path circuit,
	 * the path's speed will be zeroed out, but the path reference
	 * will NOT be nulled out. So `speed` is a good way
	 * to check if this object is currently following a path or not.</haxe_doc>
		</speed>
		<angle public="1" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* The angle in degrees between this object and the next node, where 0 is directly upward, and 90 is to the right.</haxe_doc>
		</angle>
		<autoCenter public="1" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
			<haxe_doc>* Whether the object should auto-center the path or at its origin.</haxe_doc>
		</autoCenter>
		<active public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
			<haxe_doc>* Pauses or checks the pause state of the path.</haxe_doc>
		</active>
		<onComplete public="1"><f a="">
	<c path="flixel.util.FlxPath"/>
	<x path="Void"/>
</f></onComplete>
		<debugColor public="1" expr="0xffffff">
			<x path="flixel.util.FlxColor"/>
			<meta><m n=":value"><e>0xffffff</e></m></meta>
			<haxe_doc>* Specify a debug display color for the path. Default is white.</haxe_doc>
		</debugColor>
		<ignoreDrawDebug public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
			<haxe_doc>* Setting this to true will prevent the object from appearing
	 * when FlxG.debugger.drawDebug is true.</haxe_doc>
		</ignoreDrawDebug>
		<nodeIndex public="1" set="null" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* Tracks which node of the path this object is currently moving toward.</haxe_doc>
		</nodeIndex>
		<finished public="1" set="null" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</finished>
		<_mode>
			<x path="Int"/>
			<haxe_doc>* Internal tracker for path behavior flags (like looping, horizontal only, etc).</haxe_doc>
		</_mode>
		<_inc expr="1">
			<x path="Int"/>
			<meta><m n=":value"><e>1</e></m></meta>
			<haxe_doc>* Internal helper for node navigation, specifically yo-yo and backwards movement.</haxe_doc>
		</_inc>
		<_autoRotate expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
			<haxe_doc>* Internal flag for whether the object's angle should be adjusted to the path angle during path follow behavior.</haxe_doc>
		</_autoRotate>
		<_wasObjectImmovable expr="null">
			<t path="Null"><x path="Bool"/></t>
			<meta><m n=":value"><e>null</e></m></meta>
		</_wasObjectImmovable>
		<_firstUpdate expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</_firstUpdate>
		<object>
			<c path="flixel.FlxObject"/>
			<meta><m n=":allow"><e>flixel.FlxObject</e></m></meta>
			<haxe_doc>* Object which will follow this path</haxe_doc>
		</object>
		<reset public="1" set="method" line="169">
			<f a=""><c path="flixel.util.FlxPath"/></f>
			<haxe_doc>* Just resets some debugging related variables (for debugger renderer).
	 * Also resets `autoCenter` to `true`.
	 * @return	This path object.</haxe_doc>
		</reset>
		<setProperties public="1" set="method" line="188">
			<f a="?Speed:?Mode:?AutoRotate" v="100:FlxPath.FORWARD:false">
				<x path="Float"/>
				<x path="Int"/>
				<x path="Bool"/>
				<c path="flixel.util.FlxPath"/>
			</f>
			<meta><m n=":value"><e>{ AutoRotate : false, Mode : FlxPath.FORWARD, Speed : 100 }</e></m></meta>
			<haxe_doc>* Sets the following properties: `speed`, `mode` and auto rotation.
	 * 
	 * @param	Speed			The speed at which the object is moving on the path.
	 * @param	Mode			Path following behavior (like looping, horizontal only, etc).
	 * @param	AutoRotate		Whether the object's angle should be adjusted to the path angle during path follow behavior.
	 * @return	This path object.
	 * @since   4.2.0</haxe_doc>
		</setProperties>
		<start public="1" set="method" line="206">
			<f a="?Nodes:?Speed:?Mode:?AutoRotate:?NodesAsReference" v=":100:FlxPath.FORWARD:false:false">
				<c path="Array"><c path="flixel.math.FlxPoint"/></c>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<c path="flixel.util.FlxPath"/>
			</f>
			<meta><m n=":value"><e>{ NodesAsReference : false, AutoRotate : false, Mode : FlxPath.FORWARD, Speed : 100 }</e></m></meta>
			<haxe_doc>* Starts movement along specified path.
	 * 
	 * @param	Nodes				An optional array of path waypoints. If null then previously added points will be used. Movement is not started if the resulting array has no points.
	 * @param	Speed				The speed at which the object is moving on the path.
	 * @param	Mode				Path following behavior (like looping, horizontal only, etc).
	 * @param	AutoRotate			Whether the object's angle should be adjusted to the path angle during path follow behavior.
	 * @param   NodesAsReference 	Whether to pass the input array as reference (true) or to copy the points (false). Default is false.
	 * @return	This path object.</haxe_doc>
		</start>
		<restart public="1" set="method" line="233">
			<f a=""><c path="flixel.util.FlxPath"/></f>
			<haxe_doc>* Restarts this path. So object starts movement again from the first (or last) path point 
	 * (depends on path movement behavior mode).
	 * 
	 * @return	This path object.</haxe_doc>
		</restart>
		<setNode public="1" set="method" line="263">
			<f a="NodeIndex">
				<x path="Int"/>
				<c path="flixel.util.FlxPath"/>
			</f>
			<haxe_doc>* Change the path node this object is currently at.
	 * 
	 * @param  NodeIndex    The index of the new node out of path.nodes.</haxe_doc>
		</setNode>
		<update public="1" set="method" line="280">
			<f a="elapsed">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Internal function for moving the object along the path.
	 * The first half of the function decides if the object can advance to the next node in the path,
	 * while the second half handles actually picking a velocity toward the next node.</haxe_doc>
		</update>
		<calculateVelocity set="method" line="364"><f a="node:horizontalOnly:verticalOnly">
	<c path="flixel.math.FlxPoint"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></calculateVelocity>
		<advancePath set="method" line="403">
			<f a="?Snap" v="true">
				<x path="Bool"/>
				<c path="flixel.math.FlxPoint"/>
			</f>
			<meta><m n=":value"><e>{ Snap : true }</e></m></meta>
			<haxe_doc>* Internal function that decides what node in the path to aim for next based on the behavior flags.
	 * 
	 * @return	The node (a `FlxPoint`) we are aiming for next.</haxe_doc>
		</advancePath>
		<cancel public="1" set="method" line="510">
			<f a=""><c path="flixel.util.FlxPath"/></f>
			<haxe_doc>* Stops path movement and removes this path it from the path manager.
	 * 
	 * @return	This path object.</haxe_doc>
		</cancel>
		<onEnd set="method" line="524">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Called when the path ends, either by completing normally or via `cancel()`.</haxe_doc>
		</onEnd>
		<destroy public="1" set="method" line="536">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Clean up memory.</haxe_doc>
		</destroy>
		<add public="1" set="method" line="552">
			<f a="X:Y">
				<x path="Float"/>
				<x path="Float"/>
				<c path="flixel.util.FlxPath"/>
			</f>
			<haxe_doc>* Add a new node to the end of the path at the specified location.
	 * 
	 * @param	X	X position of the new path point in world coordinates.
	 * @param	Y	Y position of the new path point in world coordinates.
	 * 
	 * @return	This path object.</haxe_doc>
		</add>
		<addAt public="1" set="method" line="567">
			<f a="X:Y:Index">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<c path="flixel.util.FlxPath"/>
			</f>
			<haxe_doc>* Add a new node to the path at the specified location and index within the path.
	 * 
	 * @param	X		X position of the new path point in world coordinates.
	 * @param	Y		Y position of the new path point in world coordinates.
	 * @param	Index	Where within the list of path nodes to insert this new point.
	 * 
	 * @return	This path object.</haxe_doc>
		</addAt>
		<addPoint public="1" set="method" line="584">
			<f a="Node:?AsReference" v=":false">
				<c path="flixel.math.FlxPoint"/>
				<x path="Bool"/>
				<c path="flixel.util.FlxPath"/>
			</f>
			<meta><m n=":value"><e>{ AsReference : false }</e></m></meta>
			<haxe_doc>* Sometimes its easier or faster to just pass a point object instead of separate X and Y coordinates.
	 * This also gives you the option of not creating a new node but actually adding that specific
	 * FlxPoint object to the path.  This allows you to do neat things, like dynamic paths.
	 * 
	 * @param	Node			The point in world coordinates you want to add to the path.
	 * @param	AsReference		Whether to add the point as a reference, or to create a new point with the specified values.
	 * 
	 * @return	This path object.</haxe_doc>
		</addPoint>
		<addPointAt public="1" set="method" line="608">
			<f a="Node:Index:?AsReference" v="::false">
				<c path="flixel.math.FlxPoint"/>
				<x path="Int"/>
				<x path="Bool"/>
				<c path="flixel.util.FlxPath"/>
			</f>
			<meta><m n=":value"><e>{ AsReference : false }</e></m></meta>
			<haxe_doc>* Sometimes its easier or faster to just pass a point object instead of separate X and Y coordinates.
	 * This also gives you the option of not creating a new node but actually adding that specific
	 * FlxPoint object to the path.  This allows you to do neat things, like dynamic paths.
	 * 
	 * @param	Node			The point in world coordinates you want to add to the path.
	 * @param	Index			Where within the list of path nodes to insert this new point.
	 * @param	AsReference		Whether to add the point as a reference, or to create a new point with the specified values.
	 * 
	 *	@return	This path object.</haxe_doc>
		</addPointAt>
		<remove public="1" set="method" line="629">
			<f a="Node">
				<c path="flixel.math.FlxPoint"/>
				<c path="flixel.math.FlxPoint"/>
			</f>
			<haxe_doc>* Remove a node from the path.
	 * NOTE: only works with points added by reference or with references from nodes itself!
	 * 
	 * @param	Node	The point object you want to remove from the path.
	 * @return	The node that was excised.  Returns null if the node was not found.</haxe_doc>
		</remove>
		<removeAt public="1" set="method" line="645">
			<f a="Index">
				<x path="Int"/>
				<c path="flixel.math.FlxPoint"/>
			</f>
			<haxe_doc>* Remove a node from the path using the specified position in the list of path nodes.
	 * 
	 * @param	Index	Where within the list of path nodes you want to remove a node.
	 * @return	The node that was excised.  Returns null if there were no nodes in the path.</haxe_doc>
		</removeAt>
		<head public="1" set="method" line="663">
			<f a=""><c path="flixel.math.FlxPoint"/></f>
			<haxe_doc>* Get the first node in the list.
	 * 
	 * @return	The first node in the path.</haxe_doc>
		</head>
		<tail public="1" set="method" line="677">
			<f a=""><c path="flixel.math.FlxPoint"/></f>
			<haxe_doc>* Get the last node in the list.
	 * 
	 * @return	The last node in the path.</haxe_doc>
		</tail>
		<drawDebug public="1" set="method" line="696">
			<f a="?Camera">
				<c path="flixel.FlxCamera"/>
				<x path="Void"/>
			</f>
			<meta><m n=":access"><e>flixel.FlxCamera</e></m></meta>
			<haxe_doc>* While this doesn't override `FlxBasic.drawDebug()`, the behavior is very similar.
	 * Based on this path data, it draws a simple lines-and-boxes representation of the path
	 * if the `drawDebug` mode was toggled in the debugger overlay.
	 * You can use `debugColor` to control the path's appearance.
	 * 
	 * @param	Camera		The camera object the path will draw to.</haxe_doc>
		</drawDebug>
		<get_nodes set="method" line="794"><f a=""><c path="Array"><c path="flixel.math.FlxPoint"/></c></f></get_nodes>
		<set_nodes set="method" line="799"><f a="Nodes">
	<c path="Array"><c path="flixel.math.FlxPoint"/></c>
	<c path="Array"><c path="flixel.math.FlxPoint"/></c>
</f></set_nodes>
		<new public="1" set="method" line="156"><f a="?Nodes">
	<c path="Array"><c path="flixel.math.FlxPoint"/></c>
	<x path="Void"/>
</f></new>
		<haxe_doc><![CDATA[* This is a simple path data container. Basically a list of points that
 * a `FlxObject` can follow.  Also has code for drawing debug visuals.
 * `FlxTilemap.findPath()` returns a path usable by `FlxPath`, but you can
 * also just make your own, using the `add()` functions below
 * or by creating your own array of points.
 * 
 * Every `FlxObject` has a `path` property which can make it move along specified array of way points.
 * Usage example:
 * 
 * ```haxe
 * var path = new FlxPath();
 * var points:Array<FlxPoint> = [new FlxPoint(0, 0), new FlxPoint(100, 0)];
 * object.path = path;
 * path.start(points, 50, FlxPath.FORWARD);
 * ```
 * 
 * You can also do this in one line:
 * 
 * ```haxe
 * object.path = new FlxPath().start([new FlxPoint(0, 0), new FlxPoint(100, 0)], 50, FlxPath.FORWARD);
 * ```
 * 
 * ...or using some more chaining:
 * 
 * ```haxe
 * object.path = new FlxPath().add(0, 0).add(100, 0).start(50, FlxPath.FORWARD);
 * ```
 * 
 * If you are fine with the default values of start (speed, mode, auto-rotate) you can also do:
 * 
 * ```haxe
 * object.path = new FlxPath([new FlxPoint(0, 0), new FlxPoint(100, 0)]).start();
 * ```]]></haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="flixel.util.FlxPool" params="T" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/util/FlxPool.hx">
		<implements path="flixel.util.IFlxPool"><c path="flixel.util.FlxPool.T"/></implements>
		<length public="1" get="accessor" set="null"><x path="Int"/></length>
		<_pool expr="[]">
			<c path="Array"><c path="flixel.util.FlxPool.T"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</_pool>
		<_class><x path="Class"><c path="flixel.util.FlxPool.T"/></x></_class>
		<_count expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* Objects aren't actually removed from the array in order to improve performance.
	 * _count keeps track of the valid, accessible pool objects.</haxe_doc>
		</_count>
		<get public="1" set="method" line="30"><f a=""><c path="flixel.util.FlxPool.T"/></f></get>
		<put public="1" set="method" line="39"><f a="obj">
	<c path="flixel.util.FlxPool.T"/>
	<x path="Void"/>
</f></put>
		<putUnsafe public="1" set="method" line="54"><f a="obj">
	<c path="flixel.util.FlxPool.T"/>
	<x path="Void"/>
</f></putUnsafe>
		<preAllocate public="1" set="method" line="63"><f a="numObjects">
	<x path="Int"/>
	<x path="Void"/>
</f></preAllocate>
		<clear public="1" set="method" line="71"><f a=""><c path="Array"><c path="flixel.util.FlxPool.T"/></c></f></clear>
		<get_length get="inline" set="null" line="79"><f a=""><x path="Int"/></f></get_length>
		<new public="1" set="method" line="25"><f a="classObj">
	<x path="Class"><c path="flixel.util.FlxPool.T"/></x>
	<x path="Void"/>
</f></new>
		<haxe_doc>* A generic container that facilitates pooling and recycling of objects.
 * WARNING: Pooled objects must have parameter-less constructors: function new()</haxe_doc>
		<meta><m n=":generic"/></meta>
	</class>
	<enum path="flixel.util.FlxSaveStatus" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/util/FlxSave.hx" module="flixel.util.FlxSave">
		<SUCCESS/>
		<PENDING/>
		<ERROR/>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<typedef path="flixel.util.FlxSignal" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/util/FlxSignal.hx"><x path="flixel.util.FlxTypedSignal"><f a=""><x path="Void"/></f></x></typedef>
	<abstract path="flixel.util.FlxTypedSignal" params="T" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/util/FlxSignal.hx" module="flixel.util.FlxSignal">
		<this><c path="flixel.util.IFlxSignal"><c path="flixel.util.FlxTypedSignal.T"/></c></this>
		<to>
			<icast field="toSignal0"><c path="flixel.util._FlxSignal.FlxSignal0"/></icast>
			<icast field="toSignal1"><c path="flixel.util._FlxSignal.FlxSignal1"><c path="toSignal1.T1"/></c></icast>
			<icast field="toSignal2"><c path="flixel.util._FlxSignal.FlxSignal2">
	<c path="toSignal2.T1"/>
	<c path="toSignal2.T2"/>
</c></icast>
			<icast field="toSignal3"><c path="flixel.util._FlxSignal.FlxSignal3">
	<c path="toSignal3.T1"/>
	<c path="toSignal3.T2"/>
	<c path="toSignal3.T3"/>
</c></icast>
			<icast field="toSignal4"><c path="flixel.util._FlxSignal.FlxSignal4">
	<c path="toSignal4.T1"/>
	<c path="toSignal4.T2"/>
	<c path="toSignal4.T3"/>
	<c path="toSignal4.T4"/>
</c></icast>
		</to>
		<meta><m n=":multiType"/></meta>
		<impl><class path="flixel.util._FlxSignal.FlxTypedSignal_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/util/FlxSignal.hx" private="1" module="flixel.util.FlxSignal">
	<dispatch public="1" get="accessor" set="null" static="1">
		<c path="flixel.util.FlxTypedSignal.T"/>
		<meta><m n=":impl"/></meta>
	</dispatch>
	<_new public="1" set="method" static="1">
		<f a=""><x path="flixel.util.FlxTypedSignal"><c path="flixel.util.FlxTypedSignal.T"/></x></f>
		<meta>
			<m n=":extern"/>
			<m n=":impl"/>
		</meta>
	</_new>
	<add public="1" get="inline" set="null" line="17" static="1">
		<f a="this:listener">
			<c path="flixel.util.IFlxSignal"><c path="flixel.util.FlxTypedSignal.T"/></c>
			<c path="flixel.util.FlxTypedSignal.T"/>
			<x path="Void"/>
		</f>
		<meta><m n=":impl"/></meta>
	</add>
	<addOnce public="1" get="inline" set="null" line="22" static="1">
		<f a="this:listener">
			<c path="flixel.util.IFlxSignal"><c path="flixel.util.FlxTypedSignal.T"/></c>
			<c path="flixel.util.FlxTypedSignal.T"/>
			<x path="Void"/>
		</f>
		<meta><m n=":impl"/></meta>
	</addOnce>
	<remove public="1" get="inline" set="null" line="27" static="1">
		<f a="this:listener">
			<c path="flixel.util.IFlxSignal"><c path="flixel.util.FlxTypedSignal.T"/></c>
			<c path="flixel.util.FlxTypedSignal.T"/>
			<x path="Void"/>
		</f>
		<meta><m n=":impl"/></meta>
	</remove>
	<has public="1" get="inline" set="null" line="32" static="1">
		<f a="this:listener">
			<c path="flixel.util.IFlxSignal"><c path="flixel.util.FlxTypedSignal.T"/></c>
			<c path="flixel.util.FlxTypedSignal.T"/>
			<x path="Bool"/>
		</f>
		<meta><m n=":impl"/></meta>
	</has>
	<removeAll public="1" get="inline" set="null" line="37" static="1">
		<f a="this">
			<c path="flixel.util.IFlxSignal"><c path="flixel.util.FlxTypedSignal.T"/></c>
			<x path="Void"/>
		</f>
		<meta><m n=":impl"/></meta>
	</removeAll>
	<get_dispatch get="inline" set="null" line="42" static="1">
		<f a="this">
			<c path="flixel.util.IFlxSignal"><c path="flixel.util.FlxTypedSignal.T"/></c>
			<c path="flixel.util.FlxTypedSignal.T"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_dispatch>
	<toSignal0 get="inline" set="null" line="48" static="1">
		<f a="signal">
			<c path="flixel.util.IFlxSignal"><f a=""><x path="Void"/></f></c>
			<c path="flixel.util._FlxSignal.FlxSignal0"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":to"/>
		</meta>
	</toSignal0>
	<toSignal1 params="T1" get="inline" set="null" line="54" static="1">
		<f a="signal">
			<c path="flixel.util.IFlxSignal"><f a="">
	<c path="toSignal1.T1"/>
	<x path="Void"/>
</f></c>
			<c path="flixel.util._FlxSignal.FlxSignal1"><c path="toSignal1.T1"/></c>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":to"/>
		</meta>
	</toSignal1>
	<toSignal2 params="T1:T2" get="inline" set="null" line="60" static="1">
		<f a="signal">
			<c path="flixel.util.IFlxSignal"><f a=":">
	<c path="toSignal2.T1"/>
	<c path="toSignal2.T2"/>
	<x path="Void"/>
</f></c>
			<c path="flixel.util._FlxSignal.FlxSignal2">
				<c path="toSignal2.T1"/>
				<c path="toSignal2.T2"/>
			</c>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":to"/>
		</meta>
	</toSignal2>
	<toSignal3 params="T1:T2:T3" get="inline" set="null" line="66" static="1">
		<f a="signal">
			<c path="flixel.util.IFlxSignal"><f a="::">
	<c path="toSignal3.T1"/>
	<c path="toSignal3.T2"/>
	<c path="toSignal3.T3"/>
	<x path="Void"/>
</f></c>
			<c path="flixel.util._FlxSignal.FlxSignal3">
				<c path="toSignal3.T1"/>
				<c path="toSignal3.T2"/>
				<c path="toSignal3.T3"/>
			</c>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":to"/>
		</meta>
	</toSignal3>
	<toSignal4 params="T1:T2:T3:T4" get="inline" set="null" line="72" static="1">
		<f a="signal">
			<c path="flixel.util.IFlxSignal"><f a=":::">
	<c path="toSignal4.T1"/>
	<c path="toSignal4.T2"/>
	<c path="toSignal4.T3"/>
	<c path="toSignal4.T4"/>
	<x path="Void"/>
</f></c>
			<c path="flixel.util._FlxSignal.FlxSignal4">
				<c path="toSignal4.T1"/>
				<c path="toSignal4.T2"/>
				<c path="toSignal4.T3"/>
				<c path="toSignal4.T4"/>
			</c>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":to"/>
		</meta>
	</toSignal4>
	<meta><m n=":final"/></meta>
</class></impl>
	</abstract>
	<class path="flixel.util._FlxSignal.FlxTypedSignal_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/util/FlxSignal.hx" private="1" module="flixel.util.FlxSignal">
		<dispatch public="1" get="accessor" set="null" static="1">
			<c path="flixel.util.FlxTypedSignal.T"/>
			<meta><m n=":impl"/></meta>
		</dispatch>
		<_new public="1" set="method" static="1">
			<f a=""><x path="flixel.util.FlxTypedSignal"><c path="flixel.util.FlxTypedSignal.T"/></x></f>
			<meta>
				<m n=":extern"/>
				<m n=":impl"/>
			</meta>
		</_new>
		<add public="1" get="inline" set="null" line="17" static="1">
			<f a="this:listener">
				<c path="flixel.util.IFlxSignal"><c path="flixel.util.FlxTypedSignal.T"/></c>
				<c path="flixel.util.FlxTypedSignal.T"/>
				<x path="Void"/>
			</f>
			<meta><m n=":impl"/></meta>
		</add>
		<addOnce public="1" get="inline" set="null" line="22" static="1">
			<f a="this:listener">
				<c path="flixel.util.IFlxSignal"><c path="flixel.util.FlxTypedSignal.T"/></c>
				<c path="flixel.util.FlxTypedSignal.T"/>
				<x path="Void"/>
			</f>
			<meta><m n=":impl"/></meta>
		</addOnce>
		<remove public="1" get="inline" set="null" line="27" static="1">
			<f a="this:listener">
				<c path="flixel.util.IFlxSignal"><c path="flixel.util.FlxTypedSignal.T"/></c>
				<c path="flixel.util.FlxTypedSignal.T"/>
				<x path="Void"/>
			</f>
			<meta><m n=":impl"/></meta>
		</remove>
		<has public="1" get="inline" set="null" line="32" static="1">
			<f a="this:listener">
				<c path="flixel.util.IFlxSignal"><c path="flixel.util.FlxTypedSignal.T"/></c>
				<c path="flixel.util.FlxTypedSignal.T"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":impl"/></meta>
		</has>
		<removeAll public="1" get="inline" set="null" line="37" static="1">
			<f a="this">
				<c path="flixel.util.IFlxSignal"><c path="flixel.util.FlxTypedSignal.T"/></c>
				<x path="Void"/>
			</f>
			<meta><m n=":impl"/></meta>
		</removeAll>
		<get_dispatch get="inline" set="null" line="42" static="1">
			<f a="this">
				<c path="flixel.util.IFlxSignal"><c path="flixel.util.FlxTypedSignal.T"/></c>
				<c path="flixel.util.FlxTypedSignal.T"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_dispatch>
		<toSignal0 get="inline" set="null" line="48" static="1">
			<f a="signal">
				<c path="flixel.util.IFlxSignal"><f a=""><x path="Void"/></f></c>
				<c path="flixel.util._FlxSignal.FlxSignal0"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":to"/>
			</meta>
		</toSignal0>
		<toSignal1 params="T1" get="inline" set="null" line="54" static="1">
			<f a="signal">
				<c path="flixel.util.IFlxSignal"><f a="">
	<c path="toSignal1.T1"/>
	<x path="Void"/>
</f></c>
				<c path="flixel.util._FlxSignal.FlxSignal1"><c path="toSignal1.T1"/></c>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":to"/>
			</meta>
		</toSignal1>
		<toSignal2 params="T1:T2" get="inline" set="null" line="60" static="1">
			<f a="signal">
				<c path="flixel.util.IFlxSignal"><f a=":">
	<c path="toSignal2.T1"/>
	<c path="toSignal2.T2"/>
	<x path="Void"/>
</f></c>
				<c path="flixel.util._FlxSignal.FlxSignal2">
					<c path="toSignal2.T1"/>
					<c path="toSignal2.T2"/>
				</c>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":to"/>
			</meta>
		</toSignal2>
		<toSignal3 params="T1:T2:T3" get="inline" set="null" line="66" static="1">
			<f a="signal">
				<c path="flixel.util.IFlxSignal"><f a="::">
	<c path="toSignal3.T1"/>
	<c path="toSignal3.T2"/>
	<c path="toSignal3.T3"/>
	<x path="Void"/>
</f></c>
				<c path="flixel.util._FlxSignal.FlxSignal3">
					<c path="toSignal3.T1"/>
					<c path="toSignal3.T2"/>
					<c path="toSignal3.T3"/>
				</c>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":to"/>
			</meta>
		</toSignal3>
		<toSignal4 params="T1:T2:T3:T4" get="inline" set="null" line="72" static="1">
			<f a="signal">
				<c path="flixel.util.IFlxSignal"><f a=":::">
	<c path="toSignal4.T1"/>
	<c path="toSignal4.T2"/>
	<c path="toSignal4.T3"/>
	<c path="toSignal4.T4"/>
	<x path="Void"/>
</f></c>
				<c path="flixel.util._FlxSignal.FlxSignal4">
					<c path="toSignal4.T1"/>
					<c path="toSignal4.T2"/>
					<c path="toSignal4.T3"/>
					<c path="toSignal4.T4"/>
				</c>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":to"/>
			</meta>
		</toSignal4>
		<meta><m n=":final"/></meta>
	</class>
	<class path="flixel.util._FlxSignal.FlxSignalHandler" params="T" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/util/FlxSignal.hx" private="1" module="flixel.util.FlxSignal">
		<implements path="flixel.util.IFlxDestroyable"/>
		<listener public="1"><c path="flixel.util._FlxSignal.FlxSignalHandler.T"/></listener>
		<dispatchOnce public="1" set="null" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</dispatchOnce>
		<destroy public="1" set="method" line="89"><f a=""><x path="Void"/></f></destroy>
		<new public="1" set="method" line="83"><f a="listener:dispatchOnce">
	<c path="flixel.util._FlxSignal.FlxSignalHandler.T"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="flixel.util.IFlxSignal" params="T" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/util/FlxSignal.hx" module="flixel.util.FlxSignal" interface="1">
		<extends path="flixel.util.IFlxDestroyable"/>
		<dispatch public="1"><c path="flixel.util.IFlxSignal.T"/></dispatch>
		<add public="1" set="method"><f a="listener">
	<c path="flixel.util.IFlxSignal.T"/>
	<x path="Void"/>
</f></add>
		<addOnce public="1" set="method"><f a="listener">
	<c path="flixel.util.IFlxSignal.T"/>
	<x path="Void"/>
</f></addOnce>
		<remove public="1" set="method"><f a="listener">
	<c path="flixel.util.IFlxSignal.T"/>
	<x path="Void"/>
</f></remove>
		<removeAll public="1" set="method"><f a=""><x path="Void"/></f></removeAll>
		<has public="1" set="method"><f a="listener">
	<c path="flixel.util.IFlxSignal.T"/>
	<x path="Bool"/>
</f></has>
	</class>
	<class path="flixel.util._FlxSignal.FlxBaseSignal" params="T" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/util/FlxSignal.hx" private="1" module="flixel.util.FlxSignal">
		<implements path="flixel.util.IFlxSignal"><c path="flixel.util._FlxSignal.FlxBaseSignal.T"/></implements>
		<dispatch public="1">
			<c path="flixel.util._FlxSignal.FlxBaseSignal.T"/>
			<haxe_doc>* Typed function reference used to dispatch this signal.</haxe_doc>
		</dispatch>
		<handlers><c path="Array"><c path="flixel.util._FlxSignal.FlxSignalHandler"><c path="flixel.util._FlxSignal.FlxBaseSignal.T"/></c></c></handlers>
		<pendingRemove><c path="Array"><c path="flixel.util._FlxSignal.FlxSignalHandler"><c path="flixel.util._FlxSignal.FlxBaseSignal.T"/></c></c></pendingRemove>
		<processingListeners expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</processingListeners>
		<add public="1" set="method" line="112"><f a="listener">
	<c path="flixel.util._FlxSignal.FlxBaseSignal.T"/>
	<x path="Void"/>
</f></add>
		<addOnce public="1" set="method" line="118"><f a="listener">
	<c path="flixel.util._FlxSignal.FlxBaseSignal.T"/>
	<x path="Void"/>
</f></addOnce>
		<remove public="1" set="method" line="124"><f a="listener">
	<c path="flixel.util._FlxSignal.FlxBaseSignal.T"/>
	<x path="Void"/>
</f></remove>
		<has public="1" set="method" line="143"><f a="listener">
	<c path="flixel.util._FlxSignal.FlxBaseSignal.T"/>
	<x path="Bool"/>
</f></has>
		<removeAll public="1" get="inline" set="null" line="150"><f a=""><x path="Void"/></f></removeAll>
		<destroy public="1" set="method" line="155"><f a=""><x path="Void"/></f></destroy>
		<registerListener set="method" line="162"><f a="listener:dispatchOnce">
	<c path="flixel.util._FlxSignal.FlxBaseSignal.T"/>
	<x path="Bool"/>
	<c path="flixel.util._FlxSignal.FlxSignalHandler"><c path="flixel.util._FlxSignal.FlxBaseSignal.T"/></c>
</f></registerListener>
		<getHandler set="method" line="183"><f a="listener">
	<c path="flixel.util._FlxSignal.FlxBaseSignal.T"/>
	<c path="flixel.util._FlxSignal.FlxSignalHandler"><c path="flixel.util._FlxSignal.FlxBaseSignal.T"/></c>
</f></getHandler>
		<new public="1" set="method" line="106"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="flixel.util._FlxSignal.FlxSignal0" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/util/FlxSignal.hx" private="1" module="flixel.util.FlxSignal">
		<extends path="flixel.util._FlxSignal.FlxBaseSignal"><f a=""><x path="Void"/></f></extends>
		<dispatch0 public="1" set="method" line="209"><f a=""><x path="Void"/></f></dispatch0>
		<new public="1" set="method" line="203"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="flixel.util._FlxSignal.FlxSignal1" params="T1" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/util/FlxSignal.hx" private="1" module="flixel.util.FlxSignal">
		<extends path="flixel.util._FlxSignal.FlxBaseSignal"><f a="">
	<c path="flixel.util._FlxSignal.FlxSignal1.T1"/>
	<x path="Void"/>
</f></extends>
		<dispatch1 public="1" set="method" line="223"><f a="value1">
	<c path="flixel.util._FlxSignal.FlxSignal1.T1"/>
	<x path="Void"/>
</f></dispatch1>
		<new public="1" set="method" line="217"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="flixel.util._FlxSignal.FlxSignal2" params="T1:T2" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/util/FlxSignal.hx" private="1" module="flixel.util.FlxSignal">
		<extends path="flixel.util._FlxSignal.FlxBaseSignal"><f a=":">
	<c path="flixel.util._FlxSignal.FlxSignal2.T1"/>
	<c path="flixel.util._FlxSignal.FlxSignal2.T2"/>
	<x path="Void"/>
</f></extends>
		<dispatch2 public="1" set="method" line="237"><f a="value1:value2">
	<c path="flixel.util._FlxSignal.FlxSignal2.T1"/>
	<c path="flixel.util._FlxSignal.FlxSignal2.T2"/>
	<x path="Void"/>
</f></dispatch2>
		<new public="1" set="method" line="231"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="flixel.util._FlxSignal.FlxSignal3" params="T1:T2:T3" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/util/FlxSignal.hx" private="1" module="flixel.util.FlxSignal">
		<extends path="flixel.util._FlxSignal.FlxBaseSignal"><f a="::">
	<c path="flixel.util._FlxSignal.FlxSignal3.T1"/>
	<c path="flixel.util._FlxSignal.FlxSignal3.T2"/>
	<c path="flixel.util._FlxSignal.FlxSignal3.T3"/>
	<x path="Void"/>
</f></extends>
		<dispatch3 public="1" set="method" line="251"><f a="value1:value2:value3">
	<c path="flixel.util._FlxSignal.FlxSignal3.T1"/>
	<c path="flixel.util._FlxSignal.FlxSignal3.T2"/>
	<c path="flixel.util._FlxSignal.FlxSignal3.T3"/>
	<x path="Void"/>
</f></dispatch3>
		<new public="1" set="method" line="245"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="flixel.util._FlxSignal.FlxSignal4" params="T1:T2:T3:T4" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/util/FlxSignal.hx" private="1" module="flixel.util.FlxSignal">
		<extends path="flixel.util._FlxSignal.FlxBaseSignal"><f a=":::">
	<c path="flixel.util._FlxSignal.FlxSignal4.T1"/>
	<c path="flixel.util._FlxSignal.FlxSignal4.T2"/>
	<c path="flixel.util._FlxSignal.FlxSignal4.T3"/>
	<c path="flixel.util._FlxSignal.FlxSignal4.T4"/>
	<x path="Void"/>
</f></extends>
		<dispatch4 public="1" set="method" line="265"><f a="value1:value2:value3:value4">
	<c path="flixel.util._FlxSignal.FlxSignal4.T1"/>
	<c path="flixel.util._FlxSignal.FlxSignal4.T2"/>
	<c path="flixel.util._FlxSignal.FlxSignal4.T3"/>
	<c path="flixel.util._FlxSignal.FlxSignal4.T4"/>
	<x path="Void"/>
</f></dispatch4>
		<new public="1" set="method" line="259"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="flixel.util._FlxSignal.Macro" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/util/FlxSignal.hx" private="1" module="flixel.util.FlxSignal"><buildDispatch public="1" set="method" static="1"><f a="exprs">
	<d/>
	<d/>
</f></buildDispatch></class>
	<class path="flixel.util.FlxSort" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/util/FlxSort.hx">
		<ASCENDING public="1" get="inline" set="null" expr="-1" line="10" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>-1</e></m></meta>
		</ASCENDING>
		<DESCENDING public="1" get="inline" set="null" expr="1" line="11" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</DESCENDING>
		<byY public="1" get="inline" set="null" line="16" static="1">
			<f a="Order:Obj1:Obj2">
				<x path="Int"/>
				<c path="flixel.FlxObject"/>
				<c path="flixel.FlxObject"/>
				<x path="Int"/>
			</f>
			<haxe_doc>* You can use this function in FlxTypedGroup.sort() to sort FlxObjects by their y values.</haxe_doc>
		</byY>
		<byValues public="1" get="inline" set="null" line="24" static="1">
			<f a="Order:Value1:Value2">
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
			</f>
			<haxe_doc>* You can use this function as a backend to write a custom sorting function (see byY() for an example).</haxe_doc>
		</byValues>
		<haxe_doc>* Helper class for sort() in FlxTypedGroup, but could theoretically be used on regular arrays as well.</haxe_doc>
	</class>
	<class path="flixel.util.FlxSpriteUtil" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/util/FlxSpriteUtil.hx">
		<flashGfxSprite public="1" set="null" expr="new Sprite()" line="38" static="1">
			<t path="flash.display.Sprite"/>
			<meta><m n=":value"><e>new Sprite()</e></m></meta>
			<haxe_doc>* Useful helper objects for doing Flash-specific rendering.
	 * Primarily used for "debug visuals" like drawing bounding boxes directly to the screen buffer.</haxe_doc>
		</flashGfxSprite>
		<flashGfx public="1" set="null" expr="flashGfxSprite.graphics" line="39" static="1">
			<t path="flash.display.Graphics"/>
			<meta><m n=":value"><e>flashGfxSprite.graphics</e></m></meta>
		</flashGfx>
		<alphaMask public="1" set="method" line="54" static="1">
			<f a="output:source:mask">
				<c path="flixel.FlxSprite"/>
				<t path="flixel.system.FlxGraphicSource"/>
				<t path="flixel.system.FlxGraphicSource"/>
				<c path="flixel.FlxSprite"/>
			</f>
			<haxe_doc>* Takes two source images (typically from Embedded bitmaps) and puts the resulting image into the output FlxSprite.
	 * Note: It assumes the source and mask are the same size. Different sizes may result in undesired results.
	 * It works by copying the source image (your picture) into the output sprite. Then it removes all areas of it that do not
	 * have an alpha color value in the mask image. So if you draw a big black circle in your mask with a transparent edge, you'll
	 * get a circular image to appear.
	 * May lead to unexpected results if `source` does not have an alpha channel.
	 * 
	 * @param	output		The FlxSprite you wish the resulting image to be placed in (will adjust width/height of image)
	 * @param	source		The source image. Typically the one with the image / picture / texture in it.
	 * @param	mask		The mask to apply. Remember the non-alpha zero areas are the parts that will display.
	 * @return 	The FlxSprite for chaining</haxe_doc>
		</alphaMask>
		<alphaMaskFlxSprite public="1" set="method" line="83" static="1">
			<f a="sprite:mask:output">
				<c path="flixel.FlxSprite"/>
				<c path="flixel.FlxSprite"/>
				<c path="flixel.FlxSprite"/>
				<c path="flixel.FlxSprite"/>
			</f>
			<haxe_doc>* Takes the image data from two FlxSprites and puts the resulting image into the output FlxSprite.
	 * Note: It assumes the source and mask are the same size. Different sizes may result in undesired results.
	 * It works by copying the source image (your picture) into the output sprite. Then it removes all areas of it that do not
	 * have an alpha color value in the mask image. So if you draw a big black circle in your mask with a transparent edge, you'll
	 * get a circular image appear.
	 * May lead to unexpected results if `sprite`'s graphic does not have an alpha channel.
	 * 
	 * @param	sprite		The source FlxSprite. Typically the one with the image / picture / texture in it.
	 * @param	mask		The FlxSprite containing the mask to apply. Remember the non-alpha zero areas are the parts that will display.
	 * @param	output		The FlxSprite you wish the resulting image to be placed in (will adjust width/height of image)
	 * @return 	The output FlxSprite for chaining</haxe_doc>
		</alphaMaskFlxSprite>
		<screenWrap public="1" set="method" line="103" static="1">
			<f a="sprite:?Left:?Right:?Top:?Bottom" v=":true:true:true:true">
				<c path="flixel.FlxSprite"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<c path="flixel.FlxSprite"/>
			</f>
			<meta><m n=":value"><e>{ Bottom : true, Top : true, Right : true, Left : true }</e></m></meta>
			<haxe_doc>* Checks the x/y coordinates of the FlxSprite and keeps them within the 
	 * area of 0, 0, FlxG.width, FlxG.height (i.e. wraps it around the screen)
	 * 
	 * @param	sprite		The FlxSprite to keep within the screen
	 * @param	Left		Whether to activate screen wrapping on the left side of the screen
	 * @param	Right		Whether to activate screen wrapping on the right side of the screen
	 * @param	Top			Whether to activate screen wrapping on the top of the screen
	 * @param	Bottom		Whether to activate screen wrapping on the bottom of the screen
	 * @return	The FlxSprite for chaining</haxe_doc>
		</screenWrap>
		<bound public="1" set="method" line="136" static="1">
			<f a="sprite:?MinX:?MaxX:?MinY:?MaxY" v=":0:0:0:0">
				<c path="flixel.FlxSprite"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<c path="flixel.FlxSprite"/>
			</f>
			<meta><m n=":value"><e>{ MaxY : 0, MinY : 0, MaxX : 0, MinX : 0 }</e></m></meta>
			<haxe_doc>* Makes sure a FlxSprite doesn't leave the specified area - most common use case is to call this every frame in update().
	 * If you call this without specifying an area, the game area (FlxG.width / height as max) will be used. Takes the graphic size into account.
	 * 
	 * @param	sprite	The FlxSprite to bound to an area
	 * @param	MinX	The minimum x position allowed
	 * @param	MaxX	The maximum x position allowed
	 * @param	MinY	The minimum y position allowed
	 * @param	MaxY	The minimum y position allowed
	 * @return	The FlxSprite for chaining</haxe_doc>
		</bound>
		<space public="1" set="method" line="166" static="1">
			<f a="objects:startX:startY:?horizontalSpacing:?verticalSpacing:?spaceFromBounds" v=":::0:0:false">
				<c path="Array"><c path="flixel.FlxObject"/></c>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ spaceFromBounds : false, verticalSpacing : 0, horizontalSpacing : 0 }</e></m></meta>
			<haxe_doc>* Aligns a set of FlxObjects so there is equal spacing between them
	 * 
	 * @param	objects				An Array of FlxObjects
	 * @param	startX				The base X coordinate to start the spacing from
	 * @param	startY				The base Y coordinate to start the spacing from
	 * @param	horizontalSpacing	The amount of pixels between each sprite horizontally (default 0)
	 * @param	verticalSpacing		The amount of pixels between each sprite vertically (default 0)
	 * @param	spaceFromBounds		If set to true the h/v spacing values will be added to the width/height of the sprite, if false it will ignore this</haxe_doc>
		</space>
		<drawLine public="1" set="method" line="202" static="1">
			<f a="sprite:StartX:StartY:EndX:EndY:?lineStyle:?drawStyle">
				<c path="flixel.FlxSprite"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<t path="flixel.util.LineStyle"/>
				<t path="flixel.util.DrawStyle"/>
				<c path="flixel.FlxSprite"/>
			</f>
			<haxe_doc>* This function draws a line on a FlxSprite from position X1,Y1
	 * to position X2,Y2 with the specified color.
	 * 
	 * @param	sprite		The FlxSprite to manipulate
	 * @param	StartX		X coordinate of the line's start point.
	 * @param	StartY		Y coordinate of the line's start point.
	 * @param	EndX		X coordinate of the line's end point.
	 * @param	EndY		Y coordinate of the line's end point.
	 * @param	lineStyle	A LineStyle typedef containing the params of Graphics.lineStyle()
	 * @param	drawStyle	A DrawStyle typedef containing the params of BitmapData.draw()
	 * @return 	The FlxSprite for chaining</haxe_doc>
		</drawLine>
		<drawCurve public="1" set="method" line="229" static="1">
			<f a="sprite:StartX:StartY:EndX:EndY:ControlX:ControlY:?FillColor:?lineStyle:?drawStyle" v=":::::::FlxColor.TRANSPARENT::">
				<c path="flixel.FlxSprite"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="flixel.util.FlxColor"/>
				<t path="flixel.util.LineStyle"/>
				<t path="flixel.util.DrawStyle"/>
				<c path="flixel.FlxSprite"/>
			</f>
			<meta><m n=":value"><e>{ FillColor : FlxColor.TRANSPARENT }</e></m></meta>
			<haxe_doc>* This function draws a curve on a FlxSprite from position X1,Y1
	 * to anchor position X2,Y2 using control points X3,Y3 with the specified color.
	 * 
	 * @param	sprite		The FlxSprite to manipulate
	 * @param	StartX		X coordinate of the curve's start point.
	 * @param	StartY		Y coordinate of the curve's start point.
	 * @param	EndX		X coordinate of the curve's end/anchor point.
	 * @param	EndY		Y coordinate of the curve's end/anchor point.
	 * @param	ControlX	X coordinate of the curve's control point.
	 * @param	ControlY	Y coordinate of the curve's control point.
	 * @param	FillColor		The ARGB color to fill this curve with. FlxColor.TRANSPARENT (0x0) means no fill. Filling a curve draws a line from End to Start to complete the figure.
	 * @param	lineStyle	A LineStyle typedef containing the params of Graphics.lineStyle()
	 * @param	drawStyle	A DrawStyle typedef containing the params of BitmapData.draw()
	 * @return 	The FlxSprite for chaining</haxe_doc>
		</drawCurve>
		<drawRect public="1" set="method" line="253" static="1">
			<f a="sprite:X:Y:Width:Height:?FillColor:?lineStyle:?drawStyle" v=":::::FlxColor.WHITE::">
				<c path="flixel.FlxSprite"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="flixel.util.FlxColor"/>
				<t path="flixel.util.LineStyle"/>
				<t path="flixel.util.DrawStyle"/>
				<c path="flixel.FlxSprite"/>
			</f>
			<meta><m n=":value"><e>{ FillColor : FlxColor.WHITE }</e></m></meta>
			<haxe_doc>* This function draws a rectangle on a FlxSprite.
	 * 
	 * @param	sprite		The FlxSprite to manipulate
	 * @param	X			X coordinate of the rectangle's start point.
	 * @param	Y			Y coordinate of the rectangle's start point.
	 * @param	Width		Width of the rectangle
	 * @param	Height		Height of the rectangle
	 * @param	FillColor		The ARGB color to fill this rectangle with. FlxColor.TRANSPARENT (0x0) means no fill.
	 * @param	lineStyle	A LineStyle typedef containing the params of Graphics.lineStyle()
	 * @param	drawStyle	A DrawStyle typedef containing the params of BitmapData.draw()
	 * @return 	The FlxSprite for chaining</haxe_doc>
		</drawRect>
		<drawRoundRect public="1" set="method" line="277" static="1">
			<f a="sprite:X:Y:Width:Height:EllipseWidth:EllipseHeight:?FillColor:?lineStyle:?drawStyle" v=":::::::FlxColor.WHITE::">
				<c path="flixel.FlxSprite"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="flixel.util.FlxColor"/>
				<t path="flixel.util.LineStyle"/>
				<t path="flixel.util.DrawStyle"/>
				<c path="flixel.FlxSprite"/>
			</f>
			<meta><m n=":value"><e>{ FillColor : FlxColor.WHITE }</e></m></meta>
			<haxe_doc>* This function draws a rounded rectangle on a FlxSprite.
	 * 
	 * @param	sprite			The FlxSprite to manipulate
	 * @param	X				X coordinate of the rectangle's start point.
	 * @param	Y				Y coordinate of the rectangle's start point.
	 * @param	Width			Width of the rectangle
	 * @param	Height			Height of the rectangle
	 * @param	EllipseWidth	The width of the ellipse used to draw the rounded corners
	 * @param	EllipseHeight	The height of the ellipse used to draw the rounded corners
	 * @param	FillColor			The ARGB color to fill this rectangle with. FlxColor.TRANSPARENT (0x0) means no fill.
	 * @param	lineStyle		A LineStyle typedef containing the params of Graphics.lineStyle()
	 * @param	drawStyle		A DrawStyle typedef containing the params of BitmapData.draw()
	 * @return 	The FlxSprite for chaining</haxe_doc>
		</drawRoundRect>
		<drawCircle public="1" set="method" line="328" static="1">
			<f a="sprite:?X:?Y:?Radius:?FillColor:?lineStyle:?drawStyle" v=":-1:-1:-1:FlxColor.WHITE::">
				<c path="flixel.FlxSprite"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="flixel.util.FlxColor"/>
				<t path="flixel.util.LineStyle"/>
				<t path="flixel.util.DrawStyle"/>
				<c path="flixel.FlxSprite"/>
			</f>
			<meta><m n=":value"><e>{ FillColor : FlxColor.WHITE, Radius : -1, Y : -1, X : -1 }</e></m></meta>
			<haxe_doc><![CDATA[* This function draws a circle on a FlxSprite at position X,Y with the specified color.
	 * 
	 * @param	sprite		The FlxSprite to manipulate
	 * @param	X 			X coordinate of the circle's center (automatically centered on the sprite if -1)
	 * @param	Y 			Y coordinate of the circle's center (automatically centered on the sprite if -1)
	 * @param	Radius 		Radius of the circle (makes sure the circle fully fits on the sprite's graphic if < 1, assuming and and y are centered)
	 * @param	FillColor 		The ARGB color to fill this circle with. FlxColor.TRANSPARENT (0x0) means no fill.
	 * @param	lineStyle	A LineStyle typedef containing the params of Graphics.lineStyle()
	 * @param	drawStyle	A DrawStyle typedef containing the params of BitmapData.draw()
	 * @return 	The FlxSprite for chaining]]></haxe_doc>
		</drawCircle>
		<drawEllipse public="1" set="method" line="368" static="1">
			<f a="sprite:X:Y:Width:Height:?FillColor:?lineStyle:?drawStyle" v=":::::FlxColor.WHITE::">
				<c path="flixel.FlxSprite"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="flixel.util.FlxColor"/>
				<t path="flixel.util.LineStyle"/>
				<t path="flixel.util.DrawStyle"/>
				<c path="flixel.FlxSprite"/>
			</f>
			<meta><m n=":value"><e>{ FillColor : FlxColor.WHITE }</e></m></meta>
			<haxe_doc>* This function draws an ellipse on a FlxSprite.
	 * 
	 * @param	sprite		The FlxSprite to manipulate
	 * @param	X			X coordinate of the ellipse's start point.
	 * @param	Y			Y coordinate of the ellipse's start point.
	 * @param	Width		Width of the ellipse
	 * @param	Height		Height of the ellipse
	 * @param	FillColor		The ARGB color to fill this ellipse with. FlxColor.TRANSPARENT (0x0) means no fill.
	 * @param	lineStyle	A LineStyle typedef containing the params of Graphics.lineStyle()
	 * @param	drawStyle	A DrawStyle typedef containing the params of BitmapData.draw()
	 * @return 	The FlxSprite for chaining</haxe_doc>
		</drawEllipse>
		<drawTriangle public="1" set="method" line="389" static="1">
			<f a="sprite:X:Y:Height:?FillColor:?lineStyle:?drawStyle" v="::::FlxColor.WHITE::">
				<c path="flixel.FlxSprite"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="flixel.util.FlxColor"/>
				<t path="flixel.util.LineStyle"/>
				<t path="flixel.util.DrawStyle"/>
				<c path="flixel.FlxSprite"/>
			</f>
			<meta><m n=":value"><e>{ FillColor : FlxColor.WHITE }</e></m></meta>
			<haxe_doc>* This function draws a simple, equilateral triangle on a FlxSprite.
	 * 
	 * @param	sprite		The FlxSprite to manipulate
	 * @param	X			X position of the triangle
	 * @param	Y			Y position of the triangle
	 * @param	Height		Height of the triangle
	 * @param	FillColor		The ARGB color to fill this triangle with. FlxColor.TRANSPARENT (0x0) means no fill.
	 * @param	lineStyle	A LineStyle typedef containing the params of Graphics.lineStyle()
	 * @param	drawStyle	A DrawStyle typedef containing the params of BitmapData.draw()
	 * @return 	The FlxSprite for chaining</haxe_doc>
		</drawTriangle>
		<drawPolygon public="1" set="method" line="411" static="1">
			<f a="sprite:Vertices:?FillColor:?lineStyle:?drawStyle" v="::FlxColor.WHITE::">
				<c path="flixel.FlxSprite"/>
				<c path="Array"><c path="flixel.math.FlxPoint"/></c>
				<x path="flixel.util.FlxColor"/>
				<t path="flixel.util.LineStyle"/>
				<t path="flixel.util.DrawStyle"/>
				<c path="flixel.FlxSprite"/>
			</f>
			<meta><m n=":value"><e>{ FillColor : FlxColor.WHITE }</e></m></meta>
			<haxe_doc>* This function draws a polygon on a FlxSprite.
	 * 
	 * @param	sprite		The FlxSprite to manipulate
	 * @param	Vertices	Array of Vertices to use for drawing the polygon
	 * @param	FillColor		The ARGB color to fill this polygon with. FlxColor.TRANSPARENT (0x0) means no fill.
	 * @param	lineStyle	A LineStyle typedef containing the params of Graphics.lineStyle()
	 * @param	drawStyle	A DrawStyle typedef containing the params of BitmapData.draw()
	 * @return 	The FlxSprite for chaining</haxe_doc>
		</drawPolygon>
		<beginDraw public="1" get="inline" set="null" line="433" static="1">
			<f a="FillColor:?lineStyle">
				<x path="flixel.util.FlxColor"/>
				<t path="flixel.util.LineStyle"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noUsing"/></meta>
			<haxe_doc>* Helper function that the drawing functions use at the start to set the color and lineStyle.
	 * 
	 * @param	FillColor		The ARGB color to use for drawing
	 * @param	lineStyle	A LineStyle typedef containing the params of Graphics.lineStyle()</haxe_doc>
		</beginDraw>
		<endDraw public="1" get="inline" set="null" line="451" static="1">
			<f a="sprite:?drawStyle">
				<c path="flixel.FlxSprite"/>
				<t path="flixel.util.DrawStyle"/>
				<c path="flixel.FlxSprite"/>
			</f>
			<haxe_doc>* Helper function that the drawing functions use at the end.
	 * 
	 * @param	sprite		The FlxSprite to draw to
	 * @param	drawStyle	A DrawStyle typedef containing the params of BitmapData.draw()
	 * @return 	The FlxSprite for chaining</haxe_doc>
		</endDraw>
		<updateSpriteGraphic public="1" set="method" line="466" static="1">
			<f a="sprite:?drawStyle">
				<c path="flixel.FlxSprite"/>
				<t path="flixel.util.DrawStyle"/>
				<c path="flixel.FlxSprite"/>
			</f>
			<haxe_doc>* Just a helper function that is called at the end of the draw functions
	 * to handle a few things related to updating a sprite's graphic.
	 * 
	 * @param	Sprite		The FlxSprite to manipulate
	 * @param	drawStyle	A DrawStyle typedef containing the params of BitmapData.draw()
	 * @return 	The FlxSprite for chaining</haxe_doc>
		</updateSpriteGraphic>
		<setLineStyle public="1" get="inline" set="null" line="490" static="1">
			<f a="lineStyle">
				<t path="flixel.util.LineStyle"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noUsing"/></meta>
			<haxe_doc>* Just a helper function that is called in the draw functions
	 * to set the lineStyle via Graphics.lineStyle()
	 * 
	 * @param	lineStyle	The lineStyle typedef</haxe_doc>
		</setLineStyle>
		<getDefaultLineStyle public="1" get="inline" set="null" line="520" static="1">
			<f a="?lineStyle">
				<t path="flixel.util.LineStyle"/>
				<t path="flixel.util.LineStyle"/>
			</f>
			<haxe_doc>* Helper function for the default line styles of drawLine() and drawCurve()
	 * 
	 * @param   lineStyle   The lineStyle typedef</haxe_doc>
		</getDefaultLineStyle>
		<fill public="1" set="method" line="539" static="1">
			<f a="sprite:FillColor">
				<c path="flixel.FlxSprite"/>
				<x path="flixel.util.FlxColor"/>
				<c path="flixel.FlxSprite"/>
			</f>
			<haxe_doc>* Fills this sprite's graphic with a specific color.
	 * 
	 * @param	Sprite	The FlxSprite to manipulate
	 * @param	FillColor	The color with which to fill the graphic, format 0xAARRGGBB.
	 * @return 	The FlxSprite for chaining</haxe_doc>
		</fill>
		<flicker public="1" get="inline" set="null" line="563" static="1">
			<f a="Object:?Duration:?Interval:?EndVisibility:?ForceRestart:?CompletionCallback:?ProgressCallback" v=":1:0.04:true:true::">
				<c path="flixel.FlxObject"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<f a="">
					<c path="flixel.effects.FlxFlicker"/>
					<x path="Void"/>
				</f>
				<f a="">
					<c path="flixel.effects.FlxFlicker"/>
					<x path="Void"/>
				</f>
				<c path="flixel.effects.FlxFlicker"/>
			</f>
			<meta><m n=":value"><e>{ ForceRestart : true, EndVisibility : true, Interval : 0.04, Duration : 1 }</e></m></meta>
			<haxe_doc><![CDATA[* A simple flicker effect for sprites achieved by toggling visibility.
	 * 
	 * @param	Object				The sprite.
	 * @param	Duration			How long to flicker for (in seconds). `0` means "forever".
	 * @param	Interval			In what interval to toggle visibility. Set to `FlxG.elapsed` if `<= 0`!
	 * @param	EndVisibility		Force the visible value when the flicker completes, useful with fast repetitive use.
	 * @param	ForceRestart		Force the flicker to restart from beginning, discarding the flickering effect already in progress if there is one.
	 * @param	CompletionCallback	An optional callback that will be triggered when a flickering has finished.
	 * @param	ProgressCallback	An optional callback that will be triggered when visibility is toggled.
	 * @return The FlxFlicker object. FlxFlickers are pooled internally, so beware of storing references.]]></haxe_doc>
		</flicker>
		<isFlickering public="1" get="inline" set="null" line="574" static="1">
			<f a="Object">
				<c path="flixel.FlxObject"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Returns whether an object is flickering or not.
	 * 
	 * @param  Object 	The object to check against.</haxe_doc>
		</isFlickering>
		<stopFlickering public="1" get="inline" set="null" line="585" static="1">
			<f a="Object">
				<c path="flixel.FlxObject"/>
				<c path="flixel.FlxObject"/>
			</f>
			<haxe_doc>* Stops flickering of the object. Also it will make the object visible.
	 * 
	 * @param  Object 	The object to stop flickering.
	 * @return The FlxObject for chaining</haxe_doc>
		</stopFlickering>
		<fadeIn public="1" get="inline" set="null" line="598" static="1">
			<f a="sprite:?Duration:?ResetAlpha:?OnComplete" v=":1::">
				<c path="flixel.FlxSprite"/>
				<x path="Float"/>
				<x path="Bool"/>
				<t path="flixel.tweens.TweenCallback"/>
				<c path="flixel.FlxSprite"/>
			</f>
			<meta><m n=":value"><e>{ Duration : 1 }</e></m></meta>
			<haxe_doc>* Fade in a sprite, tweening alpha to 1.
	 * 
	 * @param  sprite 	The object to fade.
	 * @param  Duration How long the fade will take (in seconds).
	 * @return The FlxSprite for chaining</haxe_doc>
		</fadeIn>
		<fadeOut public="1" get="inline" set="null" line="615" static="1">
			<f a="sprite:?Duration:?OnComplete" v=":1:">
				<c path="flixel.FlxSprite"/>
				<x path="Float"/>
				<t path="flixel.tweens.TweenCallback"/>
				<c path="flixel.FlxSprite"/>
			</f>
			<meta><m n=":value"><e>{ Duration : 1 }</e></m></meta>
			<haxe_doc>* Fade out a sprite, tweening alpha to 0.
	 * 
	 * @param  sprite 	The object to fade.
	 * @param  Duration How long the fade will take (in seconds).
	 * @return The FlxSprite for chaining</haxe_doc>
		</fadeOut>
		<alphaTween set="method" line="621" static="1"><f a="sprite:f">
	<c path="flixel.FlxSprite"/>
	<x path="Float"/>
	<x path="Void"/>
</f></alphaTween>
		<haxe_doc>* Some handy functions for FlxSprite (FlxObject) manipulation, mostly drawing-related.
 * Note that stage quality impacts the results of the draw() functions - 
 * use FlxG.stage.quality = flash.display.StageQuality.BEST; for best results.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<typedef path="flixel.util.LineStyle" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/util/FlxSpriteUtil.hx" module="flixel.util.FlxSpriteUtil"><a>
	<thickness>
		<t path="Null"><x path="Float"/></t>
		<meta><m n=":optional"/></meta>
	</thickness>
	<scaleMode>
		<t path="Null"><t path="flash.display.LineScaleMode"/></t>
		<meta><m n=":optional"/></meta>
	</scaleMode>
	<pixelHinting>
		<t path="Null"><x path="Bool"/></t>
		<meta><m n=":optional"/></meta>
	</pixelHinting>
	<miterLimit>
		<t path="Null"><x path="Float"/></t>
		<meta><m n=":optional"/></meta>
	</miterLimit>
	<jointStyle>
		<t path="Null"><t path="flash.display.JointStyle"/></t>
		<meta><m n=":optional"/></meta>
	</jointStyle>
	<color>
		<t path="Null"><x path="flixel.util.FlxColor"/></t>
		<meta><m n=":optional"/></meta>
	</color>
	<capsStyle>
		<t path="Null"><t path="flash.display.CapsStyle"/></t>
		<meta><m n=":optional"/></meta>
	</capsStyle>
</a></typedef>
	<typedef path="flixel.util.DrawStyle" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/util/FlxSpriteUtil.hx" module="flixel.util.FlxSpriteUtil"><a>
	<smoothing>
		<t path="Null"><x path="Bool"/></t>
		<meta><m n=":optional"/></meta>
	</smoothing>
	<matrix>
		<t path="Null"><t path="flash.geom.Matrix"/></t>
		<meta><m n=":optional"/></meta>
	</matrix>
	<colorTransform>
		<t path="Null"><t path="flash.geom.ColorTransform"/></t>
		<meta><m n=":optional"/></meta>
	</colorTransform>
	<clipRect>
		<t path="Null"><t path="flash.geom.Rectangle"/></t>
		<meta><m n=":optional"/></meta>
	</clipRect>
	<blendMode>
		<t path="Null"><t path="flash.display.BlendMode"/></t>
		<meta><m n=":optional"/></meta>
	</blendMode>
</a></typedef>
	<class path="flixel.util.FlxStringUtil" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/util/FlxStringUtil.hx">
		<formatTicks public="1" get="inline" set="null" line="28" static="1">
			<f a="StartTicks:EndTicks">
				<x path="Int"/>
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>* Takes two "ticks" timestamps and formats them into the number of seconds that passed as a String.
	 * Useful for logging, debugging, the watch window, or whatever else.
	 * 
	 * @param	StartTicks	The first timestamp from the system.
	 * @param	EndTicks	The second timestamp from the system.
	 * @return	A String containing the formatted time elapsed information.</haxe_doc>
		</formatTicks>
		<formatTime public="1" set="method" line="40" static="1">
			<f a="Seconds:?ShowMS" v=":false">
				<x path="Float"/>
				<x path="Bool"/>
				<c path="String"/>
			</f>
			<meta><m n=":value"><e>{ ShowMS : false }</e></m></meta>
			<haxe_doc>* Format seconds as minutes with a colon, an optionally with milliseconds too.
	 * 
	 * @param	Seconds		The number of seconds (for example, time remaining, time spent, etc).
	 * @param	ShowMS		Whether to show milliseconds after a "." as well.  Default value is false.
	 * @return	A nicely formatted String, like "1:03".</haxe_doc>
		</formatTime>
		<formatArray public="1" set="method" line="70" static="1">
			<f a="AnyArray">
				<c path="Array"><d/></c>
				<c path="String"/>
			</f>
			<haxe_doc>* Generate a comma-separated string from an array.
	 * Especially useful for tracing or other debug output.
	 * 
	 * @param	AnyArray	Any Array object.
	 * @return	A comma-separated String containing the .toString() output of each element in the array.</haxe_doc>
		</formatArray>
		<formatStringMap public="1" set="method" line="92" static="1">
			<f a="AnyMap">
				<x path="Map">
					<c path="String"/>
					<d/>
				</x>
				<c path="String"/>
			</f>
			<haxe_doc>* Generate a comma-separated string representation of the keys of a StringMap.
	 * 
	 * @param  AnyMap    A StringMap object.
	 * @return  A String formatted like this: key1, key2, ..., keyX</haxe_doc>
		</formatStringMap>
		<formatMoney public="1" set="method" line="115" static="1">
			<f a="Amount:?ShowDecimal:?EnglishStyle" v=":true:true">
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<c path="String"/>
			</f>
			<meta><m n=":value"><e>{ EnglishStyle : true, ShowDecimal : true }</e></m></meta>
			<haxe_doc>* Automatically commas and decimals in the right places for displaying money amounts.
	 * Does not include a dollar sign or anything, so doesn't really do much
	 * if you call say `FlxString.formatMoney(10, false)`.
	 * However, very handy for displaying large sums or decimal money values.
	 * 
	 * @param	Amount			How much moneys (in dollars, or the equivalent "main" currency - i.e. not cents).
	 * @param	ShowDecimal		Whether to show the decimals/cents component.
	 * @param	EnglishStyle	Major quantities (thousands, millions, etc) separated by commas, and decimal by a period.
	 * @return	A nicely formatted String. Does not include a dollar sign or anything!</haxe_doc>
		</formatMoney>
		<formatBytes public="1" set="method" line="162" static="1">
			<f a="Bytes:?Precision" v=":2">
				<x path="Float"/>
				<x path="Int"/>
				<c path="String"/>
			</f>
			<meta><m n=":value"><e>{ Precision : 2 }</e></m></meta>
			<haxe_doc><![CDATA[* Takes an amount of bytes and finds the fitting unit. Makes sure that the 
	 * value is below 1024. Example: formatBytes(123456789); -> 117.74MB]]></haxe_doc>
		</formatBytes>
		<filterDigits public="1" set="method" line="180" static="1">
			<f a="Input">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>* Takes a string and filters out everything but the digits.
	 * 
	 * @param 	Input	The input string
	 * @return 	The output string, digits-only</haxe_doc>
		</filterDigits>
		<htmlFormat public="1" set="method" line="206" static="1">
			<f a="Text:?Size:?Color:?Bold:?Italic:?Underlined" v=":12:&quot;FFFFFF&quot;:false:false:false">
				<c path="String"/>
				<x path="Int"/>
				<c path="String"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<c path="String"/>
			</f>
			<meta><m n=":value"><e>{ Underlined : false, Italic : false, Bold : false, Color : "FFFFFF", Size : 12 }</e></m></meta>
			<haxe_doc>* Format a text with html tags - useful for TextField.htmlText. 
	 * Used by the log window of the debugger.
	 * 
	 * @param	Text		The text to format
	 * @param	Size		The text size, using the font-size-tag
	 * @param	Color		The text color, using font-color-tag
	 * @param	Bold		Whether the text should be bold (b-tag)
	 * @param	Italic		Whether the text should be italic (i-tag)
	 * @param	Underlined 	Whether the text should be underlined (u-tag)
	 * @return	The html-formatted text.</haxe_doc>
		</htmlFormat>
		<getClassName public="1" set="method" line="237" static="1">
			<f a="Obj:?Simple" v=":false">
				<d/>
				<x path="Bool"/>
				<c path="String"/>
			</f>
			<meta><m n=":value"><e>{ Simple : false }</e></m></meta>
			<haxe_doc>* Get the String name of any Object.
	 * 
	 * @param	Obj		The object in question.
	 * @param	Simple	Returns only the class name, not the package or packages.
	 * @return	The name of the Class as a String object.</haxe_doc>
		</getClassName>
		<getHost public="1" set="method" line="269" static="1">
			<f a="url">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>* Returns the host from the specified URL.
	 * The host is one of three parts that comprise the authority.  (User and port are the other two parts.)
	 * For example, the host for "ftp://anonymous@ftp.domain.test:990/" is "ftp.domain.test".
	 *
	 * @return	The host from the URL; or the empty string ("") upon failure.
	 * @since 4.3.0</haxe_doc>
		</getHost>
		<getDomain public="1" set="method" line="288" static="1">
			<f a="url">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>* Returns the domain from the specified URL.
	 * The domain, in this case, refers specifically to the first and second levels only.
	 * For example, the domain for "api.haxe.org" is "haxe.org".
	 *
	 * @return	The domain from the URL; or the empty string ("") upon failure.</haxe_doc>
		</getDomain>
		<sameClassName public="1" get="inline" set="null" line="311" static="1">
			<f a="Obj1:Obj2:?Simple" v="::true">
				<d/>
				<d/>
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":value"><e>{ Simple : true }</e></m></meta>
			<haxe_doc>* Helper function that uses getClassName to compare two objects' class names.
	 * 
	 * @param	Obj1	The first object
	 * @param	Obj2	The second object
	 * @param	Simple 	Only uses the class name, not the package or packages.
	 * @return	Whether they have the same class name or not</haxe_doc>
		</sameClassName>
		<toIntArray public="1" set="method" line="322" static="1">
			<f a="Data">
				<c path="String"/>
				<c path="Array"><x path="Int"/></c>
			</f>
			<haxe_doc>* Split a comma-separated string into an array of ints
	 * 
	 * @param	Data 	String formatted like this: "1, 2, 5, -10, 120, 27"
	 * @return	An array of ints</haxe_doc>
		</toIntArray>
		<toFloatArray public="1" set="method" line="343" static="1">
			<f a="Data">
				<c path="String"/>
				<c path="Array"><x path="Float"/></c>
			</f>
			<haxe_doc>* Split a comma-separated string into an array of floats
	 * 
	 * @param	Data string formatted like this: "1.0,2.1,5.6,1245587.9, -0.00354"
	 * @return	An array of floats</haxe_doc>
		</toFloatArray>
		<arrayToCSV public="1" set="method" line="366" static="1">
			<f a="Data:Width:?Invert" v="::false">
				<c path="Array"><x path="Int"/></c>
				<x path="Int"/>
				<x path="Bool"/>
				<c path="String"/>
			</f>
			<meta><m n=":value"><e>{ Invert : false }</e></m></meta>
			<haxe_doc>* Converts a one-dimensional array of tile data to a comma-separated string.
	 * 
	 * @param	Data		An array full of integer tile references.
	 * @param	Width		The number of tiles in each row.
	 * @param	Invert		Recommended only for 1-bit arrays - changes 0s to 1s and vice versa.
	 * @return	A comma-separated string containing the level data in a FlxTilemap-friendly format.</haxe_doc>
		</arrayToCSV>
		<bitmapToCSV public="1" set="method" line="431" static="1">
			<f a="Bitmap:?Invert:?Scale:?ColorMap" v=":false:1:">
				<t path="flash.display.BitmapData"/>
				<x path="Bool"/>
				<x path="Int"/>
				<c path="Array"><x path="flixel.util.FlxColor"/></c>
				<c path="String"/>
			</f>
			<meta><m n=":value"><e>{ Scale : 1, Invert : false }</e></m></meta>
			<haxe_doc>* Converts a BitmapData object to a comma-separated string. Black pixels are flagged as 'solid' by default,
	 * non-black pixels are set as non-colliding. Black pixels must be PURE BLACK.
	 * 
	 * @param	Bitmap		A Flash BitmapData object, preferably black and white.
	 * @param	Invert		Load white pixels as solid instead.
	 * @param	Scale		Default is 1. Scale of 2 means each pixel forms a 2x2 block of tiles, and so on.
	 * @param	ColorMap	An array of color values (alpha values are ignored) in the order they're intended to be assigned as indices
	 * @return	A comma-separated string containing the level data in a FlxTilemap-friendly format.</haxe_doc>
		</bitmapToCSV>
		<imageToCSV public="1" set="method" line="545" static="1">
			<f a="ImageFile:?Invert:?Scale:?ColorMap" v=":false:1:">
				<d/>
				<x path="Bool"/>
				<x path="Int"/>
				<c path="Array"><x path="flixel.util.FlxColor"/></c>
				<c path="String"/>
			</f>
			<meta><m n=":value"><e>{ Scale : 1, Invert : false }</e></m></meta>
			<haxe_doc>* Converts a resource image file to a comma-separated string. Black pixels are flagged as 'solid' by default,
	 * non-black pixels are set as non-colliding. Black pixels must be PURE BLACK.
	 * 
	 * @param	ImageFile	An embedded graphic, preferably black and white.
	 * @param	Invert		Load white pixels as solid instead.
	 * @param	Scale		Default is 1.  Scale of 2 means each pixel forms a 2x2 block of tiles, and so on.
	 * @param	ColorMap	An array of color values (alpha values are ignored) in the order they're intended to be assigned as indices
	 * @return	A comma-separated string containing the level data in a FlxTilemap-friendly format.</haxe_doc>
		</imageToCSV>
		<getDebugString public="1" set="method" line="567" static="1">
			<f a="LabelValuePairs">
				<c path="Array"><c path="flixel.util.LabelValuePair"/></c>
				<c path="String"/>
			</f>
			<haxe_doc>* Helper function to create a string for toString() functions. Automatically rounds values according to FlxG.debugger.precision.
	 * Strings are formatted in the format: (x: 50 | y: 60 | visible: false)
	 * 
	 * @param	LabelValuePairs		Array with the data for the string</haxe_doc>
		</getDebugString>
		<contains public="1" get="inline" set="null" line="586" static="1"><f a="s:str">
	<c path="String"/>
	<c path="String"/>
	<x path="Bool"/>
</f></contains>
		<remove public="1" get="inline" set="null" line="594" static="1">
			<f a="s:sub">
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>* Removes occurrences of a substring by calling `StringTools.replace(s, sub, "")`.</haxe_doc>
		</remove>
		<insert public="1" get="inline" set="null" line="602" static="1">
			<f a="s:pos:insertion">
				<c path="String"/>
				<x path="Int"/>
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>* Inserts `insertion` into `s` at index `pos`.</haxe_doc>
		</insert>
		<sortAlphabetically public="1" set="method" line="607" static="1"><f a="list">
	<c path="Array"><c path="String"/></c>
	<c path="Array"><c path="String"/></c>
</f></sortAlphabetically>
		<isNullOrEmpty public="1" get="inline" set="null" line="624" static="1">
			<f a="s">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Returns true if `s` equals `null` or is empty.
	 * @since 4.1.0</haxe_doc>
		</isNullOrEmpty>
		<haxe_doc>* A class primarily containing functions related 
 * to formatting different data types to strings.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="flixel.util.LabelValuePair" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/util/FlxStringUtil.hx" module="flixel.util.FlxStringUtil">
		<implements path="flixel.util.IFlxDestroyable"/>
		<_pool expr="new FlxPool&lt;LabelValuePair&gt;(LabelValuePair)" line="632" static="1">
			<c path="flixel.util.FlxPool_flixel_util_LabelValuePair"/>
			<meta><m n=":value"><e><![CDATA[new FlxPool<LabelValuePair>(LabelValuePair)]]></e></m></meta>
		</_pool>
		<weak public="1" get="inline" set="null" line="634" static="1"><f a="label:value">
	<c path="String"/>
	<d/>
	<c path="flixel.util.LabelValuePair"/>
</f></weak>
		<label public="1"><c path="String"/></label>
		<value public="1"><d/></value>
		<create public="1" get="inline" set="null" line="642"><f a="label:value">
	<c path="String"/>
	<d/>
	<c path="flixel.util.LabelValuePair"/>
</f></create>
		<put public="1" get="inline" set="null" line="649"><f a=""><x path="Void"/></f></put>
		<destroy public="1" get="inline" set="null" line="654"><f a=""><x path="Void"/></f></destroy>
		<new set="method" line="661">
			<f a=""><x path="Void"/></f>
			<meta><m n=":keep"/></meta>
		</new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="flixel.util.FlxTimer" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/util/FlxTimer.hx">
		<implements path="flixel.util.IFlxDestroyable"/>
		<globalManager public="1" static="1">
			<c path="flixel.util.FlxTimerManager"/>
			<haxe_doc>* The global timer manager that handles global timers
	 * @since 4.2.0</haxe_doc>
		</globalManager>
		<manager public="1">
			<c path="flixel.util.FlxTimerManager"/>
			<haxe_doc>* The manager to which this timer belongs
	 * @since 4.2.0</haxe_doc>
		</manager>
		<time public="1" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* How much time the timer was set for.</haxe_doc>
		</time>
		<loops public="1" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* How many loops the timer was set for. 0 means "looping forever".</haxe_doc>
		</loops>
		<active public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
			<haxe_doc>* Pauses or checks the pause state of the timer.</haxe_doc>
		</active>
		<finished public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
			<haxe_doc>* Check to see if the timer is finished.</haxe_doc>
		</finished>
		<onComplete public="1">
			<f a="">
				<c path="flixel.util.FlxTimer"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Function that gets called when timer completes.
	 * Callback should be formed "onTimer(Timer:FlxTimer);"</haxe_doc>
		</onComplete>
		<timeLeft public="1" get="accessor" set="null">
			<x path="Float"/>
			<haxe_doc>* Read-only: check how much time is left on the timer.</haxe_doc>
		</timeLeft>
		<elapsedTime public="1" get="accessor" set="null">
			<x path="Float"/>
			<haxe_doc>* Read-only: The amount of milliseconds that have elapsed since the timer was started</haxe_doc>
		</elapsedTime>
		<loopsLeft public="1" get="accessor" set="null">
			<x path="Int"/>
			<haxe_doc>* Read-only: check how many loops are left on the timer.</haxe_doc>
		</loopsLeft>
		<elapsedLoops public="1" get="accessor" set="null">
			<x path="Int"/>
			<haxe_doc>* Read-only: how many loops that have elapsed since the timer was started.</haxe_doc>
		</elapsedLoops>
		<progress public="1" get="accessor" set="null">
			<x path="Float"/>
			<haxe_doc>* Read-only: how far along the timer is, on a scale of 0.0 to 1.0.</haxe_doc>
		</progress>
		<_timeCounter expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* Internal tracker for the actual timer counting up.</haxe_doc>
		</_timeCounter>
		<_loopsCounter expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* Internal tracker for the loops counting up.</haxe_doc>
		</_loopsCounter>
		<_inManager expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</_inManager>
		<destroy public="1" set="method" line="89">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Clean up memory.</haxe_doc>
		</destroy>
		<start public="1" set="method" line="104">
			<f a="?Time:?OnComplete:?Loops" v="1::1">
				<x path="Float"/>
				<f a="">
					<c path="flixel.util.FlxTimer"/>
					<x path="Void"/>
				</f>
				<x path="Int"/>
				<c path="flixel.util.FlxTimer"/>
			</f>
			<meta><m n=":value"><e>{ Loops : 1, Time : 1 }</e></m></meta>
			<haxe_doc>* Starts the timer and adds the timer to the timer manager.
	 * 
	 * @param	Time		How many seconds it takes for the timer to go off.
	 * 						If 0 then timer will fire OnComplete callback only once at the first call of update method (which means that Loops argument will be ignored).
	 * @param	OnComplete	Optional, triggered whenever the time runs out, once for each loop.
	 * 						Callback should be formed "onTimer(Timer:FlxTimer);"
	 * @param	Loops		How many times the timer should go off. 0 means "looping forever".
	 * @return	A reference to itself (handy for chaining or whatever).</haxe_doc>
		</start>
		<reset public="1" set="method" line="131">
			<f a="?NewTime" v="-1">
				<x path="Float"/>
				<c path="flixel.util.FlxTimer"/>
			</f>
			<meta><m n=":value"><e>{ NewTime : -1 }</e></m></meta>
			<haxe_doc>* Restart the timer using the new duration
	 * @param	NewDuration	The duration of this timer in ms.</haxe_doc>
		</reset>
		<cancel public="1" set="method" line="143">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Stops the timer and removes it from the timer manager.</haxe_doc>
		</cancel>
		<update public="1" set="method" line="161">
			<f a="elapsed">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Called by the timer manager plugin to update the timer.
	 * If time runs out, the loop counter is advanced, the timer reset, and the callback called if it exists.
	 * If the timer runs out of loops, then the timer calls cancel().
	 * However, callbacks are called AFTER cancel() is called.</haxe_doc>
		</update>
		<onLoopFinished set="method" line="178">
			<f a=""><x path="Void"/></f>
			<meta><m n=":allow"><e>flixel.util.FlxTimerManager</e></m></meta>
		</onLoopFinished>
		<get_timeLeft get="inline" set="null" line="187"><f a=""><x path="Float"/></f></get_timeLeft>
		<get_elapsedTime get="inline" set="null" line="192"><f a=""><x path="Float"/></f></get_elapsedTime>
		<get_loopsLeft get="inline" set="null" line="197"><f a=""><x path="Int"/></f></get_loopsLeft>
		<get_elapsedLoops get="inline" set="null" line="202"><f a=""><x path="Int"/></f></get_elapsedLoops>
		<get_progress get="inline" set="null" line="207"><f a=""><x path="Float"/></f></get_progress>
		<new public="1" set="method" line="81">
			<f a="?manager">
				<c path="flixel.util.FlxTimerManager"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Creates a new timer.</haxe_doc>
		</new>
		<haxe_doc>* A simple timer class, leveraging the new plugins system.
 * Can be used with callbacks or by polling the finished flag.
 * Not intended to be added to a game state or group; the timer manager
 * is responsible for actually calling update(), not the user.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="flixel.util.FlxTimerManager" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/util/FlxTimer.hx" module="flixel.util.FlxTimer">
		<extends path="flixel.FlxBasic"/>
		<_timers expr="[]">
			<c path="Array"><c path="flixel.util.FlxTimer"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</_timers>
		<destroy public="1" set="method" line="237" override="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Clean up memory.</haxe_doc>
		</destroy>
		<update public="1" set="method" line="249" override="1">
			<f a="elapsed">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Called by FlxG.plugins.update() before the game state has been updated.
	 * Cycles through timers and calls update() on each one.</haxe_doc>
		</update>
		<add set="method" line="286">
			<f a="Timer">
				<c path="flixel.util.FlxTimer"/>
				<x path="Void"/>
			</f>
			<meta><m n=":allow"><e>flixel.util.FlxTimer</e></m></meta>
			<haxe_doc>* Add a new timer to the timer manager.
	 * Called when FlxTimer is started.
	 * 
	 * @param	Timer	The FlxTimer you want to add to the manager.</haxe_doc>
		</add>
		<remove set="method" line="298">
			<f a="Timer">
				<c path="flixel.util.FlxTimer"/>
				<x path="Void"/>
			</f>
			<meta><m n=":allow"><e>flixel.util.FlxTimer</e></m></meta>
			<haxe_doc>* Remove a timer from the timer manager.
	 * Called automatically by FlxTimer's cancel() function.
	 * 
	 * @param	Timer	The FlxTimer you want to remove from the manager.</haxe_doc>
		</remove>
		<completeAll public="1" set="method" line="308">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Immediately updates all `active`, non-infinite timers to their end points, repeatedly,
	 * until all their loops are finished, resulting in `loopsLeft` callbacks being run.
	 * @since 4.2.0</haxe_doc>
		</completeAll>
		<clear public="1" get="inline" set="null" line="328">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Removes all the timers from the timer manager.</haxe_doc>
		</clear>
		<forEach public="1" set="method" line="339">
			<f a="Function">
				<f a="">
					<c path="flixel.util.FlxTimer"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<haxe_doc>* Applies a function to all timers
	 * 
	 * @param   Function   A function that modifies one timer at a time
	 * @since   4.2.0</haxe_doc>
		</forEach>
		<new public="1" set="method" line="224">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Instantiates a new timer manager.</haxe_doc>
		</new>
		<haxe_doc>* A simple manager for tracking and updating game timer objects. 
 * Normally accessed via the static `FlxTimer.manager` rather than being created separately.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<enum path="flixel.util.FlxVerticalAlign" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/util/FlxVerticalAlign.hx">
		<TOP/>
		<CENTER/>
		<BOTTOM/>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<class path="flixel.util.helpers.FlxBounds" params="T" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/util/helpers/FlxBounds.hx">
		<min public="1">
			<c path="flixel.util.helpers.FlxBounds.T"/>
			<haxe_doc>* The minimum value of this property.</haxe_doc>
		</min>
		<max public="1">
			<c path="flixel.util.helpers.FlxBounds.T"/>
			<haxe_doc>* The maximum value of this property.</haxe_doc>
		</max>
		<active public="1" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
			<haxe_doc>* A flag that can be used to toggle the use of this property.</haxe_doc>
		</active>
		<set public="1" set="method" line="42">
			<f a="min:?max">
				<c path="flixel.util.helpers.FlxBounds.T"/>
				<c path="flixel.util.helpers.FlxBounds.T"/>
				<c path="flixel.util.helpers.FlxBounds"><c path="flixel.util.helpers.FlxBounds.T"/></c>
			</f>
			<haxe_doc>* Handy function to set the minimum and maximum values of this Bounds object in one line.
	 * 
	 * @param	min  The new minimum value of the property.
	 * @param	max  The new maximum value of the property. Optional, will be set equal to min if ignored.
	 * @return  This Bounds instance (nice for chaining stuff together).</haxe_doc>
		</set>
		<equals public="1" get="inline" set="null" line="55">
			<f a="otherBounds">
				<c path="flixel.util.helpers.FlxBounds"><c path="flixel.util.helpers.FlxBounds.T"/></c>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Function to compare this FlxBounds to another.
	 * 
	 * @param	OtherFlxBounds  The other FlxBounds to compare to this one.
	 * @return	True if the FlxBounds have the same min and max value, false otherwise.</haxe_doc>
		</equals>
		<toString public="1" set="method" line="63">
			<f a=""><c path="String"/></f>
			<haxe_doc>* Convert object to readable string name. Useful for debugging, save games, etc.</haxe_doc>
		</toString>
		<new public="1" set="method" line="29">
			<f a="min:?max">
				<c path="flixel.util.helpers.FlxBounds.T"/>
				<c path="flixel.util.helpers.FlxBounds.T"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Create a new Bounds object. Must be typed, e.g. `var bounds = new FlxBounds<Float>(0, 0)`;
	 * 
	 * @param	min  The minimum value of the property.
	 * @param	max  The maximum value of the property. Optional, will be set equal to min if ignored.]]></haxe_doc>
		</new>
		<haxe_doc>* Helper object for holding minimum and maximum values of various properties.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="flixel.util.helpers.FlxPointRangeBounds" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/util/helpers/FlxPointRangeBounds.hx">
		<implements path="flixel.util.IFlxDestroyable"/>
		<start public="1">
			<c path="flixel.util.helpers.FlxBounds"><c path="flixel.math.FlxPoint"/></c>
			<haxe_doc>* The beginning X and Y values of this property.</haxe_doc>
		</start>
		<end public="1">
			<c path="flixel.util.helpers.FlxBounds"><c path="flixel.math.FlxPoint"/></c>
			<haxe_doc>* The ending X and Y values of this property.</haxe_doc>
		</end>
		<active public="1" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
			<haxe_doc>* A flag that can be used to toggle the use of this property.</haxe_doc>
		</active>
		<set public="1" set="method" line="60">
			<f a="startMinX:?startMinY:?startMaxX:?startMaxY:?endMinX:?endMinY:?endMaxX:?endMaxY">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<c path="flixel.util.helpers.FlxPointRangeBounds"/>
			</f>
			<haxe_doc>* Handy function to set the the beginning and ending range of values for a FlxPoint in one line.
	 * 
	 * @param   startMinX  The minimum possible initial value of X for this property for particles launched from this emitter.
	 * @param   startMinY  The minimum possible initial value of Y for this property for particles launched from this emitter. Optional, will be set equal to startMinX if ignored.
	 * @param   startMaxX  The maximum possible initial value of X for this property for particles launched from this emitter. Optional, will be set equal to startMinX if ignored.
	 * @param   startMaxY  The maximum possible initial value of Y for this property for particles launched from this emitter. Optional, will be set equal to startMinY if ignored.
	 * @param   endMinX    The minimum possible final value of X for this property for particles launched from this emitter. Optional, will be set equal to startMinX if ignored.
	 * @param   endMinY    The minimum possible final value of Y for this property for particles launched from this emitter. Optional, will be set equal to startMinY if ignored.
	 * @param   endMaxX    The maximum possible final value of X for this property for particles launched from this emitter. Optional, will be set equal to endMinX if ignored.
	 * @param   endMaxY    The maximum possible final value of Y for this property for particles launched from this emitter. Optional, will be set equal to endMinY if ignored.
	 * @return  This FlxPointRangeBounds instance (nice for chaining stuff together).</haxe_doc>
		</set>
		<equals public="1" get="inline" set="null" line="80">
			<f a="OtherFlxPointRangeBounds">
				<c path="flixel.util.helpers.FlxPointRangeBounds"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Function to compare this FlxPointRangeBounds to another.
	 * 
	 * @param	OtherFlxPointRangeBounds  The other FlxPointRangeBounds to compare to this one.
	 * @return	True if the FlxPointRangeBounds have the same min and max value, false otherwise.</haxe_doc>
		</equals>
		<toString public="1" set="method" line="91">
			<f a=""><c path="String"/></f>
			<haxe_doc>* Convert object to readable string name. Useful for debugging, save games, etc.</haxe_doc>
		</toString>
		<destroy public="1" set="method" line="104"><f a=""><x path="Void"/></f></destroy>
		<new public="1" set="method" line="39">
			<f a="startMinX:?startMinY:?startMaxX:?startMaxY:?endMinX:?endMinY:?endMaxX:?endMaxY">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Create a new FlxPointRangeBounds object.
	 * 
	 * @param   startMinX  The minimum possible initial value of X for this property for particles launched from this emitter.
	 * @param   startMinY  The minimum possible initial value of Y for this property for particles launched from this emitter. Optional, will be set equal to startMinX if ignored.
	 * @param   startMaxX  The maximum possible initial value of X for this property for particles launched from this emitter. Optional, will be set equal to startMinX if ignored.
	 * @param   startMaxY  The maximum possible initial value of Y for this property for particles launched from this emitter. Optional, will be set equal to startMinY if ignored.
	 * @param   endMinX    The minimum possible final value of X for this property for particles launched from this emitter. Optional, will be set equal to startMinX if ignored.
	 * @param   endMinY    The minimum possible final value of Y for this property for particles launched from this emitter. Optional, will be set equal to startMinY if ignored.
	 * @param   endMaxX    The maximum possible final value of X for this property for particles launched from this emitter. Optional, will be set equal to endMinX if ignored.
	 * @param   endMaxY    The maximum possible final value of Y for this property for particles launched from this emitter. Optional, will be set equal to endMinY if ignored.
	 * @return  This FlxPointRangeBounds instance (nice for chaining stuff together).</haxe_doc>
		</new>
		<haxe_doc><![CDATA[* Helper object for holding beginning minimum/maximum and ending minimum/maximum values of FlxPoints, which have both an x and y component.
 * This would extends Range<Bounds<FlxPoint>> but this allows a more practical use of set().]]></haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="flixel.util.helpers.FlxRange" params="T" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/util/helpers/FlxRange.hx">
		<start public="1">
			<c path="flixel.util.helpers.FlxRange.T"/>
			<haxe_doc>* The beginning value of this property.</haxe_doc>
		</start>
		<end public="1">
			<c path="flixel.util.helpers.FlxRange.T"/>
			<haxe_doc>* The ending value of this property.</haxe_doc>
		</end>
		<active public="1" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
			<haxe_doc>* A flag that can be used to toggle the use of this property.</haxe_doc>
		</active>
		<set public="1" set="method" line="42">
			<f a="start:?end">
				<c path="flixel.util.helpers.FlxRange.T"/>
				<c path="flixel.util.helpers.FlxRange.T"/>
				<c path="flixel.util.helpers.FlxRange"><c path="flixel.util.helpers.FlxRange.T"/></c>
			</f>
			<haxe_doc>* Handy function to set the initial and final values of this Range object in one line.
	 * 
	 * @param	start  The new beginning value of the property.
	 * @param	end    The new final value of the property.  Optional, will be set equal to start if ignored.
	 * @return  This Range instance (nice for chaining stuff together).</haxe_doc>
		</set>
		<equals public="1" get="inline" set="null" line="56">
			<f a="OtherFlxRange">
				<c path="flixel.util.helpers.FlxRange"><c path="flixel.util.helpers.FlxRange.T"/></c>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Function to compare this FlxRange to another.
	 * 
	 * @param	OtherFlxRange  The other FlxRange to compare to this one.
	 * @return	True if the FlxRanges have the same start and end value, false otherwise.</haxe_doc>
		</equals>
		<toString public="1" set="method" line="64">
			<f a=""><c path="String"/></f>
			<haxe_doc>* Convert object to readable string name. Useful for debugging, save games, etc.</haxe_doc>
		</toString>
		<new public="1" set="method" line="29">
			<f a="start:?end">
				<c path="flixel.util.helpers.FlxRange.T"/>
				<c path="flixel.util.helpers.FlxRange.T"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Create a new Range object. Must be typed, e.g. var myRange = new Range<Float>(0, 0);
	 * 
	 * @param	start  The beginning value of the property.
	 * @param	end    The ending value of the property. Optional, will be set equal to start if ignored.]]></haxe_doc>
		</new>
		<haxe_doc>* Helper object for holding beginning and ending values of various properties.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="flixel.util.helpers.FlxRangeBounds" params="T" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/util/helpers/FlxRangeBounds.hx">
		<start public="1">
			<c path="flixel.util.helpers.FlxBounds"><c path="flixel.util.helpers.FlxRangeBounds.T"/></c>
			<haxe_doc>* The beginning minimum and maximum values of this property.</haxe_doc>
		</start>
		<end public="1">
			<c path="flixel.util.helpers.FlxBounds"><c path="flixel.util.helpers.FlxRangeBounds.T"/></c>
			<haxe_doc>* The ending minimum and maximum values of this property.</haxe_doc>
		</end>
		<active public="1" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
			<haxe_doc>* A flag that can be used to toggle the use of this property.</haxe_doc>
		</active>
		<set public="1" set="method" line="48">
			<f a="startMin:?startMax:?endMin:?endMax">
				<c path="flixel.util.helpers.FlxRangeBounds.T"/>
				<c path="flixel.util.helpers.FlxRangeBounds.T"/>
				<c path="flixel.util.helpers.FlxRangeBounds.T"/>
				<c path="flixel.util.helpers.FlxRangeBounds.T"/>
				<c path="flixel.util.helpers.FlxRangeBounds"><c path="flixel.util.helpers.FlxRangeBounds.T"/></c>
			</f>
			<haxe_doc>* Handy function to set the the beginning and ending range of values for an emitter property in one line.
	 * 
	 * @param   startMin  The minimum possible initial value of this property for particles launched from this emitter.
	 * @param   startMax  The maximum possible initial value of this property for particles launched from this emitter. Optional, will be set equal to startMin if ignored.
	 * @param   endMin    The minimum possible final value of this property for particles launched from this emitter. Optional, will be set equal to startMin if ignored.
	 * @param   endMax    The maximum possible final value of this property for particles launched from this emitter. Optional, will be set equal to startMax if ignored.
	 * @return  This RangeBounds instance (nice for chaining stuff together).</haxe_doc>
		</set>
		<equals public="1" get="inline" set="null" line="64">
			<f a="OtherRangeBounds">
				<c path="flixel.util.helpers.FlxRangeBounds"><c path="flixel.util.helpers.FlxRangeBounds.T"/></c>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Function to compare this FlxRangeBounds to another.
	 * 
	 * @param	OtherFlxRangeBounds  The other FlxRangeBounds to compare to this one.
	 * @return	True if the FlxRangeBounds have the same min and max value, false otherwise.</haxe_doc>
		</equals>
		<toString public="1" set="method" line="72">
			<f a=""><c path="String"/></f>
			<haxe_doc>* Convert object to readable string name. Useful for debugging, save games, etc.</haxe_doc>
		</toString>
		<new public="1" set="method" line="33">
			<f a="startMin:?startMax:?endMin:?endMax">
				<c path="flixel.util.helpers.FlxRangeBounds.T"/>
				<c path="flixel.util.helpers.FlxRangeBounds.T"/>
				<c path="flixel.util.helpers.FlxRangeBounds.T"/>
				<c path="flixel.util.helpers.FlxRangeBounds.T"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Create a new RangeBounds object. Must be typed, e.g. var myRangeBounds = new RangeBounds<Float>(0, 0, 0, 0);
	 * 
	 * @param   startMin  The minimum possible initial value of this property for particles launched from this emitter.
	 * @param   startMax  The maximum possible initial value of this property for particles launched from this emitter. Optional, will be set equal to startMin if ignored.
	 * @param   endMin    The minimum possible final value of this property for particles launched from this emitter. Optional, will be set equal to startMin if ignored.
	 * @param   endMax    The maximum possible final value of this property for particles launched from this emitter. Optional, will be set equal to startMax if ignored.
	 * @return  This RangeBounds instance (nice for chaining stuff together).]]></haxe_doc>
		</new>
		<haxe_doc><![CDATA[* Helper object for holding beginning minimum/maximum and ending minimum/maximum values of different properties.
 * It would extend Range<Bounds<T>> but this allows a more practical use of set().]]></haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<abstract path="flixel.util.typeLimit.OneOfFour" params="T1:T2:T3:T4" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/util/typeLimit/OneOfFour.hx">
		<from>
			<icast><c path="flixel.util.typeLimit.OneOfFour.T4"/></icast>
			<icast><c path="flixel.util.typeLimit.OneOfFour.T3"/></icast>
			<icast><c path="flixel.util.typeLimit.OneOfFour.T2"/></icast>
			<icast><c path="flixel.util.typeLimit.OneOfFour.T1"/></icast>
		</from>
		<this><d/></this>
		<to>
			<icast><c path="flixel.util.typeLimit.OneOfFour.T4"/></icast>
			<icast><c path="flixel.util.typeLimit.OneOfFour.T3"/></icast>
			<icast><c path="flixel.util.typeLimit.OneOfFour.T2"/></icast>
			<icast><c path="flixel.util.typeLimit.OneOfFour.T1"/></icast>
		</to>
		<haxe_doc>* Useful to limit a Dynamic function argument's type to the specified
 * type parameters. This does NOT make the use of Dynamic type-safe in
 * any way (the underlying type is still Dynamic and Std.is() checks +
 * casts are necessary).</haxe_doc>
		<impl><class path="flixel.util.typeLimit._OneOfFour.OneOfFour_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/util/typeLimit/OneOfFour.hx" private="1" module="flixel.util.typeLimit.OneOfFour" extern="1"><meta><m n=":final"/></meta></class></impl>
	</abstract>
	<class path="flixel.util.typeLimit._OneOfFour.OneOfFour_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/util/typeLimit/OneOfFour.hx" private="1" module="flixel.util.typeLimit.OneOfFour" extern="1"><meta><m n=":final"/></meta></class>
	<abstract path="flixel.util.typeLimit.OneOfThree" params="T1:T2:T3" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/util/typeLimit/OneOfThree.hx">
		<from>
			<icast><c path="flixel.util.typeLimit.OneOfThree.T3"/></icast>
			<icast><c path="flixel.util.typeLimit.OneOfThree.T2"/></icast>
			<icast><c path="flixel.util.typeLimit.OneOfThree.T1"/></icast>
		</from>
		<this><d/></this>
		<to>
			<icast><c path="flixel.util.typeLimit.OneOfThree.T3"/></icast>
			<icast><c path="flixel.util.typeLimit.OneOfThree.T2"/></icast>
			<icast><c path="flixel.util.typeLimit.OneOfThree.T1"/></icast>
		</to>
		<haxe_doc>* Useful to limit a Dynamic function argument's type to the specified
 * type parameters. This does NOT make the use of Dynamic type-safe in
 * any way (the underlying type is still Dynamic and Std.is() checks +
 * casts are necessary).</haxe_doc>
		<impl><class path="flixel.util.typeLimit._OneOfThree.OneOfThree_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/util/typeLimit/OneOfThree.hx" private="1" module="flixel.util.typeLimit.OneOfThree" extern="1"><meta><m n=":final"/></meta></class></impl>
	</abstract>
	<class path="flixel.util.typeLimit._OneOfThree.OneOfThree_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/util/typeLimit/OneOfThree.hx" private="1" module="flixel.util.typeLimit.OneOfThree" extern="1"><meta><m n=":final"/></meta></class>
	<abstract path="flixel.util.typeLimit.OneOfTwo" params="T1:T2" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/util/typeLimit/OneOfTwo.hx">
		<from>
			<icast><c path="flixel.util.typeLimit.OneOfTwo.T2"/></icast>
			<icast><c path="flixel.util.typeLimit.OneOfTwo.T1"/></icast>
		</from>
		<this><d/></this>
		<to>
			<icast><c path="flixel.util.typeLimit.OneOfTwo.T2"/></icast>
			<icast><c path="flixel.util.typeLimit.OneOfTwo.T1"/></icast>
		</to>
		<haxe_doc>* Useful to limit a Dynamic function argument's type to the specified
 * type parameters. This does NOT make the use of Dynamic type-safe in
 * any way (the underlying type is still Dynamic and Std.is() checks +
 * casts are necessary).</haxe_doc>
		<impl><class path="flixel.util.typeLimit._OneOfTwo.OneOfTwo_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/util/typeLimit/OneOfTwo.hx" private="1" module="flixel.util.typeLimit.OneOfTwo" extern="1"><meta><m n=":final"/></meta></class></impl>
	</abstract>
	<class path="flixel.util.typeLimit._OneOfTwo.OneOfTwo_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\flixel/4,3,0/flixel/util/typeLimit/OneOfTwo.hx" private="1" module="flixel.util.typeLimit.OneOfTwo" extern="1"><meta><m n=":final"/></meta></class>
	<enum path="haxe.StackItem" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/haxe/CallStack.hx" module="haxe.CallStack">
		<CFunction/>
		<Module a="m"><c path="String"/></Module>
		<FilePos a="s:file:line">
			<t path="Null"><e path="haxe.StackItem"/></t>
			<c path="String"/>
			<x path="Int"/>
		</FilePos>
		<Method a="classname:method">
			<c path="String"/>
			<c path="String"/>
		</Method>
		<LocalFunction a="?v"><x path="Int"/></LocalFunction>
		<haxe_doc>Elements return by `CallStack` methods.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</enum>
	<class path="haxe.CallStack" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/haxe/CallStack.hx">
		<callStack public="1" set="method" line="77" static="1">
			<f a=""><c path="Array"><e path="haxe.StackItem"/></c></f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Return the call stack elements, or an empty array if not available.</haxe_doc>
		</callStack>
		<exceptionStack public="1" set="method" line="140" static="1">
			<f a=""><c path="Array"><e path="haxe.StackItem"/></c></f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Return the exception stack : this is the stack elements between
		the place the last exception was thrown and the place it was
		caught, or an empty array if not available.</haxe_doc>
		</exceptionStack>
		<toString public="1" set="method" line="206" static="1">
			<f a="stack">
				<c path="Array"><e path="haxe.StackItem"/></c>
				<c path="String"/>
			</f>
			<haxe_doc>Returns a representation of the stack as a printable string.</haxe_doc>
		</toString>
		<itemToString set="method" line="219" static="1"><f a="b:s">
	<c path="StringBuf"/>
	<e path="haxe.StackItem"/>
	<x path="Void"/>
</f></itemToString>
		<makeStack set="method" line="246" static="1">
			<f a="s">
				<c path="Array"><c path="String"/></c>
				<c path="Array"><e path="haxe.StackItem"/></c>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</makeStack>
		<haxe_doc>Get informations about the call stack.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<abstract path="haxe.Function" params="" file="D:\HaxeToolkit\haxe\std/haxe/Constraints.hx" module="haxe.Constraints">
		<this><d/></this>
		<haxe_doc>This type unifies with any function type.

	It is intended to be used as a type parameter constraint. If used as a real
	type, the underlying type will be `Dynamic`.</haxe_doc>
		<meta><m n=":callable"/></meta>
		<impl><class path="haxe._Constraints.Function_Impl_" params="" file="D:\HaxeToolkit\haxe\std/haxe/Constraints.hx" private="1" module="haxe.Constraints"><meta>
	<m n=":keep"/>
	<m n=":final"/>
</meta></class></impl>
	</abstract>
	<abstract path="haxe.FlatEnum" params="" file="D:\HaxeToolkit\haxe\std/haxe/Constraints.hx" module="haxe.Constraints">
		<this><d/></this>
		<haxe_doc>This type unifies with an enum instance if all constructors of the enum
	require no arguments.

	It is intended to be used as a type parameter constraint. If used as a real
	type, the underlying type will be `Dynamic`.</haxe_doc>
		<impl><class path="haxe._Constraints.FlatEnum_Impl_" params="" file="D:\HaxeToolkit\haxe\std/haxe/Constraints.hx" private="1" module="haxe.Constraints"><meta>
	<m n=":keep"/>
	<m n=":final"/>
</meta></class></impl>
	</abstract>
	<abstract path="haxe.Constructible" params="T" file="D:\HaxeToolkit\haxe\std/haxe/Constraints.hx" module="haxe.Constraints">
		<this><d/></this>
		<haxe_doc><![CDATA[This type unifies with any instance of classes that have a constructor
	which
		* is public and
		* unifies with the type used for type parameter `T`.

	If a type parameter A is assigned to a type parameter B which is constrained
	to `Constructible<T>`, A must be explicitly constrained to
	`Constructible<T>` as well.

	It is intended to be used as a type parameter constraint. If used as a real
	type, the underlying type will be `Dynamic`.]]></haxe_doc>
		<impl><class path="haxe._Constraints.Constructible_Impl_" params="" file="D:\HaxeToolkit\haxe\std/haxe/Constraints.hx" private="1" module="haxe.Constraints"><meta>
	<m n=":keep"/>
	<m n=":final"/>
</meta></class></impl>
	</abstract>
	<class path="haxe.IMap" params="K:V" file="D:\HaxeToolkit\haxe\std/haxe/Constraints.hx" module="haxe.Constraints" interface="1">
		<get public="1" set="method"><f a="k">
	<c path="haxe.IMap.K"/>
	<t path="Null"><c path="haxe.IMap.V"/></t>
</f></get>
		<set public="1" set="method"><f a="k:v">
	<c path="haxe.IMap.K"/>
	<c path="haxe.IMap.V"/>
	<x path="Void"/>
</f></set>
		<remove public="1" set="method"><f a="k">
	<c path="haxe.IMap.K"/>
	<x path="Bool"/>
</f></remove>
		<meta><m n=":keep"/></meta>
	</class>
	<abstract path="haxe.EnumFlags" params="T" file="D:\HaxeToolkit\haxe\std/haxe/EnumFlags.hx">
		<this><x path="Int"/></this>
		<haxe_doc>A typed interface for bit flags. This is not a real object, only a typed
	interface for an actual Int. Each flag can be tested/set with the
	corresponding enum instance. Up to 32 flags can be stored that way.

	Enum constructor indices are preserved from Haxe syntax, so the first
	declared is index 0, the next index 1 etc. The methods are optimized if the
	enum instance is passed directly, e.g. as has(EnumCtor). Otherwise
	Type.enumIndex() reflection is used.</haxe_doc>
		<impl><class path="haxe._EnumFlags.EnumFlags_Impl_" params="" file="D:\HaxeToolkit\haxe\std/haxe/EnumFlags.hx" private="1" module="haxe.EnumFlags"><meta>
	<m n=":keep"/>
	<m n=":final"/>
</meta></class></impl>
	</abstract>
	<class path="haxe.EnumTools" params="" file="D:\HaxeToolkit\haxe\std/haxe/EnumTools.hx" extern="1">
		<getName public="1" params="T" get="inline" set="null" line="50" static="1">
			<f a="e">
				<x path="Enum"><c path="getName.T"/></x>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the name of enum `e`, including its path.

		If `e` is inside a package, the package structure is returned dot-
		separated, with another dot separating the enum name:
			pack1.pack2.(...).packN.EnumName
		If `e` is a sub-type of a Haxe module, that module is not part of the
		package structure.

		If `e` has no package, the enum name is returned.

		If `e` is `null`, the result is unspecified.

		The enum name does not include any type parameters.</haxe_doc>
		</getName>
		<createByName public="1" params="T" get="inline" set="null" line="63" static="1">
			<f a="e:constr:?params">
				<x path="Enum"><c path="createByName.T"/></x>
				<c path="String"/>
				<c path="Array"><d/></c>
				<c path="createByName.T"/>
			</f>
			<haxe_doc>Creates an instance of enum `e` by calling its constructor `constr` with
		arguments `params`.

		If `e` or `constr` is `null`, or if enum `e` has no constructor named
		`constr`, or if the number of elements in `params` does not match the
		expected number of constructor arguments, or if any argument has an
		invalid type, the result is unspecified.</haxe_doc>
		</createByName>
		<createByIndex public="1" params="T" get="inline" set="null" line="79" static="1">
			<f a="e:index:?params">
				<x path="Enum"><c path="createByIndex.T"/></x>
				<x path="Int"/>
				<c path="Array"><d/></c>
				<c path="createByIndex.T"/>
			</f>
			<haxe_doc>Creates an instance of enum `e` by calling its constructor number
		`index` with arguments `params`.

		The constructor indices are preserved from Haxe syntax, so the first
		declared is index 0, the next index 1 etc.

		If `e` or `index` is `null`, or if enum `e` has no constructor
		corresponding to index `index`, or if the number of elements in `params`
		does not match the expected number of constructor arguments, or if any
		argument has an invalid type, the result is unspecified.</haxe_doc>
		</createByIndex>
		<createAll public="1" params="T" get="inline" set="null" line="96" static="1">
			<f a="e">
				<x path="Enum"><c path="createAll.T"/></x>
				<c path="Array"><c path="createAll.T"/></c>
			</f>
			<haxe_doc>Returns a list of all constructors of enum `e` that require no
		arguments.

		This may return the empty Array `[]` if all constructors of `e` require
		arguments.

		Otherwise an instance of `e` constructed through each of its non-
		argument constructors is returned, in the order of the constructor
		declaration.

		If `e` is `null`, the result is unspecified.</haxe_doc>
		</createAll>
		<getConstructors public="1" params="T" get="inline" set="null" line="108" static="1">
			<f a="e">
				<x path="Enum"><c path="getConstructors.T"/></x>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>Returns a list of the names of all constructors of enum `e`.

		The order of the constructor names in the returned Array is preserved
		from the original syntax.

		If `c` is `null`, the result is unspecified.</haxe_doc>
		</getConstructors>
		<haxe_doc>This class provides advanced methods on enums. It is ideally used with
	`using EnumTools` and then acts as an 
  [extension](https://haxe.org/manual/lf-static-extension.html) to the 
  `enum` types.

	If the first argument to any of the methods is null, the result is
	unspecified.</haxe_doc>
	</class>
	<class path="haxe.EnumValueTools" params="" file="D:\HaxeToolkit\haxe\std/haxe/EnumTools.hx" module="haxe.EnumTools" extern="1">
		<equals public="1" params="T" get="inline" set="null" line="132" static="1">
			<f a="a:b">
				<c path="equals.T"/>
				<c path="equals.T"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Recursively compares two enum instances `a` and `b` by value.

		Unlike `a == b`, this function performs a deep equality check on the
		arguments of the constructors (if there are any).

		If `a` or `b` are `null`, the result is unspecified.</haxe_doc>
		</equals>
		<getName public="1" get="inline" set="null" line="143" static="1">
			<f a="e">
				<x path="EnumValue"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the constructor name of enum instance `e`.

		The result String does not contain any constructor arguments.

		If `e` is `null`, the result is unspecified.</haxe_doc>
		</getName>
		<getParameters public="1" get="inline" set="null" line="157" static="1">
			<f a="e">
				<x path="EnumValue"/>
				<c path="Array"><d/></c>
			</f>
			<haxe_doc>Returns a list of the constructor arguments of enum instance `e`.

		If `e` has no arguments, the result is `[]`.

		Otherwise the result are the values that were used as arguments to `e`,
		in the order of their declaration.

		If `e` is `null`, the result is unspecified.</haxe_doc>
		</getParameters>
		<getIndex public="1" get="inline" set="null" line="169" static="1">
			<f a="e">
				<x path="EnumValue"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the index of enum instance `e`.

		This corresponds to the original syntactic position of `e`. The index of
		the first declared constructor is 0, the next one is 1 etc.

		If `e` is `null`, the result is unspecified.</haxe_doc>
		</getIndex>
		<match public="1" set="method" static="1">
			<f a="e:pattern">
				<x path="EnumValue"/>
				<d/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Matches enum instance `e` against pattern `pattern`, returning `true` if
		matching succeeded and `false` otherwise.

		Example usage:

		```haxe
		if (e.match(pattern)) {
			// codeIfTrue
		} else {
			// codeIfFalse
		}
		```

		This is equivalent to the following code:

		```haxe
		switch (e) {
			case pattern:
				// codeIfTrue
			case _:
				// codeIfFalse
		}
		```

		This method is implemented in the compiler. This definition exists only
		for documentation.</haxe_doc>
		</match>
		<haxe_doc>This class provides advanced methods on enum values. It is ideally used with
	`using EnumValueTools` and then acts as an 
  [extension](https://haxe.org/manual/lf-static-extension.html) to the 
  `EnumValue` types.

	If the first argument to any of the methods is null, the result is
	unspecified.</haxe_doc>
	</class>
	<abstract path="haxe.Int32" params="" file="D:\HaxeToolkit\haxe\std/haxe/Int32.hx">
		<from><icast><x path="Int"/></icast></from>
		<this><x path="Int"/></this>
		<to>
			<icast><x path="Int"/></icast>
			<icast field="toFloat"><x path="Float"/></icast>
		</to>
		<haxe_doc>Int32 provides a 32-bit integer with consistent overflow behavior across
 	all platforms.</haxe_doc>
		<impl><class path="haxe._Int32.Int32_Impl_" params="" file="D:\HaxeToolkit\haxe\std/haxe/Int32.hx" private="1" module="haxe.Int32"><meta>
	<m n=":keep"/>
	<m n=":final"/>
</meta></class></impl>
	</abstract>
	<abstract path="haxe.Int64" params="" file="D:\HaxeToolkit\haxe\std/haxe/Int64.hx">
		<from>
			<icast><t path="haxe._Int64.__Int64"/></icast>
			<icast field="ofInt"><x path="Int"/></icast>
		</from>
		<this><t path="haxe._Int64.__Int64"/></this>
		<to><icast><t path="haxe._Int64.__Int64"/></icast></to>
		<haxe_doc>A cross-platform signed 64-bit integer.
	Int64 instances can be created from two 32-bit words using `Int64.make()`.</haxe_doc>
		<impl><class path="haxe._Int64.Int64_Impl_" params="" file="D:\HaxeToolkit\haxe\std/haxe/Int64.hx" private="1" module="haxe.Int64">
	<high public="1" get="accessor" set="null" static="1">
		<x path="haxe.Int32"/>
		<meta><m n=":impl"/></meta>
	</high>
	<low public="1" get="accessor" set="null" static="1">
		<x path="haxe.Int32"/>
		<meta><m n=":impl"/></meta>
	</low>
	<meta>
		<m n=":keep"/>
		<m n=":final"/>
	</meta>
</class></impl>
	</abstract>
	<typedef path="haxe._Int64.__Int64" params="" file="D:\HaxeToolkit\haxe\std/haxe/Int64.hx" private="1" module="haxe.Int64">
		<c path="haxe._Int64.___Int64"/>
		<haxe_doc>* This typedef will fool @:coreApi into thinking that we are using
  * the same underlying type, even though it might be different on
  * specific platforms.</haxe_doc>
	</typedef>
	<typedef path="haxe.PosInfos" params="" file="D:\HaxeToolkit\haxe\std/haxe/PosInfos.hx">
		<a>
			<methodName><c path="String"/></methodName>
			<lineNumber><x path="Int"/></lineNumber>
			<fileName><c path="String"/></fileName>
			<customParams>
				<t path="Null"><c path="Array"><d/></c></t>
				<meta><m n=":optional"/></meta>
			</customParams>
			<className><c path="String"/></className>
		</a>
		<haxe_doc>PosInfos is a magic type which can be used to generate position information
	into the output for debugging use.

	If a function has a final optional argument of this type, i.e.
	(..., ?pos:haxe.PosInfos), each call to that function which does not assign
	a value to that argument has its position added as call argument.

	This can be used to track positions of calls in e.g. a unit testing
	framework.</haxe_doc>
	</typedef>
	<class path="haxe.Resource" params="" file="D:\HaxeToolkit\haxe\std/haxe/Resource.hx">
		<content static="1"><c path="Array"><a>
	<str><c path="String"/></str>
	<name><c path="String"/></name>
	<data><c path="String"/></data>
</a></c></content>
		<getBytes public="1" set="method" line="70" static="1">
			<f a="name">
				<c path="String"/>
				<c path="haxe.io.Bytes"/>
			</f>
			<haxe_doc>Retrieves the resource identified by `name` as an instance of
		haxe.io.Bytes.

		If `name` does not match any resource name, null is returned.</haxe_doc>
		</getBytes>
		<haxe_doc>Resource can be used to access resources that were added through the
	-resource file@name command line parameter.

	Depending on their type they can be obtained as String through
	getString(name), or as binary data through getBytes(name).

	A list of all available resource names can be obtained from listNames().</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="haxe.Serializer" params="" file="D:\HaxeToolkit\haxe\std/haxe/Serializer.hx">
		<USE_CACHE public="1" expr="false" line="55" static="1">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
			<haxe_doc>If the values you are serializing can contain circular references or
		objects repetitions, you should set `USE_CACHE` to true to prevent
		infinite loops.

		This may also reduce the size of serialization Strings at the expense of
		performance.

		This value can be changed for individual instances of Serializer by
		setting their useCache field.</haxe_doc>
		</USE_CACHE>
		<USE_ENUM_INDEX public="1" expr="false" line="67" static="1">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
			<haxe_doc>Use constructor indexes for enums instead of names.

		This may reduce the size of serialization Strings, but makes them less
		suited for long-term storage: If constructors are removed or added from
		the enum, the indices may no longer match.

		This value can be changed for individual instances of Serializer by
		setting their useEnumIndex field.</haxe_doc>
		</USE_ENUM_INDEX>
		<BASE64 expr="&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789%:&quot;" line="69" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789%:"</e></m></meta>
		</BASE64>
		<run public="1" set="method" line="556" static="1">
			<f a="v">
				<d/>
				<c path="String"/>
			</f>
			<haxe_doc>Serializes `v` and returns the String representation.

		This is a convenience function for creating a new instance of
		Serializer, serialize `v` into it and obtain the result through a call
		to toString().</haxe_doc>
		</run>
		<base_encode expr="neko.Lib.load(&quot;std&quot;, &quot;base_encode&quot;, 2)" line="563" static="1">
			<f a=":">
				<t path="haxe.io.BytesData"/>
				<unknown/>
				<c path="String"/>
			</f>
			<meta><m n=":value"><e>neko.Lib.load("std", "base_encode", 2)</e></m></meta>
		</base_encode>
		<buf><c path="StringBuf"/></buf>
		<cache><c path="Array"><d/></c></cache>
		<shash><c path="haxe.ds.StringMap"><x path="Int"/></c></shash>
		<scount><x path="Int"/></scount>
		<useCache public="1">
			<x path="Bool"/>
			<haxe_doc>The individual cache setting for `this` Serializer instance.

		See USE_CACHE for a complete description.</haxe_doc>
		</useCache>
		<useEnumIndex public="1">
			<x path="Bool"/>
			<haxe_doc>The individual enum index setting for `this` Serializer instance.

		See USE_ENUM_INDEX for a complete description.</haxe_doc>
		</useEnumIndex>
		<toString public="1" set="method" line="116">
			<f a=""><c path="String"/></f>
			<haxe_doc>Return the String representation of `this` Serializer.

		The exact format specification can be found here:
		https://haxe.org/manual/serialization/format</haxe_doc>
		</toString>
		<serializeString set="method" line="153"><f a="s">
	<c path="String"/>
	<x path="Void"/>
</f></serializeString>
		<serializeRef set="method" line="172"><f a="v">
	<unknown/>
	<x path="Bool"/>
</f></serializeRef>
		<serializeFields set="method" line="209"><f a="v">
	<unknown/>
	<x path="Void"/>
</f></serializeFields>
		<serialize public="1" set="method" line="227">
			<f a="v">
				<d/>
				<x path="Void"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Serializes `v`.

		All haxe-defined values and objects with the exception of functions can
		be serialized. Serialization of external/native objects is not
		guaranteed to work.

		The values of `this.useCache` and `this.useEnumIndex` may affect
		serialization output.</haxe_doc>
		</serialize>
		<new public="1" set="method" line="101">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new Serializer instance.

		Subsequent calls to `this.serialize` will append values to the
		internal buffer of this String. Once complete, the contents can be
		retrieved through a call to `this.toString`.

		Each Serializer instance maintains its own cache if this.useCache` is
		true.</haxe_doc>
		</new>
		<haxe_doc><![CDATA[The Serializer class can be used to encode values and objects into a `String`,
	from which the `Unserializer` class can recreate the original representation.

	This class can be used in two ways:

	- create a `new Serializer()` instance, call its `serialize()` method with
		any argument and finally retrieve the String representation from
		`toString()`
	- call `Serializer.run()` to obtain the serialized representation of a
		single argument

	Serialization is guaranteed to work for all haxe-defined classes, but may
	or may not work for instances of external/native classes.

	The specification of the serialization format can be found here:
	<https://haxe.org/manual/serialization/format>]]></haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="haxe.Timer" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/haxe/Timer.hx">
		<sRunningTimers expr="[]" line="203" static="1">
			<c path="Array"><c path="haxe.Timer"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</sRunningTimers>
		<delay public="1" set="method" line="220" static="1"><f a="f:time">
	<f a=""><x path="Void"/></f>
	<x path="Int"/>
	<c path="haxe.Timer"/>
</f></delay>
		<getMS set="method" line="236" static="1"><f a=""><x path="Float"/></f></getMS>
		<measure public="1" params="T" set="method" line="247" static="1"><f a="f:?pos">
	<f a=""><c path="measure.T"/></f>
	<t path="haxe.PosInfos"/>
	<c path="measure.T"/>
</f></measure>
		<stamp public="1" set="method" line="264" static="1"><f a=""><x path="Float"/></f></stamp>
		<__checkTimers public="1" set="method" line="309" static="1">
			<f a=""><x path="Void"/></f>
			<meta>
				<m n=":noCompletion"/>
				<m n=":dox"><e>hide</e></m>
			</meta>
		</__checkTimers>
		<mTime><x path="Float"/></mTime>
		<mFireAt><x path="Float"/></mFireAt>
		<mRunning><x path="Bool"/></mRunning>
		<run public="1" set="dynamic" line="257"><f a=""><x path="Void"/></f></run>
		<stop public="1" set="method" line="275"><f a=""><x path="Void"/></f></stop>
		<__check set="method" line="297">
			<f a="inTime">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</__check>
		<new public="1" set="method" line="210"><f a="time">
	<x path="Float"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="haxe._Unserializer.DefaultResolver" params="" file="D:\HaxeToolkit\haxe\std/haxe/Unserializer.hx" private="1" module="haxe.Unserializer">
		<resolveClass public="1" get="inline" set="null" line="477">
			<f a="name">
				<c path="String"/>
				<x path="Class"><d/></x>
			</f>
			<meta><m n=":final"/></meta>
		</resolveClass>
		<resolveEnum public="1" get="inline" set="null" line="478">
			<f a="name">
				<c path="String"/>
				<x path="Enum"><d/></x>
			</f>
			<meta><m n=":final"/></meta>
		</resolveEnum>
		<new public="1" set="method" line="476"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="haxe.Unserializer" params="" file="D:\HaxeToolkit\haxe\std/haxe/Unserializer.hx">
		<DEFAULT_RESOLVER public="1" expr="new DefaultResolver()" line="63" static="1">
			<t path="haxe.TypeResolver"/>
			<meta><m n=":value"><e>new DefaultResolver()</e></m></meta>
			<haxe_doc><![CDATA[This value can be set to use custom type resolvers.

		A type resolver finds a `Class` or `Enum` instance from a given `String`. 
		By default, the Haxe `Type` Api is used.

		A type resolver must provide two methods:

		1. `resolveClass(name:String):Class<Dynamic>` is called to determine a
				`Class` from a class name
		2. `resolveEnum(name:String):Enum<Dynamic>` is called to determine an
				`Enum` from an enum name

		This value is applied when a new `Unserializer` instance is created.
		Changing it afterwards has no effect on previously created instances.]]></haxe_doc>
		</DEFAULT_RESOLVER>
		<BASE64 expr="&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789%:&quot;" line="65" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789%:"</e></m></meta>
		</BASE64>
		<base_decode expr="neko.Lib.load(&quot;std&quot;, &quot;base_decode&quot;, 2)" line="470" static="1">
			<f a=":">
				<unknown/>
				<unknown/>
				<t path="haxe.io.BytesData"/>
			</f>
			<meta><m n=":value"><e>neko.Lib.load("std", "base_decode", 2)</e></m></meta>
		</base_decode>
		<buf><c path="String"/></buf>
		<pos><x path="Int"/></pos>
		<length><x path="Int"/></length>
		<cache><c path="Array"><d/></c></cache>
		<scache><c path="Array"><c path="String"/></c></scache>
		<resolver><t path="haxe.TypeResolver"/></resolver>
		<upos><x path="Int"/></upos>
		<setResolver public="1" set="method" line="127">
			<f a="r">
				<t path="haxe.TypeResolver"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sets the type resolver of `this` Unserializer instance to `r`.

		If `r` is null, a special resolver is used which returns null for all
		input values.

		See `DEFAULT_RESOLVER` for more information on type resolvers.</haxe_doc>
		</setResolver>
		<readDigits set="method" line="147"><f a=""><x path="Int"/></f></readDigits>
		<readFloat set="method" line="172"><f a=""><x path="Float"/></f></readFloat>
		<unserializeObject set="method" line="186"><f a="o">
	<a/>
	<x path="Void"/>
</f></unserializeObject>
		<unserializeEnum set="method" line="201"><f a="edecl:tag">
	<x path="Enum"><unknown/></x>
	<c path="String"/>
	<unknown/>
</f></unserializeEnum>
		<unserialize public="1" set="method" line="233">
			<f a=""><d/></f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Unserializes the next part of `this` Unserializer instance and returns
		the according value.

		This function may call `this.resolver.resolveClass` to determine a
		Class from a String, and `this.resolver.resolveEnum` to determine an
		Enum from a String.

		If `this` Unserializer instance contains no more or invalid data, an
		exception is thrown.

		This operation may fail on structurally valid data if a type cannot be
		resolved or if a field cannot be set. This can happen when unserializing
		Strings that were serialized on a different Haxe target, in which the
		serialization side has to make sure not to include platform-specific
		data.

		Classes are created from `Type.createEmptyInstance`, which means their
		constructors are not called.</haxe_doc>
		</unserialize>
		<new public="1" set="method" line="102">
			<f a="buf">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Creates a new Unserializer instance, with its internal buffer
		initialized to `buf`.

		This does not parse `buf` immediately. It is parsed only when calls to
		`this.unserialize` are made.

		Each Unserializer instance maintains its own cache.</haxe_doc>
		</new>
		<haxe_doc><![CDATA[The `Unserializer` class is the complement to the `Serializer` class. It parses
	a serialization `String` and creates objects from the contained data.

	This class can be used in two ways:

	- create a `new Unserializer()` instance with a given serialization
		String, then call its `unserialize()` method until all values are
		extracted
	- call `Unserializer.run()`  to unserialize a single value from a given
		String

	The specification of the serialization format can be found here:
	<https://haxe.org/manual/serialization/format>]]></haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="haxe._Unserializer.NullResolver" params="" file="D:\HaxeToolkit\haxe\std/haxe/Unserializer.hx" private="1" module="haxe.Unserializer">
		<instance public="1" get="null" set="null" static="1"><c path="haxe._Unserializer.NullResolver"/></instance>
		<resolveClass public="1" get="inline" set="null" line="483">
			<f a="name">
				<c path="String"/>
				<x path="Class"><d/></x>
			</f>
			<meta><m n=":final"/></meta>
		</resolveClass>
		<resolveEnum public="1" get="inline" set="null" line="484">
			<f a="name">
				<c path="String"/>
				<x path="Enum"><d/></x>
			</f>
			<meta><m n=":final"/></meta>
		</resolveEnum>
		<new set="method" line="482"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="haxe.Utf8" params="" file="D:\HaxeToolkit\haxe\std/neko/_std/haxe/Utf8.hx">
		<length public="1" set="method" line="83" static="1">
			<f a="s">
				<c path="String"/>
				<x path="Int"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Returns the number of UTF8 chars of the String.</haxe_doc>
		</length>
		<compare public="1" set="method" line="87" static="1">
			<f a="a:b">
				<c path="String"/>
				<c path="String"/>
				<x path="Int"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Compare two UTF8 strings, character by character.</haxe_doc>
		</compare>
		<sub public="1" set="method" line="91" static="1">
			<f a="s:pos:len">
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
				<c path="String"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>This is similar to `String.substr` but the `pos` and `len` parts are considering UTF8 characters.</haxe_doc>
		</sub>
		<utf8_length expr="neko.Lib.load(&quot;std&quot;, &quot;utf8_length&quot;, 1)" line="103" static="1">
			<f a="">
				<unknown/>
				<x path="Int"/>
			</f>
			<meta><m n=":value"><e>neko.Lib.load("std", "utf8_length", 1)</e></m></meta>
		</utf8_length>
		<utf8_compare expr="neko.Lib.load(&quot;std&quot;, &quot;utf8_compare&quot;, 2)" line="104" static="1">
			<f a=":">
				<unknown/>
				<unknown/>
				<x path="Int"/>
			</f>
			<meta><m n=":value"><e>neko.Lib.load("std", "utf8_compare", 2)</e></m></meta>
		</utf8_compare>
		<utf8_sub expr="neko.Lib.load(&quot;std&quot;, &quot;utf8_sub&quot;, 3)" line="105" static="1">
			<f a="::">
				<unknown/>
				<x path="Int"/>
				<x path="Int"/>
				<c path="String"/>
			</f>
			<meta><m n=":value"><e>neko.Lib.load("std", "utf8_sub", 3)</e></m></meta>
		</utf8_sub>
		<haxe_doc>Since not all platforms guarantee that `String` always uses UTF-8 encoding, you
	can use this crossplatform API to perform operations on such strings.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<class path="haxe.crypto.BaseCode" params="" file="D:\HaxeToolkit\haxe\std/haxe/crypto/BaseCode.hx">
		<haxe_doc>Allows to encode/decode String and bytes using a power of two base dictionary.</haxe_doc>
		<meta><m n=":keep"/></meta>
	</class>
	<class path="haxe.crypto.Md5" params="" file="D:\HaxeToolkit\haxe\std/haxe/crypto/Md5.hx">
		<encode public="1" set="method" line="29" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</encode>
		<base_encode expr="neko.Lib.load(&quot;std&quot;, &quot;base_encode&quot;, 2)" line="61" static="1">
			<f a=":">
				<t path="haxe.io.BytesData"/>
				<unknown/>
				<c path="String"/>
			</f>
			<meta><m n=":value"><e>neko.Lib.load("std", "base_encode", 2)</e></m></meta>
		</base_encode>
		<make_md5 expr="neko.Lib.load(&quot;std&quot;, &quot;make_md5&quot;, 1)" line="62" static="1">
			<f a="">
				<t path="haxe.io.BytesData"/>
				<t path="haxe.io.BytesData"/>
			</f>
			<meta><m n=":value"><e>neko.Lib.load("std", "make_md5", 1)</e></m></meta>
		</make_md5>
		<haxe_doc>Creates a MD5 of a String.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="haxe.ds.ArraySort" params="" file="D:\HaxeToolkit\haxe\std/haxe/ds/ArraySort.hx">
		<sort public="1" params="T" set="method" line="43" static="1">
			<f a="a:cmp">
				<c path="Array"><c path="sort.T"/></c>
				<f a=":">
					<c path="sort.T"/>
					<c path="sort.T"/>
					<x path="Int"/>
				</f>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[Sorts Array `a` according to the comparison function `cmp`, where
		`cmp(x,y)` returns 0 if `x == y`, a positive Int if `x > y` and a
		negative Int if `x < y`.

		This operation modifies Array `a` in place.

		This operation is stable: The order of equal elements is preserved.

		If `a` or `cmp` are null, the result is unspecified.]]></haxe_doc>
		</sort>
		<rec params="T" set="method" line="47" static="1"><f a="a:cmp:from:to">
	<c path="Array"><c path="rec.T"/></c>
	<f a=":">
		<c path="rec.T"/>
		<c path="rec.T"/>
		<x path="Int"/>
	</f>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></rec>
		<doMerge params="T" set="method" line="68" static="1"><f a="a:cmp:from:pivot:to:len1:len2">
	<c path="Array"><c path="doMerge.T"/></c>
	<f a=":">
		<c path="doMerge.T"/>
		<c path="doMerge.T"/>
		<x path="Int"/>
	</f>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></doMerge>
		<rotate params="T" set="method" line="94" static="1"><f a="a:cmp:from:mid:to">
	<c path="Array"><c path="rotate.T"/></c>
	<f a=":">
		<c path="doMerge.T"/>
		<c path="doMerge.T"/>
		<x path="Int"/>
	</f>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></rotate>
		<gcd set="method" line="112" static="1"><f a="m:n">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></gcd>
		<upper params="T" set="method" line="121" static="1"><f a="a:cmp:from:to:val">
	<c path="Array"><c path="upper.T"/></c>
	<f a=":">
		<c path="upper.T"/>
		<c path="upper.T"/>
		<x path="Int"/>
	</f>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></upper>
		<lower params="T" set="method" line="136" static="1"><f a="a:cmp:from:to:val">
	<c path="Array"><c path="lower.T"/></c>
	<f a=":">
		<c path="lower.T"/>
		<c path="lower.T"/>
		<x path="Int"/>
	</f>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></lower>
		<swap params="T" set="method" line="150" static="1"><f a="a:i:j">
	<c path="Array"><c path="swap.T"/></c>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></swap>
		<haxe_doc>ArraySort provides a stable implementation of merge sort through its `sort`
	method. It should be used instead of `Array.sort` in cases where the order
	of equal elements has to be retained on all targets.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="haxe.ds.BalancedTree" params="K:V" file="D:\HaxeToolkit\haxe\std/haxe/ds/BalancedTree.hx">
		<root><c path="haxe.ds.TreeNode">
	<c path="haxe.ds.BalancedTree.K"/>
	<c path="haxe.ds.BalancedTree.V"/>
</c></root>
		<set public="1" set="method" line="50">
			<f a="key:value">
				<c path="haxe.ds.BalancedTree.K"/>
				<c path="haxe.ds.BalancedTree.V"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Binds `key` to `value`.

		If `key` is already bound to a value, that binding disappears.

		If `key` is null, the result is unspecified.</haxe_doc>
		</set>
		<get public="1" set="method" line="61">
			<f a="key">
				<c path="haxe.ds.BalancedTree.K"/>
				<t path="Null"><c path="haxe.ds.BalancedTree.V"/></t>
			</f>
			<haxe_doc>Returns the value `key` is bound to.

		If `key` is not bound to any value, `null` is returned.

		If `key` is null, the result is unspecified.</haxe_doc>
		</get>
		<remove public="1" set="method" line="82">
			<f a="key">
				<c path="haxe.ds.BalancedTree.K"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Removes the current binding of `key`.

		If `key` has no binding, `this` BalancedTree is unchanged and false is
		returned.

		Otherwise the binding of `key` is removed and true is returned.

		If `key` is null, the result is unspecified.</haxe_doc>
		</remove>
		<setLoop set="method" line="132"><f a="k:v:node">
	<c path="haxe.ds.BalancedTree.K"/>
	<c path="haxe.ds.BalancedTree.V"/>
	<c path="haxe.ds.TreeNode">
		<c path="haxe.ds.BalancedTree.K"/>
		<c path="haxe.ds.BalancedTree.V"/>
	</c>
	<c path="haxe.ds.TreeNode">
		<c path="haxe.ds.BalancedTree.K"/>
		<c path="haxe.ds.BalancedTree.V"/>
	</c>
</f></setLoop>
		<removeLoop set="method" line="145"><f a="k:node">
	<c path="haxe.ds.BalancedTree.K"/>
	<c path="haxe.ds.TreeNode">
		<c path="haxe.ds.BalancedTree.K"/>
		<c path="haxe.ds.BalancedTree.V"/>
	</c>
	<c path="haxe.ds.TreeNode">
		<c path="haxe.ds.BalancedTree.K"/>
		<c path="haxe.ds.BalancedTree.V"/>
	</c>
</f></removeLoop>
		<merge set="method" line="169"><f a="t1:t2">
	<c path="haxe.ds.TreeNode">
		<c path="haxe.ds.BalancedTree.K"/>
		<c path="haxe.ds.BalancedTree.V"/>
	</c>
	<c path="haxe.ds.TreeNode">
		<c path="haxe.ds.BalancedTree.K"/>
		<c path="haxe.ds.BalancedTree.V"/>
	</c>
	<c path="haxe.ds.TreeNode">
		<c path="haxe.ds.BalancedTree.K"/>
		<c path="haxe.ds.BalancedTree.V"/>
	</c>
</f></merge>
		<minBinding set="method" line="176"><f a="t">
	<c path="haxe.ds.TreeNode">
		<c path="haxe.ds.BalancedTree.K"/>
		<c path="haxe.ds.BalancedTree.V"/>
	</c>
	<c path="haxe.ds.TreeNode">
		<c path="haxe.ds.BalancedTree.K"/>
		<c path="haxe.ds.BalancedTree.V"/>
	</c>
</f></minBinding>
		<removeMinBinding set="method" line="182"><f a="t">
	<c path="haxe.ds.TreeNode">
		<c path="haxe.ds.BalancedTree.K"/>
		<c path="haxe.ds.BalancedTree.V"/>
	</c>
	<c path="haxe.ds.TreeNode">
		<c path="haxe.ds.BalancedTree.K"/>
		<c path="haxe.ds.BalancedTree.V"/>
	</c>
</f></removeMinBinding>
		<balance set="method" line="187"><f a="l:k:v:r">
	<c path="haxe.ds.TreeNode">
		<c path="haxe.ds.BalancedTree.K"/>
		<c path="haxe.ds.BalancedTree.V"/>
	</c>
	<c path="haxe.ds.BalancedTree.K"/>
	<c path="haxe.ds.BalancedTree.V"/>
	<c path="haxe.ds.TreeNode">
		<c path="haxe.ds.BalancedTree.K"/>
		<c path="haxe.ds.BalancedTree.V"/>
	</c>
	<c path="haxe.ds.TreeNode">
		<c path="haxe.ds.BalancedTree.K"/>
		<c path="haxe.ds.BalancedTree.V"/>
	</c>
</f></balance>
		<compare set="method" line="201"><f a="k1:k2">
	<c path="haxe.ds.BalancedTree.K"/>
	<c path="haxe.ds.BalancedTree.K"/>
	<x path="Int"/>
</f></compare>
		<new public="1" set="method" line="41">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new BalancedTree, which is initially empty.</haxe_doc>
		</new>
		<haxe_doc>BalancedTree allows key-value mapping with arbitrary keys, as long as they
	can be ordered. By default, `Reflect.compare` is used in the `compare`
	method, which can be overridden in subclasses.

	Operations have a logarithmic average and worst-case cost.

	Iteration over keys and values, using `keys` and `iterator` respectively,
	are in-order.</haxe_doc>
		<meta><m n=":keep"/></meta>
	</class>
	<class path="haxe.ds.TreeNode" params="K:V" file="D:\HaxeToolkit\haxe\std/haxe/ds/BalancedTree.hx" module="haxe.ds.BalancedTree">
		<left public="1"><c path="haxe.ds.TreeNode">
	<c path="haxe.ds.TreeNode.K"/>
	<c path="haxe.ds.TreeNode.V"/>
</c></left>
		<right public="1"><c path="haxe.ds.TreeNode">
	<c path="haxe.ds.TreeNode.K"/>
	<c path="haxe.ds.TreeNode.V"/>
</c></right>
		<key public="1"><c path="haxe.ds.TreeNode.K"/></key>
		<value public="1"><c path="haxe.ds.TreeNode.V"/></value>
		<_height><x path="Int"/></_height>
		<new public="1" set="method" line="223">
			<f a="l:k:v:r:?h" v="::::-1">
				<c path="haxe.ds.TreeNode">
					<c path="haxe.ds.TreeNode.K"/>
					<c path="haxe.ds.TreeNode.V"/>
				</c>
				<c path="haxe.ds.TreeNode.K"/>
				<c path="haxe.ds.TreeNode.V"/>
				<c path="haxe.ds.TreeNode">
					<c path="haxe.ds.TreeNode.K"/>
					<c path="haxe.ds.TreeNode.V"/>
				</c>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ h : -1 }</e></m></meta>
		</new>
		<haxe_doc>A tree node of `haxe.ds.BalancedTree`.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="haxe.ds.EnumValueMap" params="K:V" file="D:\HaxeToolkit\haxe\std/haxe/ds/EnumValueMap.hx">
		<extends path="haxe.ds.BalancedTree">
			<c path="haxe.ds.EnumValueMap.K"/>
			<c path="haxe.ds.EnumValueMap.V"/>
		</extends>
		<implements path="haxe.IMap">
			<c path="haxe.ds.EnumValueMap.K"/>
			<c path="haxe.ds.EnumValueMap.V"/>
		</implements>
		<compare set="method" line="33" override="1"><f a="k1:k2">
	<x path="EnumValue"/>
	<x path="EnumValue"/>
	<x path="Int"/>
</f></compare>
		<compareArgs set="method" line="42"><f a="a1:a2">
	<c path="Array"><d/></c>
	<c path="Array"><d/></c>
	<x path="Int"/>
</f></compareArgs>
		<compareArg set="method" line="52"><f a="v1:v2">
	<d/>
	<d/>
	<x path="Int"/>
</f></compareArg>
		<new public="1" set="method" line="31"><f a=""><x path="Void"/></f></new>
		<haxe_doc>EnumValueMap allows mapping of enum value keys to arbitrary values.

	Keys are compared by value and recursively over their parameters. If any
	parameter is not an enum value, `Reflect.compare` is used to compare them.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<abstract path="haxe.ds.HashMap" params="K:V" file="D:\HaxeToolkit\haxe\std/haxe/ds/HashMap.hx">
		<this><c path="haxe.ds._HashMap.HashMapData">
	<c path="haxe.ds.HashMap.K"/>
	<c path="haxe.ds.HashMap.V"/>
</c></this>
		<haxe_doc>HashMap allows mapping of hashable objects to arbitrary values.

	See `Map` for documentation details.

	@see https://haxe.org/manual/std-Map.html</haxe_doc>
		<impl><class path="haxe.ds._HashMap.HashMap_Impl_" params="" file="D:\HaxeToolkit\haxe\std/haxe/ds/HashMap.hx" private="1" module="haxe.ds.HashMap"><meta>
	<m n=":keep"/>
	<m n=":final"/>
</meta></class></impl>
	</abstract>
	<class path="haxe.ds.IntMap" params="T" file="D:\HaxeToolkit\haxe\std/neko/_std/haxe/ds/IntMap.hx">
		<implements path="haxe.IMap">
			<x path="Int"/>
			<c path="haxe.ds.IntMap.T"/>
		</implements>
		<h><d/></h>
		<set public="1" get="inline" set="null" line="32">
			<f a="key:value">
				<x path="Int"/>
				<c path="haxe.ds.IntMap.T"/>
				<x path="Void"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>See `Map.set`</haxe_doc>
		</set>
		<get public="1" set="method" line="36">
			<f a="key">
				<x path="Int"/>
				<t path="Null"><c path="haxe.ds.IntMap.T"/></t>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>See `Map.get`</haxe_doc>
		</get>
		<remove public="1" get="inline" set="null" line="44">
			<f a="key">
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>See `Map.remove`</haxe_doc>
		</remove>
		<keys public="1" set="method" line="48">
			<f a=""><t path="Iterator"><x path="Int"/></t></f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>See `Map.keys`</haxe_doc>
		</keys>
		<new public="1" set="method" line="28">
			<f a=""><x path="Void"/></f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Creates a new IntMap.</haxe_doc>
		</new>
		<haxe_doc>IntMap allows mapping of Int keys to arbitrary values.

	See `Map` for documentation details.

	@see https://haxe.org/manual/std-Map.html</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<class path="haxe.ds.ObjectMap" params="K:V" file="D:\HaxeToolkit\haxe\std/neko/_std/haxe/ds/ObjectMap.hx">
		<implements path="haxe.IMap">
			<c path="haxe.ds.ObjectMap.K"/>
			<c path="haxe.ds.ObjectMap.V"/>
		</implements>
		<count expr="0" line="27" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</count>
		<h><a/></h>
		<k><a/></k>
		<set public="1" get="inline" set="null" line="47">
			<f a="key:value">
				<c path="haxe.ds.ObjectMap.K"/>
				<c path="haxe.ds.ObjectMap.V"/>
				<x path="Void"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>See `Map.set`</haxe_doc>
		</set>
		<get public="1" set="method" line="53">
			<f a="key">
				<c path="haxe.ds.ObjectMap.K"/>
				<t path="Null"><c path="haxe.ds.ObjectMap.V"/></t>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>See `Map.get`</haxe_doc>
		</get>
		<remove public="1" set="method" line="61">
			<f a="key">
				<c path="haxe.ds.ObjectMap.K"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>See `Map.remove`</haxe_doc>
		</remove>
		<keys public="1" set="method" line="67">
			<f a=""><t path="Iterator"><c path="haxe.ds.ObjectMap.K"/></t></f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>See `Map.keys`</haxe_doc>
		</keys>
		<new public="1" set="method" line="42">
			<f a=""><x path="Void"/></f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Creates a new ObjectMap.</haxe_doc>
		</new>
		<haxe_doc>ObjectMap allows mapping of object keys to arbitrary values.

	On static targets, the keys are considered to be strong references. Refer
	to `haxe.ds.WeakMap` for a weak reference version.

	See `Map` for documentation details.

	@see https://haxe.org/manual/std-Map.html</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<class path="haxe.ds.StringMap" params="T" file="D:\HaxeToolkit\haxe\std/neko/_std/haxe/ds/StringMap.hx">
		<implements path="haxe.IMap">
			<c path="String"/>
			<c path="haxe.ds.StringMap.T"/>
		</implements>
		<h><d/></h>
		<set public="1" get="inline" set="null" line="32">
			<f a="key:value">
				<c path="String"/>
				<c path="haxe.ds.StringMap.T"/>
				<x path="Void"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>See `Map.set`</haxe_doc>
		</set>
		<get public="1" get="inline" set="null" line="36">
			<f a="key">
				<c path="String"/>
				<t path="Null"><c path="haxe.ds.StringMap.T"/></t>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>See `Map.get`</haxe_doc>
		</get>
		<remove public="1" get="inline" set="null" line="44">
			<f a="key">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>See `Map.remove`</haxe_doc>
		</remove>
		<keys public="1" set="method" line="48">
			<f a=""><t path="Iterator"><c path="String"/></t></f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>See `Map.keys`</haxe_doc>
		</keys>
		<iterator public="1" set="method" line="54">
			<f a=""><t path="Iterator"><c path="haxe.ds.StringMap.T"/></t></f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>See `Map.iterator`</haxe_doc>
		</iterator>
		<new public="1" set="method" line="28">
			<f a=""><x path="Void"/></f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Creates a new StringMap.</haxe_doc>
		</new>
		<haxe_doc>StringMap allows mapping of String keys to arbitrary values.

	See `Map` for documentation details.

	@see https://haxe.org/manual/std-Map.html</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<typedef path="haxe.ds._Vector.VectorData" params="T" file="D:\HaxeToolkit\haxe\std/haxe/ds/Vector.hx" private="1" module="haxe.ds.Vector"><c path="neko.NativeArray"><c path="haxe.ds._Vector.VectorData.T"/></c></typedef>
	<abstract path="haxe.ds.Vector" params="T" file="D:\HaxeToolkit\haxe\std/haxe/ds/Vector.hx">
		<this><t path="haxe.ds._Vector.VectorData"><c path="haxe.ds.Vector.T"/></t></this>
		<haxe_doc>A Vector is a storage of fixed size. It can be faster than Array on some
	targets, and is never slower.

	@see https://haxe.org/manual/std-vector.html</haxe_doc>
		<impl><class path="haxe.ds._Vector.Vector_Impl_" params="" file="D:\HaxeToolkit\haxe\std/haxe/ds/Vector.hx" private="1" module="haxe.ds.Vector">
	<length public="1" get="null" set="null" static="1">
		<x path="Int"/>
		<meta><m n=":impl"/></meta>
		<haxe_doc>Returns the length of `this` Vector.</haxe_doc>
	</length>
	<toArray public="1" set="method" line="181" static="1">
		<f a="this">
			<t path="haxe.ds._Vector.VectorData"><c path="haxe.ds.Vector.T"/></t>
			<c path="Array"><c path="haxe.ds.Vector.T"/></c>
		</f>
		<meta><m n=":impl"/></meta>
		<haxe_doc>Creates a new Array, copy the content from the Vector to it, and returns it.</haxe_doc>
	</toArray>
	<meta>
		<m n=":keep"/>
		<m n=":directlyUsed"/>
		<m n=":final"/>
	</meta>
</class></impl>
	</abstract>
	<class path="haxe.ds._Vector.Vector_Impl_" params="" file="D:\HaxeToolkit\haxe\std/haxe/ds/Vector.hx" private="1" module="haxe.ds.Vector">
		<length public="1" get="null" set="null" static="1">
			<x path="Int"/>
			<meta><m n=":impl"/></meta>
			<haxe_doc>Returns the length of `this` Vector.</haxe_doc>
		</length>
		<toArray public="1" set="method" line="181" static="1">
			<f a="this">
				<t path="haxe.ds._Vector.VectorData"><c path="haxe.ds.Vector.T"/></t>
				<c path="Array"><c path="haxe.ds.Vector.T"/></c>
			</f>
			<meta><m n=":impl"/></meta>
			<haxe_doc>Creates a new Array, copy the content from the Vector to it, and returns it.</haxe_doc>
		</toArray>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":final"/>
		</meta>
	</class>
	<class path="haxe.format.JsonParser" params="" file="D:\HaxeToolkit\haxe\std/haxe/format/JsonParser.hx">
		<str><c path="String"/></str>
		<pos><x path="Int"/></pos>
		<parseRec set="method" line="56"><f a=""><d/></f></parseRec>
		<parseString set="method" line="138"><f a=""><c path="String"/></f></parseString>
		<invalidChar set="method" line="249"><f a=""><x path="Void"/></f></invalidChar>
		<invalidNumber set="method" line="254"><f a="start">
	<x path="Int"/>
	<x path="Void"/>
</f></invalidNumber>
		<new set="method" line="51"><f a="str">
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>An implementation of JSON parser in Haxe.

	This class is used by `haxe.Json` when native JSON implementation
	is not available.

	@see https://haxe.org/manual/std-Json-parsing.html</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="haxe.io.BytesBuffer" params="" file="D:\HaxeToolkit\haxe\std/haxe/io/BytesBuffer.hx">
		<b><d/></b>
		<length public="1" get="null" set="null">
			<x path="Int"/>
			<haxe_doc>The length of the buffer in bytes.</haxe_doc>
		</length>
		<getBytes public="1" set="method" line="191">
			<f a=""><c path="haxe.io.Bytes"/></f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Returns either a copy or a reference of the current bytes.
		Once called, the buffer can no longer be used.</haxe_doc>
		</getBytes>
		<new public="1" set="method" line="45">
			<f a=""><x path="Void"/></f>
			<meta><m n=":has_untyped"/></meta>
		</new>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<typedef path="haxe.io.BytesData" params="" file="D:\HaxeToolkit\haxe\std/haxe/io/BytesData.hx"><c path="neko.NativeString"/></typedef>
	<class path="haxe.io.Input" params="" file="D:\HaxeToolkit\haxe\std/haxe/io/Input.hx">
		<bigEndian public="1" set="null">
			<x path="Bool"/>
			<haxe_doc>Endianness (word byte order) used when reading numbers.

		If `true`, big-endian is used, otherwise `little-endian` is used.</haxe_doc>
		</bigEndian>
		<readByte public="1" set="method" line="49">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Read and return one byte.</haxe_doc>
		</readByte>
		<close public="1" set="method" line="92">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Close the input source.

		Behaviour while reading after calling this method is unspecified.</haxe_doc>
		</close>
		<readLine public="1" set="method" line="177">
			<f a=""><c path="String"/></f>
			<haxe_doc>Read a line of text separated by CR and/or LF bytes.

		The CR/LF characters are not included in the resulting string.</haxe_doc>
		</readLine>
		<readFloat public="1" set="method" line="199">
			<f a=""><x path="Float"/></f>
			<haxe_doc>Read a 32-bit floating point number.

		Endianness is specified by the `bigEndian` property.</haxe_doc>
		</readFloat>
		<readInt32 public="1" set="method" line="281">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Read a 32-bit signed integer.

		Endianness is specified by the `bigEndian` property.</haxe_doc>
		</readInt32>
		<haxe_doc>An Input is an abstract reader. See other classes in the `haxe.io` package
	for several possible implementations.

	All functions which read data throw `Eof` when the end of the stream
	is reached.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="haxe.io.BytesInput" params="" file="D:\HaxeToolkit\haxe\std/haxe/io/BytesInput.hx">
		<extends path="haxe.io.Input"/>
		<b><t path="haxe.io.BytesData"/></b>
		<pos><x path="Int"/></pos>
		<len><x path="Int"/></len>
		<totlen><x path="Int"/></totlen>
		<position public="1" get="null" set="null">
			<x path="Int"/>
			<haxe_doc>The current position in the stream in bytes.</haxe_doc>
		</position>
		<length public="1" get="null" set="null">
			<x path="Int"/>
			<haxe_doc>The length of the stream in bytes.</haxe_doc>
		</length>
		<readByte public="1" set="method" line="90" override="1">
			<f a=""><x path="Int"/></f>
			<meta><m n=":has_untyped"/></meta>
		</readByte>
		<new public="1" set="method" line="38"><f a="b:?pos:?len">
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="haxe.io.Output" params="" file="D:\HaxeToolkit\haxe\std/haxe/io/Output.hx">
		<writeByte public="1" set="method" line="46">
			<f a="c">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Write one byte.</haxe_doc>
		</writeByte>
		<writeBytes public="1" set="method" line="57">
			<f a="s:pos:len">
				<c path="haxe.io.Bytes"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Write `len` bytes from `s` starting by position specified by `pos`.

		Returns the actual length of written data that can differ from `len`.

		See `writeFullBytes` that tries to write the exact amount of specified bytes.</haxe_doc>
		</writeBytes>
		<close public="1" set="method" line="93">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Close the output.

		Behaviour while writing after calling this method is unspecified.</haxe_doc>
		</close>
		<writeFullBytes public="1" set="method" line="122">
			<f a="s:pos:len">
				<c path="haxe.io.Bytes"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Write `len` bytes from `s` starting by position specified by `pos`.

		Unlike `writeBytes`, this method tries to write the exact `len` amount of bytes.</haxe_doc>
		</writeFullBytes>
		<writeString public="1" set="method" line="278">
			<f a="s">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Write `s` string.</haxe_doc>
		</writeString>
		<haxe_doc>An Output is an abstract write. A specific output implementation will only
	have to override the `writeByte` and maybe the `write`, `flush` and `close`
	methods. See `File.write` and `String.write` for two ways of creating an
	Output.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="haxe.io.Eof" params="" file="D:\HaxeToolkit\haxe\std/haxe/io/Eof.hx">
		<toString set="method" line="30">
			<f a=""><c path="String"/></f>
			<meta><m n=":keep"/></meta>
		</toString>
		<new public="1" set="method" line="28"><f a=""><x path="Void"/></f></new>
		<haxe_doc>This exception is raised when reading while data is no longer available in the `haxe.io.Input`.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<enum path="haxe.io.Error" params="" file="D:\HaxeToolkit\haxe\std/haxe/io/Error.hx">
		<Blocked><haxe_doc>The IO is set into nonblocking mode and some data cannot be read or written</haxe_doc></Blocked>
		<Overflow><haxe_doc>An integer value is outside its allowed range</haxe_doc></Overflow>
		<OutsideBounds><haxe_doc>An operation on Bytes is outside of its valid range</haxe_doc></OutsideBounds>
		<Custom a="e">
			<d/>
			<haxe_doc>Other errors</haxe_doc>
		</Custom>
		<haxe_doc>The possible IO errors that can occur</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</enum>
	<class path="neko.vm.Tls" params="T" file="D:\HaxeToolkit\haxe\std/neko/vm/Tls.hx">
		<tls_create expr="neko.Lib.load(&quot;std&quot;, &quot;tls_create&quot;, 0)" line="57" static="1">
			<f a=""><unknown/></f>
			<meta><m n=":value"><e>neko.Lib.load("std", "tls_create", 0)</e></m></meta>
		</tls_create>
		<tls_get expr="neko.Lib.load(&quot;std&quot;, &quot;tls_get&quot;, 1)" line="58" static="1">
			<f a="">
				<d/>
				<c path="neko.vm.Tls.T"/>
			</f>
			<meta><m n=":value"><e>neko.Lib.load("std", "tls_get", 1)</e></m></meta>
		</tls_get>
		<tls_set expr="neko.Lib.load(&quot;std&quot;, &quot;tls_set&quot;, 2)" line="59" static="1">
			<f a=":">
				<d/>
				<c path="neko.vm.Tls.T"/>
				<unknown/>
			</f>
			<meta><m n=":value"><e>neko.Lib.load("std", "tls_set", 2)</e></m></meta>
		</tls_set>
		<t><d/></t>
		<value public="1" get="accessor" set="accessor"><c path="neko.vm.Tls.T"/></value>
		<get_value set="method" line="45">
			<f a=""><c path="neko.vm.Tls.T"/></f>
			<haxe_doc>Returns the value set by tls_set for the local thread.</haxe_doc>
		</get_value>
		<set_value set="method" line="52">
			<f a="v">
				<c path="neko.vm.Tls.T"/>
				<c path="neko.vm.Tls.T"/>
			</f>
			<haxe_doc>Set the value of the TLS for the local thread.</haxe_doc>
		</set_value>
		<new public="1" set="method" line="38">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates thread local storage. This is placeholder that can store
		a value that will be different depending on the local thread. 
		Set the tls value to `null` before exiting the thread 
		or the memory will never be collected.</haxe_doc>
		</new>
		<haxe_doc>Creates thread local storage.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="haxe.io.FPHelper" params="" file="D:\HaxeToolkit\haxe\std/haxe/io/FPHelper.hx">
		<helperf expr="new neko.vm.Tls&lt;neko.NativeString&gt;()" line="42" static="1">
			<c path="neko.vm.Tls"><c path="neko.NativeString"/></c>
			<meta><m n=":value"><e><![CDATA[new neko.vm.Tls<neko.NativeString>()]]></e></m></meta>
		</helperf>
		<helperd expr="new neko.vm.Tls&lt;neko.NativeString&gt;()" line="43" static="1">
			<c path="neko.vm.Tls"><c path="neko.NativeString"/></c>
			<meta><m n=":value"><e><![CDATA[new neko.vm.Tls<neko.NativeString>()]]></e></m></meta>
		</helperd>
		<_float_of_bytes expr="neko.Lib.load(&quot;std&quot;, &quot;float_of_bytes&quot;, 2)" line="44" static="1">
			<f a=":">
				<c path="neko.NativeString"/>
				<x path="Bool"/>
				<x path="Float"/>
			</f>
			<meta><m n=":value"><e>neko.Lib.load("std", "float_of_bytes", 2)</e></m></meta>
		</_float_of_bytes>
		<_double_of_bytes expr="neko.Lib.load(&quot;std&quot;, &quot;double_of_bytes&quot;, 2)" line="45" static="1">
			<f a=":">
				<c path="neko.NativeString"/>
				<x path="Bool"/>
				<x path="Float"/>
			</f>
			<meta><m n=":value"><e>neko.Lib.load("std", "double_of_bytes", 2)</e></m></meta>
		</_double_of_bytes>
		<_float_bytes expr="neko.Lib.load(&quot;std&quot;, &quot;float_bytes&quot;, 2)" line="46" static="1">
			<f a=":">
				<x path="Float"/>
				<x path="Bool"/>
				<unknown/>
			</f>
			<meta><m n=":value"><e>neko.Lib.load("std", "float_bytes", 2)</e></m></meta>
		</_float_bytes>
		<_double_bytes expr="neko.Lib.load(&quot;std&quot;, &quot;double_bytes&quot;, 2)" line="47" static="1">
			<f a=":">
				<x path="Float"/>
				<x path="Bool"/>
				<unknown/>
			</f>
			<meta><m n=":value"><e>neko.Lib.load("std", "double_bytes", 2)</e></m></meta>
		</_double_bytes>
		<i32ToFloat public="1" set="method" line="62" static="1">
			<f a="i">
				<x path="Int"/>
				<x path="Float"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</i32ToFloat>
		<i64ToDouble public="1" set="method" line="153" static="1">
			<f a="low:high">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Float"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</i64ToDouble>
		<haxe_doc>Helper that converts between floating point and binary representation.
	Always works in low-endian encoding.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="haxe.io.Path" params="" file="D:\HaxeToolkit\haxe\std/haxe/io/Path.hx">
		<withoutDirectory public="1" set="method" line="134" static="1">
			<f a="path">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the String representation of `path` without the directory.

		If `path` is null, the result is unspecified.</haxe_doc>
		</withoutDirectory>
		<directory public="1" set="method" line="147" static="1">
			<f a="path">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the directory of `path`.

		If the directory is null, the empty String `""` is returned.

		If `path` is null, the result is unspecified.</haxe_doc>
		</directory>
		<addTrailingSlash public="1" set="method" line="262" static="1">
			<f a="path">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Adds a trailing slash to `path`, if it does not have one already.

		If the last slash in `path` is a backslash, a backslash is appended to
		`path`.

		If the last slash in `path` is a slash, or if no slash is found, a slash
		is appended to `path`. In particular, this applies to the empty String
		`""`.

		If `path` is null, the result is unspecified.</haxe_doc>
		</addTrailingSlash>
		<removeTrailingSlashes public="1" set="method" line="287" static="1">
			<f a="path">
				<c path="String"/>
				<c path="String"/>
			</f>
			<meta><m n=":require"><e><![CDATA[haxe_ver >= 3.1]]></e></m></meta>
			<haxe_doc>Removes trailing slashes from `path`.

		If `path` does not end with a `/` or `\`, `path` is returned unchanged.

		Otherwise the substring of `path` excluding the trailing slashes or
		backslashes is returned.

		If `path` is null, the result is unspecified.</haxe_doc>
		</removeTrailingSlashes>
		<dir public="1">
			<c path="String"/>
			<haxe_doc>The directory.

		This is the leading part of the path that is not part of the file name
		and the extension.

		Does not end with a `/` or `\` separator.

		If the path has no directory, the value is null.</haxe_doc>
		</dir>
		<file public="1">
			<c path="String"/>
			<haxe_doc>The file name.

		This is the part of the part between the directory and the extension.

		If there is no file name, e.g. for ".htaccess" or "/dir/", the value
		is the empty String "".</haxe_doc>
		</file>
		<ext public="1">
			<c path="String"/>
			<haxe_doc>The file extension.

		It is separated from the file name by a dot. This dot is not part of
		the extension.

		If the path has no extension, the value is null.</haxe_doc>
		</ext>
		<backslash public="1">
			<x path="Bool"/>
			<haxe_doc>True if the last directory separator is a backslash, false otherwise.</haxe_doc>
		</backslash>
		<toString public="1" set="method" line="114">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns a String representation of `this` path.

		If `this.backslash` is true, backslash is used as directory separator,
		otherwise slash is used. This only affects the separator between
		`this.dir` and `this.file`.

		If `this.directory` or `this.extension` is null, their representation
		is the empty String "".</haxe_doc>
		</toString>
		<new public="1" set="method" line="76">
			<f a="path">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Creates a new Path instance by parsing `path`.

		Path information can be retrieved by accessing the dir, file and ext
		properties.</haxe_doc>
		</new>
		<haxe_doc>This class provides a convenient way of working with paths. It supports the
	common path formats:

	- directory1/directory2/filename.extension
	- directory1\directory2\filename.extension</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<typedef path="haxe.macro.Position" params="" file="D:\HaxeToolkit\haxe\std/haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<a>
			<min>
				<x path="Int"/>
				<haxe_doc>Position of the first character.</haxe_doc>
			</min>
			<max>
				<x path="Int"/>
				<haxe_doc>Position of the last character.</haxe_doc>
			</max>
			<file>
				<c path="String"/>
				<haxe_doc>Reference to the filename.</haxe_doc>
			</file>
		</a>
		<haxe_doc>Represents a position in a file.</haxe_doc>
	</typedef>
	<typedef path="haxe.macro.Expr" params="" file="D:\HaxeToolkit\haxe\std/haxe/macro/Expr.hx">
		<a>
			<pos>
				<t path="haxe.macro.Position"/>
				<haxe_doc>The position of the expression.</haxe_doc>
			</pos>
			<expr>
				<e path="haxe.macro.ExprDef"/>
				<haxe_doc>The expression kind.</haxe_doc>
			</expr>
		</a>
		<haxe_doc>Represents a node in the AST.
	@see https://haxe.org/manual/macro-reification-expression.html</haxe_doc>
	</typedef>
	<typedef path="haxe.macro.ExprOf" params="T" file="D:\HaxeToolkit\haxe\std/haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<t path="haxe.macro.Expr"/>
		<haxe_doc>Represents a AST node identical to `Expr`, but it allows constraining the
	type of accepted expressions.
	@see https://haxe.org/manual/macro-ExprOf.html</haxe_doc>
	</typedef>
	<typedef path="haxe.macro.Case" params="" file="D:\HaxeToolkit\haxe\std/haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<a>
			<values>
				<c path="Array"><t path="haxe.macro.Expr"/></c>
				<haxe_doc>The value expressions of the case.</haxe_doc>
			</values>
			<guard>
				<t path="Null"><t path="Null"><t path="haxe.macro.Expr"/></t></t>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The optional guard expressions of the case, if available.</haxe_doc>
			</guard>
			<expr>
				<t path="Null"><t path="haxe.macro.Expr"/></t>
				<haxe_doc>The expression of the case, if available.</haxe_doc>
			</expr>
		</a>
		<haxe_doc>Represents a switch case.
	@see https://haxe.org/manual/expression-switch.html</haxe_doc>
	</typedef>
	<typedef path="haxe.macro.Var" params="" file="D:\HaxeToolkit\haxe\std/haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<a>
			<type>
				<t path="Null"><e path="haxe.macro.ComplexType"/></t>
				<haxe_doc>The type-hint of the variable, if available.</haxe_doc>
			</type>
			<name>
				<c path="String"/>
				<haxe_doc>The name of the variable.</haxe_doc>
			</name>
			<expr>
				<t path="Null"><t path="haxe.macro.Expr"/></t>
				<haxe_doc>The expression of the variable, if available.</haxe_doc>
			</expr>
		</a>
		<haxe_doc>Represents a variable in the AST.
	@see https://haxe.org/manual/expression-var.html</haxe_doc>
	</typedef>
	<typedef path="haxe.macro.Catch" params="" file="D:\HaxeToolkit\haxe\std/haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<a>
			<type>
				<e path="haxe.macro.ComplexType"/>
				<haxe_doc>The type of the catch.</haxe_doc>
			</type>
			<name>
				<c path="String"/>
				<haxe_doc>The name of the catch variable.</haxe_doc>
			</name>
			<expr>
				<t path="haxe.macro.Expr"/>
				<haxe_doc>The expression of the catch.</haxe_doc>
			</expr>
		</a>
		<haxe_doc>Represents a catch in the AST.
	@https://haxe.org/manual/expression-try-catch.html</haxe_doc>
	</typedef>
	<typedef path="haxe.macro.TypePath" params="" file="D:\HaxeToolkit\haxe\std/haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<a>
			<sub>
				<t path="Null"><t path="Null"><c path="String"/></t></t>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Sub is set on module sub-type access:
		`pack.Module.Type` has name = Module, sub = Type, if available.</haxe_doc>
			</sub>
			<params>
				<t path="Null"><c path="Array"><e path="haxe.macro.TypeParam"/></c></t>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Optional parameters of the type path.</haxe_doc>
			</params>
			<pack>
				<c path="Array"><c path="String"/></c>
				<haxe_doc>Represents the package of the type path.</haxe_doc>
			</pack>
			<name>
				<c path="String"/>
				<haxe_doc>The name of the type path.</haxe_doc>
			</name>
		</a>
		<haxe_doc>Represents a type path in the AST.</haxe_doc>
	</typedef>
	<typedef path="haxe.macro.TypeParamDecl" params="" file="D:\HaxeToolkit\haxe\std/haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<a>
			<params>
				<t path="Null"><c path="Array"><t path="haxe.macro.TypeParamDecl"/></c></t>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The optional parameters of the type parameter.</haxe_doc>
			</params>
			<name>
				<c path="String"/>
				<haxe_doc>The name of the type parameter.</haxe_doc>
			</name>
			<meta>
				<t path="Null"><t path="haxe.macro.Metadata"/></t>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The metadata of the type parameter.</haxe_doc>
			</meta>
			<constraints>
				<t path="Null"><c path="Array"><e path="haxe.macro.ComplexType"/></c></t>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The optional constraints of the type parameter.</haxe_doc>
			</constraints>
		</a>
		<haxe_doc>Represents a type parameter declaration in the AST.</haxe_doc>
	</typedef>
	<typedef path="haxe.macro.Function" params="" file="D:\HaxeToolkit\haxe\std/haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<a>
			<ret>
				<t path="Null"><e path="haxe.macro.ComplexType"/></t>
				<haxe_doc>The return type-hint of the function, if available.</haxe_doc>
			</ret>
			<params>
				<t path="Null"><c path="Array"><t path="haxe.macro.TypeParamDecl"/></c></t>
				<meta><m n=":optional"/></meta>
				<haxe_doc>An optional list of function parameter type declarations.</haxe_doc>
			</params>
			<expr>
				<t path="Null"><t path="haxe.macro.Expr"/></t>
				<haxe_doc>The expression of the function body, if available.</haxe_doc>
			</expr>
			<args>
				<c path="Array"><t path="haxe.macro.FunctionArg"/></c>
				<haxe_doc>A list of function arguments.</haxe_doc>
			</args>
		</a>
		<haxe_doc>Represents a function in the AST.</haxe_doc>
	</typedef>
	<typedef path="haxe.macro.FunctionArg" params="" file="D:\HaxeToolkit\haxe\std/haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<a>
			<value>
				<t path="Null"><t path="Null"><t path="haxe.macro.Expr"/></t></t>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The optional value of the function argument, if available.</haxe_doc>
			</value>
			<type>
				<t path="Null"><e path="haxe.macro.ComplexType"/></t>
				<haxe_doc>The type-hint of the function argument, if available.</haxe_doc>
			</type>
			<opt>
				<t path="Null"><x path="Bool"/></t>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Whether or not the function argument is optional.</haxe_doc>
			</opt>
			<name>
				<c path="String"/>
				<haxe_doc>The name of the function argument.</haxe_doc>
			</name>
			<meta>
				<t path="Null"><t path="haxe.macro.Metadata"/></t>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The metadata of the function argument.</haxe_doc>
			</meta>
		</a>
		<haxe_doc>Represents a function argument in the AST.</haxe_doc>
	</typedef>
	<typedef path="haxe.macro.MetadataEntry" params="" file="D:\HaxeToolkit\haxe\std/haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<a>
			<pos>
				<t path="haxe.macro.Position"/>
				<haxe_doc>The position of the metadata entry.</haxe_doc>
			</pos>
			<params>
				<t path="Null"><c path="Array"><t path="haxe.macro.Expr"/></c></t>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The optional parameters of the metadata entry.</haxe_doc>
			</params>
			<name>
				<c path="String"/>
				<haxe_doc>The name of the metadata entry.</haxe_doc>
			</name>
		</a>
		<haxe_doc>Represents a metadata entry in the AST.</haxe_doc>
	</typedef>
	<typedef path="haxe.macro.Metadata" params="" file="D:\HaxeToolkit\haxe\std/haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<c path="Array"><t path="haxe.macro.MetadataEntry"/></c>
		<haxe_doc>Represents metadata in the AST.</haxe_doc>
	</typedef>
	<typedef path="haxe.macro.Field" params="" file="D:\HaxeToolkit\haxe\std/haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<a>
			<pos>
				<t path="haxe.macro.Position"/>
				<haxe_doc>The position of the field.</haxe_doc>
			</pos>
			<name>
				<c path="String"/>
				<haxe_doc>The name of the field.</haxe_doc>
			</name>
			<meta>
				<t path="Null"><t path="haxe.macro.Metadata"/></t>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The optional metadata of the field.</haxe_doc>
			</meta>
			<kind>
				<e path="haxe.macro.FieldType"/>
				<haxe_doc>The kind of the field.</haxe_doc>
			</kind>
			<doc>
				<t path="Null"><t path="Null"><c path="String"/></t></t>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The documentation of the field, if available. If the field has no
		documentation, the value is `null`.</haxe_doc>
			</doc>
			<access>
				<t path="Null"><c path="Array"><e path="haxe.macro.Access"/></c></t>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The access modifiers of the field. By default fields have private access.
		@see https://haxe.org/manual/class-field-access-modifier.html</haxe_doc>
			</access>
		</a>
		<haxe_doc>Represents a field in the AST.</haxe_doc>
	</typedef>
	<typedef path="haxe.macro.TypeDefinition" params="" file="D:\HaxeToolkit\haxe\std/haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<a>
			<pos>
				<t path="haxe.macro.Position"/>
				<haxe_doc>The position to the type definition.</haxe_doc>
			</pos>
			<params>
				<t path="Null"><c path="Array"><t path="haxe.macro.TypeParamDecl"/></c></t>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The paramater type declarations of the type definition.</haxe_doc>
			</params>
			<pack>
				<c path="Array"><c path="String"/></c>
				<haxe_doc>The package of the type definition.</haxe_doc>
			</pack>
			<name>
				<c path="String"/>
				<haxe_doc>The name of the type definition.</haxe_doc>
			</name>
			<meta>
				<t path="Null"><t path="haxe.macro.Metadata"/></t>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The optional metadata of the type definition.</haxe_doc>
			</meta>
			<kind>
				<e path="haxe.macro.TypeDefKind"/>
				<haxe_doc>The kind of the type definition.</haxe_doc>
			</kind>
			<isExtern>
				<t path="Null"><x path="Bool"/></t>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Whether or not the type is extern.</haxe_doc>
			</isExtern>
			<fields>
				<c path="Array"><t path="haxe.macro.Field"/></c>
				<haxe_doc>The fields of the type definition.</haxe_doc>
			</fields>
		</a>
		<haxe_doc>Represents a type definition.</haxe_doc>
	</typedef>
	<typedef path="haxe.macro.ImportExpr" params="" file="D:\HaxeToolkit\haxe\std/haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<a>
			<path>
				<c path="Array"><a>
	<pos><t path="haxe.macro.Position"/></pos>
	<name><c path="String"/></name>
</a></c>
				<haxe_doc>The path to the import expression.</haxe_doc>
			</path>
			<mode>
				<e path="haxe.macro.ImportMode"/>
				<haxe_doc>The mode of the import expression.</haxe_doc>
			</mode>
		</a>
		<haxe_doc>Represents the import expression.</haxe_doc>
	</typedef>
	<typedef path="haxe.macro.TExprTools" params="" file="D:\HaxeToolkit\haxe\std/haxe/macro/Tools.hx" module="haxe.macro.Tools">
		<c path="haxe.macro.ExprTools"/>
		<haxe_doc><![CDATA[This class can be added via `using haxe.macro.Tools` in order to enable
	`using` functionality on these macro tool classes:

	- `haxe.macro.ExprTools`
	- `haxe.macro.ComplexTypeTools`
	- `haxe.macro.TypeTools`
	- `haxe.macro.MacroStringTools`
	- `haxe.macro.TypedExprTools`
	- `haxe.macro.PositionTools`
  
  @see <https://haxe.org/manual/lf-static-extension.html>]]></haxe_doc>
		<meta><m n=":dox"><e>hide</e></m></meta>
	</typedef>
	<typedef path="haxe.macro.TComplexTypeTools" params="" file="D:\HaxeToolkit\haxe\std/haxe/macro/Tools.hx" module="haxe.macro.Tools">
		<c path="haxe.macro.ComplexTypeTools"/>
		<meta><m n=":dox"><e>hide</e></m></meta>
	</typedef>
	<typedef path="haxe.macro.TTypeTools" params="" file="D:\HaxeToolkit\haxe\std/haxe/macro/Tools.hx" module="haxe.macro.Tools">
		<c path="haxe.macro.TypeTools"/>
		<meta><m n=":dox"><e>hide</e></m></meta>
	</typedef>
	<typedef path="haxe.macro.TMacroStringTools" params="" file="D:\HaxeToolkit\haxe\std/haxe/macro/Tools.hx" module="haxe.macro.Tools">
		<c path="haxe.macro.MacroStringTools"/>
		<meta><m n=":dox"><e>hide</e></m></meta>
	</typedef>
	<typedef path="haxe.macro.TTypedExprTools" params="" file="D:\HaxeToolkit\haxe\std/haxe/macro/Tools.hx" module="haxe.macro.Tools">
		<c path="haxe.macro.TypedExprTools"/>
		<meta><m n=":dox"><e>hide</e></m></meta>
	</typedef>
	<typedef path="haxe.macro.TPositionTools" params="" file="D:\HaxeToolkit\haxe\std/haxe/macro/Tools.hx" module="haxe.macro.Tools">
		<c path="haxe.macro.PositionTools"/>
		<meta><m n=":dox"><e>hide</e></m></meta>
	</typedef>
	<typedef path="haxe.macro.Ref" params="T" file="D:\HaxeToolkit\haxe\std/haxe/macro/Type.hx" module="haxe.macro.Type">
		<a>
			<toString set="method"><f a=""><c path="String"/></f></toString>
			<get set="method"><f a=""><c path="haxe.macro.Ref.T"/></f></get>
		</a>
		<haxe_doc>Represents a reference to internal compiler structure. It exists to avoid
	expensive encoding if it is not required and to ensure that physical
	equality remains intact.

	A structure is only encoded when user requests it through `ref.get()`.</haxe_doc>
	</typedef>
	<typedef path="haxe.macro.AnonType" params="" file="D:\HaxeToolkit\haxe\std/haxe/macro/Type.hx" module="haxe.macro.Type">
		<a>
			<status>
				<e path="haxe.macro.AnonStatus"/>
				<haxe_doc>The status/kind of the structure.</haxe_doc>
			</status>
			<fields>
				<c path="Array"><t path="haxe.macro.ClassField"/></c>
				<haxe_doc>The class fields of the structure.</haxe_doc>
			</fields>
		</a>
		<haxe_doc>Represents information for anonymous structure types.</haxe_doc>
	</typedef>
	<typedef path="haxe.macro.TypeParameter" params="" file="D:\HaxeToolkit\haxe\std/haxe/macro/Type.hx" module="haxe.macro.Type">
		<a>
			<t>
				<e path="haxe.macro.Type"/>
				<haxe_doc>The type of the type parameter. It is guaranteed to be a `TInst` with a
		`KTypeParameter` kind.</haxe_doc>
			</t>
			<name>
				<c path="String"/>
				<haxe_doc>The name of the type parameter.</haxe_doc>
			</name>
		</a>
		<haxe_doc>Represents the declaration of type parameters.</haxe_doc>
	</typedef>
	<typedef path="haxe.macro.ClassField" params="" file="D:\HaxeToolkit\haxe\std/haxe/macro/Type.hx" module="haxe.macro.Type">
		<a>
			<type>
				<e path="haxe.macro.Type"/>
				<haxe_doc>The type of the class field.</haxe_doc>
			</type>
			<pos>
				<t path="haxe.macro.Position"/>
				<haxe_doc>The position of the class field.</haxe_doc>
			</pos>
			<params>
				<c path="Array"><t path="haxe.macro.TypeParameter"/></c>
				<haxe_doc>The type parameters of the class field.</haxe_doc>
			</params>
			<overloads>
				<t path="haxe.macro.Ref"><c path="Array"><t path="haxe.macro.ClassField"/></c></t>
				<haxe_doc>The overload fields of the class field.</haxe_doc>
			</overloads>
			<name>
				<c path="String"/>
				<haxe_doc>The name of the class field.</haxe_doc>
			</name>
			<meta>
				<t path="haxe.macro.MetaAccess"/>
				<haxe_doc>The metadata of the class field.</haxe_doc>
			</meta>
			<kind>
				<e path="haxe.macro.FieldKind"/>
				<haxe_doc>The class field kind.</haxe_doc>
			</kind>
			<isPublic>
				<x path="Bool"/>
				<haxe_doc>Whether or not the class field is public.</haxe_doc>
			</isPublic>
			<expr set="method">
				<f a=""><t path="Null"><t path="haxe.macro.TypedExpr"/></t></f>
				<haxe_doc>Returns the typed expression of the class field.</haxe_doc>
			</expr>
			<doc>
				<t path="Null"><c path="String"/></t>
				<haxe_doc>The associated documentation of the class field.</haxe_doc>
			</doc>
		</a>
		<haxe_doc>Represents a class field.</haxe_doc>
	</typedef>
	<typedef path="haxe.macro.EnumField" params="" file="D:\HaxeToolkit\haxe\std/haxe/macro/Type.hx" module="haxe.macro.Type">
		<a>
			<type>
				<e path="haxe.macro.Type"/>
				<haxe_doc>The type of the enum constructor.</haxe_doc>
			</type>
			<pos>
				<t path="haxe.macro.Position"/>
				<haxe_doc>The position of the enum constructor.</haxe_doc>
			</pos>
			<params>
				<c path="Array"><t path="haxe.macro.TypeParameter"/></c>
				<haxe_doc>The type parameters of the enum constructor.</haxe_doc>
			</params>
			<name>
				<c path="String"/>
				<haxe_doc>The name of the enum constructor.</haxe_doc>
			</name>
			<meta>
				<t path="haxe.macro.MetaAccess"/>
				<haxe_doc>The metadata of the enum constructor.</haxe_doc>
			</meta>
			<index>
				<x path="Int"/>
				<haxe_doc>The index of the enum constructor, i.e. in which position it appears
		in the syntax.</haxe_doc>
			</index>
			<doc>
				<t path="Null"><c path="String"/></t>
				<haxe_doc>The associated documentation of the enum constructor.</haxe_doc>
			</doc>
		</a>
		<haxe_doc>Represents an enum constructor.</haxe_doc>
	</typedef>
	<typedef path="haxe.macro.BaseType" params="" file="D:\HaxeToolkit\haxe\std/haxe/macro/Type.hx" module="haxe.macro.Type">
		<a>
			<pos>
				<t path="haxe.macro.Position"/>
				<haxe_doc>The position of the type.</haxe_doc>
			</pos>
			<params>
				<c path="Array"><t path="haxe.macro.TypeParameter"/></c>
				<haxe_doc>The type parameters of the type.</haxe_doc>
			</params>
			<pack>
				<c path="Array"><c path="String"/></c>
				<haxe_doc>The package of the type.</haxe_doc>
			</pack>
			<name>
				<c path="String"/>
				<haxe_doc>The name of the type.</haxe_doc>
			</name>
			<module>
				<c path="String"/>
				<haxe_doc>The module name of the type, which might be different.</haxe_doc>
			</module>
			<meta>
				<t path="haxe.macro.MetaAccess"/>
				<haxe_doc>The metadata of the type.</haxe_doc>
			</meta>
			<isPrivate>
				<x path="Bool"/>
				<haxe_doc>Whether or not the type is private.</haxe_doc>
			</isPrivate>
			<isExtern>
				<x path="Bool"/>
				<haxe_doc>Whether or not the type is extern.</haxe_doc>
			</isExtern>
			<exclude set="method">
				<f a=""><x path="Void"/></f>
				<haxe_doc>Allows excluding the type from compilation.</haxe_doc>
			</exclude>
			<doc>
				<t path="Null"><c path="String"/></t>
				<haxe_doc>The associated documentation of the class field.</haxe_doc>
			</doc>
		</a>
		<haxe_doc>The information that all types (`ClassType`, `EnumType`, `DefType`,
	`AbstractType`) have in common.</haxe_doc>
	</typedef>
	<typedef path="haxe.macro.ClassType" params="" file="D:\HaxeToolkit\haxe\std/haxe/macro/Type.hx" module="haxe.macro.Type">
		<a>
			<superClass>
				<t path="Null"><a>
	<t><t path="haxe.macro.Ref"><t path="haxe.macro.ClassType"/></t></t>
	<params><c path="Array"><e path="haxe.macro.Type"/></c></params>
</a></t>
				<haxe_doc>The parent class and its type parameters, if available.</haxe_doc>
			</superClass>
			<statics>
				<t path="haxe.macro.Ref"><c path="Array"><t path="haxe.macro.ClassField"/></c></t>
				<haxe_doc>The static fields of the class.</haxe_doc>
			</statics>
			<pos>
				<t path="haxe.macro.Position"/>
				<haxe_doc>The position of the type.</haxe_doc>
			</pos>
			<params>
				<c path="Array"><t path="haxe.macro.TypeParameter"/></c>
				<haxe_doc>The type parameters of the type.</haxe_doc>
			</params>
			<pack>
				<c path="Array"><c path="String"/></c>
				<haxe_doc>The package of the type.</haxe_doc>
			</pack>
			<overrides>
				<c path="Array"><t path="haxe.macro.Ref"><t path="haxe.macro.ClassField"/></t></c>
				<haxe_doc>The list of fields that have override status.</haxe_doc>
			</overrides>
			<name>
				<c path="String"/>
				<haxe_doc>The name of the type.</haxe_doc>
			</name>
			<module>
				<c path="String"/>
				<haxe_doc>The module name of the type, which might be different.</haxe_doc>
			</module>
			<meta>
				<t path="haxe.macro.MetaAccess"/>
				<haxe_doc>The metadata of the type.</haxe_doc>
			</meta>
			<kind>
				<e path="haxe.macro.ClassKind"/>
				<haxe_doc>The kind of the class.</haxe_doc>
			</kind>
			<isPrivate>
				<x path="Bool"/>
				<haxe_doc>Whether or not the type is private.</haxe_doc>
			</isPrivate>
			<isInterface>
				<x path="Bool"/>
				<haxe_doc>If true the type is an interface, otherwise it is a class.</haxe_doc>
			</isInterface>
			<isExtern>
				<x path="Bool"/>
				<haxe_doc>Whether or not the type is extern.</haxe_doc>
			</isExtern>
			<interfaces>
				<c path="Array"><a>
	<t><t path="haxe.macro.Ref"><t path="haxe.macro.ClassType"/></t></t>
	<params><c path="Array"><e path="haxe.macro.Type"/></c></params>
</a></c>
				<haxe_doc>The implemented interfaces and their type parameters.</haxe_doc>
			</interfaces>
			<init>
				<t path="Null"><t path="haxe.macro.TypedExpr"/></t>
				<haxe_doc>The `__init__` expression of the class, if available.</haxe_doc>
			</init>
			<fields>
				<t path="haxe.macro.Ref"><c path="Array"><t path="haxe.macro.ClassField"/></c></t>
				<haxe_doc>The member fields of the class.</haxe_doc>
			</fields>
			<exclude set="method">
				<f a=""><x path="Void"/></f>
				<haxe_doc>Allows excluding the type from compilation.</haxe_doc>
			</exclude>
			<doc>
				<t path="Null"><c path="String"/></t>
				<haxe_doc>The associated documentation of the class field.</haxe_doc>
			</doc>
			<constructor>
				<t path="Null"><t path="haxe.macro.Ref"><t path="haxe.macro.ClassField"/></t></t>
				<haxe_doc>The constructor of the class, if available.</haxe_doc>
			</constructor>
		</a>
		<haxe_doc>Represents a class type.</haxe_doc>
	</typedef>
	<typedef path="haxe.macro.EnumType" params="" file="D:\HaxeToolkit\haxe\std/haxe/macro/Type.hx" module="haxe.macro.Type">
		<a>
			<pos>
				<t path="haxe.macro.Position"/>
				<haxe_doc>The position of the type.</haxe_doc>
			</pos>
			<params>
				<c path="Array"><t path="haxe.macro.TypeParameter"/></c>
				<haxe_doc>The type parameters of the type.</haxe_doc>
			</params>
			<pack>
				<c path="Array"><c path="String"/></c>
				<haxe_doc>The package of the type.</haxe_doc>
			</pack>
			<names>
				<c path="Array"><c path="String"/></c>
				<haxe_doc>An ordered list of enum constructor names.</haxe_doc>
			</names>
			<name>
				<c path="String"/>
				<haxe_doc>The name of the type.</haxe_doc>
			</name>
			<module>
				<c path="String"/>
				<haxe_doc>The module name of the type, which might be different.</haxe_doc>
			</module>
			<meta>
				<t path="haxe.macro.MetaAccess"/>
				<haxe_doc>The metadata of the type.</haxe_doc>
			</meta>
			<isPrivate>
				<x path="Bool"/>
				<haxe_doc>Whether or not the type is private.</haxe_doc>
			</isPrivate>
			<isExtern>
				<x path="Bool"/>
				<haxe_doc>Whether or not the type is extern.</haxe_doc>
			</isExtern>
			<exclude set="method">
				<f a=""><x path="Void"/></f>
				<haxe_doc>Allows excluding the type from compilation.</haxe_doc>
			</exclude>
			<doc>
				<t path="Null"><c path="String"/></t>
				<haxe_doc>The associated documentation of the class field.</haxe_doc>
			</doc>
			<constructs>
				<x path="Map">
					<c path="String"/>
					<t path="haxe.macro.EnumField"/>
				</x>
				<haxe_doc>The available enum constructors.</haxe_doc>
			</constructs>
		</a>
		<haxe_doc>Represents an enum type.</haxe_doc>
	</typedef>
	<typedef path="haxe.macro.DefType" params="" file="D:\HaxeToolkit\haxe\std/haxe/macro/Type.hx" module="haxe.macro.Type">
		<a>
			<type>
				<e path="haxe.macro.Type"/>
				<haxe_doc>The target type of the typedef.</haxe_doc>
			</type>
			<pos>
				<t path="haxe.macro.Position"/>
				<haxe_doc>The position of the type.</haxe_doc>
			</pos>
			<params>
				<c path="Array"><t path="haxe.macro.TypeParameter"/></c>
				<haxe_doc>The type parameters of the type.</haxe_doc>
			</params>
			<pack>
				<c path="Array"><c path="String"/></c>
				<haxe_doc>The package of the type.</haxe_doc>
			</pack>
			<name>
				<c path="String"/>
				<haxe_doc>The name of the type.</haxe_doc>
			</name>
			<module>
				<c path="String"/>
				<haxe_doc>The module name of the type, which might be different.</haxe_doc>
			</module>
			<meta>
				<t path="haxe.macro.MetaAccess"/>
				<haxe_doc>The metadata of the type.</haxe_doc>
			</meta>
			<isPrivate>
				<x path="Bool"/>
				<haxe_doc>Whether or not the type is private.</haxe_doc>
			</isPrivate>
			<isExtern>
				<x path="Bool"/>
				<haxe_doc>Whether or not the type is extern.</haxe_doc>
			</isExtern>
			<exclude set="method">
				<f a=""><x path="Void"/></f>
				<haxe_doc>Allows excluding the type from compilation.</haxe_doc>
			</exclude>
			<doc>
				<t path="Null"><c path="String"/></t>
				<haxe_doc>The associated documentation of the class field.</haxe_doc>
			</doc>
		</a>
		<haxe_doc>Represents a typedef.</haxe_doc>
	</typedef>
	<typedef path="haxe.macro.AbstractType" params="" file="D:\HaxeToolkit\haxe\std/haxe/macro/Type.hx" module="haxe.macro.Type">
		<a>
			<unops>
				<c path="Array"><a>
	<postFix><x path="Bool"/></postFix>
	<op><e path="haxe.macro.Unop"/></op>
	<field><t path="haxe.macro.ClassField"/></field>
</a></c>
				<haxe_doc>The defined unary operators of the abstract.</haxe_doc>
			</unops>
			<type>
				<e path="haxe.macro.Type"/>
				<haxe_doc>The underlying type of the abstract.</haxe_doc>
			</type>
			<to>
				<c path="Array"><a>
	<t><e path="haxe.macro.Type"/></t>
	<field><t path="Null"><t path="haxe.macro.ClassField"/></t></field>
</a></c>
				<haxe_doc>The available implicit to-casts of the abstract.

		@see https://haxe.org/manual/types-abstract-implicit-casts.html</haxe_doc>
			</to>
			<resolve>
				<t path="Null"><t path="haxe.macro.ClassField"/></t>
				<meta><m n=":require"><e><![CDATA[haxe_ver >= 3.3]]></e></m></meta>
				<haxe_doc>The method used for resolving unknown field access, if available.</haxe_doc>
			</resolve>
			<pos>
				<t path="haxe.macro.Position"/>
				<haxe_doc>The position of the type.</haxe_doc>
			</pos>
			<params>
				<c path="Array"><t path="haxe.macro.TypeParameter"/></c>
				<haxe_doc>The type parameters of the type.</haxe_doc>
			</params>
			<pack>
				<c path="Array"><c path="String"/></c>
				<haxe_doc>The package of the type.</haxe_doc>
			</pack>
			<name>
				<c path="String"/>
				<haxe_doc>The name of the type.</haxe_doc>
			</name>
			<module>
				<c path="String"/>
				<haxe_doc>The module name of the type, which might be different.</haxe_doc>
			</module>
			<meta>
				<t path="haxe.macro.MetaAccess"/>
				<haxe_doc>The metadata of the type.</haxe_doc>
			</meta>
			<isPrivate>
				<x path="Bool"/>
				<haxe_doc>Whether or not the type is private.</haxe_doc>
			</isPrivate>
			<isExtern>
				<x path="Bool"/>
				<haxe_doc>Whether or not the type is extern.</haxe_doc>
			</isExtern>
			<impl>
				<t path="Null"><t path="haxe.macro.Ref"><t path="haxe.macro.ClassType"/></t></t>
				<haxe_doc>The implementation class of the abstract, if available.</haxe_doc>
			</impl>
			<from>
				<c path="Array"><a>
	<t><e path="haxe.macro.Type"/></t>
	<field><t path="Null"><t path="haxe.macro.ClassField"/></t></field>
</a></c>
				<haxe_doc>The available implicit from-casts of the abstract.

		@see https://haxe.org/manual/types-abstract-implicit-casts.html</haxe_doc>
			</from>
			<exclude set="method">
				<f a=""><x path="Void"/></f>
				<haxe_doc>Allows excluding the type from compilation.</haxe_doc>
			</exclude>
			<doc>
				<t path="Null"><c path="String"/></t>
				<haxe_doc>The associated documentation of the class field.</haxe_doc>
			</doc>
			<binops>
				<c path="Array"><a>
	<op><e path="haxe.macro.Binop"/></op>
	<field><t path="haxe.macro.ClassField"/></field>
</a></c>
				<haxe_doc>The defined binary operators of the abstract.</haxe_doc>
			</binops>
			<array>
				<c path="Array"><t path="haxe.macro.ClassField"/></c>
				<haxe_doc>The defined array-access fields of the abstract.</haxe_doc>
			</array>
		</a>
		<haxe_doc>Represents an abstract type.</haxe_doc>
	</typedef>
	<typedef path="haxe.macro.MetaAccess" params="" file="D:\HaxeToolkit\haxe\std/haxe/macro/Type.hx" module="haxe.macro.Type">
		<a>
			<remove set="method">
				<f a="name">
					<c path="String"/>
					<x path="Void"/>
				</f>
				<haxe_doc>Removes all `name` metadata entries from the origin of `this`
		MetaAccess.

		This method might clear several metadata entries of the same name.

		If a `Metadata` array is obtained through a call to `get`, a subsequent
		call to `remove` has no effect on that array.

		If `name` is null, compilation fails with an error.</haxe_doc>
			</remove>
			<has set="method">
				<f a="name">
					<c path="String"/>
					<x path="Bool"/>
				</f>
				<haxe_doc>Tells if the origin of `this` MetaAccess has a `name` metadata entry.

		If `name` is null, compilation fails with an error.</haxe_doc>
			</has>
			<get set="method">
				<f a=""><t path="haxe.macro.Metadata"/></f>
				<haxe_doc>Return the wrapped `Metadata` array.

		Modifying this array has no effect on the origin of `this` MetaAccess.
		The `add` and `remove` methods can be used for that.</haxe_doc>
			</get>
			<extract set="method">
				<f a="name">
					<c path="String"/>
					<c path="Array"><t path="haxe.macro.MetadataEntry"/></c>
				</f>
				<haxe_doc>Extract metadata entries by given `name`.

		If there's no metadata with such name, empty array `[]` is returned.

		If `name` is null, compilation fails with an error.</haxe_doc>
			</extract>
			<add set="method">
				<f a="name:params:pos">
					<c path="String"/>
					<c path="Array"><t path="haxe.macro.Expr"/></c>
					<t path="haxe.macro.Position"/>
					<x path="Void"/>
				</f>
				<haxe_doc>Adds the metadata specified by `name`, `params` and `pos` to the origin
		of `this` MetaAccess.

		Metadata names are not unique during compilation, so this method never
		overwrites a previous metadata.

		If a `Metadata` array is obtained through a call to `get`, a subsequent
		call to `add` has no effect on that array.

		If any argument is null, compilation fails with an error.</haxe_doc>
			</add>
		</a>
		<haxe_doc>MetaAccess is a wrapper for the `Metadata` array. It can be used to add
	metadata to and remove metadata from its origin.</haxe_doc>
	</typedef>
	<typedef path="haxe.macro.TVar" params="" file="D:\HaxeToolkit\haxe\std/haxe/macro/Type.hx" module="haxe.macro.Type">
		<a>
			<t set="null">
				<e path="haxe.macro.Type"/>
				<haxe_doc>The type of the variable.</haxe_doc>
			</t>
			<name set="null">
				<c path="String"/>
				<haxe_doc>The name of the variable.</haxe_doc>
			</name>
			<meta set="null">
				<t path="Null"><t path="haxe.macro.MetaAccess"/></t>
				<haxe_doc>The metadata of the variable.</haxe_doc>
			</meta>
			<id set="null">
				<x path="Int"/>
				<haxe_doc>The unique ID of the variable.</haxe_doc>
			</id>
			<extra set="null">
				<t path="Null"><a>
	<params><c path="Array"><t path="haxe.macro.TypeParameter"/></c></params>
	<expr><t path="Null"><t path="haxe.macro.TypedExpr"/></t></expr>
</a></t>
				<haxe_doc>Special information which is internally used to keep track of closure.
		information</haxe_doc>
			</extra>
			<capture set="null">
				<x path="Bool"/>
				<haxe_doc>Whether or not the variable has been captured by a closure.</haxe_doc>
			</capture>
		</a>
		<haxe_doc>Represents a variable in the typed AST.</haxe_doc>
	</typedef>
	<typedef path="haxe.macro.TFunc" params="" file="D:\HaxeToolkit\haxe\std/haxe/macro/Type.hx" module="haxe.macro.Type">
		<a>
			<t>
				<e path="haxe.macro.Type"/>
				<haxe_doc>The return type of the function.</haxe_doc>
			</t>
			<expr>
				<t path="haxe.macro.TypedExpr"/>
				<haxe_doc>The expression of the function body.</haxe_doc>
			</expr>
			<args>
				<c path="Array"><a>
	<value><t path="Null"><e path="haxe.macro.TConstant"/></t></value>
	<v><t path="haxe.macro.TVar"/></v>
</a></c>
				<haxe_doc>A list of function arguments identified by an argument variable `v` and
		an optional initialization `value`.</haxe_doc>
			</args>
		</a>
		<haxe_doc>Represents a function in the typed AST.</haxe_doc>
	</typedef>
	<typedef path="haxe.macro.TypedExpr" params="" file="D:\HaxeToolkit\haxe\std/haxe/macro/Type.hx" module="haxe.macro.Type">
		<a>
			<t>
				<e path="haxe.macro.Type"/>
				<haxe_doc>The type of the expression.</haxe_doc>
			</t>
			<pos>
				<t path="haxe.macro.Position"/>
				<haxe_doc>The position of the expression.</haxe_doc>
			</pos>
			<expr>
				<e path="haxe.macro.TypedExprDef"/>
				<haxe_doc>The expression kind.</haxe_doc>
			</expr>
		</a>
		<haxe_doc>Represents a typed AST node.</haxe_doc>
	</typedef>
	<class path="haxe.xml._Fast.NodeAccess" params="" file="D:\HaxeToolkit\haxe\std/haxe/xml/Fast.hx" private="1" module="haxe.xml.Fast">
		<__x><c path="Xml"/></__x>
		<new public="1" set="method" line="28"><f a="x">
	<c path="Xml"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
		<haxe_dynamic><c path="haxe.xml.Fast"/></haxe_dynamic>
	</class>
	<class path="haxe.xml._Fast.AttribAccess" params="" file="D:\HaxeToolkit\haxe\std/haxe/xml/Fast.hx" private="1" module="haxe.xml.Fast">
		<__x><c path="Xml"/></__x>
		<resolve public="1" set="method" line="51"><f a="name">
	<c path="String"/>
	<c path="String"/>
</f></resolve>
		<new public="1" set="method" line="47"><f a="x">
	<c path="Xml"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
		<haxe_dynamic><c path="String"/></haxe_dynamic>
	</class>
	<class path="haxe.xml._Fast.HasAttribAccess" params="" file="D:\HaxeToolkit\haxe\std/haxe/xml/Fast.hx" private="1" module="haxe.xml.Fast">
		<__x><c path="Xml"/></__x>
		<resolve public="1" set="method" line="70"><f a="name">
	<c path="String"/>
	<x path="Bool"/>
</f></resolve>
		<new public="1" set="method" line="66"><f a="x">
	<c path="Xml"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
		<haxe_dynamic><x path="Bool"/></haxe_dynamic>
	</class>
	<class path="haxe.xml._Fast.HasNodeAccess" params="" file="D:\HaxeToolkit\haxe\std/haxe/xml/Fast.hx" private="1" module="haxe.xml.Fast">
		<__x><c path="Xml"/></__x>
		<new public="1" set="method" line="82"><f a="x">
	<c path="Xml"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
		<haxe_dynamic><x path="Bool"/></haxe_dynamic>
	</class>
	<class path="haxe.xml._Fast.NodeListAccess" params="" file="D:\HaxeToolkit\haxe\std/haxe/xml/Fast.hx" private="1" module="haxe.xml.Fast">
		<__x><c path="Xml"/></__x>
		<resolve public="1" set="method" line="100"><f a="name">
	<c path="String"/>
	<c path="List"><c path="haxe.xml.Fast"/></c>
</f></resolve>
		<new public="1" set="method" line="96"><f a="x">
	<c path="Xml"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
		<haxe_dynamic><c path="List"><c path="haxe.xml.Fast"/></c></haxe_dynamic>
	</class>
	<class path="haxe.xml.Fast" params="" file="D:\HaxeToolkit\haxe\std/haxe/xml/Fast.hx">
		<x public="1" set="null">
			<c path="Xml"/>
			<haxe_doc>The current corresponding `Xml` node.</haxe_doc>
		</x>
		<node public="1" set="null">
			<c path="haxe.xml._Fast.NodeAccess"/>
			<haxe_doc><![CDATA[Access to the first sub element with the given name.

		An exception is thrown if the element doesn't exists.
		Use `hasNode` to check the existence of a node.

		```haxe
		var fast = new haxe.xml.Fast(Xml.parse("<user><name>John</name></user>"));
		var user = fast.node.user;
		var name = user.node.name;
		trace(name.innerData); // John

		// Uncaught Error: Document is missing element password
		var password = user.node.password;
		```]]></haxe_doc>
		</node>
		<nodes public="1" set="null">
			<c path="haxe.xml._Fast.NodeListAccess"/>
			<haxe_doc><![CDATA[Access to the List of elements with the given name.
		```haxe
		var fast = new haxe.xml.Fast(Xml.parse("<users>
				<user name='John'/>
				<user name='Andy'/>
				<user name='Dan'/>
		</users>"));

		var users = fast.node.users;
		for(user in users.nodes.user) {
				trace(user.att.name);
		}
		```]]></haxe_doc>
		</nodes>
		<att public="1" set="null">
			<c path="haxe.xml._Fast.AttribAccess"/>
			<haxe_doc><![CDATA[Access to a given attribute.

		An exception is thrown if the attribute doesn't exists.
		Use `has` to check the existence of an attribute.

		```haxe
		var f = new haxe.xml.Fast(Xml.parse("<user name='Mark'></user>"));
		var user = f.node.user;
		if (user.has.name) {
			trace(user.att.name); // Mark
		}
		```]]></haxe_doc>
		</att>
		<has public="1" set="null">
			<c path="haxe.xml._Fast.HasAttribAccess"/>
			<haxe_doc>Check the existence of an attribute with the given name.</haxe_doc>
		</has>
		<hasNode public="1" set="null">
			<c path="haxe.xml._Fast.HasNodeAccess"/>
			<haxe_doc><![CDATA[Check the existence of a sub node with the given name.

		```haxe
		var f = new haxe.xml.Fast(Xml.parse("<user><age>31</age></user>"));
		var user = f.node.user;
		if (user.hasNode.age) {
			trace(user.node.age.innerData); // 31
		}
		```]]></haxe_doc>
		</hasNode>
		<new public="1" set="method" line="211"><f a="x">
	<c path="Xml"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>The `haxe.xml.Fast` API helps providing a fast dot-syntax access to the
	most common `Xml` methods.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="haxe.xml._Parser.S" params="" file="D:\HaxeToolkit\haxe\std/haxe/xml/Parser.hx" private="1" module="haxe.xml.Parser" extern="1">
		<IGNORE_SPACES public="1" get="inline" set="null" expr="0" line="28" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</IGNORE_SPACES>
		<BEGIN public="1" get="inline" set="null" expr="1" line="29" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</BEGIN>
		<BEGIN_NODE public="1" get="inline" set="null" expr="2" line="30" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>2</e></m></meta>
		</BEGIN_NODE>
		<TAG_NAME public="1" get="inline" set="null" expr="3" line="31" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>3</e></m></meta>
		</TAG_NAME>
		<BODY public="1" get="inline" set="null" expr="4" line="32" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>4</e></m></meta>
		</BODY>
		<ATTRIB_NAME public="1" get="inline" set="null" expr="5" line="33" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>5</e></m></meta>
		</ATTRIB_NAME>
		<EQUALS public="1" get="inline" set="null" expr="6" line="34" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>6</e></m></meta>
		</EQUALS>
		<ATTVAL_BEGIN public="1" get="inline" set="null" expr="7" line="35" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>7</e></m></meta>
		</ATTVAL_BEGIN>
		<ATTRIB_VAL public="1" get="inline" set="null" expr="8" line="36" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>8</e></m></meta>
		</ATTRIB_VAL>
		<CHILDS public="1" get="inline" set="null" expr="9" line="37" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>9</e></m></meta>
		</CHILDS>
		<CLOSE public="1" get="inline" set="null" expr="10" line="38" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>10</e></m></meta>
		</CLOSE>
		<WAIT_END public="1" get="inline" set="null" expr="11" line="39" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>11</e></m></meta>
		</WAIT_END>
		<WAIT_END_RET public="1" get="inline" set="null" expr="12" line="40" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>12</e></m></meta>
		</WAIT_END_RET>
		<PCDATA public="1" get="inline" set="null" expr="13" line="41" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>13</e></m></meta>
		</PCDATA>
		<HEADER public="1" get="inline" set="null" expr="14" line="42" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>14</e></m></meta>
		</HEADER>
		<COMMENT public="1" get="inline" set="null" expr="15" line="43" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>15</e></m></meta>
		</COMMENT>
		<DOCTYPE public="1" get="inline" set="null" expr="16" line="44" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>16</e></m></meta>
		</DOCTYPE>
		<CDATA public="1" get="inline" set="null" expr="17" line="45" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>17</e></m></meta>
		</CDATA>
		<ESCAPE public="1" get="inline" set="null" expr="18" line="46" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>18</e></m></meta>
		</ESCAPE>
	</class>
	<class path="haxe.xml.XmlParserException" params="" file="D:\HaxeToolkit\haxe\std/haxe/xml/Parser.hx" module="haxe.xml.Parser">
		<message public="1">
			<c path="String"/>
			<haxe_doc>* the XML parsing error message</haxe_doc>
		</message>
		<lineNumber public="1">
			<x path="Int"/>
			<haxe_doc>* the line number at which the XML parsing error occured</haxe_doc>
		</lineNumber>
		<positionAtLine public="1">
			<x path="Int"/>
			<haxe_doc>* the character position in the reported line at which the parsing error occured</haxe_doc>
		</positionAtLine>
		<position public="1">
			<x path="Int"/>
			<haxe_doc>* the character position in the XML string at which the parsing error occured</haxe_doc>
		</position>
		<xml public="1">
			<c path="String"/>
			<haxe_doc>* the invalid XML string</haxe_doc>
		</xml>
		<toString public="1" set="method" line="96"><f a=""><c path="String"/></f></toString>
		<new public="1" set="method" line="76"><f a="message:xml:position">
	<c path="String"/>
	<c path="String"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="haxe.xml.Parser" params="" file="D:\HaxeToolkit\haxe\std/haxe/xml/Parser.hx">
		<escapes expr="{
	var h = new haxe.ds.StringMap();
	h.set(&quot;lt&quot;, &quot;&lt;&quot;);
	h.set(&quot;gt&quot;, &quot;&gt;&quot;);
	h.set(&quot;amp&quot;, &quot;&amp;&quot;);
	h.set(&quot;quot&quot;, &quot;\&quot;&quot;);
	h.set(&quot;apos&quot;, &quot;&apos;&quot;);
	h;
}" line="104" static="1">
			<c path="haxe.ds.StringMap"><c path="String"/></c>
			<meta><m n=":value"><e><![CDATA[{
	var h = new haxe.ds.StringMap();
	h.set("lt", "<");
	h.set("gt", ">");
	h.set("amp", "&");
	h.set("quot", "\"");
	h.set("apos", "'");
	h;
}]]></e></m></meta>
		</escapes>
		<parse public="1" set="method" line="119" static="1">
			<f a="str:?strict" v=":false">
				<c path="String"/>
				<x path="Bool"/>
				<c path="Xml"/>
			</f>
			<meta><m n=":value"><e>{ strict : false }</e></m></meta>
			<haxe_doc>* Parses the String into an XML Document. Set strict parsing to true in order to enable a strict check of XML attributes and entities.
	 *
	 * @throws haxe.xml.XmlParserException</haxe_doc>
		</parse>
		<doParse set="method" line="126" static="1">
			<f a="str:strict:?p:?parent" v="::0:">
				<c path="String"/>
				<x path="Bool"/>
				<x path="Int"/>
				<c path="Xml"/>
				<x path="Int"/>
			</f>
			<meta><m n=":value"><e>{ p : 0 }</e></m></meta>
		</doParse>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="haxe.zip.Compress" params="" file="D:\HaxeToolkit\haxe\std/neko/_std/haxe/zip/Compress.hx">
		<run public="1" set="method" line="45" static="1"><f a="s:level">
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<c path="haxe.io.Bytes"/>
</f></run>
		<_deflate_init expr="neko.Lib.load(&quot;zlib&quot;, &quot;deflate_init&quot;, 1)" line="56" static="1">
			<f a="">
				<x path="Int"/>
				<unknown/>
			</f>
			<meta><m n=":value"><e>neko.Lib.load("zlib", "deflate_init", 1)</e></m></meta>
		</_deflate_init>
		<_deflate_bound expr="neko.Lib.load(&quot;zlib&quot;, &quot;deflate_bound&quot;, 2)" line="57" static="1">
			<f a=":">
				<d/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":value"><e>neko.Lib.load("zlib", "deflate_bound", 2)</e></m></meta>
		</_deflate_bound>
		<_deflate_buffer expr="neko.Lib.load(&quot;zlib&quot;, &quot;deflate_buffer&quot;, 5)" line="58" static="1">
			<f a="::::">
				<d/>
				<t path="haxe.io.BytesData"/>
				<x path="Int"/>
				<t path="haxe.io.BytesData"/>
				<x path="Int"/>
				<a>
					<write><x path="Int"/></write>
					<read><x path="Int"/></read>
					<done><x path="Bool"/></done>
				</a>
			</f>
			<meta><m n=":value"><e>neko.Lib.load("zlib", "deflate_buffer", 5)</e></m></meta>
		</_deflate_buffer>
		<_deflate_end expr="neko.Lib.load(&quot;zlib&quot;, &quot;deflate_end&quot;, 1)" line="59" static="1">
			<f a="">
				<d/>
				<unknown/>
			</f>
			<meta><m n=":value"><e>neko.Lib.load("zlib", "deflate_end", 1)</e></m></meta>
		</_deflate_end>
		<_set_flush_mode expr="neko.Lib.load(&quot;zlib&quot;, &quot;set_flush_mode&quot;, 2)" line="60" static="1">
			<f a=":">
				<d/>
				<unknown/>
				<unknown/>
			</f>
			<meta><m n=":value"><e>neko.Lib.load("zlib", "set_flush_mode", 2)</e></m></meta>
		</_set_flush_mode>
		<s><d/></s>
		<execute public="1" set="method" line="33"><f a="src:srcPos:dst:dstPos">
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<a>
		<write><x path="Int"/></write>
		<read><x path="Int"/></read>
		<done><x path="Bool"/></done>
	</a>
</f></execute>
		<setFlushMode public="1" set="method" line="37">
			<f a="f">
				<e path="haxe.zip.FlushMode"/>
				<x path="Void"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</setFlushMode>
		<close public="1" set="method" line="41"><f a=""><x path="Void"/></f></close>
		<new public="1" set="method" line="29"><f a="level">
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<enum path="haxe.zip.FlushMode" params="" file="D:\HaxeToolkit\haxe\std/haxe/zip/FlushMode.hx">
		<NO/>
		<SYNC/>
		<FULL/>
		<FINISH/>
		<BLOCK/>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<class path="haxe.zip.Uncompress" params="" file="D:\HaxeToolkit\haxe\std/neko/_std/haxe/zip/Uncompress.hx">
		<run public="1" set="method" line="45" static="1"><f a="src:?bufsize">
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<c path="haxe.io.Bytes"/>
</f></run>
		<_inflate_init expr="neko.Lib.load(&quot;zlib&quot;, &quot;inflate_init&quot;, 1)" line="63" static="1">
			<f a="">
				<t path="Null"><x path="Int"/></t>
				<unknown/>
			</f>
			<meta><m n=":value"><e>neko.Lib.load("zlib", "inflate_init", 1)</e></m></meta>
		</_inflate_init>
		<_inflate_buffer expr="neko.Lib.load(&quot;zlib&quot;, &quot;inflate_buffer&quot;, 5)" line="64" static="1">
			<f a="::::">
				<d/>
				<t path="haxe.io.BytesData"/>
				<x path="Int"/>
				<t path="haxe.io.BytesData"/>
				<x path="Int"/>
				<a>
					<write><x path="Int"/></write>
					<read><x path="Int"/></read>
					<done><x path="Bool"/></done>
				</a>
			</f>
			<meta><m n=":value"><e>neko.Lib.load("zlib", "inflate_buffer", 5)</e></m></meta>
		</_inflate_buffer>
		<_inflate_end expr="neko.Lib.load(&quot;zlib&quot;, &quot;inflate_end&quot;, 1)" line="65" static="1">
			<f a="">
				<d/>
				<unknown/>
			</f>
			<meta><m n=":value"><e>neko.Lib.load("zlib", "inflate_end", 1)</e></m></meta>
		</_inflate_end>
		<_set_flush_mode expr="neko.Lib.load(&quot;zlib&quot;, &quot;set_flush_mode&quot;, 2)" line="66" static="1">
			<f a=":">
				<d/>
				<unknown/>
				<unknown/>
			</f>
			<meta><m n=":value"><e>neko.Lib.load("zlib", "set_flush_mode", 2)</e></m></meta>
		</_set_flush_mode>
		<s><d/></s>
		<execute public="1" set="method" line="33"><f a="src:srcPos:dst:dstPos">
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<a>
		<write><x path="Int"/></write>
		<read><x path="Int"/></read>
		<done><x path="Bool"/></done>
	</a>
</f></execute>
		<setFlushMode public="1" set="method" line="37">
			<f a="f">
				<e path="haxe.zip.FlushMode"/>
				<x path="Void"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</setFlushMode>
		<close public="1" set="method" line="41"><f a=""><x path="Void"/></f></close>
		<new public="1" set="method" line="29"><f a="?windowBits">
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<class path="helix.GameTime" params="" file="src/helix/GameTime.hx">
		<totalGameTimeSeconds public="1" set="null" expr="0" line="11" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</totalGameTimeSeconds>
		<update public="1" set="method" line="13" static="1"><f a="elapsedSeconds">
	<x path="Float"/>
	<x path="Void"/>
</f></update>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<typedef path="helix.TotalGameTime" params="" file="src/helix/GameTime.hx" module="helix.GameTime"><x path="Float"/></typedef>
	<class path="helix.core.HelixSprite" params="" file="src/helix/core/HelixSprite.hx">
		<extends path="flixel.FlxSprite"/>
		<DEFAULT_FONT_SIZE get="inline" set="null" expr="16" line="18" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>16</e></m></meta>
		</DEFAULT_FONT_SIZE>
		<keyboardMoveSpeed public="1" set="null" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</keyboardMoveSpeed>
		<componentVelocities expr="new Map&lt;String,FlxPoint&gt;()">
			<x path="Map">
				<c path="String"/>
				<c path="flixel.math.FlxPoint"/>
			</x>
			<meta><m n=":value"><e><![CDATA[new Map<String,FlxPoint>()]]></e></m></meta>
		</componentVelocities>
		<collisionTargets expr="new Array&lt;FlxBasic&gt;()">
			<c path="Array"><c path="flixel.FlxBasic"/></c>
			<meta><m n=":value"><e><![CDATA[new Array<FlxBasic>()]]></e></m></meta>
		</collisionTargets>
		<collideAndResolveTargets expr="new Array&lt;FlxBasic&gt;()">
			<c path="Array"><c path="flixel.FlxBasic"/></c>
			<meta><m n=":value"><e><![CDATA[new Array<FlxBasic>()]]></e></m></meta>
		</collideAndResolveTargets>
		<collisionCallbacks expr="new Map&lt;FlxBasic,Dynamic -&gt; Dynamic&gt;()">
			<x path="Map">
				<c path="flixel.FlxBasic"/>
				<f a=":">
					<d/>
					<d/>
					<x path="Void"/>
				</f>
			</x>
			<meta><m n=":value"><e><![CDATA[new Map<FlxBasic,Dynamic -> Dynamic>()]]></e></m></meta>
		</collisionCallbacks>
		<textField><c path="flixel.text.FlxText"/></textField>
		<update public="1" set="method" line="54" override="1"><f a="elapsedSeconds">
	<x path="Float"/>
	<x path="Void"/>
</f></update>
		<hasComponentVelocity public="1" set="method" line="111"><f a="name">
	<c path="String"/>
	<x path="Bool"/>
</f></hasComponentVelocity>
		<destroy public="1" set="method" line="116" override="1"><f a=""><x path="Void"/></f></destroy>
		<collide public="1" set="method" line="130"><f a="objectOrGroup:callback">
	<c path="flixel.FlxBasic"/>
	<f a=":">
		<d/>
		<d/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></collide>
		<collideResolve public="1" set="method" line="139">
			<f a="objectOrGroup:?callback" v=":null">
				<c path="flixel.FlxBasic"/>
				<f a=":">
					<d/>
					<d/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ callback : null }</e></m></meta>
		</collideResolve>
		<collisionImmovable public="1" set="method" line="146"><f a=""><c path="helix.core.HelixSprite"/></f></collisionImmovable>
		<flicker public="1" set="method" line="152"><f a="durationSeconds">
	<x path="Float"/>
	<c path="helix.core.HelixSprite"/>
</f></flicker>
		<onClick public="1" set="method" line="158"><f a="callback">
	<f a=""><x path="Void"/></f>
	<c path="helix.core.HelixSprite"/>
</f></onClick>
		<move public="1" set="method" line="167"><f a="x:y">
	<x path="Float"/>
	<x path="Float"/>
	<c path="helix.core.HelixSprite"/>
</f></move>
		<moveWithKeyboard public="1" set="method" line="174"><f a="keyboardMoveSpeed">
	<x path="Float"/>
	<c path="helix.core.HelixSprite"/>
</f></moveWithKeyboard>
		<setComponentVelocity set="method" line="180"><f a="name:vx:vy">
	<c path="String"/>
	<x path="Float"/>
	<x path="Float"/>
	<c path="helix.core.HelixSprite"/>
</f></setComponentVelocity>
		<trackWithCamera public="1" set="method" line="203"><f a=""><c path="helix.core.HelixSprite"/></f></trackWithCamera>
		<text public="1" set="method" line="210"><f a="message:?colour">
	<c path="String"/>
	<x path="flixel.util.FlxColor"/>
	<c path="helix.core.HelixSprite"/>
</f></text>
		<new public="1" set="method" line="34">
			<f a="?filename:?colourDetails">
				<c path="String"/>
				<t path="helix.core.ColourDetails"/>
				<x path="Void"/>
			</f>
			<haxe_doc>*  Creates a new sprite with the given image. If you just want to use a coloured
     *  rectangle, pass in null for the filename and fill out the other parameters.</haxe_doc>
		</new>
	</class>
	<typedef path="helix.core.ColourDetails" params="" file="src/helix/core/HelixSprite.hx" module="helix.core.HelixSprite"><a>
	<width><x path="Int"/></width>
	<height><x path="Int"/></height>
	<colour><x path="flixel.util.FlxColor"/></colour>
</a></typedef>
	<class path="helix.core.HelixState" params="" file="src/helix/core/HelixState.hx">
		<extends path="flixel.FlxState"/>
		<current public="1" set="null" static="1"><c path="helix.core.HelixState"/></current>
		<width public="1" get="accessor" set="null"><x path="Int"/></width>
		<height public="1" get="accessor" set="null"><x path="Int"/></height>
		<movesToKeyboard public="1"><c path="helix.core.HelixSprite"/></movesToKeyboard>
		<update public="1" set="method" line="27" override="1"><f a="elapsedSeconds">
	<x path="Float"/>
	<x path="Void"/>
</f></update>
		<setCollisionBounds public="1" set="method" line="35"><f a="x:y:width:height">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></setCollisionBounds>
		<isKeyPressed public="1" set="method" line="40"><f a="keyCode">
	<x path="Int"/>
	<x path="Bool"/>
</f></isKeyPressed>
		<wasJustPressed public="1" set="method" line="45"><f a="keyCode">
	<x path="Int"/>
	<x path="Bool"/>
</f></wasJustPressed>
		<get_width set="method" line="50"><f a=""><x path="Int"/></f></get_width>
		<get_height set="method" line="55"><f a=""><x path="Int"/></f></get_height>
		<new public="1" set="method" line="21"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="helix.core.HelixText" params="" file="src/helix/core/HelixText.hx">
		<extends path="flixel.text.FlxText"/>
		<DEFAULT_FIELD_WIDTH get="inline" set="null" expr="0" line="8" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</DEFAULT_FIELD_WIDTH>
		<defaultFont public="1" expr="&quot;&quot;" line="9" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>""</e></m></meta>
		</defaultFont>
		<fontSize public="1" get="accessor" set="null"><x path="Int"/></fontSize>
		<onClick public="1" set="method" line="24">
			<f a="callback">
				<f a=""><x path="Void"/></f>
				<c path="helix.core.HelixText"/>
			</f>
			<haxe_doc>A callback to invoke when the user clicks on this text.
    NB: the bounding box of the text is used (it's not pixel-perfect).</haxe_doc>
		</onClick>
		<get_fontSize public="1" set="method" line="34">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Alias for "size."</haxe_doc>
		</get_fontSize>
		<new public="1" set="method" line="13"><f a="x:y:content:fontSize">
	<x path="Int"/>
	<x path="Int"/>
	<c path="String"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="helix.data.Config" params="" file="src/helix/data/Config.hx">
		<values public="1" static="1"><x path="Map">
	<c path="String"/>
	<x path="Any"/>
</x></values>
		<get public="1" params="Any" set="method" line="14" static="1"><f a="key">
	<c path="String"/>
	<c path="get.Any"/>
</f></get>
		<getBool public="1" set="method" line="25" static="1"><f a="key">
	<c path="String"/>
	<x path="Bool"/>
</f></getBool>
		<getInt public="1" set="method" line="36" static="1"><f a="key">
	<c path="String"/>
	<x path="Int"/>
</f></getInt>
		<getFloat public="1" set="method" line="47" static="1"><f a="key">
	<c path="String"/>
	<x path="Float"/>
</f></getFloat>
		<getString public="1" set="method" line="58" static="1"><f a="key">
	<c path="String"/>
	<c path="String"/>
</f></getString>
		<set public="1" set="method" line="69" static="1"><f a="key:value">
	<c path="String"/>
	<x path="Any"/>
	<x path="Void"/>
</f></set>
		<loadAndCacheJson set="method" line="79" static="1"><f a=""><x path="Void"/></f></loadAndCacheJson>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="helix.random.IntervalRandomTimer" params="" file="src/helix/random/IntervalRandomTimer.hx">
		<minIntervalSeconds expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</minIntervalSeconds>
		<maxIntervalSeconds expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</maxIntervalSeconds>
		<random expr="new FlxRandom()">
			<c path="flixel.math.FlxRandom"/>
			<meta><m n=":value"><e>new FlxRandom()</e></m></meta>
		</random>
		<callback><f a=""><x path="Void"/></f></callback>
		<createdOn><t path="helix.TotalGameTime"/></createdOn>
		<nextCallbackTime><t path="helix.TotalGameTime"/></nextCallbackTime>
		<update public="1" set="method" line="28"><f a="elapsedSeconds">
	<x path="Float"/>
	<x path="Void"/>
</f></update>
		<pickNextInterval set="method" line="37"><f a=""><x path="Void"/></f></pickNextInterval>
		<new public="1" set="method" line="18"><f a="minIntervalSeconds:maxIntervalSeconds:callback">
	<x path="Float"/>
	<x path="Float"/>
	<f a=""><x path="Void"/></f>
	<x path="Void"/>
</f></new>
	</class>
	<class path="lime.AssetCache" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/Assets.hx" module="lime.Assets">
		<audio public="1"><x path="Map">
	<c path="String"/>
	<c path="lime.audio.AudioBuffer"/>
</x></audio>
		<enabled public="1" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</enabled>
		<image public="1"><x path="Map">
	<c path="String"/>
	<c path="lime.graphics.Image"/>
</x></image>
		<font public="1"><x path="Map">
	<c path="String"/>
	<d/>
</x></font>
		<version public="1"><x path="Int"/></version>
		<clear public="1" set="method" line="1068">
			<f a="?prefix" v="null">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ prefix : null }</e></m></meta>
		</clear>
		<new public="1" set="method" line="1058"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="lime.app.Event_Void_Void" params="T" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/audio/AudioSource.hx">
		<canceled public="1" set="null"><x path="Bool"/></canceled>
		<__repeat public="1">
			<c path="Array"><x path="Bool"/></c>
			<meta>
				<m n=":noCompletion"/>
				<m n=":dox"><e>hide</e></m>
			</meta>
		</__repeat>
		<__priorities><c path="Array"><x path="Int"/></c></__priorities>
		<add public="1" set="method" line="38">
			<f a="listener:?once:?priority" v=":false:0">
				<c path="lime.app.Event_Void_Void.T"/>
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ priority : 0, once : false }</e></m></meta>
		</add>
		<cancel public="1" set="method" line="209"><f a=""><x path="Void"/></f></cancel>
		<has public="1" set="method" line="247"><f a="listener">
	<c path="lime.app.Event_Void_Void.T"/>
	<x path="Bool"/>
</f></has>
		<remove public="1" set="method" line="262"><f a="listener">
	<c path="lime.app.Event_Void_Void.T"/>
	<x path="Void"/>
</f></remove>
		<__listeners public="1"><c path="Array"><f a=""><x path="Void"/></f></c></__listeners>
		<dispatch public="1" set="method" line="30"><f a=""><x path="Void"/></f></dispatch>
		<new public="1" set="method" line="26"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":dox"><e>hide</e></m>
			<m n=":noCompletion"/>
		</meta>
	</class>
	<class path="lime.Assets" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/Assets.hx">
		<cache public="1" expr="new AssetCache()" line="40" static="1">
			<c path="lime.AssetCache"/>
			<meta><m n=":value"><e>new AssetCache()</e></m></meta>
		</cache>
		<libraries public="1" set="null" expr="new Map&lt;String,AssetLibrary&gt;()" line="41" static="1">
			<x path="Map">
				<c path="String"/>
				<c path="lime.AssetLibrary"/>
			</x>
			<meta><m n=":value"><e><![CDATA[new Map<String,AssetLibrary>()]]></e></m></meta>
		</libraries>
		<onChange public="1" expr="new Event&lt;Void&gt;()" line="42" static="1">
			<c path="lime.app.Event_Void_Void"><f a=""><x path="Void"/></f></c>
			<meta><m n=":value"><e><![CDATA[new Event<Void>()]]></e></m></meta>
		</onChange>
		<initialized expr="false" line="44" static="1">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</initialized>
		<exists public="1" set="method" line="47" static="1">
			<f a="id:?type" v=":null">
				<c path="String"/>
				<x path="lime.AssetType"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":value"><e>{ type : null }</e></m></meta>
		</exists>
		<getAudioBuffer public="1" set="method" line="82" static="1">
			<f a="id:?useCache" v=":true">
				<c path="String"/>
				<x path="Bool"/>
				<c path="lime.audio.AudioBuffer"/>
			</f>
			<meta><m n=":value"><e>{ useCache : true }</e></m></meta>
			<haxe_doc>* Gets an instance of an embedded sound
	 * @usage		var sound = Assets.getSound("sound.wav");
	 * @param	id		The ID or asset path for the sound
	 * @return		A new Sound object</haxe_doc>
		</getAudioBuffer>
		<getBytes public="1" set="method" line="151" static="1">
			<f a="id">
				<c path="String"/>
				<c path="lime.utils.Bytes"/>
			</f>
			<haxe_doc>* Gets an instance of an embedded binary asset
	 * @usage		var bytes = Assets.getBytes("file.zip");
	 * @param	id		The ID or asset path for the file
	 * @return		A new Bytes object</haxe_doc>
		</getBytes>
		<getFont public="1" set="method" line="200" static="1">
			<f a="id:?useCache" v=":true">
				<c path="String"/>
				<x path="Bool"/>
				<c path="lime.text.Font"/>
			</f>
			<meta><m n=":value"><e>{ useCache : true }</e></m></meta>
			<haxe_doc>* Gets an instance of an embedded font
	 * @usage		var fontName = Assets.getFont("font.ttf").fontName;
	 * @param	id		The ID or asset path for the font
	 * @return		A new Font object</haxe_doc>
		</getFont>
		<getImage public="1" set="method" line="264" static="1">
			<f a="id:?useCache" v=":true">
				<c path="String"/>
				<x path="Bool"/>
				<c path="lime.graphics.Image"/>
			</f>
			<meta><m n=":value"><e>{ useCache : true }</e></m></meta>
			<haxe_doc>* Gets an instance of an embedded bitmap
	 * @usage		var bitmap = new Bitmap(Assets.getBitmapData("image.jpg"));
	 * @param	id		The ID or asset path for the bitmap
	 * @param	useCache		(Optional) Whether to use BitmapData from the cache(Default: true)
	 * @return		A new BitmapData object</haxe_doc>
		</getImage>
		<getLibrary set="method" line="327" static="1"><f a="name">
	<c path="String"/>
	<c path="lime.AssetLibrary"/>
</f></getLibrary>
		<getPath public="1" set="method" line="346" static="1">
			<f a="id">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>* Gets the file path (if available) for an asset
	 * @usage		var path = Assets.getPath("image.jpg");
	 * @param	id		The ID or asset path for the asset
	 * @return		The path to the asset (or null)</haxe_doc>
		</getPath>
		<getText public="1" set="method" line="387" static="1">
			<f a="id">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>* Gets an instance of an embedded text asset
	 * @usage		var text = Assets.getText("text.txt");
	 * @param	id		The ID or asset path for the file
	 * @return		A new String object</haxe_doc>
		</getText>
		<initialize set="method" line="430" static="1"><f a=""><x path="Void"/></f></initialize>
		<isLocal public="1" set="method" line="447" static="1">
			<f a="id:?type:?useCache" v=":null:true">
				<c path="String"/>
				<x path="lime.AssetType"/>
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":value"><e>{ useCache : true, type : null }</e></m></meta>
		</isLocal>
		<isValidAudio set="method" line="492" static="1"><f a="buffer">
	<c path="lime.audio.AudioBuffer"/>
	<x path="Bool"/>
</f></isValidAudio>
		<isValidImage set="method" line="508" static="1"><f a="buffer">
	<c path="lime.graphics.Image"/>
	<x path="Bool"/>
</f></isValidImage>
		<list public="1" set="method" line="537" static="1">
			<f a="?type" v="null">
				<x path="lime.AssetType"/>
				<c path="Array"><c path="String"/></c>
			</f>
			<meta><m n=":value"><e>{ type : null }</e></m></meta>
		</list>
		<loadAudioBuffer public="1" set="method" line="560" static="1">
			<f a="id:?useCache" v=":true">
				<c path="String"/>
				<x path="Bool"/>
				<c path="lime.app.Future"><c path="lime.audio.AudioBuffer"/></c>
			</f>
			<meta><m n=":value"><e>{ useCache : true }</e></m></meta>
		</loadAudioBuffer>
		<loadBytes public="1" set="method" line="618" static="1"><f a="id">
	<c path="String"/>
	<c path="lime.app.Future"><c path="lime.utils.Bytes"/></c>
</f></loadBytes>
		<loadFont public="1" set="method" line="655" static="1"><f a="id">
	<c path="String"/>
	<c path="lime.app.Future"><c path="lime.text.Font"/></c>
</f></loadFont>
		<loadImage public="1" set="method" line="692" static="1">
			<f a="id:?useCache" v=":true">
				<c path="String"/>
				<x path="Bool"/>
				<c path="lime.app.Future"><c path="lime.graphics.Image"/></c>
			</f>
			<meta><m n=":value"><e>{ useCache : true }</e></m></meta>
		</loadImage>
		<loadLibrary public="1" set="method" line="750" static="1"><f a="name">
	<c path="String"/>
	<c path="lime.app.Future"><c path="lime.AssetLibrary"/></c>
</f></loadLibrary>
		<loadText public="1" set="method" line="781" static="1"><f a="id">
	<c path="String"/>
	<c path="lime.app.Future"><c path="String"/></c>
</f></loadText>
		<registerLibrary public="1" set="method" line="818" static="1"><f a="name:library">
	<c path="String"/>
	<c path="lime.AssetLibrary"/>
	<x path="Void"/>
</f></registerLibrary>
		<unloadLibrary public="1" set="method" line="845" static="1"><f a="name">
	<c path="String"/>
	<x path="Void"/>
</f></unloadLibrary>
		<library_onChange set="method" line="875" static="1"><f a=""><x path="Void"/></f></library_onChange>
		<haxe_doc><![CDATA[* <p>The Assets class provides a cross-platform interface to access 
 * embedded images, fonts, sounds and other resource files.</p>
 * 
 * <p>The contents are populated automatically when an application
 * is compiled using the Lime command-line tools, based on the
 * contents of the *.xml project file.</p>
 * 
 * <p>For most platforms, the assets are included in the same directory
 * or package as the application, and the paths are handled
 * automatically. For web content, the assets are preloaded before
 * the start of the rest of the application. You can customize the 
 * preloader by extending the <code>NMEPreloader</code> class,
 * and specifying a custom preloader using <window preloader="" />
 * in the project file.</p>]]></haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":access"><e>lime.AssetLibrary</e></m>
		</meta>
	</class>
	<class path="lime.AssetLibrary" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/Assets.hx" module="lime.Assets">
		<onChange public="1" expr="new Event&lt;Void&gt;()">
			<c path="lime.app.Event_Void_Void"><f a=""><x path="Void"/></f></c>
			<meta><m n=":value"><e><![CDATA[new Event<Void>()]]></e></m></meta>
		</onChange>
		<exists public="1" set="method" line="899"><f a="id:type">
	<c path="String"/>
	<c path="String"/>
	<x path="Bool"/>
</f></exists>
		<getAudioBuffer public="1" set="method" line="906"><f a="id">
	<c path="String"/>
	<c path="lime.audio.AudioBuffer"/>
</f></getAudioBuffer>
		<getBytes public="1" set="method" line="913"><f a="id">
	<c path="String"/>
	<c path="lime.utils.Bytes"/>
</f></getBytes>
		<getFont public="1" set="method" line="920"><f a="id">
	<c path="String"/>
	<c path="lime.text.Font"/>
</f></getFont>
		<getImage public="1" set="method" line="927"><f a="id">
	<c path="String"/>
	<c path="lime.graphics.Image"/>
</f></getImage>
		<getPath public="1" set="method" line="934"><f a="id">
	<c path="String"/>
	<c path="String"/>
</f></getPath>
		<getText public="1" set="method" line="941"><f a="id">
	<c path="String"/>
	<c path="String"/>
</f></getText>
		<isLocal public="1" set="method" line="966"><f a="id:type">
	<c path="String"/>
	<c path="String"/>
	<x path="Bool"/>
</f></isLocal>
		<list public="1" set="method" line="973"><f a="type">
	<c path="String"/>
	<c path="Array"><c path="String"/></c>
</f></list>
		<load set="method" line="980"><f a=""><c path="lime.app.Future"><c path="lime.AssetLibrary"/></c></f></load>
		<loadAudioBuffer public="1" set="method" line="987"><f a="id">
	<c path="String"/>
	<c path="lime.app.Future"><c path="lime.audio.AudioBuffer"/></c>
</f></loadAudioBuffer>
		<loadBytes public="1" set="method" line="994"><f a="id">
	<c path="String"/>
	<c path="lime.app.Future"><c path="lime.utils.Bytes"/></c>
</f></loadBytes>
		<loadFont public="1" set="method" line="1001"><f a="id">
	<c path="String"/>
	<c path="lime.app.Future"><c path="lime.text.Font"/></c>
</f></loadFont>
		<loadImage public="1" set="method" line="1008"><f a="id">
	<c path="String"/>
	<c path="lime.app.Future"><c path="lime.graphics.Image"/></c>
</f></loadImage>
		<loadText public="1" set="method" line="1015"><f a="id">
	<c path="String"/>
	<c path="lime.app.Future"><c path="String"/></c>
</f></loadText>
		<unload public="1" set="method" line="1038"><f a=""><x path="Void"/></f></unload>
		<new public="1" set="method" line="892"><f a=""><x path="Void"/></f></new>
	</class>
	<abstract path="lime.AssetType" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/Assets.hx" module="lime.Assets">
		<this><c path="String"/></this>
		<meta><m n=":enum"/></meta>
		<impl><class path="lime._Assets.AssetType_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/Assets.hx" private="1" module="lime.Assets" extern="1">
	<BINARY public="1" get="inline" set="null" expr="cast &quot;BINARY&quot;" line="1538" static="1">
		<x path="lime.AssetType"/>
		<meta>
			<m n=":value"><e>cast "BINARY"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</BINARY>
	<FONT public="1" get="inline" set="null" expr="cast &quot;FONT&quot;" line="1539" static="1">
		<x path="lime.AssetType"/>
		<meta>
			<m n=":value"><e>cast "FONT"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</FONT>
	<IMAGE public="1" get="inline" set="null" expr="cast &quot;IMAGE&quot;" line="1540" static="1">
		<x path="lime.AssetType"/>
		<meta>
			<m n=":value"><e>cast "IMAGE"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</IMAGE>
	<MUSIC public="1" get="inline" set="null" expr="cast &quot;MUSIC&quot;" line="1541" static="1">
		<x path="lime.AssetType"/>
		<meta>
			<m n=":value"><e>cast "MUSIC"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</MUSIC>
	<SOUND public="1" get="inline" set="null" expr="cast &quot;SOUND&quot;" line="1542" static="1">
		<x path="lime.AssetType"/>
		<meta>
			<m n=":value"><e>cast "SOUND"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</SOUND>
	<TEMPLATE public="1" get="inline" set="null" expr="cast &quot;TEMPLATE&quot;" line="1543" static="1">
		<x path="lime.AssetType"/>
		<meta>
			<m n=":value"><e>cast "TEMPLATE"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</TEMPLATE>
	<TEXT public="1" get="inline" set="null" expr="cast &quot;TEXT&quot;" line="1544" static="1">
		<x path="lime.AssetType"/>
		<meta>
			<m n=":value"><e>cast "TEXT"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</TEXT>
	<meta>
		<m n=":final"/>
		<m n=":enum"/>
	</meta>
</class></impl>
	</abstract>
	<class path="lime._Assets.AssetType_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/Assets.hx" private="1" module="lime.Assets" extern="1">
		<BINARY public="1" get="inline" set="null" expr="cast &quot;BINARY&quot;" line="1538" static="1">
			<x path="lime.AssetType"/>
			<meta>
				<m n=":value"><e>cast "BINARY"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</BINARY>
		<FONT public="1" get="inline" set="null" expr="cast &quot;FONT&quot;" line="1539" static="1">
			<x path="lime.AssetType"/>
			<meta>
				<m n=":value"><e>cast "FONT"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</FONT>
		<IMAGE public="1" get="inline" set="null" expr="cast &quot;IMAGE&quot;" line="1540" static="1">
			<x path="lime.AssetType"/>
			<meta>
				<m n=":value"><e>cast "IMAGE"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</IMAGE>
		<MUSIC public="1" get="inline" set="null" expr="cast &quot;MUSIC&quot;" line="1541" static="1">
			<x path="lime.AssetType"/>
			<meta>
				<m n=":value"><e>cast "MUSIC"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</MUSIC>
		<SOUND public="1" get="inline" set="null" expr="cast &quot;SOUND&quot;" line="1542" static="1">
			<x path="lime.AssetType"/>
			<meta>
				<m n=":value"><e>cast "SOUND"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</SOUND>
		<TEMPLATE public="1" get="inline" set="null" expr="cast &quot;TEMPLATE&quot;" line="1543" static="1">
			<x path="lime.AssetType"/>
			<meta>
				<m n=":value"><e>cast "TEMPLATE"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</TEMPLATE>
		<TEXT public="1" get="inline" set="null" expr="cast &quot;TEXT&quot;" line="1544" static="1">
			<x path="lime.AssetType"/>
			<meta>
				<m n=":value"><e>cast "TEXT"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</TEXT>
		<meta>
			<m n=":final"/>
			<m n=":enum"/>
		</meta>
	</class>
	<class path="lime.system.CFFI" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/system/CFFI.hx">
		<__moduleNames expr="null" line="12" static="1">
			<x path="Map">
				<c path="String"/>
				<c path="String"/>
			</x>
			<meta>
				<m n=":value"><e>null</e></m>
				<m n=":noCompletion"/>
			</meta>
		</__moduleNames>
		<__loadedNekoAPI static="1"><x path="Bool"/></__loadedNekoAPI>
		<available public="1" static="1"><x path="Bool"/></available>
		<enabled public="1" static="1"><x path="Bool"/></enabled>
		<load public="1" set="method" line="45" static="1">
			<f a="library:method:?args:?lazy" v="::0:false">
				<c path="String"/>
				<c path="String"/>
				<x path="Int"/>
				<x path="Bool"/>
				<d/>
			</f>
			<meta><m n=":value"><e>{ lazy : false, args : 0 }</e></m></meta>
			<haxe_doc>* Tries to load a native CFFI primitive on compatible platforms
	 * @param	library	The name of the native library (such as "lime")
	 * @param	method	The exported primitive method name
	 * @param	args	The number of arguments
	 * @param	lazy	Whether to load the symbol immediately, or to allow lazy loading
	 * @return	The loaded method</haxe_doc>
		</load>
		<loadPrime public="1" set="method" static="1"><f a="library:method:signature:lazy">
	<d/>
	<d/>
	<d/>
	<d/>
	<d/>
</f></loadPrime>
		<__findHaxelib set="method" line="205" static="1"><f a="library">
	<c path="String"/>
	<c path="String"/>
</f></__findHaxelib>
		<__loaderTrace set="method" line="250" static="1"><f a="message">
	<c path="String"/>
	<x path="Void"/>
</f></__loaderTrace>
		<__loadNekoAPI set="method" line="271" static="1"><f a="lazy">
	<x path="Bool"/>
	<x path="Void"/>
</f></__loadNekoAPI>
		<__sysName set="method" line="323" static="1"><f a=""><c path="String"/></f></__sysName>
		<__tryLoad set="method" line="339" static="1"><f a="name:library:func:args">
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
	<x path="Int"/>
	<d/>
</f></__tryLoad>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="sys.io.Process" params="" file="D:\HaxeToolkit\haxe\std/neko/_std/sys/io/Process.hx">
		<_run expr="neko.Lib.load(&quot;std&quot;, &quot;process_run&quot;, 2)" line="122" static="1">
			<f a=":">
				<unknown/>
				<d/>
				<unknown/>
			</f>
			<meta><m n=":value"><e>neko.Lib.load("std", "process_run", 2)</e></m></meta>
		</_run>
		<_close expr="neko.Lib.loadLazy(&quot;std&quot;, &quot;process_close&quot;, 1)" line="125" static="1">
			<f a="">
				<d/>
				<unknown/>
			</f>
			<meta><m n=":value"><e>neko.Lib.loadLazy("std", "process_close", 1)</e></m></meta>
		</_close>
		<p><d/></p>
		<stdout public="1" set="null">
			<c path="haxe.io.Input"/>
			<haxe_doc>Standard output. The output stream where a process writes its output data.</haxe_doc>
		</stdout>
		<stderr public="1" set="null">
			<c path="haxe.io.Input"/>
			<haxe_doc>Standard error. The output stream to output error messages or diagnostics.</haxe_doc>
		</stderr>
		<stdin public="1" set="null">
			<c path="haxe.io.Output"/>
			<haxe_doc>Standard input. The stream data going into a process.</haxe_doc>
		</stdin>
		<close public="1" set="method" line="114">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Close the process handle and release the associated resources.
		All `Process` fields should not be used after `close()` is called.</haxe_doc>
		</close>
		<new public="1" set="method" line="95">
			<f a="cmd:?args">
				<c path="String"/>
				<c path="Array"><c path="String"/></c>
				<x path="Void"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Construct a `Process` object, which run the given command immediately.

		Command arguments can be passed in two ways: 1. using `args`, 2. appending to `cmd` and leaving `args` as `null`.

		 1. When using `args` to pass command arguments, each argument will be automatically quoted, and shell meta-characters will be escaped if needed.
		`cmd` should be an executable name that can be located in the `PATH` environment variable, or a path to an executable.

		 2. When `args` is not given or is `null`, command arguments can be appended to `cmd`. No automatic quoting/escaping will be performed. `cmd` should be formatted exactly as it would be when typed at the command line.
		It can run executables, as well as shell commands that are not executables (e.g. on Windows: `dir`, `cd`, `echo` etc).

		`close()` should be called when the `Process` is no longer used.</haxe_doc>
		</new>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<class path="sys.io._Process.Stdin" params="" file="D:\HaxeToolkit\haxe\std/neko/_std/sys/io/Process.hx" private="1" module="sys.io.Process">
		<extends path="haxe.io.Output"/>
		<_stdin_write expr="neko.Lib.load(&quot;std&quot;, &quot;process_stdin_write&quot;, 4)" line="52" static="1">
			<f a=":::">
				<d/>
				<t path="haxe.io.BytesData"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":value"><e>neko.Lib.load("std", "process_stdin_write", 4)</e></m></meta>
		</_stdin_write>
		<_stdin_close expr="neko.Lib.load(&quot;std&quot;, &quot;process_stdin_close&quot;, 1)" line="53" static="1">
			<f a="">
				<d/>
				<unknown/>
			</f>
			<meta><m n=":value"><e>neko.Lib.load("std", "process_stdin_close", 1)</e></m></meta>
		</_stdin_close>
		<p><d/></p>
		<buf><c path="haxe.io.Bytes"/></buf>
		<close public="1" set="method" line="34" override="1"><f a=""><x path="Void"/></f></close>
		<writeByte public="1" set="method" line="39" override="1"><f a="c">
	<x path="Int"/>
	<x path="Void"/>
</f></writeByte>
		<writeBytes public="1" set="method" line="44" override="1"><f a="buf:pos:len">
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></writeBytes>
		<new public="1" set="method" line="29"><f a="p">
	<unknown/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="sys.io._Process.Stdout" params="" file="D:\HaxeToolkit\haxe\std/neko/_std/sys/io/Process.hx" private="1" module="sys.io.Process">
		<extends path="haxe.io.Input"/>
		<_stdout_read expr="neko.Lib.load(&quot;std&quot;, &quot;process_stdout_read&quot;, 4)" line="83" static="1">
			<f a=":::">
				<d/>
				<t path="haxe.io.BytesData"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":value"><e>neko.Lib.load("std", "process_stdout_read", 4)</e></m></meta>
		</_stdout_read>
		<_stderr_read expr="neko.Lib.load(&quot;std&quot;, &quot;process_stderr_read&quot;, 4)" line="84" static="1">
			<f a=":::">
				<d/>
				<t path="haxe.io.BytesData"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":value"><e>neko.Lib.load("std", "process_stderr_read", 4)</e></m></meta>
		</_stderr_read>
		<p><d/></p>
		<out><x path="Bool"/></out>
		<buf><c path="haxe.io.Bytes"/></buf>
		<readByte public="1" set="method" line="69" override="1"><f a=""><x path="Int"/></f></readByte>
		<readBytes public="1" set="method" line="75"><f a="str:pos:len">
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></readBytes>
		<new public="1" set="method" line="63"><f a="p:out">
	<unknown/>
	<x path="Bool"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="lime._backend.native.NativeApplication" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/_backend/native/NativeApplication.hx">
		<lime_application_create get="inline" set="null" line="627" static="1">
			<f a="config">
				<d/>
				<d/>
			</f>
			<meta><m n=":cffi"/></meta>
		</lime_application_create>
		<lime_application_event_manager_register get="inline" set="null" line="628" static="1">
			<f a="callback:eventObject">
				<d/>
				<d/>
				<x path="Void"/>
			</f>
			<meta><m n=":cffi"/></meta>
		</lime_application_event_manager_register>
		<lime_application_exec get="inline" set="null" line="629" static="1">
			<f a="handle">
				<d/>
				<x path="Int"/>
			</f>
			<meta><m n=":cffi"/></meta>
		</lime_application_exec>
		<lime_application_init get="inline" set="null" line="630" static="1">
			<f a="handle">
				<d/>
				<x path="Void"/>
			</f>
			<meta><m n=":cffi"/></meta>
		</lime_application_init>
		<lime_application_quit get="inline" set="null" line="631" static="1">
			<f a="handle">
				<d/>
				<x path="Int"/>
			</f>
			<meta><m n=":cffi"/></meta>
		</lime_application_quit>
		<lime_application_set_frame_rate get="inline" set="null" line="632" static="1">
			<f a="handle:value">
				<d/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":cffi"/></meta>
		</lime_application_set_frame_rate>
		<lime_application_update get="inline" set="null" line="633" static="1">
			<f a="handle">
				<d/>
				<x path="Bool"/>
			</f>
			<meta><m n=":cffi"/></meta>
		</lime_application_update>
		<lime_drop_event_manager_register get="inline" set="null" line="634" static="1">
			<f a="callback:eventObject">
				<d/>
				<d/>
				<x path="Void"/>
			</f>
			<meta><m n=":cffi"/></meta>
		</lime_drop_event_manager_register>
		<lime_gamepad_event_manager_register get="inline" set="null" line="635" static="1">
			<f a="callback:eventObject">
				<d/>
				<d/>
				<x path="Void"/>
			</f>
			<meta><m n=":cffi"/></meta>
		</lime_gamepad_event_manager_register>
		<lime_joystick_event_manager_register get="inline" set="null" line="636" static="1">
			<f a="callback:eventObject">
				<d/>
				<d/>
				<x path="Void"/>
			</f>
			<meta><m n=":cffi"/></meta>
		</lime_joystick_event_manager_register>
		<lime_key_event_manager_register get="inline" set="null" line="637" static="1">
			<f a="callback:eventObject">
				<d/>
				<d/>
				<x path="Void"/>
			</f>
			<meta><m n=":cffi"/></meta>
		</lime_key_event_manager_register>
		<lime_mouse_event_manager_register get="inline" set="null" line="638" static="1">
			<f a="callback:eventObject">
				<d/>
				<d/>
				<x path="Void"/>
			</f>
			<meta><m n=":cffi"/></meta>
		</lime_mouse_event_manager_register>
		<lime_render_event_manager_register get="inline" set="null" line="639" static="1">
			<f a="callback:eventObject">
				<d/>
				<d/>
				<x path="Void"/>
			</f>
			<meta><m n=":cffi"/></meta>
		</lime_render_event_manager_register>
		<lime_sensor_event_manager_register get="inline" set="null" line="640" static="1">
			<f a="callback:eventObject">
				<d/>
				<d/>
				<x path="Void"/>
			</f>
			<meta><m n=":cffi"/></meta>
		</lime_sensor_event_manager_register>
		<lime_text_event_manager_register get="inline" set="null" line="641" static="1">
			<f a="callback:eventObject">
				<d/>
				<d/>
				<x path="Void"/>
			</f>
			<meta><m n=":cffi"/></meta>
		</lime_text_event_manager_register>
		<lime_touch_event_manager_register get="inline" set="null" line="642" static="1">
			<f a="callback:eventObject">
				<d/>
				<d/>
				<x path="Void"/>
			</f>
			<meta><m n=":cffi"/></meta>
		</lime_touch_event_manager_register>
		<lime_window_event_manager_register get="inline" set="null" line="643" static="1">
			<f a="callback:eventObject">
				<d/>
				<d/>
				<x path="Void"/>
			</f>
			<meta><m n=":cffi"/></meta>
		</lime_window_event_manager_register>
		<cffi_lime_application_create expr="new cpp.Callable&lt;Dynamic&gt;(lime.system.CFFI.load(&quot;lime&quot;, &quot;lime_application_create&quot;, 1, false))" line="627" static="1">
			<x path="cpp.Callable"><f a="">
	<d/>
	<d/>
</f></x>
			<meta><m n=":value"><e><![CDATA[new cpp.Callable<Dynamic>(lime.system.CFFI.load("lime", "lime_application_create", 1, false))]]></e></m></meta>
		</cffi_lime_application_create>
		<cffi_lime_application_event_manager_register expr="new cpp.Callable&lt;Dynamic -&gt; Dynamic&gt;(lime.system.CFFI.load(&quot;lime&quot;, &quot;lime_application_event_manager_register&quot;, 2, false))" line="628" static="1">
			<x path="cpp.Callable"><f a=":">
	<d/>
	<d/>
	<x path="Void"/>
</f></x>
			<meta><m n=":value"><e><![CDATA[new cpp.Callable<Dynamic -> Dynamic>(lime.system.CFFI.load("lime", "lime_application_event_manager_register", 2, false))]]></e></m></meta>
		</cffi_lime_application_event_manager_register>
		<cffi_lime_application_exec expr="new cpp.Callable&lt;Dynamic&gt;(lime.system.CFFI.load(&quot;lime&quot;, &quot;lime_application_exec&quot;, 1, false))" line="629" static="1">
			<x path="cpp.Callable"><f a="">
	<d/>
	<x path="Int"/>
</f></x>
			<meta><m n=":value"><e><![CDATA[new cpp.Callable<Dynamic>(lime.system.CFFI.load("lime", "lime_application_exec", 1, false))]]></e></m></meta>
		</cffi_lime_application_exec>
		<cffi_lime_application_init expr="new cpp.Callable&lt;Dynamic&gt;(lime.system.CFFI.load(&quot;lime&quot;, &quot;lime_application_init&quot;, 1, false))" line="630" static="1">
			<x path="cpp.Callable"><f a="">
	<d/>
	<x path="Void"/>
</f></x>
			<meta><m n=":value"><e><![CDATA[new cpp.Callable<Dynamic>(lime.system.CFFI.load("lime", "lime_application_init", 1, false))]]></e></m></meta>
		</cffi_lime_application_init>
		<cffi_lime_application_quit expr="new cpp.Callable&lt;Dynamic&gt;(lime.system.CFFI.load(&quot;lime&quot;, &quot;lime_application_quit&quot;, 1, false))" line="631" static="1">
			<x path="cpp.Callable"><f a="">
	<d/>
	<x path="Int"/>
</f></x>
			<meta><m n=":value"><e><![CDATA[new cpp.Callable<Dynamic>(lime.system.CFFI.load("lime", "lime_application_quit", 1, false))]]></e></m></meta>
		</cffi_lime_application_quit>
		<cffi_lime_application_set_frame_rate expr="new cpp.Callable&lt;Dynamic -&gt; Float&gt;(lime.system.CFFI.load(&quot;lime&quot;, &quot;lime_application_set_frame_rate&quot;, 2, false))" line="632" static="1">
			<x path="cpp.Callable"><f a=":">
	<d/>
	<x path="Float"/>
	<x path="Void"/>
</f></x>
			<meta><m n=":value"><e><![CDATA[new cpp.Callable<Dynamic -> Float>(lime.system.CFFI.load("lime", "lime_application_set_frame_rate", 2, false))]]></e></m></meta>
		</cffi_lime_application_set_frame_rate>
		<cffi_lime_application_update expr="new cpp.Callable&lt;Dynamic&gt;(lime.system.CFFI.load(&quot;lime&quot;, &quot;lime_application_update&quot;, 1, false))" line="633" static="1">
			<x path="cpp.Callable"><f a="">
	<d/>
	<x path="Bool"/>
</f></x>
			<meta><m n=":value"><e><![CDATA[new cpp.Callable<Dynamic>(lime.system.CFFI.load("lime", "lime_application_update", 1, false))]]></e></m></meta>
		</cffi_lime_application_update>
		<cffi_lime_drop_event_manager_register expr="new cpp.Callable&lt;Dynamic -&gt; Dynamic&gt;(lime.system.CFFI.load(&quot;lime&quot;, &quot;lime_drop_event_manager_register&quot;, 2, false))" line="634" static="1">
			<x path="cpp.Callable"><f a=":">
	<d/>
	<d/>
	<x path="Void"/>
</f></x>
			<meta><m n=":value"><e><![CDATA[new cpp.Callable<Dynamic -> Dynamic>(lime.system.CFFI.load("lime", "lime_drop_event_manager_register", 2, false))]]></e></m></meta>
		</cffi_lime_drop_event_manager_register>
		<cffi_lime_gamepad_event_manager_register expr="new cpp.Callable&lt;Dynamic -&gt; Dynamic&gt;(lime.system.CFFI.load(&quot;lime&quot;, &quot;lime_gamepad_event_manager_register&quot;, 2, false))" line="635" static="1">
			<x path="cpp.Callable"><f a=":">
	<d/>
	<d/>
	<x path="Void"/>
</f></x>
			<meta><m n=":value"><e><![CDATA[new cpp.Callable<Dynamic -> Dynamic>(lime.system.CFFI.load("lime", "lime_gamepad_event_manager_register", 2, false))]]></e></m></meta>
		</cffi_lime_gamepad_event_manager_register>
		<cffi_lime_joystick_event_manager_register expr="new cpp.Callable&lt;Dynamic -&gt; Dynamic&gt;(lime.system.CFFI.load(&quot;lime&quot;, &quot;lime_joystick_event_manager_register&quot;, 2, false))" line="636" static="1">
			<x path="cpp.Callable"><f a=":">
	<d/>
	<d/>
	<x path="Void"/>
</f></x>
			<meta><m n=":value"><e><![CDATA[new cpp.Callable<Dynamic -> Dynamic>(lime.system.CFFI.load("lime", "lime_joystick_event_manager_register", 2, false))]]></e></m></meta>
		</cffi_lime_joystick_event_manager_register>
		<cffi_lime_key_event_manager_register expr="new cpp.Callable&lt;Dynamic -&gt; Dynamic&gt;(lime.system.CFFI.load(&quot;lime&quot;, &quot;lime_key_event_manager_register&quot;, 2, false))" line="637" static="1">
			<x path="cpp.Callable"><f a=":">
	<d/>
	<d/>
	<x path="Void"/>
</f></x>
			<meta><m n=":value"><e><![CDATA[new cpp.Callable<Dynamic -> Dynamic>(lime.system.CFFI.load("lime", "lime_key_event_manager_register", 2, false))]]></e></m></meta>
		</cffi_lime_key_event_manager_register>
		<cffi_lime_mouse_event_manager_register expr="new cpp.Callable&lt;Dynamic -&gt; Dynamic&gt;(lime.system.CFFI.load(&quot;lime&quot;, &quot;lime_mouse_event_manager_register&quot;, 2, false))" line="638" static="1">
			<x path="cpp.Callable"><f a=":">
	<d/>
	<d/>
	<x path="Void"/>
</f></x>
			<meta><m n=":value"><e><![CDATA[new cpp.Callable<Dynamic -> Dynamic>(lime.system.CFFI.load("lime", "lime_mouse_event_manager_register", 2, false))]]></e></m></meta>
		</cffi_lime_mouse_event_manager_register>
		<cffi_lime_render_event_manager_register expr="new cpp.Callable&lt;Dynamic -&gt; Dynamic&gt;(lime.system.CFFI.load(&quot;lime&quot;, &quot;lime_render_event_manager_register&quot;, 2, false))" line="639" static="1">
			<x path="cpp.Callable"><f a=":">
	<d/>
	<d/>
	<x path="Void"/>
</f></x>
			<meta><m n=":value"><e><![CDATA[new cpp.Callable<Dynamic -> Dynamic>(lime.system.CFFI.load("lime", "lime_render_event_manager_register", 2, false))]]></e></m></meta>
		</cffi_lime_render_event_manager_register>
		<cffi_lime_sensor_event_manager_register expr="new cpp.Callable&lt;Dynamic -&gt; Dynamic&gt;(lime.system.CFFI.load(&quot;lime&quot;, &quot;lime_sensor_event_manager_register&quot;, 2, false))" line="640" static="1">
			<x path="cpp.Callable"><f a=":">
	<d/>
	<d/>
	<x path="Void"/>
</f></x>
			<meta><m n=":value"><e><![CDATA[new cpp.Callable<Dynamic -> Dynamic>(lime.system.CFFI.load("lime", "lime_sensor_event_manager_register", 2, false))]]></e></m></meta>
		</cffi_lime_sensor_event_manager_register>
		<cffi_lime_text_event_manager_register expr="new cpp.Callable&lt;Dynamic -&gt; Dynamic&gt;(lime.system.CFFI.load(&quot;lime&quot;, &quot;lime_text_event_manager_register&quot;, 2, false))" line="641" static="1">
			<x path="cpp.Callable"><f a=":">
	<d/>
	<d/>
	<x path="Void"/>
</f></x>
			<meta><m n=":value"><e><![CDATA[new cpp.Callable<Dynamic -> Dynamic>(lime.system.CFFI.load("lime", "lime_text_event_manager_register", 2, false))]]></e></m></meta>
		</cffi_lime_text_event_manager_register>
		<cffi_lime_touch_event_manager_register expr="new cpp.Callable&lt;Dynamic -&gt; Dynamic&gt;(lime.system.CFFI.load(&quot;lime&quot;, &quot;lime_touch_event_manager_register&quot;, 2, false))" line="642" static="1">
			<x path="cpp.Callable"><f a=":">
	<d/>
	<d/>
	<x path="Void"/>
</f></x>
			<meta><m n=":value"><e><![CDATA[new cpp.Callable<Dynamic -> Dynamic>(lime.system.CFFI.load("lime", "lime_touch_event_manager_register", 2, false))]]></e></m></meta>
		</cffi_lime_touch_event_manager_register>
		<cffi_lime_window_event_manager_register expr="new cpp.Callable&lt;Dynamic -&gt; Dynamic&gt;(lime.system.CFFI.load(&quot;lime&quot;, &quot;lime_window_event_manager_register&quot;, 2, false))" line="643" static="1">
			<x path="cpp.Callable"><f a=":">
	<d/>
	<d/>
	<x path="Void"/>
</f></x>
			<meta><m n=":value"><e><![CDATA[new cpp.Callable<Dynamic -> Dynamic>(lime.system.CFFI.load("lime", "lime_window_event_manager_register", 2, false))]]></e></m></meta>
		</cffi_lime_window_event_manager_register>
		<applicationEventInfo expr="new ApplicationEventInfo(UPDATE)">
			<c path="lime._backend.native._NativeApplication.ApplicationEventInfo"/>
			<meta><m n=":value"><e>new ApplicationEventInfo(UPDATE)</e></m></meta>
		</applicationEventInfo>
		<currentTouches expr="new Map&lt;Int,Touch&gt;()">
			<x path="Map">
				<x path="Int"/>
				<c path="lime.ui.Touch"/>
			</x>
			<meta><m n=":value"><e><![CDATA[new Map<Int,Touch>()]]></e></m></meta>
		</currentTouches>
		<dropEventInfo expr="new DropEventInfo()">
			<c path="lime._backend.native._NativeApplication.DropEventInfo"/>
			<meta><m n=":value"><e>new DropEventInfo()</e></m></meta>
		</dropEventInfo>
		<gamepadEventInfo expr="new GamepadEventInfo()">
			<c path="lime._backend.native._NativeApplication.GamepadEventInfo"/>
			<meta><m n=":value"><e>new GamepadEventInfo()</e></m></meta>
		</gamepadEventInfo>
		<joystickEventInfo expr="new JoystickEventInfo()">
			<c path="lime._backend.native._NativeApplication.JoystickEventInfo"/>
			<meta><m n=":value"><e>new JoystickEventInfo()</e></m></meta>
		</joystickEventInfo>
		<keyEventInfo expr="new KeyEventInfo()">
			<c path="lime._backend.native._NativeApplication.KeyEventInfo"/>
			<meta><m n=":value"><e>new KeyEventInfo()</e></m></meta>
		</keyEventInfo>
		<mouseEventInfo expr="new MouseEventInfo()">
			<c path="lime._backend.native._NativeApplication.MouseEventInfo"/>
			<meta><m n=":value"><e>new MouseEventInfo()</e></m></meta>
		</mouseEventInfo>
		<renderEventInfo expr="new RenderEventInfo(RENDER)">
			<c path="lime._backend.native._NativeApplication.RenderEventInfo"/>
			<meta><m n=":value"><e>new RenderEventInfo(RENDER)</e></m></meta>
		</renderEventInfo>
		<sensorEventInfo expr="new SensorEventInfo()">
			<c path="lime._backend.native._NativeApplication.SensorEventInfo"/>
			<meta><m n=":value"><e>new SensorEventInfo()</e></m></meta>
		</sensorEventInfo>
		<textEventInfo expr="new TextEventInfo()">
			<c path="lime._backend.native._NativeApplication.TextEventInfo"/>
			<meta><m n=":value"><e>new TextEventInfo()</e></m></meta>
		</textEventInfo>
		<touchEventInfo expr="new TouchEventInfo()">
			<c path="lime._backend.native._NativeApplication.TouchEventInfo"/>
			<meta><m n=":value"><e>new TouchEventInfo()</e></m></meta>
		</touchEventInfo>
		<unusedTouchesPool expr="new List&lt;Touch&gt;()">
			<c path="List"><c path="lime.ui.Touch"/></c>
			<meta><m n=":value"><e><![CDATA[new List<Touch>()]]></e></m></meta>
		</unusedTouchesPool>
		<windowEventInfo expr="new WindowEventInfo()">
			<c path="lime._backend.native._NativeApplication.WindowEventInfo"/>
			<meta><m n=":value"><e>new WindowEventInfo()</e></m></meta>
		</windowEventInfo>
		<handle public="1"><d/></handle>
		<frameRate><x path="Float"/></frameRate>
		<parent><c path="lime.app.Application"/></parent>
		<create public="1" set="method" line="77"><f a="config">
	<t path="lime.app.Config"/>
	<x path="Void"/>
</f></create>
		<exec public="1" set="method" line="86"><f a=""><x path="Int"/></f></exec>
		<exit public="1" set="method" line="144"><f a=""><x path="Void"/></f></exit>
		<getFrameRate public="1" set="method" line="155"><f a=""><x path="Float"/></f></getFrameRate>
		<handleApplicationEvent set="method" line="162"><f a=""><x path="Void"/></f></handleApplicationEvent>
		<handleDropEvent set="method" line="180"><f a=""><x path="Void"/></f></handleDropEvent>
		<handleGamepadEvent set="method" line="191"><f a=""><x path="Void"/></f></handleGamepadEvent>
		<handleJoystickEvent set="method" line="223"><f a=""><x path="Void"/></f></handleJoystickEvent>
		<handleKeyEvent set="method" line="265"><f a=""><x path="Void"/></f></handleKeyEvent>
		<handleMouseEvent set="method" line="318"><f a=""><x path="Void"/></f></handleMouseEvent>
		<handleRenderEvent set="method" line="352"><f a=""><x path="Void"/></f></handleRenderEvent>
		<handleSensorEvent set="method" line="396"><f a=""><x path="Void"/></f></handleSensorEvent>
		<handleTextEvent set="method" line="409"><f a=""><x path="Void"/></f></handleTextEvent>
		<handleTouchEvent set="method" line="434"><f a=""><x path="Void"/></f></handleTouchEvent>
		<handleWindowEvent set="method" line="504"><f a=""><x path="Void"/></f></handleWindowEvent>
		<setFrameRate public="1" set="method" line="576"><f a="value">
	<x path="Float"/>
	<x path="Float"/>
</f></setFrameRate>
		<updateTimer set="method" line="586"><f a=""><x path="Void"/></f></updateTimer>
		<new public="1" set="method" line="63"><f a="parent">
	<c path="lime.app.Application"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>lime.system.CFFI.build()</e></m>
			<m n=":access"><e>haxe.Timer</e></m>
			<m n=":access"><e>lime._backend.native.NativeRenderer</e></m>
			<m n=":access"><e>lime.app.Application</e></m>
			<m n=":access"><e>lime.graphics.Renderer</e></m>
			<m n=":access"><e>lime.system.Sensor</e></m>
			<m n=":access"><e>lime.ui.Gamepad</e></m>
			<m n=":access"><e>lime.ui.Joystick</e></m>
			<m n=":access"><e>lime.ui.Window</e></m>
		</meta>
	</class>
	<class path="lime._backend.native._NativeApplication.ApplicationEventInfo" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/_backend/native/NativeApplication.hx" private="1" module="lime._backend.native.NativeApplication">
		<deltaTime public="1"><x path="Int"/></deltaTime>
		<type public="1"><x path="lime._backend.native._NativeApplication.ApplicationEventType"/></type>
		<clone public="1" set="method" line="665"><f a=""><c path="lime._backend.native._NativeApplication.ApplicationEventInfo"/></f></clone>
		<new public="1" set="method" line="657">
			<f a="?type:?deltaTime" v="null:0">
				<x path="lime._backend.native._NativeApplication.ApplicationEventType"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ deltaTime : 0, type : null }</e></m></meta>
		</new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<abstract path="lime._backend.native._NativeApplication.ApplicationEventType" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/_backend/native/NativeApplication.hx" private="1" module="lime._backend.native.NativeApplication">
		<this><x path="Int"/></this>
		<meta><m n=":enum"/></meta>
		<impl><class path="lime._backend.native._NativeApplication.ApplicationEventType_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/_backend/native/NativeApplication.hx" private="1" module="lime._backend.native.NativeApplication" extern="1">
	<UPDATE public="1" get="inline" set="null" expr="cast 0" line="677" static="1">
		<x path="lime._backend.native._NativeApplication.ApplicationEventType"/>
		<meta>
			<m n=":value"><e>cast 0</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</UPDATE>
	<EXIT public="1" get="inline" set="null" expr="cast 1" line="678" static="1">
		<x path="lime._backend.native._NativeApplication.ApplicationEventType"/>
		<meta>
			<m n=":value"><e>cast 1</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</EXIT>
	<meta>
		<m n=":final"/>
		<m n=":enum"/>
	</meta>
</class></impl>
	</abstract>
	<class path="lime._backend.native._NativeApplication.ApplicationEventType_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/_backend/native/NativeApplication.hx" private="1" module="lime._backend.native.NativeApplication" extern="1">
		<UPDATE public="1" get="inline" set="null" expr="cast 0" line="677" static="1">
			<x path="lime._backend.native._NativeApplication.ApplicationEventType"/>
			<meta>
				<m n=":value"><e>cast 0</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</UPDATE>
		<EXIT public="1" get="inline" set="null" expr="cast 1" line="678" static="1">
			<x path="lime._backend.native._NativeApplication.ApplicationEventType"/>
			<meta>
				<m n=":value"><e>cast 1</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</EXIT>
		<meta>
			<m n=":final"/>
			<m n=":enum"/>
		</meta>
	</class>
	<class path="lime._backend.native._NativeApplication.DropEventInfo" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/_backend/native/NativeApplication.hx" private="1" module="lime._backend.native.NativeApplication">
		<file public="1"><c path="String"/></file>
		<type public="1"><x path="lime._backend.native._NativeApplication.DropEventType"/></type>
		<clone public="1" set="method" line="698"><f a=""><c path="lime._backend.native._NativeApplication.DropEventInfo"/></f></clone>
		<new public="1" set="method" line="690">
			<f a="?type:?file" v="null:null">
				<x path="lime._backend.native._NativeApplication.DropEventType"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ file : null, type : null }</e></m></meta>
		</new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<abstract path="lime._backend.native._NativeApplication.DropEventType" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/_backend/native/NativeApplication.hx" private="1" module="lime._backend.native.NativeApplication">
		<this><x path="Int"/></this>
		<meta><m n=":enum"/></meta>
		<impl><class path="lime._backend.native._NativeApplication.DropEventType_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/_backend/native/NativeApplication.hx" private="1" module="lime._backend.native.NativeApplication" extern="1">
	<DROP_FILE public="1" get="inline" set="null" expr="cast 0" line="710" static="1">
		<x path="lime._backend.native._NativeApplication.DropEventType"/>
		<meta>
			<m n=":value"><e>cast 0</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</DROP_FILE>
	<meta>
		<m n=":final"/>
		<m n=":enum"/>
	</meta>
</class></impl>
	</abstract>
	<class path="lime._backend.native._NativeApplication.DropEventType_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/_backend/native/NativeApplication.hx" private="1" module="lime._backend.native.NativeApplication" extern="1">
		<DROP_FILE public="1" get="inline" set="null" expr="cast 0" line="710" static="1">
			<x path="lime._backend.native._NativeApplication.DropEventType"/>
			<meta>
				<m n=":value"><e>cast 0</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</DROP_FILE>
		<meta>
			<m n=":final"/>
			<m n=":enum"/>
		</meta>
	</class>
	<class path="lime._backend.native._NativeApplication.GamepadEventInfo" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/_backend/native/NativeApplication.hx" private="1" module="lime._backend.native.NativeApplication">
		<axis public="1"><x path="Int"/></axis>
		<button public="1"><x path="Int"/></button>
		<id public="1"><x path="Int"/></id>
		<type public="1"><x path="lime._backend.native._NativeApplication.GamepadEventType"/></type>
		<value public="1"><x path="Float"/></value>
		<clone public="1" set="method" line="736"><f a=""><c path="lime._backend.native._NativeApplication.GamepadEventInfo"/></f></clone>
		<new public="1" set="method" line="725">
			<f a="?type:?id:?button:?axis:?value" v="null:0:0:0:0">
				<x path="lime._backend.native._NativeApplication.GamepadEventType"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ value : 0, axis : 0, button : 0, id : 0, type : null }</e></m></meta>
		</new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<abstract path="lime._backend.native._NativeApplication.GamepadEventType" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/_backend/native/NativeApplication.hx" private="1" module="lime._backend.native.NativeApplication">
		<this><x path="Int"/></this>
		<meta><m n=":enum"/></meta>
		<impl><class path="lime._backend.native._NativeApplication.GamepadEventType_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/_backend/native/NativeApplication.hx" private="1" module="lime._backend.native.NativeApplication" extern="1">
	<AXIS_MOVE public="1" get="inline" set="null" expr="cast 0" line="748" static="1">
		<x path="lime._backend.native._NativeApplication.GamepadEventType"/>
		<meta>
			<m n=":value"><e>cast 0</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</AXIS_MOVE>
	<BUTTON_DOWN public="1" get="inline" set="null" expr="cast 1" line="749" static="1">
		<x path="lime._backend.native._NativeApplication.GamepadEventType"/>
		<meta>
			<m n=":value"><e>cast 1</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</BUTTON_DOWN>
	<BUTTON_UP public="1" get="inline" set="null" expr="cast 2" line="750" static="1">
		<x path="lime._backend.native._NativeApplication.GamepadEventType"/>
		<meta>
			<m n=":value"><e>cast 2</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</BUTTON_UP>
	<CONNECT public="1" get="inline" set="null" expr="cast 3" line="751" static="1">
		<x path="lime._backend.native._NativeApplication.GamepadEventType"/>
		<meta>
			<m n=":value"><e>cast 3</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</CONNECT>
	<DISCONNECT public="1" get="inline" set="null" expr="cast 4" line="752" static="1">
		<x path="lime._backend.native._NativeApplication.GamepadEventType"/>
		<meta>
			<m n=":value"><e>cast 4</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</DISCONNECT>
	<meta>
		<m n=":final"/>
		<m n=":enum"/>
	</meta>
</class></impl>
	</abstract>
	<class path="lime._backend.native._NativeApplication.GamepadEventType_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/_backend/native/NativeApplication.hx" private="1" module="lime._backend.native.NativeApplication" extern="1">
		<AXIS_MOVE public="1" get="inline" set="null" expr="cast 0" line="748" static="1">
			<x path="lime._backend.native._NativeApplication.GamepadEventType"/>
			<meta>
				<m n=":value"><e>cast 0</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</AXIS_MOVE>
		<BUTTON_DOWN public="1" get="inline" set="null" expr="cast 1" line="749" static="1">
			<x path="lime._backend.native._NativeApplication.GamepadEventType"/>
			<meta>
				<m n=":value"><e>cast 1</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</BUTTON_DOWN>
		<BUTTON_UP public="1" get="inline" set="null" expr="cast 2" line="750" static="1">
			<x path="lime._backend.native._NativeApplication.GamepadEventType"/>
			<meta>
				<m n=":value"><e>cast 2</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</BUTTON_UP>
		<CONNECT public="1" get="inline" set="null" expr="cast 3" line="751" static="1">
			<x path="lime._backend.native._NativeApplication.GamepadEventType"/>
			<meta>
				<m n=":value"><e>cast 3</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</CONNECT>
		<DISCONNECT public="1" get="inline" set="null" expr="cast 4" line="752" static="1">
			<x path="lime._backend.native._NativeApplication.GamepadEventType"/>
			<meta>
				<m n=":value"><e>cast 4</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</DISCONNECT>
		<meta>
			<m n=":final"/>
			<m n=":enum"/>
		</meta>
	</class>
	<class path="lime._backend.native._NativeApplication.JoystickEventInfo" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/_backend/native/NativeApplication.hx" private="1" module="lime._backend.native.NativeApplication">
		<id public="1"><x path="Int"/></id>
		<index public="1"><x path="Int"/></index>
		<type public="1"><x path="lime._backend.native._NativeApplication.JoystickEventType"/></type>
		<value public="1"><x path="Float"/></value>
		<x public="1"><x path="Int"/></x>
		<y public="1"><x path="Int"/></y>
		<clone public="1" set="method" line="780"><f a=""><c path="lime._backend.native._NativeApplication.JoystickEventInfo"/></f></clone>
		<new public="1" set="method" line="768">
			<f a="?type:?id:?index:?value:?x:?y" v="null:0:0:0:0:0">
				<x path="lime._backend.native._NativeApplication.JoystickEventType"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ y : 0, x : 0, value : 0, index : 0, id : 0, type : null }</e></m></meta>
		</new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<abstract path="lime._backend.native._NativeApplication.JoystickEventType" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/_backend/native/NativeApplication.hx" private="1" module="lime._backend.native.NativeApplication">
		<this><x path="Int"/></this>
		<meta><m n=":enum"/></meta>
		<impl><class path="lime._backend.native._NativeApplication.JoystickEventType_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/_backend/native/NativeApplication.hx" private="1" module="lime._backend.native.NativeApplication" extern="1">
	<AXIS_MOVE public="1" get="inline" set="null" expr="cast 0" line="792" static="1">
		<x path="lime._backend.native._NativeApplication.JoystickEventType"/>
		<meta>
			<m n=":value"><e>cast 0</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</AXIS_MOVE>
	<HAT_MOVE public="1" get="inline" set="null" expr="cast 1" line="793" static="1">
		<x path="lime._backend.native._NativeApplication.JoystickEventType"/>
		<meta>
			<m n=":value"><e>cast 1</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</HAT_MOVE>
	<TRACKBALL_MOVE public="1" get="inline" set="null" expr="cast 2" line="794" static="1">
		<x path="lime._backend.native._NativeApplication.JoystickEventType"/>
		<meta>
			<m n=":value"><e>cast 2</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</TRACKBALL_MOVE>
	<BUTTON_DOWN public="1" get="inline" set="null" expr="cast 3" line="795" static="1">
		<x path="lime._backend.native._NativeApplication.JoystickEventType"/>
		<meta>
			<m n=":value"><e>cast 3</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</BUTTON_DOWN>
	<BUTTON_UP public="1" get="inline" set="null" expr="cast 4" line="796" static="1">
		<x path="lime._backend.native._NativeApplication.JoystickEventType"/>
		<meta>
			<m n=":value"><e>cast 4</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</BUTTON_UP>
	<CONNECT public="1" get="inline" set="null" expr="cast 5" line="797" static="1">
		<x path="lime._backend.native._NativeApplication.JoystickEventType"/>
		<meta>
			<m n=":value"><e>cast 5</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</CONNECT>
	<DISCONNECT public="1" get="inline" set="null" expr="cast 6" line="798" static="1">
		<x path="lime._backend.native._NativeApplication.JoystickEventType"/>
		<meta>
			<m n=":value"><e>cast 6</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</DISCONNECT>
	<meta>
		<m n=":final"/>
		<m n=":enum"/>
	</meta>
</class></impl>
	</abstract>
	<class path="lime._backend.native._NativeApplication.JoystickEventType_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/_backend/native/NativeApplication.hx" private="1" module="lime._backend.native.NativeApplication" extern="1">
		<AXIS_MOVE public="1" get="inline" set="null" expr="cast 0" line="792" static="1">
			<x path="lime._backend.native._NativeApplication.JoystickEventType"/>
			<meta>
				<m n=":value"><e>cast 0</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</AXIS_MOVE>
		<HAT_MOVE public="1" get="inline" set="null" expr="cast 1" line="793" static="1">
			<x path="lime._backend.native._NativeApplication.JoystickEventType"/>
			<meta>
				<m n=":value"><e>cast 1</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</HAT_MOVE>
		<TRACKBALL_MOVE public="1" get="inline" set="null" expr="cast 2" line="794" static="1">
			<x path="lime._backend.native._NativeApplication.JoystickEventType"/>
			<meta>
				<m n=":value"><e>cast 2</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</TRACKBALL_MOVE>
		<BUTTON_DOWN public="1" get="inline" set="null" expr="cast 3" line="795" static="1">
			<x path="lime._backend.native._NativeApplication.JoystickEventType"/>
			<meta>
				<m n=":value"><e>cast 3</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</BUTTON_DOWN>
		<BUTTON_UP public="1" get="inline" set="null" expr="cast 4" line="796" static="1">
			<x path="lime._backend.native._NativeApplication.JoystickEventType"/>
			<meta>
				<m n=":value"><e>cast 4</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</BUTTON_UP>
		<CONNECT public="1" get="inline" set="null" expr="cast 5" line="797" static="1">
			<x path="lime._backend.native._NativeApplication.JoystickEventType"/>
			<meta>
				<m n=":value"><e>cast 5</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</CONNECT>
		<DISCONNECT public="1" get="inline" set="null" expr="cast 6" line="798" static="1">
			<x path="lime._backend.native._NativeApplication.JoystickEventType"/>
			<meta>
				<m n=":value"><e>cast 6</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</DISCONNECT>
		<meta>
			<m n=":final"/>
			<m n=":enum"/>
		</meta>
	</class>
	<class path="lime._backend.native._NativeApplication.KeyEventInfo" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/_backend/native/NativeApplication.hx" private="1" module="lime._backend.native.NativeApplication">
		<keyCode public="1"><x path="Int"/></keyCode>
		<modifier public="1"><x path="Int"/></modifier>
		<type public="1"><x path="lime._backend.native._NativeApplication.KeyEventType"/></type>
		<windowID public="1"><x path="Int"/></windowID>
		<clone public="1" set="method" line="822"><f a=""><c path="lime._backend.native._NativeApplication.KeyEventInfo"/></f></clone>
		<new public="1" set="method" line="812">
			<f a="?type:?windowID:?keyCode:?modifier" v="null:0:0:0">
				<x path="lime._backend.native._NativeApplication.KeyEventType"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ modifier : 0, keyCode : 0, windowID : 0, type : null }</e></m></meta>
		</new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<abstract path="lime._backend.native._NativeApplication.KeyEventType" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/_backend/native/NativeApplication.hx" private="1" module="lime._backend.native.NativeApplication">
		<this><x path="Int"/></this>
		<meta><m n=":enum"/></meta>
		<impl><class path="lime._backend.native._NativeApplication.KeyEventType_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/_backend/native/NativeApplication.hx" private="1" module="lime._backend.native.NativeApplication" extern="1">
	<KEY_DOWN public="1" get="inline" set="null" expr="cast 0" line="834" static="1">
		<x path="lime._backend.native._NativeApplication.KeyEventType"/>
		<meta>
			<m n=":value"><e>cast 0</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</KEY_DOWN>
	<KEY_UP public="1" get="inline" set="null" expr="cast 1" line="835" static="1">
		<x path="lime._backend.native._NativeApplication.KeyEventType"/>
		<meta>
			<m n=":value"><e>cast 1</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</KEY_UP>
	<meta>
		<m n=":final"/>
		<m n=":enum"/>
	</meta>
</class></impl>
	</abstract>
	<class path="lime._backend.native._NativeApplication.KeyEventType_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/_backend/native/NativeApplication.hx" private="1" module="lime._backend.native.NativeApplication" extern="1">
		<KEY_DOWN public="1" get="inline" set="null" expr="cast 0" line="834" static="1">
			<x path="lime._backend.native._NativeApplication.KeyEventType"/>
			<meta>
				<m n=":value"><e>cast 0</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</KEY_DOWN>
		<KEY_UP public="1" get="inline" set="null" expr="cast 1" line="835" static="1">
			<x path="lime._backend.native._NativeApplication.KeyEventType"/>
			<meta>
				<m n=":value"><e>cast 1</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</KEY_UP>
		<meta>
			<m n=":final"/>
			<m n=":enum"/>
		</meta>
	</class>
	<class path="lime._backend.native._NativeApplication.MouseEventInfo" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/_backend/native/NativeApplication.hx" private="1" module="lime._backend.native.NativeApplication">
		<button public="1"><x path="Int"/></button>
		<movementX public="1"><x path="Float"/></movementX>
		<movementY public="1"><x path="Float"/></movementY>
		<type public="1"><x path="lime._backend.native._NativeApplication.MouseEventType"/></type>
		<windowID public="1"><x path="Int"/></windowID>
		<x public="1"><x path="Float"/></x>
		<y public="1"><x path="Float"/></y>
		<clone public="1" set="method" line="866"><f a=""><c path="lime._backend.native._NativeApplication.MouseEventInfo"/></f></clone>
		<new public="1" set="method" line="853">
			<f a="?type:?windowID:?x:?y:?button:?movementX:?movementY" v="null:0:0:0:0:0:0">
				<x path="lime._backend.native._NativeApplication.MouseEventType"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ movementY : 0, movementX : 0, button : 0, y : 0, x : 0, windowID : 0, type : null }</e></m></meta>
		</new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<abstract path="lime._backend.native._NativeApplication.MouseEventType" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/_backend/native/NativeApplication.hx" private="1" module="lime._backend.native.NativeApplication">
		<this><x path="Int"/></this>
		<meta><m n=":enum"/></meta>
		<impl><class path="lime._backend.native._NativeApplication.MouseEventType_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/_backend/native/NativeApplication.hx" private="1" module="lime._backend.native.NativeApplication" extern="1">
	<MOUSE_DOWN public="1" get="inline" set="null" expr="cast 0" line="878" static="1">
		<x path="lime._backend.native._NativeApplication.MouseEventType"/>
		<meta>
			<m n=":value"><e>cast 0</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</MOUSE_DOWN>
	<MOUSE_UP public="1" get="inline" set="null" expr="cast 1" line="879" static="1">
		<x path="lime._backend.native._NativeApplication.MouseEventType"/>
		<meta>
			<m n=":value"><e>cast 1</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</MOUSE_UP>
	<MOUSE_MOVE public="1" get="inline" set="null" expr="cast 2" line="880" static="1">
		<x path="lime._backend.native._NativeApplication.MouseEventType"/>
		<meta>
			<m n=":value"><e>cast 2</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</MOUSE_MOVE>
	<MOUSE_WHEEL public="1" get="inline" set="null" expr="cast 3" line="881" static="1">
		<x path="lime._backend.native._NativeApplication.MouseEventType"/>
		<meta>
			<m n=":value"><e>cast 3</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</MOUSE_WHEEL>
	<meta>
		<m n=":final"/>
		<m n=":enum"/>
	</meta>
</class></impl>
	</abstract>
	<class path="lime._backend.native._NativeApplication.MouseEventType_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/_backend/native/NativeApplication.hx" private="1" module="lime._backend.native.NativeApplication" extern="1">
		<MOUSE_DOWN public="1" get="inline" set="null" expr="cast 0" line="878" static="1">
			<x path="lime._backend.native._NativeApplication.MouseEventType"/>
			<meta>
				<m n=":value"><e>cast 0</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</MOUSE_DOWN>
		<MOUSE_UP public="1" get="inline" set="null" expr="cast 1" line="879" static="1">
			<x path="lime._backend.native._NativeApplication.MouseEventType"/>
			<meta>
				<m n=":value"><e>cast 1</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</MOUSE_UP>
		<MOUSE_MOVE public="1" get="inline" set="null" expr="cast 2" line="880" static="1">
			<x path="lime._backend.native._NativeApplication.MouseEventType"/>
			<meta>
				<m n=":value"><e>cast 2</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</MOUSE_MOVE>
		<MOUSE_WHEEL public="1" get="inline" set="null" expr="cast 3" line="881" static="1">
			<x path="lime._backend.native._NativeApplication.MouseEventType"/>
			<meta>
				<m n=":value"><e>cast 3</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</MOUSE_WHEEL>
		<meta>
			<m n=":final"/>
			<m n=":enum"/>
		</meta>
	</class>
	<class path="lime._backend.native._NativeApplication.RenderEventInfo" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/_backend/native/NativeApplication.hx" private="1" module="lime._backend.native.NativeApplication">
		<context public="1"><e path="lime.graphics.RenderContext"/></context>
		<type public="1"><x path="lime._backend.native._NativeApplication.RenderEventType"/></type>
		<clone public="1" set="method" line="901"><f a=""><c path="lime._backend.native._NativeApplication.RenderEventInfo"/></f></clone>
		<new public="1" set="method" line="893">
			<f a="?type:?context" v="null:null">
				<x path="lime._backend.native._NativeApplication.RenderEventType"/>
				<e path="lime.graphics.RenderContext"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ context : null, type : null }</e></m></meta>
		</new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<abstract path="lime._backend.native._NativeApplication.RenderEventType" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/_backend/native/NativeApplication.hx" private="1" module="lime._backend.native.NativeApplication">
		<this><x path="Int"/></this>
		<meta><m n=":enum"/></meta>
		<impl><class path="lime._backend.native._NativeApplication.RenderEventType_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/_backend/native/NativeApplication.hx" private="1" module="lime._backend.native.NativeApplication" extern="1">
	<RENDER public="1" get="inline" set="null" expr="cast 0" line="913" static="1">
		<x path="lime._backend.native._NativeApplication.RenderEventType"/>
		<meta>
			<m n=":value"><e>cast 0</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</RENDER>
	<RENDER_CONTEXT_LOST public="1" get="inline" set="null" expr="cast 1" line="914" static="1">
		<x path="lime._backend.native._NativeApplication.RenderEventType"/>
		<meta>
			<m n=":value"><e>cast 1</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</RENDER_CONTEXT_LOST>
	<RENDER_CONTEXT_RESTORED public="1" get="inline" set="null" expr="cast 2" line="915" static="1">
		<x path="lime._backend.native._NativeApplication.RenderEventType"/>
		<meta>
			<m n=":value"><e>cast 2</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</RENDER_CONTEXT_RESTORED>
	<meta>
		<m n=":final"/>
		<m n=":enum"/>
	</meta>
</class></impl>
	</abstract>
	<class path="lime._backend.native._NativeApplication.RenderEventType_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/_backend/native/NativeApplication.hx" private="1" module="lime._backend.native.NativeApplication" extern="1">
		<RENDER public="1" get="inline" set="null" expr="cast 0" line="913" static="1">
			<x path="lime._backend.native._NativeApplication.RenderEventType"/>
			<meta>
				<m n=":value"><e>cast 0</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</RENDER>
		<RENDER_CONTEXT_LOST public="1" get="inline" set="null" expr="cast 1" line="914" static="1">
			<x path="lime._backend.native._NativeApplication.RenderEventType"/>
			<meta>
				<m n=":value"><e>cast 1</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</RENDER_CONTEXT_LOST>
		<RENDER_CONTEXT_RESTORED public="1" get="inline" set="null" expr="cast 2" line="915" static="1">
			<x path="lime._backend.native._NativeApplication.RenderEventType"/>
			<meta>
				<m n=":value"><e>cast 2</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</RENDER_CONTEXT_RESTORED>
		<meta>
			<m n=":final"/>
			<m n=":enum"/>
		</meta>
	</class>
	<class path="lime._backend.native._NativeApplication.SensorEventInfo" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/_backend/native/NativeApplication.hx" private="1" module="lime._backend.native.NativeApplication">
		<id public="1"><x path="Int"/></id>
		<x public="1"><x path="Float"/></x>
		<y public="1"><x path="Float"/></y>
		<z public="1"><x path="Float"/></z>
		<type public="1"><x path="lime._backend.native._NativeApplication.SensorEventType"/></type>
		<clone public="1" set="method" line="941"><f a=""><c path="lime._backend.native._NativeApplication.SensorEventInfo"/></f></clone>
		<new public="1" set="method" line="930">
			<f a="?type:?id:?x:?y:?z" v="null:0:0:0:0">
				<x path="lime._backend.native._NativeApplication.SensorEventType"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ z : 0, y : 0, x : 0, id : 0, type : null }</e></m></meta>
		</new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<abstract path="lime._backend.native._NativeApplication.SensorEventType" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/_backend/native/NativeApplication.hx" private="1" module="lime._backend.native.NativeApplication">
		<this><x path="Int"/></this>
		<meta><m n=":enum"/></meta>
		<impl><class path="lime._backend.native._NativeApplication.SensorEventType_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/_backend/native/NativeApplication.hx" private="1" module="lime._backend.native.NativeApplication" extern="1">
	<ACCELEROMETER public="1" get="inline" set="null" expr="cast 0" line="953" static="1">
		<x path="lime._backend.native._NativeApplication.SensorEventType"/>
		<meta>
			<m n=":value"><e>cast 0</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</ACCELEROMETER>
	<meta>
		<m n=":final"/>
		<m n=":enum"/>
	</meta>
</class></impl>
	</abstract>
	<class path="lime._backend.native._NativeApplication.SensorEventType_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/_backend/native/NativeApplication.hx" private="1" module="lime._backend.native.NativeApplication" extern="1">
		<ACCELEROMETER public="1" get="inline" set="null" expr="cast 0" line="953" static="1">
			<x path="lime._backend.native._NativeApplication.SensorEventType"/>
			<meta>
				<m n=":value"><e>cast 0</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</ACCELEROMETER>
		<meta>
			<m n=":final"/>
			<m n=":enum"/>
		</meta>
	</class>
	<class path="lime._backend.native._NativeApplication.TextEventInfo" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/_backend/native/NativeApplication.hx" private="1" module="lime._backend.native.NativeApplication">
		<id public="1"><x path="Int"/></id>
		<length public="1"><x path="Int"/></length>
		<start public="1"><x path="Int"/></start>
		<text public="1"><c path="String"/></text>
		<type public="1"><x path="lime._backend.native._NativeApplication.TextEventType"/></type>
		<windowID public="1"><x path="Int"/></windowID>
		<clone public="1" set="method" line="980"><f a=""><c path="lime._backend.native._NativeApplication.TextEventInfo"/></f></clone>
		<new public="1" set="method" line="969">
			<f a="?type:?windowID:?text:?start:?length" v="null:0:&quot;&quot;:0:0">
				<x path="lime._backend.native._NativeApplication.TextEventType"/>
				<x path="Int"/>
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ length : 0, start : 0, text : "", windowID : 0, type : null }</e></m></meta>
		</new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<abstract path="lime._backend.native._NativeApplication.TextEventType" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/_backend/native/NativeApplication.hx" private="1" module="lime._backend.native.NativeApplication">
		<this><x path="Int"/></this>
		<meta><m n=":enum"/></meta>
		<impl><class path="lime._backend.native._NativeApplication.TextEventType_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/_backend/native/NativeApplication.hx" private="1" module="lime._backend.native.NativeApplication" extern="1">
	<TEXT_INPUT public="1" get="inline" set="null" expr="cast 0" line="992" static="1">
		<x path="lime._backend.native._NativeApplication.TextEventType"/>
		<meta>
			<m n=":value"><e>cast 0</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</TEXT_INPUT>
	<TEXT_EDIT public="1" get="inline" set="null" expr="cast 1" line="993" static="1">
		<x path="lime._backend.native._NativeApplication.TextEventType"/>
		<meta>
			<m n=":value"><e>cast 1</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</TEXT_EDIT>
	<meta>
		<m n=":final"/>
		<m n=":enum"/>
	</meta>
</class></impl>
	</abstract>
	<class path="lime._backend.native._NativeApplication.TextEventType_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/_backend/native/NativeApplication.hx" private="1" module="lime._backend.native.NativeApplication" extern="1">
		<TEXT_INPUT public="1" get="inline" set="null" expr="cast 0" line="992" static="1">
			<x path="lime._backend.native._NativeApplication.TextEventType"/>
			<meta>
				<m n=":value"><e>cast 0</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</TEXT_INPUT>
		<TEXT_EDIT public="1" get="inline" set="null" expr="cast 1" line="993" static="1">
			<x path="lime._backend.native._NativeApplication.TextEventType"/>
			<meta>
				<m n=":value"><e>cast 1</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</TEXT_EDIT>
		<meta>
			<m n=":final"/>
			<m n=":enum"/>
		</meta>
	</class>
	<class path="lime._backend.native._NativeApplication.TouchEventInfo" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/_backend/native/NativeApplication.hx" private="1" module="lime._backend.native.NativeApplication">
		<device public="1"><x path="Int"/></device>
		<dx public="1"><x path="Float"/></dx>
		<dy public="1"><x path="Float"/></dy>
		<id public="1"><x path="Int"/></id>
		<pressure public="1"><x path="Float"/></pressure>
		<type public="1"><x path="lime._backend.native._NativeApplication.TouchEventType"/></type>
		<x public="1"><x path="Float"/></x>
		<y public="1"><x path="Float"/></y>
		<clone public="1" set="method" line="1025"><f a=""><c path="lime._backend.native._NativeApplication.TouchEventInfo"/></f></clone>
		<new public="1" set="method" line="1011">
			<f a="?type:?x:?y:?id:?dx:?dy:?pressure:?device" v="null:0:0:0:0:0:0:0">
				<x path="lime._backend.native._NativeApplication.TouchEventType"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ device : 0, pressure : 0, dy : 0, dx : 0, id : 0, y : 0, x : 0, type : null }</e></m></meta>
		</new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<abstract path="lime._backend.native._NativeApplication.TouchEventType" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/_backend/native/NativeApplication.hx" private="1" module="lime._backend.native.NativeApplication">
		<this><x path="Int"/></this>
		<meta><m n=":enum"/></meta>
		<impl><class path="lime._backend.native._NativeApplication.TouchEventType_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/_backend/native/NativeApplication.hx" private="1" module="lime._backend.native.NativeApplication" extern="1">
	<TOUCH_START public="1" get="inline" set="null" expr="cast 0" line="1037" static="1">
		<x path="lime._backend.native._NativeApplication.TouchEventType"/>
		<meta>
			<m n=":value"><e>cast 0</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</TOUCH_START>
	<TOUCH_END public="1" get="inline" set="null" expr="cast 1" line="1038" static="1">
		<x path="lime._backend.native._NativeApplication.TouchEventType"/>
		<meta>
			<m n=":value"><e>cast 1</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</TOUCH_END>
	<TOUCH_MOVE public="1" get="inline" set="null" expr="cast 2" line="1039" static="1">
		<x path="lime._backend.native._NativeApplication.TouchEventType"/>
		<meta>
			<m n=":value"><e>cast 2</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</TOUCH_MOVE>
	<meta>
		<m n=":final"/>
		<m n=":enum"/>
	</meta>
</class></impl>
	</abstract>
	<class path="lime._backend.native._NativeApplication.TouchEventType_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/_backend/native/NativeApplication.hx" private="1" module="lime._backend.native.NativeApplication" extern="1">
		<TOUCH_START public="1" get="inline" set="null" expr="cast 0" line="1037" static="1">
			<x path="lime._backend.native._NativeApplication.TouchEventType"/>
			<meta>
				<m n=":value"><e>cast 0</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</TOUCH_START>
		<TOUCH_END public="1" get="inline" set="null" expr="cast 1" line="1038" static="1">
			<x path="lime._backend.native._NativeApplication.TouchEventType"/>
			<meta>
				<m n=":value"><e>cast 1</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</TOUCH_END>
		<TOUCH_MOVE public="1" get="inline" set="null" expr="cast 2" line="1039" static="1">
			<x path="lime._backend.native._NativeApplication.TouchEventType"/>
			<meta>
				<m n=":value"><e>cast 2</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</TOUCH_MOVE>
		<meta>
			<m n=":final"/>
			<m n=":enum"/>
		</meta>
	</class>
	<class path="lime._backend.native._NativeApplication.WindowEventInfo" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/_backend/native/NativeApplication.hx" private="1" module="lime._backend.native.NativeApplication">
		<height public="1"><x path="Int"/></height>
		<type public="1"><x path="lime._backend.native._NativeApplication.WindowEventType"/></type>
		<width public="1"><x path="Int"/></width>
		<windowID public="1"><x path="Int"/></windowID>
		<x public="1"><x path="Int"/></x>
		<y public="1"><x path="Int"/></y>
		<clone public="1" set="method" line="1067"><f a=""><c path="lime._backend.native._NativeApplication.WindowEventInfo"/></f></clone>
		<new public="1" set="method" line="1055">
			<f a="?type:?windowID:?width:?height:?x:?y" v="null:0:0:0:0:0">
				<x path="lime._backend.native._NativeApplication.WindowEventType"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ y : 0, x : 0, height : 0, width : 0, windowID : 0, type : null }</e></m></meta>
		</new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<abstract path="lime._backend.native._NativeApplication.WindowEventType" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/_backend/native/NativeApplication.hx" private="1" module="lime._backend.native.NativeApplication">
		<this><x path="Int"/></this>
		<meta><m n=":enum"/></meta>
		<impl><class path="lime._backend.native._NativeApplication.WindowEventType_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/_backend/native/NativeApplication.hx" private="1" module="lime._backend.native.NativeApplication" extern="1">
	<WINDOW_ACTIVATE public="1" get="inline" set="null" expr="cast 0" line="1079" static="1">
		<x path="lime._backend.native._NativeApplication.WindowEventType"/>
		<meta>
			<m n=":value"><e>cast 0</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</WINDOW_ACTIVATE>
	<WINDOW_CLOSE public="1" get="inline" set="null" expr="cast 1" line="1080" static="1">
		<x path="lime._backend.native._NativeApplication.WindowEventType"/>
		<meta>
			<m n=":value"><e>cast 1</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</WINDOW_CLOSE>
	<WINDOW_DEACTIVATE public="1" get="inline" set="null" expr="cast 2" line="1081" static="1">
		<x path="lime._backend.native._NativeApplication.WindowEventType"/>
		<meta>
			<m n=":value"><e>cast 2</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</WINDOW_DEACTIVATE>
	<WINDOW_ENTER public="1" get="inline" set="null" expr="cast 3" line="1082" static="1">
		<x path="lime._backend.native._NativeApplication.WindowEventType"/>
		<meta>
			<m n=":value"><e>cast 3</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</WINDOW_ENTER>
	<WINDOW_FOCUS_IN public="1" get="inline" set="null" expr="cast 4" line="1083" static="1">
		<x path="lime._backend.native._NativeApplication.WindowEventType"/>
		<meta>
			<m n=":value"><e>cast 4</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</WINDOW_FOCUS_IN>
	<WINDOW_FOCUS_OUT public="1" get="inline" set="null" expr="cast 5" line="1084" static="1">
		<x path="lime._backend.native._NativeApplication.WindowEventType"/>
		<meta>
			<m n=":value"><e>cast 5</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</WINDOW_FOCUS_OUT>
	<WINDOW_LEAVE public="1" get="inline" set="null" expr="cast 6" line="1085" static="1">
		<x path="lime._backend.native._NativeApplication.WindowEventType"/>
		<meta>
			<m n=":value"><e>cast 6</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</WINDOW_LEAVE>
	<WINDOW_MINIMIZE public="1" get="inline" set="null" expr="cast 7" line="1086" static="1">
		<x path="lime._backend.native._NativeApplication.WindowEventType"/>
		<meta>
			<m n=":value"><e>cast 7</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</WINDOW_MINIMIZE>
	<WINDOW_MOVE public="1" get="inline" set="null" expr="cast 8" line="1087" static="1">
		<x path="lime._backend.native._NativeApplication.WindowEventType"/>
		<meta>
			<m n=":value"><e>cast 8</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</WINDOW_MOVE>
	<WINDOW_RESIZE public="1" get="inline" set="null" expr="cast 9" line="1088" static="1">
		<x path="lime._backend.native._NativeApplication.WindowEventType"/>
		<meta>
			<m n=":value"><e>cast 9</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</WINDOW_RESIZE>
	<WINDOW_RESTORE public="1" get="inline" set="null" expr="cast 10" line="1089" static="1">
		<x path="lime._backend.native._NativeApplication.WindowEventType"/>
		<meta>
			<m n=":value"><e>cast 10</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</WINDOW_RESTORE>
	<meta>
		<m n=":final"/>
		<m n=":enum"/>
	</meta>
</class></impl>
	</abstract>
	<class path="lime._backend.native._NativeApplication.WindowEventType_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/_backend/native/NativeApplication.hx" private="1" module="lime._backend.native.NativeApplication" extern="1">
		<WINDOW_ACTIVATE public="1" get="inline" set="null" expr="cast 0" line="1079" static="1">
			<x path="lime._backend.native._NativeApplication.WindowEventType"/>
			<meta>
				<m n=":value"><e>cast 0</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</WINDOW_ACTIVATE>
		<WINDOW_CLOSE public="1" get="inline" set="null" expr="cast 1" line="1080" static="1">
			<x path="lime._backend.native._NativeApplication.WindowEventType"/>
			<meta>
				<m n=":value"><e>cast 1</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</WINDOW_CLOSE>
		<WINDOW_DEACTIVATE public="1" get="inline" set="null" expr="cast 2" line="1081" static="1">
			<x path="lime._backend.native._NativeApplication.WindowEventType"/>
			<meta>
				<m n=":value"><e>cast 2</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</WINDOW_DEACTIVATE>
		<WINDOW_ENTER public="1" get="inline" set="null" expr="cast 3" line="1082" static="1">
			<x path="lime._backend.native._NativeApplication.WindowEventType"/>
			<meta>
				<m n=":value"><e>cast 3</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</WINDOW_ENTER>
		<WINDOW_FOCUS_IN public="1" get="inline" set="null" expr="cast 4" line="1083" static="1">
			<x path="lime._backend.native._NativeApplication.WindowEventType"/>
			<meta>
				<m n=":value"><e>cast 4</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</WINDOW_FOCUS_IN>
		<WINDOW_FOCUS_OUT public="1" get="inline" set="null" expr="cast 5" line="1084" static="1">
			<x path="lime._backend.native._NativeApplication.WindowEventType"/>
			<meta>
				<m n=":value"><e>cast 5</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</WINDOW_FOCUS_OUT>
		<WINDOW_LEAVE public="1" get="inline" set="null" expr="cast 6" line="1085" static="1">
			<x path="lime._backend.native._NativeApplication.WindowEventType"/>
			<meta>
				<m n=":value"><e>cast 6</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</WINDOW_LEAVE>
		<WINDOW_MINIMIZE public="1" get="inline" set="null" expr="cast 7" line="1086" static="1">
			<x path="lime._backend.native._NativeApplication.WindowEventType"/>
			<meta>
				<m n=":value"><e>cast 7</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</WINDOW_MINIMIZE>
		<WINDOW_MOVE public="1" get="inline" set="null" expr="cast 8" line="1087" static="1">
			<x path="lime._backend.native._NativeApplication.WindowEventType"/>
			<meta>
				<m n=":value"><e>cast 8</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</WINDOW_MOVE>
		<WINDOW_RESIZE public="1" get="inline" set="null" expr="cast 9" line="1088" static="1">
			<x path="lime._backend.native._NativeApplication.WindowEventType"/>
			<meta>
				<m n=":value"><e>cast 9</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</WINDOW_RESIZE>
		<WINDOW_RESTORE public="1" get="inline" set="null" expr="cast 10" line="1089" static="1">
			<x path="lime._backend.native._NativeApplication.WindowEventType"/>
			<meta>
				<m n=":value"><e>cast 10</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</WINDOW_RESTORE>
		<meta>
			<m n=":final"/>
			<m n=":enum"/>
		</meta>
	</class>
	<class path="lime._backend.native.NativeMouse" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/_backend/native/NativeMouse.hx">
		<__cursor static="1"><e path="lime.ui.MouseCursor"/></__cursor>
		<__hidden static="1"><x path="Bool"/></__hidden>
		<__lock static="1"><x path="Bool"/></__lock>
		<hide public="1" set="method" line="22" static="1"><f a=""><x path="Void"/></f></hide>
		<show public="1" set="method" line="37" static="1"><f a=""><x path="Void"/></f></show>
		<warp public="1" set="method" line="52" static="1"><f a="x:y:window">
	<x path="Int"/>
	<x path="Int"/>
	<c path="lime.ui.Window"/>
	<x path="Void"/>
</f></warp>
		<get_cursor public="1" set="method" line="68" static="1"><f a=""><e path="lime.ui.MouseCursor"/></f></get_cursor>
		<set_cursor public="1" set="method" line="76" static="1"><f a="value">
	<e path="lime.ui.MouseCursor"/>
	<e path="lime.ui.MouseCursor"/>
</f></set_cursor>
		<get_lock public="1" set="method" line="114" static="1"><f a=""><x path="Bool"/></f></get_lock>
		<set_lock public="1" set="method" line="121" static="1"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_lock>
		<lime_mouse_hide get="inline" set="null" line="147" static="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":cffi"/></meta>
		</lime_mouse_hide>
		<lime_mouse_set_cursor get="inline" set="null" line="148" static="1">
			<f a="cursor">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":cffi"/></meta>
		</lime_mouse_set_cursor>
		<lime_mouse_set_lock get="inline" set="null" line="149" static="1">
			<f a="lock">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":cffi"/></meta>
		</lime_mouse_set_lock>
		<lime_mouse_show get="inline" set="null" line="150" static="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":cffi"/></meta>
		</lime_mouse_show>
		<lime_mouse_warp get="inline" set="null" line="151" static="1">
			<f a="x:y:window">
				<x path="Int"/>
				<x path="Int"/>
				<d/>
				<x path="Void"/>
			</f>
			<meta><m n=":cffi"/></meta>
		</lime_mouse_warp>
		<cffi_lime_mouse_hide expr="new cpp.Callable&lt;Void&gt;(lime.system.CFFI.load(&quot;lime&quot;, &quot;lime_mouse_hide&quot;, 0, false))" line="147" static="1">
			<x path="cpp.Callable"><f a=""><x path="Void"/></f></x>
			<meta><m n=":value"><e><![CDATA[new cpp.Callable<Void>(lime.system.CFFI.load("lime", "lime_mouse_hide", 0, false))]]></e></m></meta>
		</cffi_lime_mouse_hide>
		<cffi_lime_mouse_set_cursor expr="new cpp.Callable&lt;Int&gt;(lime.system.CFFI.load(&quot;lime&quot;, &quot;lime_mouse_set_cursor&quot;, 1, false))" line="148" static="1">
			<x path="cpp.Callable"><f a="">
	<x path="Int"/>
	<x path="Void"/>
</f></x>
			<meta><m n=":value"><e><![CDATA[new cpp.Callable<Int>(lime.system.CFFI.load("lime", "lime_mouse_set_cursor", 1, false))]]></e></m></meta>
		</cffi_lime_mouse_set_cursor>
		<cffi_lime_mouse_set_lock expr="new cpp.Callable&lt;Bool&gt;(lime.system.CFFI.load(&quot;lime&quot;, &quot;lime_mouse_set_lock&quot;, 1, false))" line="149" static="1">
			<x path="cpp.Callable"><f a="">
	<x path="Bool"/>
	<x path="Void"/>
</f></x>
			<meta><m n=":value"><e><![CDATA[new cpp.Callable<Bool>(lime.system.CFFI.load("lime", "lime_mouse_set_lock", 1, false))]]></e></m></meta>
		</cffi_lime_mouse_set_lock>
		<cffi_lime_mouse_show expr="new cpp.Callable&lt;Void&gt;(lime.system.CFFI.load(&quot;lime&quot;, &quot;lime_mouse_show&quot;, 0, false))" line="150" static="1">
			<x path="cpp.Callable"><f a=""><x path="Void"/></f></x>
			<meta><m n=":value"><e><![CDATA[new cpp.Callable<Void>(lime.system.CFFI.load("lime", "lime_mouse_show", 0, false))]]></e></m></meta>
		</cffi_lime_mouse_show>
		<cffi_lime_mouse_warp expr="new cpp.Callable&lt;Int -&gt; Int -&gt; Dynamic&gt;(lime.system.CFFI.load(&quot;lime&quot;, &quot;lime_mouse_warp&quot;, 3, false))" line="151" static="1">
			<x path="cpp.Callable"><f a="::">
	<x path="Int"/>
	<x path="Int"/>
	<d/>
	<x path="Void"/>
</f></x>
			<meta><m n=":value"><e><![CDATA[new cpp.Callable<Int -> Int -> Dynamic>(lime.system.CFFI.load("lime", "lime_mouse_warp", 3, false))]]></e></m></meta>
		</cffi_lime_mouse_warp>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>lime.system.CFFI.build()</e></m>
			<m n=":access"><e>lime.ui.Window</e></m>
		</meta>
	</class>
	<abstract path="lime._backend.native._NativeMouse.MouseCursorType" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/_backend/native/NativeMouse.hx" private="1" module="lime._backend.native.NativeMouse">
		<from><icast><x path="Int"/></icast></from>
		<this><x path="Int"/></this>
		<to><icast><x path="Int"/></icast></to>
		<meta><m n=":enum"/></meta>
		<impl><class path="lime._backend.native._NativeMouse.MouseCursorType_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/_backend/native/NativeMouse.hx" private="1" module="lime._backend.native.NativeMouse" extern="1">
	<ARROW public="1" get="inline" set="null" expr="cast 0" line="160" static="1">
		<x path="lime._backend.native._NativeMouse.MouseCursorType"/>
		<meta>
			<m n=":value"><e>cast 0</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</ARROW>
	<CROSSHAIR public="1" get="inline" set="null" expr="cast 1" line="161" static="1">
		<x path="lime._backend.native._NativeMouse.MouseCursorType"/>
		<meta>
			<m n=":value"><e>cast 1</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</CROSSHAIR>
	<DEFAULT public="1" get="inline" set="null" expr="cast 2" line="162" static="1">
		<x path="lime._backend.native._NativeMouse.MouseCursorType"/>
		<meta>
			<m n=":value"><e>cast 2</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</DEFAULT>
	<MOVE public="1" get="inline" set="null" expr="cast 3" line="163" static="1">
		<x path="lime._backend.native._NativeMouse.MouseCursorType"/>
		<meta>
			<m n=":value"><e>cast 3</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</MOVE>
	<POINTER public="1" get="inline" set="null" expr="cast 4" line="164" static="1">
		<x path="lime._backend.native._NativeMouse.MouseCursorType"/>
		<meta>
			<m n=":value"><e>cast 4</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</POINTER>
	<RESIZE_NESW public="1" get="inline" set="null" expr="cast 5" line="165" static="1">
		<x path="lime._backend.native._NativeMouse.MouseCursorType"/>
		<meta>
			<m n=":value"><e>cast 5</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</RESIZE_NESW>
	<RESIZE_NS public="1" get="inline" set="null" expr="cast 6" line="166" static="1">
		<x path="lime._backend.native._NativeMouse.MouseCursorType"/>
		<meta>
			<m n=":value"><e>cast 6</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</RESIZE_NS>
	<RESIZE_NWSE public="1" get="inline" set="null" expr="cast 7" line="167" static="1">
		<x path="lime._backend.native._NativeMouse.MouseCursorType"/>
		<meta>
			<m n=":value"><e>cast 7</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</RESIZE_NWSE>
	<RESIZE_WE public="1" get="inline" set="null" expr="cast 8" line="168" static="1">
		<x path="lime._backend.native._NativeMouse.MouseCursorType"/>
		<meta>
			<m n=":value"><e>cast 8</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</RESIZE_WE>
	<TEXT public="1" get="inline" set="null" expr="cast 9" line="169" static="1">
		<x path="lime._backend.native._NativeMouse.MouseCursorType"/>
		<meta>
			<m n=":value"><e>cast 9</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</TEXT>
	<WAIT public="1" get="inline" set="null" expr="cast 10" line="170" static="1">
		<x path="lime._backend.native._NativeMouse.MouseCursorType"/>
		<meta>
			<m n=":value"><e>cast 10</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</WAIT>
	<WAIT_ARROW public="1" get="inline" set="null" expr="cast 11" line="171" static="1">
		<x path="lime._backend.native._NativeMouse.MouseCursorType"/>
		<meta>
			<m n=":value"><e>cast 11</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</WAIT_ARROW>
	<meta>
		<m n=":final"/>
		<m n=":enum"/>
	</meta>
</class></impl>
	</abstract>
	<class path="lime._backend.native._NativeMouse.MouseCursorType_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/_backend/native/NativeMouse.hx" private="1" module="lime._backend.native.NativeMouse" extern="1">
		<ARROW public="1" get="inline" set="null" expr="cast 0" line="160" static="1">
			<x path="lime._backend.native._NativeMouse.MouseCursorType"/>
			<meta>
				<m n=":value"><e>cast 0</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</ARROW>
		<CROSSHAIR public="1" get="inline" set="null" expr="cast 1" line="161" static="1">
			<x path="lime._backend.native._NativeMouse.MouseCursorType"/>
			<meta>
				<m n=":value"><e>cast 1</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</CROSSHAIR>
		<DEFAULT public="1" get="inline" set="null" expr="cast 2" line="162" static="1">
			<x path="lime._backend.native._NativeMouse.MouseCursorType"/>
			<meta>
				<m n=":value"><e>cast 2</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</DEFAULT>
		<MOVE public="1" get="inline" set="null" expr="cast 3" line="163" static="1">
			<x path="lime._backend.native._NativeMouse.MouseCursorType"/>
			<meta>
				<m n=":value"><e>cast 3</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</MOVE>
		<POINTER public="1" get="inline" set="null" expr="cast 4" line="164" static="1">
			<x path="lime._backend.native._NativeMouse.MouseCursorType"/>
			<meta>
				<m n=":value"><e>cast 4</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</POINTER>
		<RESIZE_NESW public="1" get="inline" set="null" expr="cast 5" line="165" static="1">
			<x path="lime._backend.native._NativeMouse.MouseCursorType"/>
			<meta>
				<m n=":value"><e>cast 5</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</RESIZE_NESW>
		<RESIZE_NS public="1" get="inline" set="null" expr="cast 6" line="166" static="1">
			<x path="lime._backend.native._NativeMouse.MouseCursorType"/>
			<meta>
				<m n=":value"><e>cast 6</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</RESIZE_NS>
		<RESIZE_NWSE public="1" get="inline" set="null" expr="cast 7" line="167" static="1">
			<x path="lime._backend.native._NativeMouse.MouseCursorType"/>
			<meta>
				<m n=":value"><e>cast 7</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</RESIZE_NWSE>
		<RESIZE_WE public="1" get="inline" set="null" expr="cast 8" line="168" static="1">
			<x path="lime._backend.native._NativeMouse.MouseCursorType"/>
			<meta>
				<m n=":value"><e>cast 8</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</RESIZE_WE>
		<TEXT public="1" get="inline" set="null" expr="cast 9" line="169" static="1">
			<x path="lime._backend.native._NativeMouse.MouseCursorType"/>
			<meta>
				<m n=":value"><e>cast 9</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</TEXT>
		<WAIT public="1" get="inline" set="null" expr="cast 10" line="170" static="1">
			<x path="lime._backend.native._NativeMouse.MouseCursorType"/>
			<meta>
				<m n=":value"><e>cast 10</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</WAIT>
		<WAIT_ARROW public="1" get="inline" set="null" expr="cast 11" line="171" static="1">
			<x path="lime._backend.native._NativeMouse.MouseCursorType"/>
			<meta>
				<m n=":value"><e>cast 11</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</WAIT_ARROW>
		<meta>
			<m n=":final"/>
			<m n=":enum"/>
		</meta>
	</class>
	<class path="lime._backend.native.NativeRenderer" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/_backend/native/NativeRenderer.hx">
		<lime_renderer_create get="inline" set="null" line="183" static="1">
			<f a="window">
				<d/>
				<d/>
			</f>
			<meta><m n=":cffi"/></meta>
		</lime_renderer_create>
		<lime_renderer_flip get="inline" set="null" line="184" static="1">
			<f a="handle">
				<d/>
				<x path="Void"/>
			</f>
			<meta><m n=":cffi"/></meta>
		</lime_renderer_flip>
		<lime_renderer_get_context get="inline" set="null" line="185" static="1">
			<f a="handle">
				<d/>
				<x path="Float"/>
			</f>
			<meta><m n=":cffi"/></meta>
		</lime_renderer_get_context>
		<lime_renderer_get_scale get="inline" set="null" line="186" static="1">
			<f a="handle">
				<d/>
				<x path="Float"/>
			</f>
			<meta><m n=":cffi"/></meta>
		</lime_renderer_get_scale>
		<lime_renderer_get_type get="inline" set="null" line="187" static="1">
			<f a="handle">
				<d/>
				<d/>
			</f>
			<meta><m n=":cffi"/></meta>
		</lime_renderer_get_type>
		<lime_renderer_lock get="inline" set="null" line="188" static="1">
			<f a="handle">
				<d/>
				<d/>
			</f>
			<meta><m n=":cffi"/></meta>
		</lime_renderer_lock>
		<lime_renderer_make_current get="inline" set="null" line="189" static="1">
			<f a="handle">
				<d/>
				<x path="Void"/>
			</f>
			<meta><m n=":cffi"/></meta>
		</lime_renderer_make_current>
		<lime_renderer_read_pixels get="inline" set="null" line="190" static="1">
			<f a="handle:rect">
				<d/>
				<d/>
				<d/>
			</f>
			<meta><m n=":cffi"/></meta>
		</lime_renderer_read_pixels>
		<lime_renderer_unlock get="inline" set="null" line="191" static="1">
			<f a="handle">
				<d/>
				<x path="Void"/>
			</f>
			<meta><m n=":cffi"/></meta>
		</lime_renderer_unlock>
		<cffi_lime_renderer_create expr="new cpp.Callable&lt;Dynamic&gt;(lime.system.CFFI.load(&quot;lime&quot;, &quot;lime_renderer_create&quot;, 1, false))" line="183" static="1">
			<x path="cpp.Callable"><f a="">
	<d/>
	<d/>
</f></x>
			<meta><m n=":value"><e><![CDATA[new cpp.Callable<Dynamic>(lime.system.CFFI.load("lime", "lime_renderer_create", 1, false))]]></e></m></meta>
		</cffi_lime_renderer_create>
		<cffi_lime_renderer_flip expr="new cpp.Callable&lt;Dynamic&gt;(lime.system.CFFI.load(&quot;lime&quot;, &quot;lime_renderer_flip&quot;, 1, false))" line="184" static="1">
			<x path="cpp.Callable"><f a="">
	<d/>
	<x path="Void"/>
</f></x>
			<meta><m n=":value"><e><![CDATA[new cpp.Callable<Dynamic>(lime.system.CFFI.load("lime", "lime_renderer_flip", 1, false))]]></e></m></meta>
		</cffi_lime_renderer_flip>
		<cffi_lime_renderer_get_context expr="new cpp.Callable&lt;Dynamic&gt;(lime.system.CFFI.load(&quot;lime&quot;, &quot;lime_renderer_get_context&quot;, 1, false))" line="185" static="1">
			<x path="cpp.Callable"><f a="">
	<d/>
	<x path="Float"/>
</f></x>
			<meta><m n=":value"><e><![CDATA[new cpp.Callable<Dynamic>(lime.system.CFFI.load("lime", "lime_renderer_get_context", 1, false))]]></e></m></meta>
		</cffi_lime_renderer_get_context>
		<cffi_lime_renderer_get_scale expr="new cpp.Callable&lt;Dynamic&gt;(lime.system.CFFI.load(&quot;lime&quot;, &quot;lime_renderer_get_scale&quot;, 1, false))" line="186" static="1">
			<x path="cpp.Callable"><f a="">
	<d/>
	<x path="Float"/>
</f></x>
			<meta><m n=":value"><e><![CDATA[new cpp.Callable<Dynamic>(lime.system.CFFI.load("lime", "lime_renderer_get_scale", 1, false))]]></e></m></meta>
		</cffi_lime_renderer_get_scale>
		<cffi_lime_renderer_get_type expr="new cpp.Callable&lt;Dynamic&gt;(lime.system.CFFI.load(&quot;lime&quot;, &quot;lime_renderer_get_type&quot;, 1, false))" line="187" static="1">
			<x path="cpp.Callable"><f a="">
	<d/>
	<d/>
</f></x>
			<meta><m n=":value"><e><![CDATA[new cpp.Callable<Dynamic>(lime.system.CFFI.load("lime", "lime_renderer_get_type", 1, false))]]></e></m></meta>
		</cffi_lime_renderer_get_type>
		<cffi_lime_renderer_lock expr="new cpp.Callable&lt;Dynamic&gt;(lime.system.CFFI.load(&quot;lime&quot;, &quot;lime_renderer_lock&quot;, 1, false))" line="188" static="1">
			<x path="cpp.Callable"><f a="">
	<d/>
	<d/>
</f></x>
			<meta><m n=":value"><e><![CDATA[new cpp.Callable<Dynamic>(lime.system.CFFI.load("lime", "lime_renderer_lock", 1, false))]]></e></m></meta>
		</cffi_lime_renderer_lock>
		<cffi_lime_renderer_make_current expr="new cpp.Callable&lt;Dynamic&gt;(lime.system.CFFI.load(&quot;lime&quot;, &quot;lime_renderer_make_current&quot;, 1, false))" line="189" static="1">
			<x path="cpp.Callable"><f a="">
	<d/>
	<x path="Void"/>
</f></x>
			<meta><m n=":value"><e><![CDATA[new cpp.Callable<Dynamic>(lime.system.CFFI.load("lime", "lime_renderer_make_current", 1, false))]]></e></m></meta>
		</cffi_lime_renderer_make_current>
		<cffi_lime_renderer_read_pixels expr="new cpp.Callable&lt;Dynamic -&gt; Dynamic&gt;(lime.system.CFFI.load(&quot;lime&quot;, &quot;lime_renderer_read_pixels&quot;, 2, false))" line="190" static="1">
			<x path="cpp.Callable"><f a=":">
	<d/>
	<d/>
	<d/>
</f></x>
			<meta><m n=":value"><e><![CDATA[new cpp.Callable<Dynamic -> Dynamic>(lime.system.CFFI.load("lime", "lime_renderer_read_pixels", 2, false))]]></e></m></meta>
		</cffi_lime_renderer_read_pixels>
		<cffi_lime_renderer_unlock expr="new cpp.Callable&lt;Dynamic&gt;(lime.system.CFFI.load(&quot;lime&quot;, &quot;lime_renderer_unlock&quot;, 1, false))" line="191" static="1">
			<x path="cpp.Callable"><f a="">
	<d/>
	<x path="Void"/>
</f></x>
			<meta><m n=":value"><e><![CDATA[new cpp.Callable<Dynamic>(lime.system.CFFI.load("lime", "lime_renderer_unlock", 1, false))]]></e></m></meta>
		</cffi_lime_renderer_unlock>
		<handle public="1"><d/></handle>
		<parent><c path="lime.graphics.Renderer"/></parent>
		<useHardware><x path="Bool"/></useHardware>
		<create public="1" set="method" line="48"><f a=""><x path="Void"/></f></create>
		<dispatch set="method" line="91"><f a=""><x path="Void"/></f></dispatch>
		<flip public="1" set="method" line="98"><f a=""><x path="Void"/></f></flip>
		<readPixels public="1" set="method" line="120"><f a="rect">
	<c path="lime.math.Rectangle"/>
	<c path="lime.graphics.Image"/>
</f></readPixels>
		<render public="1" set="method" line="138"><f a=""><x path="Void"/></f></render>
		<new public="1" set="method" line="41"><f a="parent">
	<c path="lime.graphics.Renderer"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>lime.system.CFFI.build()</e></m>
			<m n=":access"><e>lime.graphics.cairo.Cairo</e></m>
			<m n=":access"><e>lime.ui.Window</e></m>
		</meta>
	</class>
	<class path="lime._backend.native.NativeWindow" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/_backend/native/NativeWindow.hx">
		<lime_window_alert get="inline" set="null" line="323" static="1">
			<f a="handle:message:title">
				<d/>
				<c path="String"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":cffi"/></meta>
		</lime_window_alert>
		<lime_window_close get="inline" set="null" line="324" static="1">
			<f a="handle">
				<d/>
				<x path="Void"/>
			</f>
			<meta><m n=":cffi"/></meta>
		</lime_window_close>
		<lime_window_create get="inline" set="null" line="325" static="1">
			<f a="application:width:height:flags:title">
				<d/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<c path="String"/>
				<d/>
			</f>
			<meta><m n=":cffi"/></meta>
		</lime_window_create>
		<lime_window_focus get="inline" set="null" line="326" static="1">
			<f a="handle">
				<d/>
				<x path="Void"/>
			</f>
			<meta><m n=":cffi"/></meta>
		</lime_window_focus>
		<lime_window_get_display get="inline" set="null" line="327" static="1">
			<f a="handle">
				<d/>
				<x path="Int"/>
			</f>
			<meta><m n=":cffi"/></meta>
		</lime_window_get_display>
		<lime_window_get_enable_text_events get="inline" set="null" line="328" static="1">
			<f a="handle">
				<d/>
				<x path="Bool"/>
			</f>
			<meta><m n=":cffi"/></meta>
		</lime_window_get_enable_text_events>
		<lime_window_get_height get="inline" set="null" line="329" static="1">
			<f a="handle">
				<d/>
				<x path="Int"/>
			</f>
			<meta><m n=":cffi"/></meta>
		</lime_window_get_height>
		<lime_window_get_id get="inline" set="null" line="330" static="1">
			<f a="handle">
				<d/>
				<x path="Int"/>
			</f>
			<meta><m n=":cffi"/></meta>
		</lime_window_get_id>
		<lime_window_get_width get="inline" set="null" line="331" static="1">
			<f a="handle">
				<d/>
				<x path="Int"/>
			</f>
			<meta><m n=":cffi"/></meta>
		</lime_window_get_width>
		<lime_window_get_x get="inline" set="null" line="332" static="1">
			<f a="handle">
				<d/>
				<x path="Int"/>
			</f>
			<meta><m n=":cffi"/></meta>
		</lime_window_get_x>
		<lime_window_get_y get="inline" set="null" line="333" static="1">
			<f a="handle">
				<d/>
				<x path="Int"/>
			</f>
			<meta><m n=":cffi"/></meta>
		</lime_window_get_y>
		<lime_window_move get="inline" set="null" line="334" static="1">
			<f a="handle:x:y">
				<d/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":cffi"/></meta>
		</lime_window_move>
		<lime_window_resize get="inline" set="null" line="335" static="1">
			<f a="handle:width:height">
				<d/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":cffi"/></meta>
		</lime_window_resize>
		<lime_window_set_borderless get="inline" set="null" line="336" static="1">
			<f a="handle:borderless">
				<d/>
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":cffi"/></meta>
		</lime_window_set_borderless>
		<lime_window_set_enable_text_events get="inline" set="null" line="337" static="1">
			<f a="handle:enabled">
				<d/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":cffi"/></meta>
		</lime_window_set_enable_text_events>
		<lime_window_set_fullscreen get="inline" set="null" line="338" static="1">
			<f a="handle:fullscreen">
				<d/>
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":cffi"/></meta>
		</lime_window_set_fullscreen>
		<lime_window_set_icon get="inline" set="null" line="339" static="1">
			<f a="handle:buffer">
				<d/>
				<d/>
				<x path="Void"/>
			</f>
			<meta><m n=":cffi"/></meta>
		</lime_window_set_icon>
		<lime_window_set_maximized get="inline" set="null" line="340" static="1">
			<f a="handle:maximized">
				<d/>
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":cffi"/></meta>
		</lime_window_set_maximized>
		<lime_window_set_minimized get="inline" set="null" line="341" static="1">
			<f a="handle:minimized">
				<d/>
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":cffi"/></meta>
		</lime_window_set_minimized>
		<lime_window_set_resizable get="inline" set="null" line="342" static="1">
			<f a="handle:resizable">
				<d/>
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":cffi"/></meta>
		</lime_window_set_resizable>
		<lime_window_set_title get="inline" set="null" line="343" static="1">
			<f a="handle:title">
				<d/>
				<c path="String"/>
				<d/>
			</f>
			<meta><m n=":cffi"/></meta>
		</lime_window_set_title>
		<cffi_lime_window_alert expr="new cpp.Callable&lt;Dynamic -&gt; String -&gt; String&gt;(lime.system.CFFI.load(&quot;lime&quot;, &quot;lime_window_alert&quot;, 3, false))" line="323" static="1">
			<x path="cpp.Callable"><f a="::">
	<d/>
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></x>
			<meta><m n=":value"><e><![CDATA[new cpp.Callable<Dynamic -> String -> String>(lime.system.CFFI.load("lime", "lime_window_alert", 3, false))]]></e></m></meta>
		</cffi_lime_window_alert>
		<cffi_lime_window_close expr="new cpp.Callable&lt;Dynamic&gt;(lime.system.CFFI.load(&quot;lime&quot;, &quot;lime_window_close&quot;, 1, false))" line="324" static="1">
			<x path="cpp.Callable"><f a="">
	<d/>
	<x path="Void"/>
</f></x>
			<meta><m n=":value"><e><![CDATA[new cpp.Callable<Dynamic>(lime.system.CFFI.load("lime", "lime_window_close", 1, false))]]></e></m></meta>
		</cffi_lime_window_close>
		<cffi_lime_window_create expr="new cpp.Callable&lt;Dynamic -&gt; Int -&gt; Int -&gt; Int -&gt; String&gt;(lime.system.CFFI.load(&quot;lime&quot;, &quot;lime_window_create&quot;, 5, false))" line="325" static="1">
			<x path="cpp.Callable"><f a="::::">
	<d/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<c path="String"/>
	<d/>
</f></x>
			<meta><m n=":value"><e><![CDATA[new cpp.Callable<Dynamic -> Int -> Int -> Int -> String>(lime.system.CFFI.load("lime", "lime_window_create", 5, false))]]></e></m></meta>
		</cffi_lime_window_create>
		<cffi_lime_window_focus expr="new cpp.Callable&lt;Dynamic&gt;(lime.system.CFFI.load(&quot;lime&quot;, &quot;lime_window_focus&quot;, 1, false))" line="326" static="1">
			<x path="cpp.Callable"><f a="">
	<d/>
	<x path="Void"/>
</f></x>
			<meta><m n=":value"><e><![CDATA[new cpp.Callable<Dynamic>(lime.system.CFFI.load("lime", "lime_window_focus", 1, false))]]></e></m></meta>
		</cffi_lime_window_focus>
		<cffi_lime_window_get_display expr="new cpp.Callable&lt;Dynamic&gt;(lime.system.CFFI.load(&quot;lime&quot;, &quot;lime_window_get_display&quot;, 1, false))" line="327" static="1">
			<x path="cpp.Callable"><f a="">
	<d/>
	<x path="Int"/>
</f></x>
			<meta><m n=":value"><e><![CDATA[new cpp.Callable<Dynamic>(lime.system.CFFI.load("lime", "lime_window_get_display", 1, false))]]></e></m></meta>
		</cffi_lime_window_get_display>
		<cffi_lime_window_get_enable_text_events expr="new cpp.Callable&lt;Dynamic&gt;(lime.system.CFFI.load(&quot;lime&quot;, &quot;lime_window_get_enable_text_events&quot;, 1, false))" line="328" static="1">
			<x path="cpp.Callable"><f a="">
	<d/>
	<x path="Bool"/>
</f></x>
			<meta><m n=":value"><e><![CDATA[new cpp.Callable<Dynamic>(lime.system.CFFI.load("lime", "lime_window_get_enable_text_events", 1, false))]]></e></m></meta>
		</cffi_lime_window_get_enable_text_events>
		<cffi_lime_window_get_height expr="new cpp.Callable&lt;Dynamic&gt;(lime.system.CFFI.load(&quot;lime&quot;, &quot;lime_window_get_height&quot;, 1, false))" line="329" static="1">
			<x path="cpp.Callable"><f a="">
	<d/>
	<x path="Int"/>
</f></x>
			<meta><m n=":value"><e><![CDATA[new cpp.Callable<Dynamic>(lime.system.CFFI.load("lime", "lime_window_get_height", 1, false))]]></e></m></meta>
		</cffi_lime_window_get_height>
		<cffi_lime_window_get_id expr="new cpp.Callable&lt;Dynamic&gt;(lime.system.CFFI.load(&quot;lime&quot;, &quot;lime_window_get_id&quot;, 1, false))" line="330" static="1">
			<x path="cpp.Callable"><f a="">
	<d/>
	<x path="Int"/>
</f></x>
			<meta><m n=":value"><e><![CDATA[new cpp.Callable<Dynamic>(lime.system.CFFI.load("lime", "lime_window_get_id", 1, false))]]></e></m></meta>
		</cffi_lime_window_get_id>
		<cffi_lime_window_get_width expr="new cpp.Callable&lt;Dynamic&gt;(lime.system.CFFI.load(&quot;lime&quot;, &quot;lime_window_get_width&quot;, 1, false))" line="331" static="1">
			<x path="cpp.Callable"><f a="">
	<d/>
	<x path="Int"/>
</f></x>
			<meta><m n=":value"><e><![CDATA[new cpp.Callable<Dynamic>(lime.system.CFFI.load("lime", "lime_window_get_width", 1, false))]]></e></m></meta>
		</cffi_lime_window_get_width>
		<cffi_lime_window_get_x expr="new cpp.Callable&lt;Dynamic&gt;(lime.system.CFFI.load(&quot;lime&quot;, &quot;lime_window_get_x&quot;, 1, false))" line="332" static="1">
			<x path="cpp.Callable"><f a="">
	<d/>
	<x path="Int"/>
</f></x>
			<meta><m n=":value"><e><![CDATA[new cpp.Callable<Dynamic>(lime.system.CFFI.load("lime", "lime_window_get_x", 1, false))]]></e></m></meta>
		</cffi_lime_window_get_x>
		<cffi_lime_window_get_y expr="new cpp.Callable&lt;Dynamic&gt;(lime.system.CFFI.load(&quot;lime&quot;, &quot;lime_window_get_y&quot;, 1, false))" line="333" static="1">
			<x path="cpp.Callable"><f a="">
	<d/>
	<x path="Int"/>
</f></x>
			<meta><m n=":value"><e><![CDATA[new cpp.Callable<Dynamic>(lime.system.CFFI.load("lime", "lime_window_get_y", 1, false))]]></e></m></meta>
		</cffi_lime_window_get_y>
		<cffi_lime_window_move expr="new cpp.Callable&lt;Dynamic -&gt; Int -&gt; Int&gt;(lime.system.CFFI.load(&quot;lime&quot;, &quot;lime_window_move&quot;, 3, false))" line="334" static="1">
			<x path="cpp.Callable"><f a="::">
	<d/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></x>
			<meta><m n=":value"><e><![CDATA[new cpp.Callable<Dynamic -> Int -> Int>(lime.system.CFFI.load("lime", "lime_window_move", 3, false))]]></e></m></meta>
		</cffi_lime_window_move>
		<cffi_lime_window_resize expr="new cpp.Callable&lt;Dynamic -&gt; Int -&gt; Int&gt;(lime.system.CFFI.load(&quot;lime&quot;, &quot;lime_window_resize&quot;, 3, false))" line="335" static="1">
			<x path="cpp.Callable"><f a="::">
	<d/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></x>
			<meta><m n=":value"><e><![CDATA[new cpp.Callable<Dynamic -> Int -> Int>(lime.system.CFFI.load("lime", "lime_window_resize", 3, false))]]></e></m></meta>
		</cffi_lime_window_resize>
		<cffi_lime_window_set_borderless expr="new cpp.Callable&lt;Dynamic -&gt; Bool&gt;(lime.system.CFFI.load(&quot;lime&quot;, &quot;lime_window_set_borderless&quot;, 2, false))" line="336" static="1">
			<x path="cpp.Callable"><f a=":">
	<d/>
	<x path="Bool"/>
	<x path="Bool"/>
</f></x>
			<meta><m n=":value"><e><![CDATA[new cpp.Callable<Dynamic -> Bool>(lime.system.CFFI.load("lime", "lime_window_set_borderless", 2, false))]]></e></m></meta>
		</cffi_lime_window_set_borderless>
		<cffi_lime_window_set_enable_text_events expr="new cpp.Callable&lt;Dynamic -&gt; Bool&gt;(lime.system.CFFI.load(&quot;lime&quot;, &quot;lime_window_set_enable_text_events&quot;, 2, false))" line="337" static="1">
			<x path="cpp.Callable"><f a=":">
	<d/>
	<x path="Bool"/>
	<x path="Void"/>
</f></x>
			<meta><m n=":value"><e><![CDATA[new cpp.Callable<Dynamic -> Bool>(lime.system.CFFI.load("lime", "lime_window_set_enable_text_events", 2, false))]]></e></m></meta>
		</cffi_lime_window_set_enable_text_events>
		<cffi_lime_window_set_fullscreen expr="new cpp.Callable&lt;Dynamic -&gt; Bool&gt;(lime.system.CFFI.load(&quot;lime&quot;, &quot;lime_window_set_fullscreen&quot;, 2, false))" line="338" static="1">
			<x path="cpp.Callable"><f a=":">
	<d/>
	<x path="Bool"/>
	<x path="Bool"/>
</f></x>
			<meta><m n=":value"><e><![CDATA[new cpp.Callable<Dynamic -> Bool>(lime.system.CFFI.load("lime", "lime_window_set_fullscreen", 2, false))]]></e></m></meta>
		</cffi_lime_window_set_fullscreen>
		<cffi_lime_window_set_icon expr="new cpp.Callable&lt;Dynamic -&gt; Dynamic&gt;(lime.system.CFFI.load(&quot;lime&quot;, &quot;lime_window_set_icon&quot;, 2, false))" line="339" static="1">
			<x path="cpp.Callable"><f a=":">
	<d/>
	<d/>
	<x path="Void"/>
</f></x>
			<meta><m n=":value"><e><![CDATA[new cpp.Callable<Dynamic -> Dynamic>(lime.system.CFFI.load("lime", "lime_window_set_icon", 2, false))]]></e></m></meta>
		</cffi_lime_window_set_icon>
		<cffi_lime_window_set_maximized expr="new cpp.Callable&lt;Dynamic -&gt; Bool&gt;(lime.system.CFFI.load(&quot;lime&quot;, &quot;lime_window_set_maximized&quot;, 2, false))" line="340" static="1">
			<x path="cpp.Callable"><f a=":">
	<d/>
	<x path="Bool"/>
	<x path="Bool"/>
</f></x>
			<meta><m n=":value"><e><![CDATA[new cpp.Callable<Dynamic -> Bool>(lime.system.CFFI.load("lime", "lime_window_set_maximized", 2, false))]]></e></m></meta>
		</cffi_lime_window_set_maximized>
		<cffi_lime_window_set_minimized expr="new cpp.Callable&lt;Dynamic -&gt; Bool&gt;(lime.system.CFFI.load(&quot;lime&quot;, &quot;lime_window_set_minimized&quot;, 2, false))" line="341" static="1">
			<x path="cpp.Callable"><f a=":">
	<d/>
	<x path="Bool"/>
	<x path="Bool"/>
</f></x>
			<meta><m n=":value"><e><![CDATA[new cpp.Callable<Dynamic -> Bool>(lime.system.CFFI.load("lime", "lime_window_set_minimized", 2, false))]]></e></m></meta>
		</cffi_lime_window_set_minimized>
		<cffi_lime_window_set_resizable expr="new cpp.Callable&lt;Dynamic -&gt; Bool&gt;(lime.system.CFFI.load(&quot;lime&quot;, &quot;lime_window_set_resizable&quot;, 2, false))" line="342" static="1">
			<x path="cpp.Callable"><f a=":">
	<d/>
	<x path="Bool"/>
	<x path="Bool"/>
</f></x>
			<meta><m n=":value"><e><![CDATA[new cpp.Callable<Dynamic -> Bool>(lime.system.CFFI.load("lime", "lime_window_set_resizable", 2, false))]]></e></m></meta>
		</cffi_lime_window_set_resizable>
		<cffi_lime_window_set_title expr="new cpp.Callable&lt;Dynamic -&gt; String&gt;(lime.system.CFFI.load(&quot;lime&quot;, &quot;lime_window_set_title&quot;, 2, false))" line="343" static="1">
			<x path="cpp.Callable"><f a=":">
	<d/>
	<c path="String"/>
	<d/>
</f></x>
			<meta><m n=":value"><e><![CDATA[new cpp.Callable<Dynamic -> String>(lime.system.CFFI.load("lime", "lime_window_set_title", 2, false))]]></e></m></meta>
		</cffi_lime_window_set_title>
		<handle public="1"><d/></handle>
		<parent><c path="lime.ui.Window"/></parent>
		<alert public="1" set="method" line="35"><f a="message:title">
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></alert>
		<close public="1" set="method" line="48"><f a=""><x path="Void"/></f></close>
		<create public="1" set="method" line="62"><f a="application">
	<c path="lime.app.Application"/>
	<x path="Void"/>
</f></create>
		<focus public="1" set="method" line="117"><f a=""><x path="Void"/></f></focus>
		<getDisplay public="1" set="method" line="130"><f a=""><c path="lime.system.Display"/></f></getDisplay>
		<getEnableTextEvents public="1" set="method" line="149"><f a=""><x path="Bool"/></f></getEnableTextEvents>
		<move public="1" set="method" line="164"><f a="x:y">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></move>
		<resize public="1" set="method" line="177"><f a="width:height">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></resize>
		<setBorderless public="1" set="method" line="190"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></setBorderless>
		<setEnableTextEvents public="1" set="method" line="204"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></setEnableTextEvents>
		<setFullscreen public="1" set="method" line="219"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></setFullscreen>
		<setIcon public="1" set="method" line="245"><f a="image">
	<c path="lime.graphics.Image"/>
	<x path="Void"/>
</f></setIcon>
		<setMaximized public="1" set="method" line="258"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></setMaximized>
		<setMinimized public="1" set="method" line="273"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></setMinimized>
		<setResizable public="1" set="method" line="288"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></setResizable>
		<setTitle public="1" set="method" line="307"><f a="value">
	<c path="String"/>
	<c path="String"/>
</f></setTitle>
		<new public="1" set="method" line="28"><f a="parent">
	<c path="lime.ui.Window"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>lime.system.CFFI.build()</e></m>
			<m n=":access"><e>lime.app.Application</e></m>
			<m n=":access"><e>lime.ui.Window</e></m>
		</meta>
	</class>
	<abstract path="lime._backend.native._NativeWindow.WindowFlags" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/_backend/native/NativeWindow.hx" private="1" module="lime._backend.native.NativeWindow">
		<this><x path="Int"/></this>
		<meta><m n=":enum"/></meta>
		<impl><class path="lime._backend.native._NativeWindow.WindowFlags_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/_backend/native/NativeWindow.hx" private="1" module="lime._backend.native.NativeWindow" extern="1">
	<WINDOW_FLAG_FULLSCREEN public="1" get="inline" set="null" expr="cast 0x00000001" line="352" static="1">
		<x path="lime._backend.native._NativeWindow.WindowFlags"/>
		<meta>
			<m n=":value"><e>cast 0x00000001</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</WINDOW_FLAG_FULLSCREEN>
	<WINDOW_FLAG_BORDERLESS public="1" get="inline" set="null" expr="cast 0x00000002" line="353" static="1">
		<x path="lime._backend.native._NativeWindow.WindowFlags"/>
		<meta>
			<m n=":value"><e>cast 0x00000002</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</WINDOW_FLAG_BORDERLESS>
	<WINDOW_FLAG_RESIZABLE public="1" get="inline" set="null" expr="cast 0x00000004" line="354" static="1">
		<x path="lime._backend.native._NativeWindow.WindowFlags"/>
		<meta>
			<m n=":value"><e>cast 0x00000004</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</WINDOW_FLAG_RESIZABLE>
	<WINDOW_FLAG_HARDWARE public="1" get="inline" set="null" expr="cast 0x00000008" line="355" static="1">
		<x path="lime._backend.native._NativeWindow.WindowFlags"/>
		<meta>
			<m n=":value"><e>cast 0x00000008</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</WINDOW_FLAG_HARDWARE>
	<WINDOW_FLAG_VSYNC public="1" get="inline" set="null" expr="cast 0x00000010" line="356" static="1">
		<x path="lime._backend.native._NativeWindow.WindowFlags"/>
		<meta>
			<m n=":value"><e>cast 0x00000010</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</WINDOW_FLAG_VSYNC>
	<WINDOW_FLAG_HW_AA public="1" get="inline" set="null" expr="cast 0x00000020" line="357" static="1">
		<x path="lime._backend.native._NativeWindow.WindowFlags"/>
		<meta>
			<m n=":value"><e>cast 0x00000020</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</WINDOW_FLAG_HW_AA>
	<WINDOW_FLAG_HW_AA_HIRES public="1" get="inline" set="null" expr="cast 0x00000060" line="358" static="1">
		<x path="lime._backend.native._NativeWindow.WindowFlags"/>
		<meta>
			<m n=":value"><e>cast 0x00000060</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</WINDOW_FLAG_HW_AA_HIRES>
	<WINDOW_FLAG_ALLOW_SHADERS public="1" get="inline" set="null" expr="cast 0x00000080" line="359" static="1">
		<x path="lime._backend.native._NativeWindow.WindowFlags"/>
		<meta>
			<m n=":value"><e>cast 0x00000080</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</WINDOW_FLAG_ALLOW_SHADERS>
	<WINDOW_FLAG_REQUIRE_SHADERS public="1" get="inline" set="null" expr="cast 0x00000100" line="360" static="1">
		<x path="lime._backend.native._NativeWindow.WindowFlags"/>
		<meta>
			<m n=":value"><e>cast 0x00000100</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</WINDOW_FLAG_REQUIRE_SHADERS>
	<WINDOW_FLAG_DEPTH_BUFFER public="1" get="inline" set="null" expr="cast 0x00000200" line="361" static="1">
		<x path="lime._backend.native._NativeWindow.WindowFlags"/>
		<meta>
			<m n=":value"><e>cast 0x00000200</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</WINDOW_FLAG_DEPTH_BUFFER>
	<WINDOW_FLAG_STENCIL_BUFFER public="1" get="inline" set="null" expr="cast 0x00000400" line="362" static="1">
		<x path="lime._backend.native._NativeWindow.WindowFlags"/>
		<meta>
			<m n=":value"><e>cast 0x00000400</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</WINDOW_FLAG_STENCIL_BUFFER>
	<WINDOW_FLAG_ALLOW_HIGHDPI public="1" get="inline" set="null" expr="cast 0x00000800" line="363" static="1">
		<x path="lime._backend.native._NativeWindow.WindowFlags"/>
		<meta>
			<m n=":value"><e>cast 0x00000800</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</WINDOW_FLAG_ALLOW_HIGHDPI>
	<meta>
		<m n=":final"/>
		<m n=":enum"/>
	</meta>
</class></impl>
	</abstract>
	<class path="lime._backend.native._NativeWindow.WindowFlags_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/_backend/native/NativeWindow.hx" private="1" module="lime._backend.native.NativeWindow" extern="1">
		<WINDOW_FLAG_FULLSCREEN public="1" get="inline" set="null" expr="cast 0x00000001" line="352" static="1">
			<x path="lime._backend.native._NativeWindow.WindowFlags"/>
			<meta>
				<m n=":value"><e>cast 0x00000001</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</WINDOW_FLAG_FULLSCREEN>
		<WINDOW_FLAG_BORDERLESS public="1" get="inline" set="null" expr="cast 0x00000002" line="353" static="1">
			<x path="lime._backend.native._NativeWindow.WindowFlags"/>
			<meta>
				<m n=":value"><e>cast 0x00000002</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</WINDOW_FLAG_BORDERLESS>
		<WINDOW_FLAG_RESIZABLE public="1" get="inline" set="null" expr="cast 0x00000004" line="354" static="1">
			<x path="lime._backend.native._NativeWindow.WindowFlags"/>
			<meta>
				<m n=":value"><e>cast 0x00000004</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</WINDOW_FLAG_RESIZABLE>
		<WINDOW_FLAG_HARDWARE public="1" get="inline" set="null" expr="cast 0x00000008" line="355" static="1">
			<x path="lime._backend.native._NativeWindow.WindowFlags"/>
			<meta>
				<m n=":value"><e>cast 0x00000008</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</WINDOW_FLAG_HARDWARE>
		<WINDOW_FLAG_VSYNC public="1" get="inline" set="null" expr="cast 0x00000010" line="356" static="1">
			<x path="lime._backend.native._NativeWindow.WindowFlags"/>
			<meta>
				<m n=":value"><e>cast 0x00000010</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</WINDOW_FLAG_VSYNC>
		<WINDOW_FLAG_HW_AA public="1" get="inline" set="null" expr="cast 0x00000020" line="357" static="1">
			<x path="lime._backend.native._NativeWindow.WindowFlags"/>
			<meta>
				<m n=":value"><e>cast 0x00000020</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</WINDOW_FLAG_HW_AA>
		<WINDOW_FLAG_HW_AA_HIRES public="1" get="inline" set="null" expr="cast 0x00000060" line="358" static="1">
			<x path="lime._backend.native._NativeWindow.WindowFlags"/>
			<meta>
				<m n=":value"><e>cast 0x00000060</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</WINDOW_FLAG_HW_AA_HIRES>
		<WINDOW_FLAG_ALLOW_SHADERS public="1" get="inline" set="null" expr="cast 0x00000080" line="359" static="1">
			<x path="lime._backend.native._NativeWindow.WindowFlags"/>
			<meta>
				<m n=":value"><e>cast 0x00000080</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</WINDOW_FLAG_ALLOW_SHADERS>
		<WINDOW_FLAG_REQUIRE_SHADERS public="1" get="inline" set="null" expr="cast 0x00000100" line="360" static="1">
			<x path="lime._backend.native._NativeWindow.WindowFlags"/>
			<meta>
				<m n=":value"><e>cast 0x00000100</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</WINDOW_FLAG_REQUIRE_SHADERS>
		<WINDOW_FLAG_DEPTH_BUFFER public="1" get="inline" set="null" expr="cast 0x00000200" line="361" static="1">
			<x path="lime._backend.native._NativeWindow.WindowFlags"/>
			<meta>
				<m n=":value"><e>cast 0x00000200</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</WINDOW_FLAG_DEPTH_BUFFER>
		<WINDOW_FLAG_STENCIL_BUFFER public="1" get="inline" set="null" expr="cast 0x00000400" line="362" static="1">
			<x path="lime._backend.native._NativeWindow.WindowFlags"/>
			<meta>
				<m n=":value"><e>cast 0x00000400</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</WINDOW_FLAG_STENCIL_BUFFER>
		<WINDOW_FLAG_ALLOW_HIGHDPI public="1" get="inline" set="null" expr="cast 0x00000800" line="363" static="1">
			<x path="lime._backend.native._NativeWindow.WindowFlags"/>
			<meta>
				<m n=":value"><e>cast 0x00000800</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</WINDOW_FLAG_ALLOW_HIGHDPI>
		<meta>
			<m n=":final"/>
			<m n=":enum"/>
		</meta>
	</class>
	<class path="lime.app.IModule" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/app/IModule.hx" interface="1">
		<onGamepadAxisMove public="1" set="method">
			<f a="gamepad:axis:value">
				<c path="lime.ui.Gamepad"/>
				<x path="lime.ui.GamepadAxis"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Called when a gamepad axis move event is fired
	 * @param	gamepad	The current gamepad
	 * @param	axis	The axis that was moved
	 * @param	value	The axis value (between 0 and 1)</haxe_doc>
		</onGamepadAxisMove>
		<onGamepadButtonDown public="1" set="method">
			<f a="gamepad:button">
				<c path="lime.ui.Gamepad"/>
				<x path="lime.ui.GamepadButton"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Called when a gamepad button down event is fired
	 * @param	gamepad	The current gamepad
	 * @param	button	The button that was pressed</haxe_doc>
		</onGamepadButtonDown>
		<onGamepadButtonUp public="1" set="method">
			<f a="gamepad:button">
				<c path="lime.ui.Gamepad"/>
				<x path="lime.ui.GamepadButton"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Called when a gamepad button up event is fired
	 * @param	gamepad	The current gamepad
	 * @param	button	The button that was released</haxe_doc>
		</onGamepadButtonUp>
		<onGamepadConnect public="1" set="method">
			<f a="gamepad">
				<c path="lime.ui.Gamepad"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Called when a gamepad is connected
	 * @param	gamepad	The gamepad that was connected</haxe_doc>
		</onGamepadConnect>
		<onGamepadDisconnect public="1" set="method">
			<f a="gamepad">
				<c path="lime.ui.Gamepad"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Called when a gamepad is disconnected
	 * @param	gamepad	The gamepad that was disconnected</haxe_doc>
		</onGamepadDisconnect>
		<onJoystickAxisMove public="1" set="method">
			<f a="joystick:axis:value">
				<c path="lime.ui.Joystick"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Called when a joystick axis move event is fired
	 * @param	joystick	The current joystick
	 * @param	axis	The axis that was moved
	 * @param	value	The axis value (between 0 and 1)</haxe_doc>
		</onJoystickAxisMove>
		<onJoystickButtonDown public="1" set="method">
			<f a="joystick:button">
				<c path="lime.ui.Joystick"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Called when a joystick button down event is fired
	 * @param	joystick	The current joystick
	 * @param	button	The button that was pressed</haxe_doc>
		</onJoystickButtonDown>
		<onJoystickButtonUp public="1" set="method">
			<f a="joystick:button">
				<c path="lime.ui.Joystick"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Called when a joystick button up event is fired
	 * @param	joystick	The current joystick
	 * @param	button	The button that was released</haxe_doc>
		</onJoystickButtonUp>
		<onJoystickConnect public="1" set="method">
			<f a="joystick">
				<c path="lime.ui.Joystick"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Called when a joystick is connected
	 * @param	joystick	The joystick that was connected</haxe_doc>
		</onJoystickConnect>
		<onJoystickDisconnect public="1" set="method">
			<f a="joystick">
				<c path="lime.ui.Joystick"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Called when a joystick is disconnected
	 * @param	joystick	The joystick that was disconnected</haxe_doc>
		</onJoystickDisconnect>
		<onJoystickHatMove public="1" set="method">
			<f a="joystick:hat:position">
				<c path="lime.ui.Joystick"/>
				<x path="Int"/>
				<x path="lime.ui.JoystickHatPosition"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Called when a joystick hat move event is fired
	 * @param	joystick	The current joystick
	 * @param	hat	The hat that was moved
	 * @param	position	The current hat position</haxe_doc>
		</onJoystickHatMove>
		<onJoystickTrackballMove public="1" set="method">
			<f a="joystick:trackball:value">
				<c path="lime.ui.Joystick"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Called when a joystick axis move event is fired
	 * @param	joystick	The current joystick
	 * @param	trackball	The trackball that was moved
	 * @param	value	The trackball value (between 0 and 1)</haxe_doc>
		</onJoystickTrackballMove>
		<onKeyDown public="1" set="method">
			<f a="window:keyCode:modifier">
				<c path="lime.ui.Window"/>
				<x path="lime.ui.KeyCode"/>
				<x path="lime.ui.KeyModifier"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Called when a key down event is fired
	 * @param	window	The window dispatching the event
	 * @param	keyCode	The code of the key that was pressed
	 * @param	modifier	The modifier of the key that was pressed</haxe_doc>
		</onKeyDown>
		<onKeyUp public="1" set="method">
			<f a="window:keyCode:modifier">
				<c path="lime.ui.Window"/>
				<x path="lime.ui.KeyCode"/>
				<x path="lime.ui.KeyModifier"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Called when a key up event is fired
	 * @param	window	The window dispatching the event
	 * @param	keyCode	The code of the key that was released
	 * @param	modifier	The modifier of the key that was released</haxe_doc>
		</onKeyUp>
		<onModuleExit public="1" set="method">
			<f a="code">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Called when the module is exiting</haxe_doc>
		</onModuleExit>
		<onMouseDown public="1" set="method">
			<f a="window:x:y:button">
				<c path="lime.ui.Window"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Called when a mouse down event is fired
	 * @param	window	The window dispatching the event
	 * @param	x	The current x coordinate of the mouse
	 * @param	y	The current y coordinate of the mouse
	 * @param	button	The ID of the mouse button that was pressed</haxe_doc>
		</onMouseDown>
		<onMouseMove public="1" set="method">
			<f a="window:x:y">
				<c path="lime.ui.Window"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Called when a mouse move event is fired
	 * @param	window	The window dispatching the event
	 * @param	x	The current x coordinate of the mouse
	 * @param	y	The current y coordinate of the mouse
	 * @param	button	The ID of the mouse button that was pressed</haxe_doc>
		</onMouseMove>
		<onMouseMoveRelative public="1" set="method">
			<f a="window:x:y">
				<c path="lime.ui.Window"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Called when a mouse move relative event is fired
	 * @param	window	The window dispatching the event
	 * @param	x	The x movement of the mouse
	 * @param	y	The y movement of the mouse
	 * @param	button	The ID of the mouse button that was pressed</haxe_doc>
		</onMouseMoveRelative>
		<onMouseUp public="1" set="method">
			<f a="window:x:y:button">
				<c path="lime.ui.Window"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Called when a mouse up event is fired
	 * @param	window	The window dispatching the event
	 * @param	x	The current x coordinate of the mouse
	 * @param	y	The current y coordinate of the mouse
	 * @param	button	The ID of the button that was released</haxe_doc>
		</onMouseUp>
		<onMouseWheel public="1" set="method">
			<f a="window:deltaX:deltaY">
				<c path="lime.ui.Window"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Called when a mouse wheel event is fired
	 * @param	window	The window dispatching the event
	 * @param	deltaX	The amount of horizontal scrolling (if applicable)
	 * @param	deltaY	The amount of vertical scrolling (if applicable)</haxe_doc>
		</onMouseWheel>
		<onPreloadComplete public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Called when a preload complete event is fired</haxe_doc>
		</onPreloadComplete>
		<onPreloadProgress public="1" set="method">
			<f a="loaded:total">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Called when a preload progress event is fired
	 * @param	loaded	The number of items that are loaded
	 * @param	total	The total number of items will be loaded</haxe_doc>
		</onPreloadProgress>
		<onRenderContextLost public="1" set="method">
			<f a="renderer">
				<c path="lime.graphics.Renderer"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Called when a render context is lost
	 * @param	renderer	The renderer dispatching the event</haxe_doc>
		</onRenderContextLost>
		<onRenderContextRestored public="1" set="method">
			<f a="renderer:context">
				<c path="lime.graphics.Renderer"/>
				<e path="lime.graphics.RenderContext"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Called when a render context is restored
	 * @param	renderer	The renderer dispatching the event
	 * @param	context	The current render context</haxe_doc>
		</onRenderContextRestored>
		<onTextEdit public="1" set="method">
			<f a="window:text:start:length">
				<c path="lime.ui.Window"/>
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Called when a text edit event is fired
	 * @param	window	The window dispatching the event
	 * @param	text	The current replacement text
	 * @param	start	The starting index for the edit
	 * @param	length	The length of the edit</haxe_doc>
		</onTextEdit>
		<onTextInput public="1" set="method">
			<f a="window:text">
				<c path="lime.ui.Window"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Called when a text input event is fired
	 * @param	window	The window dispatching the event
	 * @param	text	The current input text</haxe_doc>
		</onTextInput>
		<onTouchEnd public="1" set="method">
			<f a="touch">
				<c path="lime.ui.Touch"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Called when a touch end event is fired
	 * @param	touch	The current touch object</haxe_doc>
		</onTouchEnd>
		<onTouchMove public="1" set="method">
			<f a="touch">
				<c path="lime.ui.Touch"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Called when a touch move event is fired
	 * @param	touch	The current touch object</haxe_doc>
		</onTouchMove>
		<onTouchStart public="1" set="method">
			<f a="touch">
				<c path="lime.ui.Touch"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Called when a touch start event is fired
	 * @param	touch	The current touch object</haxe_doc>
		</onTouchStart>
		<onWindowActivate public="1" set="method">
			<f a="window">
				<c path="lime.ui.Window"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Called when a window activate event is fired
	 * @param	window	The window dispatching the event</haxe_doc>
		</onWindowActivate>
		<onWindowClose public="1" set="method">
			<f a="window">
				<c path="lime.ui.Window"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Called when a window close event is fired
	 * @param	window	The window dispatching the event</haxe_doc>
		</onWindowClose>
		<onWindowCreate public="1" set="method">
			<f a="window">
				<c path="lime.ui.Window"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Called when a window create event is fired
	 * @param	window	The window dispatching the event</haxe_doc>
		</onWindowCreate>
		<onWindowDeactivate public="1" set="method">
			<f a="window">
				<c path="lime.ui.Window"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Called when a window deactivate event is fired
	 * @param	window	The window dispatching the event</haxe_doc>
		</onWindowDeactivate>
		<onWindowDropFile public="1" set="method">
			<f a="window:file">
				<c path="lime.ui.Window"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Called when a window drop file event is fired
	 * @param	window	The window dispatching the event</haxe_doc>
		</onWindowDropFile>
		<onWindowEnter public="1" set="method">
			<f a="window">
				<c path="lime.ui.Window"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Called when a window enter event is fired
	 * @param	window	The window dispatching the event</haxe_doc>
		</onWindowEnter>
		<onWindowFocusIn public="1" set="method">
			<f a="window">
				<c path="lime.ui.Window"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Called when a window focus in event is fired
	 * @param	window	The window dispatching the event</haxe_doc>
		</onWindowFocusIn>
		<onWindowFocusOut public="1" set="method">
			<f a="window">
				<c path="lime.ui.Window"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Called when a window focus out event is fired
	 * @param	window	The window dispatching the event</haxe_doc>
		</onWindowFocusOut>
		<onWindowFullscreen public="1" set="method">
			<f a="window">
				<c path="lime.ui.Window"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Called when a window enters fullscreen
	 * @param	window	The window dispatching the event</haxe_doc>
		</onWindowFullscreen>
		<onWindowLeave public="1" set="method">
			<f a="window">
				<c path="lime.ui.Window"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Called when a window leave event is fired
	 * @param	window	The window dispatching the event</haxe_doc>
		</onWindowLeave>
		<onWindowMove public="1" set="method">
			<f a="window:x:y">
				<c path="lime.ui.Window"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Called when a window move event is fired
	 * @param	window	The window dispatching the event
	 * @param	x	The x position of the window in desktop coordinates
	 * @param	y	The y position of the window in desktop coordinates</haxe_doc>
		</onWindowMove>
		<onWindowMinimize public="1" set="method">
			<f a="window">
				<c path="lime.ui.Window"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Called when a window is minimized
	 * @param	window	The window dispatching the event</haxe_doc>
		</onWindowMinimize>
		<onWindowResize public="1" set="method">
			<f a="window:width:height">
				<c path="lime.ui.Window"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Called when a window resize event is fired
	 * @param	window	The window dispatching the event
	 * @param	width	The width of the window
	 * @param	height	The height of the window</haxe_doc>
		</onWindowResize>
		<onWindowRestore public="1" set="method">
			<f a="window">
				<c path="lime.ui.Window"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Called when a window is restored from being minimized or fullscreen
	 * @param	window	The window dispatching the event</haxe_doc>
		</onWindowRestore>
		<render public="1" set="method">
			<f a="renderer">
				<c path="lime.graphics.Renderer"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Called when a render event is fired
	 * @param	renderer	The renderer dispatching the event</haxe_doc>
		</render>
		<update public="1" set="method">
			<f a="deltaTime">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Called when an update event is fired
	 * @param	deltaTime	The amount of time in milliseconds that has elapsed since the last update</haxe_doc>
		</update>
	</class>
	<class path="lime.app.Module" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/app/Module.hx">
		<implements path="lime.app.IModule"/>
		<onExit public="1" expr="new Event&lt;Int&gt;()">
			<c path="lime.app.Event_Int_Void"><f a="">
	<x path="Int"/>
	<x path="Void"/>
</f></c>
			<meta><m n=":value"><e><![CDATA[new Event<Int>()]]></e></m></meta>
			<haxe_doc>* Exit events are dispatched when the application is exiting</haxe_doc>
		</onExit>
		<onGamepadAxisMove public="1" set="method" line="39">
			<f a="gamepad:axis:value">
				<c path="lime.ui.Gamepad"/>
				<x path="lime.ui.GamepadAxis"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Called when a gamepad axis move event is fired
	 * @param	gamepad	The current gamepad
	 * @param	axis	The axis that was moved
	 * @param	value	The axis value (between 0 and 1)</haxe_doc>
		</onGamepadAxisMove>
		<onGamepadButtonDown public="1" set="method" line="47">
			<f a="gamepad:button">
				<c path="lime.ui.Gamepad"/>
				<x path="lime.ui.GamepadButton"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Called when a gamepad button down event is fired
	 * @param	gamepad	The current gamepad
	 * @param	button	The button that was pressed</haxe_doc>
		</onGamepadButtonDown>
		<onGamepadButtonUp public="1" set="method" line="55">
			<f a="gamepad:button">
				<c path="lime.ui.Gamepad"/>
				<x path="lime.ui.GamepadButton"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Called when a gamepad button up event is fired
	 * @param	gamepad	The current gamepad
	 * @param	button	The button that was released</haxe_doc>
		</onGamepadButtonUp>
		<onGamepadConnect public="1" set="method" line="62">
			<f a="gamepad">
				<c path="lime.ui.Gamepad"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Called when a gamepad is connected
	 * @param	gamepad	The gamepad that was connected</haxe_doc>
		</onGamepadConnect>
		<onGamepadDisconnect public="1" set="method" line="73">
			<f a="gamepad">
				<c path="lime.ui.Gamepad"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Called when a gamepad is disconnected
	 * @param	gamepad	The gamepad that was disconnected</haxe_doc>
		</onGamepadDisconnect>
		<onJoystickAxisMove public="1" set="method" line="82">
			<f a="joystick:axis:value">
				<c path="lime.ui.Joystick"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Called when a joystick axis move event is fired
	 * @param	joystick	The current joystick
	 * @param	axis	The axis that was moved
	 * @param	value	The axis value (between 0 and 1)</haxe_doc>
		</onJoystickAxisMove>
		<onJoystickButtonDown public="1" set="method" line="90">
			<f a="joystick:button">
				<c path="lime.ui.Joystick"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Called when a joystick button down event is fired
	 * @param	joystick	The current joystick
	 * @param	button	The button that was pressed</haxe_doc>
		</onJoystickButtonDown>
		<onJoystickButtonUp public="1" set="method" line="98">
			<f a="joystick:button">
				<c path="lime.ui.Joystick"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Called when a joystick button up event is fired
	 * @param	joystick	The current joystick
	 * @param	button	The button that was released</haxe_doc>
		</onJoystickButtonUp>
		<onJoystickConnect public="1" set="method" line="105">
			<f a="joystick">
				<c path="lime.ui.Joystick"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Called when a joystick is connected
	 * @param	joystick	The joystick that was connected</haxe_doc>
		</onJoystickConnect>
		<onJoystickDisconnect public="1" set="method" line="112">
			<f a="joystick">
				<c path="lime.ui.Joystick"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Called when a joystick is disconnected
	 * @param	joystick	The joystick that was disconnected</haxe_doc>
		</onJoystickDisconnect>
		<onJoystickHatMove public="1" set="method" line="121">
			<f a="joystick:hat:position">
				<c path="lime.ui.Joystick"/>
				<x path="Int"/>
				<x path="lime.ui.JoystickHatPosition"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Called when a joystick hat move event is fired
	 * @param	joystick	The current joystick
	 * @param	hat	The hat that was moved
	 * @param	position	The current hat position</haxe_doc>
		</onJoystickHatMove>
		<onJoystickTrackballMove public="1" set="method" line="130">
			<f a="joystick:trackball:value">
				<c path="lime.ui.Joystick"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Called when a joystick axis move event is fired
	 * @param	joystick	The current joystick
	 * @param	trackball	The trackball that was moved
	 * @param	value	The trackball value (between 0 and 1)</haxe_doc>
		</onJoystickTrackballMove>
		<onKeyDown public="1" set="method" line="139">
			<f a="window:keyCode:modifier">
				<c path="lime.ui.Window"/>
				<x path="lime.ui.KeyCode"/>
				<x path="lime.ui.KeyModifier"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Called when a key down event is fired
	 * @param	window	The window dispatching the event
	 * @param	keyCode	The code of the key that was pressed
	 * @param	modifier	The modifier of the key that was pressed</haxe_doc>
		</onKeyDown>
		<onKeyUp public="1" set="method" line="148">
			<f a="window:keyCode:modifier">
				<c path="lime.ui.Window"/>
				<x path="lime.ui.KeyCode"/>
				<x path="lime.ui.KeyModifier"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Called when a key up event is fired
	 * @param	window	The window dispatching the event
	 * @param	keyCode	The code of the key that was released
	 * @param	modifier	The modifier of the key that was released</haxe_doc>
		</onKeyUp>
		<onModuleExit public="1" set="method" line="154">
			<f a="code">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Called when the module is exiting</haxe_doc>
		</onModuleExit>
		<onMouseDown public="1" set="method" line="164">
			<f a="window:x:y:button">
				<c path="lime.ui.Window"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Called when a mouse down event is fired
	 * @param	window	The window dispatching the event
	 * @param	x	The current x coordinate of the mouse
	 * @param	y	The current y coordinate of the mouse
	 * @param	button	The ID of the mouse button that was pressed</haxe_doc>
		</onMouseDown>
		<onMouseMove public="1" set="method" line="174">
			<f a="window:x:y">
				<c path="lime.ui.Window"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Called when a mouse move event is fired
	 * @param	window	The window dispatching the event
	 * @param	x	The current x coordinate of the mouse
	 * @param	y	The current y coordinate of the mouse
	 * @param	button	The ID of the mouse button that was pressed</haxe_doc>
		</onMouseMove>
		<onMouseMoveRelative public="1" set="method" line="184">
			<f a="window:x:y">
				<c path="lime.ui.Window"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Called when a mouse move relative event is fired
	 * @param	window	The window dispatching the event
	 * @param	x	The x movement of the mouse
	 * @param	y	The y movement of the mouse
	 * @param	button	The ID of the mouse button that was pressed</haxe_doc>
		</onMouseMoveRelative>
		<onMouseUp public="1" set="method" line="194">
			<f a="window:x:y:button">
				<c path="lime.ui.Window"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Called when a mouse up event is fired
	 * @param	window	The window dispatching the event
	 * @param	x	The current x coordinate of the mouse
	 * @param	y	The current y coordinate of the mouse
	 * @param	button	The ID of the button that was released</haxe_doc>
		</onMouseUp>
		<onMouseWheel public="1" set="method" line="203">
			<f a="window:deltaX:deltaY">
				<c path="lime.ui.Window"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Called when a mouse wheel event is fired
	 * @param	window	The window dispatching the event
	 * @param	deltaX	The amount of horizontal scrolling (if applicable)
	 * @param	deltaY	The amount of vertical scrolling (if applicable)</haxe_doc>
		</onMouseWheel>
		<onPreloadComplete public="1" set="method" line="209">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Called when a preload complete event is fired</haxe_doc>
		</onPreloadComplete>
		<onPreloadProgress public="1" set="method" line="217">
			<f a="loaded:total">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Called when a preload progress event is fired
	 * @param	loaded	The number of items that are loaded
	 * @param	total	The total number of items will be loaded</haxe_doc>
		</onPreloadProgress>
		<onRenderContextLost public="1" set="method" line="224">
			<f a="renderer">
				<c path="lime.graphics.Renderer"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Called when a render context is lost
	 * @param	renderer	The renderer dispatching the event</haxe_doc>
		</onRenderContextLost>
		<onRenderContextRestored public="1" set="method" line="232">
			<f a="renderer:context">
				<c path="lime.graphics.Renderer"/>
				<e path="lime.graphics.RenderContext"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Called when a render context is restored
	 * @param	renderer	The renderer dispatching the event
	 * @param	context	The current render context</haxe_doc>
		</onRenderContextRestored>
		<onTextEdit public="1" set="method" line="242">
			<f a="window:text:start:length">
				<c path="lime.ui.Window"/>
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Called when a text edit event is fired
	 * @param	window	The window dispatching the event
	 * @param	text	The current replacement text
	 * @param	start	The starting index for the edit
	 * @param	length	The length of the edit</haxe_doc>
		</onTextEdit>
		<onTextInput public="1" set="method" line="250">
			<f a="window:text">
				<c path="lime.ui.Window"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Called when a text input event is fired
	 * @param	window	The window dispatching the event
	 * @param	text	The current input text</haxe_doc>
		</onTextInput>
		<onTouchEnd public="1" set="method" line="257">
			<f a="touch">
				<c path="lime.ui.Touch"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Called when a touch end event is fired
	 * @param	touch	The current touch object</haxe_doc>
		</onTouchEnd>
		<onTouchMove public="1" set="method" line="264">
			<f a="touch">
				<c path="lime.ui.Touch"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Called when a touch move event is fired
	 * @param	touch	The current touch object</haxe_doc>
		</onTouchMove>
		<onTouchStart public="1" set="method" line="271">
			<f a="touch">
				<c path="lime.ui.Touch"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Called when a touch start event is fired
	 * @param	touch	The current touch object</haxe_doc>
		</onTouchStart>
		<onWindowActivate public="1" set="method" line="278">
			<f a="window">
				<c path="lime.ui.Window"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Called when a window activate event is fired
	 * @param	window	The window dispatching the event</haxe_doc>
		</onWindowActivate>
		<onWindowClose public="1" set="method" line="285">
			<f a="window">
				<c path="lime.ui.Window"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Called when a window close event is fired
	 * @param	window	The window dispatching the event</haxe_doc>
		</onWindowClose>
		<onWindowCreate public="1" set="method" line="292">
			<f a="window">
				<c path="lime.ui.Window"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Called when a window create event is fired
	 * @param	window	The window dispatching the event</haxe_doc>
		</onWindowCreate>
		<onWindowDeactivate public="1" set="method" line="299">
			<f a="window">
				<c path="lime.ui.Window"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Called when a window deactivate event is fired
	 * @param	window	The window dispatching the event</haxe_doc>
		</onWindowDeactivate>
		<onWindowDropFile public="1" set="method" line="306">
			<f a="window:file">
				<c path="lime.ui.Window"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Called when a window drop file event is fired
	 * @param	window	The window dispatching the event</haxe_doc>
		</onWindowDropFile>
		<onWindowEnter public="1" set="method" line="313">
			<f a="window">
				<c path="lime.ui.Window"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Called when a window enter event is fired
	 * @param	window	The window dispatching the event</haxe_doc>
		</onWindowEnter>
		<onWindowFocusIn public="1" set="method" line="320">
			<f a="window">
				<c path="lime.ui.Window"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Called when a window focus in event is fired
	 * @param	window	The window dispatching the event</haxe_doc>
		</onWindowFocusIn>
		<onWindowFocusOut public="1" set="method" line="327">
			<f a="window">
				<c path="lime.ui.Window"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Called when a window focus out event is fired
	 * @param	window	The window dispatching the event</haxe_doc>
		</onWindowFocusOut>
		<onWindowFullscreen public="1" set="method" line="334">
			<f a="window">
				<c path="lime.ui.Window"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Called when a window enters fullscreen
	 * @param	window	The window dispatching the event</haxe_doc>
		</onWindowFullscreen>
		<onWindowLeave public="1" set="method" line="341">
			<f a="window">
				<c path="lime.ui.Window"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Called when a window leave event is fired
	 * @param	window	The window dispatching the event</haxe_doc>
		</onWindowLeave>
		<onWindowMove public="1" set="method" line="350">
			<f a="window:x:y">
				<c path="lime.ui.Window"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Called when a window move event is fired
	 * @param	window	The window dispatching the event
	 * @param	x	The x position of the window in desktop coordinates
	 * @param	y	The y position of the window in desktop coordinates</haxe_doc>
		</onWindowMove>
		<onWindowMinimize public="1" set="method" line="357">
			<f a="window">
				<c path="lime.ui.Window"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Called when a window is minimized
	 * @param	window	The window dispatching the event</haxe_doc>
		</onWindowMinimize>
		<onWindowResize public="1" set="method" line="366">
			<f a="window:width:height">
				<c path="lime.ui.Window"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Called when a window resize event is fired
	 * @param	window	The window dispatching the event
	 * @param	width	The width of the window
	 * @param	height	The height of the window</haxe_doc>
		</onWindowResize>
		<onWindowRestore public="1" set="method" line="373">
			<f a="window">
				<c path="lime.ui.Window"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Called when a window is restored from being minimized or fullscreen
	 * @param	window	The window dispatching the event</haxe_doc>
		</onWindowRestore>
		<render public="1" set="method" line="380">
			<f a="renderer">
				<c path="lime.graphics.Renderer"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Called when a render event is fired
	 * @param	renderer	The renderer dispatching the event</haxe_doc>
		</render>
		<update public="1" set="method" line="387">
			<f a="deltaTime">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Called when an update event is fired
	 * @param	deltaTime	The amount of time in milliseconds that has elapsed since the last update</haxe_doc>
		</update>
		<new public="1" set="method" line="26"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="lime.app.Application" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/app/Application.hx">
		<extends path="lime.app.Module"/>
		<current public="1" set="null" static="1"><c path="lime.app.Application"/></current>
		<config public="1" set="null"><t path="lime.app.Config"/></config>
		<frameRate public="1" get="accessor" set="accessor"><x path="Float"/></frameRate>
		<modules public="1" set="null"><c path="Array"><c path="lime.app.IModule"/></c></modules>
		<preloader public="1" set="null"><c path="lime.app.Preloader"/></preloader>
		<onUpdate public="1" expr="new Event&lt;Int&gt;()">
			<c path="lime.app.Event_Int_Void"><f a="">
	<x path="Int"/>
	<x path="Void"/>
</f></c>
			<meta><m n=":value"><e><![CDATA[new Event<Int>()]]></e></m></meta>
			<haxe_doc>* Update events are dispatched each frame (usually just before rendering)</haxe_doc>
		</onUpdate>
		<renderer public="1" get="accessor" set="null"><c path="lime.graphics.Renderer"/></renderer>
		<renderers public="1" set="null"><c path="Array"><c path="lime.graphics.Renderer"/></c></renderers>
		<window public="1" get="accessor" set="null"><c path="lime.ui.Window"/></window>
		<windows public="1" set="null"><c path="Array"><c path="lime.ui.Window"/></c></windows>
		<backend>
			<t path="lime.app._Application.ApplicationBackend"/>
			<meta><m n=":noCompletion"/></meta>
		</backend>
		<windowByID>
			<x path="Map">
				<x path="Int"/>
				<c path="lime.ui.Window"/>
			</x>
			<meta><m n=":noCompletion"/></meta>
		</windowByID>
		<addModule public="1" set="method" line="80">
			<f a="module">
				<c path="lime.app.IModule"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Adds a new module to the Application
	 * @param	module	A module to add</haxe_doc>
		</addModule>
		<addRenderer public="1" set="method" line="108">
			<f a="renderer">
				<c path="lime.graphics.Renderer"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Adds a new Renderer to the Application. By default, this is
	 * called automatically by create()
	 * @param	renderer	A Renderer object to add</haxe_doc>
		</addRenderer>
		<create public="1" set="method" line="125">
			<f a="config">
				<t path="lime.app.Config"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Initializes the Application, using the settings defined in
	 * the config instance. By default, this is called automatically
	 * when building the project using Lime's command-line tools
	 * @param	config	A Config object</haxe_doc>
		</create>
		<createWindow public="1" set="method" line="170">
			<f a="window">
				<c path="lime.ui.Window"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Adds a new Window to the Application. By default, this is
	 * called automatically by create()
	 * @param	window	A Window object to add</haxe_doc>
		</createWindow>
		<exec public="1" set="method" line="218">
			<f a=""><x path="Int"/></f>
			<haxe_doc>* Execute the Application. On native platforms, this method
	 * blocks until the application is finished running. On other 
	 * platforms, it will return immediately
	 * @return An exit code, 0 if there was no error</haxe_doc>
		</exec>
		<onGamepadAxisMove public="1" set="method" line="227" override="1"><f a="gamepad:axis:value">
	<c path="lime.ui.Gamepad"/>
	<x path="lime.ui.GamepadAxis"/>
	<x path="Float"/>
	<x path="Void"/>
</f></onGamepadAxisMove>
		<onGamepadButtonDown public="1" set="method" line="238" override="1"><f a="gamepad:button">
	<c path="lime.ui.Gamepad"/>
	<x path="lime.ui.GamepadButton"/>
	<x path="Void"/>
</f></onGamepadButtonDown>
		<onGamepadButtonUp public="1" set="method" line="249" override="1"><f a="gamepad:button">
	<c path="lime.ui.Gamepad"/>
	<x path="lime.ui.GamepadButton"/>
	<x path="Void"/>
</f></onGamepadButtonUp>
		<onGamepadConnect public="1" set="method" line="260" override="1"><f a="gamepad">
	<c path="lime.ui.Gamepad"/>
	<x path="Void"/>
</f></onGamepadConnect>
		<onGamepadDisconnect public="1" set="method" line="271" override="1"><f a="gamepad">
	<c path="lime.ui.Gamepad"/>
	<x path="Void"/>
</f></onGamepadDisconnect>
		<onJoystickAxisMove public="1" set="method" line="282" override="1"><f a="joystick:axis:value">
	<c path="lime.ui.Joystick"/>
	<x path="Int"/>
	<x path="Float"/>
	<x path="Void"/>
</f></onJoystickAxisMove>
		<onJoystickButtonDown public="1" set="method" line="293" override="1"><f a="joystick:button">
	<c path="lime.ui.Joystick"/>
	<x path="Int"/>
	<x path="Void"/>
</f></onJoystickButtonDown>
		<onJoystickButtonUp public="1" set="method" line="304" override="1"><f a="joystick:button">
	<c path="lime.ui.Joystick"/>
	<x path="Int"/>
	<x path="Void"/>
</f></onJoystickButtonUp>
		<onJoystickConnect public="1" set="method" line="315" override="1"><f a="joystick">
	<c path="lime.ui.Joystick"/>
	<x path="Void"/>
</f></onJoystickConnect>
		<onJoystickDisconnect public="1" set="method" line="326" override="1"><f a="joystick">
	<c path="lime.ui.Joystick"/>
	<x path="Void"/>
</f></onJoystickDisconnect>
		<onJoystickHatMove public="1" set="method" line="337" override="1"><f a="joystick:hat:position">
	<c path="lime.ui.Joystick"/>
	<x path="Int"/>
	<x path="lime.ui.JoystickHatPosition"/>
	<x path="Void"/>
</f></onJoystickHatMove>
		<onJoystickTrackballMove public="1" set="method" line="348" override="1"><f a="joystick:trackball:value">
	<c path="lime.ui.Joystick"/>
	<x path="Int"/>
	<x path="Float"/>
	<x path="Void"/>
</f></onJoystickTrackballMove>
		<onKeyDown public="1" set="method" line="359" override="1"><f a="window:keyCode:modifier">
	<c path="lime.ui.Window"/>
	<x path="lime.ui.KeyCode"/>
	<x path="lime.ui.KeyModifier"/>
	<x path="Void"/>
</f></onKeyDown>
		<onKeyUp public="1" set="method" line="370" override="1"><f a="window:keyCode:modifier">
	<c path="lime.ui.Window"/>
	<x path="lime.ui.KeyCode"/>
	<x path="lime.ui.KeyModifier"/>
	<x path="Void"/>
</f></onKeyUp>
		<onModuleExit public="1" set="method" line="381" override="1"><f a="code">
	<x path="Int"/>
	<x path="Void"/>
</f></onModuleExit>
		<onMouseDown public="1" set="method" line="394" override="1"><f a="window:x:y:button">
	<c path="lime.ui.Window"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Int"/>
	<x path="Void"/>
</f></onMouseDown>
		<onMouseMove public="1" set="method" line="405" override="1"><f a="window:x:y">
	<c path="lime.ui.Window"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></onMouseMove>
		<onMouseMoveRelative public="1" set="method" line="416" override="1"><f a="window:x:y">
	<c path="lime.ui.Window"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></onMouseMoveRelative>
		<onMouseUp public="1" set="method" line="427" override="1"><f a="window:x:y:button">
	<c path="lime.ui.Window"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Int"/>
	<x path="Void"/>
</f></onMouseUp>
		<onMouseWheel public="1" set="method" line="438" override="1"><f a="window:deltaX:deltaY">
	<c path="lime.ui.Window"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></onMouseWheel>
		<onPreloadComplete public="1" set="method" line="449" override="1"><f a=""><x path="Void"/></f></onPreloadComplete>
		<onPreloadProgress public="1" set="method" line="460" override="1"><f a="loaded:total">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></onPreloadProgress>
		<onRenderContextLost public="1" set="method" line="471" override="1"><f a="renderer">
	<c path="lime.graphics.Renderer"/>
	<x path="Void"/>
</f></onRenderContextLost>
		<onRenderContextRestored public="1" set="method" line="482" override="1"><f a="renderer:context">
	<c path="lime.graphics.Renderer"/>
	<e path="lime.graphics.RenderContext"/>
	<x path="Void"/>
</f></onRenderContextRestored>
		<onTextEdit public="1" set="method" line="493" override="1"><f a="window:text:start:length">
	<c path="lime.ui.Window"/>
	<c path="String"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></onTextEdit>
		<onTextInput public="1" set="method" line="504" override="1"><f a="window:text">
	<c path="lime.ui.Window"/>
	<c path="String"/>
	<x path="Void"/>
</f></onTextInput>
		<onTouchEnd public="1" set="method" line="515" override="1"><f a="touch">
	<c path="lime.ui.Touch"/>
	<x path="Void"/>
</f></onTouchEnd>
		<onTouchMove public="1" set="method" line="526" override="1"><f a="touch">
	<c path="lime.ui.Touch"/>
	<x path="Void"/>
</f></onTouchMove>
		<onTouchStart public="1" set="method" line="537" override="1"><f a="touch">
	<c path="lime.ui.Touch"/>
	<x path="Void"/>
</f></onTouchStart>
		<onWindowActivate public="1" set="method" line="548" override="1"><f a="window">
	<c path="lime.ui.Window"/>
	<x path="Void"/>
</f></onWindowActivate>
		<onWindowClose public="1" set="method" line="559" override="1"><f a="window">
	<c path="lime.ui.Window"/>
	<x path="Void"/>
</f></onWindowClose>
		<onWindowCreate public="1" set="method" line="572" override="1"><f a="window">
	<c path="lime.ui.Window"/>
	<x path="Void"/>
</f></onWindowCreate>
		<onWindowDeactivate public="1" set="method" line="583" override="1"><f a="window">
	<c path="lime.ui.Window"/>
	<x path="Void"/>
</f></onWindowDeactivate>
		<onWindowDropFile public="1" set="method" line="594" override="1"><f a="window:file">
	<c path="lime.ui.Window"/>
	<c path="String"/>
	<x path="Void"/>
</f></onWindowDropFile>
		<onWindowEnter public="1" set="method" line="605" override="1"><f a="window">
	<c path="lime.ui.Window"/>
	<x path="Void"/>
</f></onWindowEnter>
		<onWindowFocusIn public="1" set="method" line="616" override="1"><f a="window">
	<c path="lime.ui.Window"/>
	<x path="Void"/>
</f></onWindowFocusIn>
		<onWindowFocusOut public="1" set="method" line="627" override="1"><f a="window">
	<c path="lime.ui.Window"/>
	<x path="Void"/>
</f></onWindowFocusOut>
		<onWindowFullscreen public="1" set="method" line="638" override="1"><f a="window">
	<c path="lime.ui.Window"/>
	<x path="Void"/>
</f></onWindowFullscreen>
		<onWindowLeave public="1" set="method" line="649" override="1"><f a="window">
	<c path="lime.ui.Window"/>
	<x path="Void"/>
</f></onWindowLeave>
		<onWindowMinimize public="1" set="method" line="660" override="1"><f a="window">
	<c path="lime.ui.Window"/>
	<x path="Void"/>
</f></onWindowMinimize>
		<onWindowMove public="1" set="method" line="671" override="1"><f a="window:x:y">
	<c path="lime.ui.Window"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></onWindowMove>
		<onWindowResize public="1" set="method" line="682" override="1"><f a="window:width:height">
	<c path="lime.ui.Window"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></onWindowResize>
		<onWindowRestore public="1" set="method" line="693" override="1"><f a="window">
	<c path="lime.ui.Window"/>
	<x path="Void"/>
</f></onWindowRestore>
		<removeModule public="1" set="method" line="708">
			<f a="module">
				<c path="lime.app.IModule"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Removes a module from the Application
	 * @param	module	A module to remove</haxe_doc>
		</removeModule>
		<removeRenderer public="1" set="method" line="724">
			<f a="renderer">
				<c path="lime.graphics.Renderer"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Removes a Renderer from the Application
	 * @param	renderer	A Renderer object to remove</haxe_doc>
		</removeRenderer>
		<removeWindow set="method" line="739">
			<f a="window">
				<c path="lime.ui.Window"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Removes a Window from the Application
	 * @param	window	A Window object to remove</haxe_doc>
		</removeWindow>
		<render public="1" set="method" line="758" override="1"><f a="renderer">
	<c path="lime.graphics.Renderer"/>
	<x path="Void"/>
</f></render>
		<setPreloader set="method" line="769"><f a="preloader">
	<c path="lime.app.Preloader"/>
	<x path="Void"/>
</f></setPreloader>
		<update public="1" set="method" line="794" override="1"><f a="deltaTime">
	<x path="Int"/>
	<x path="Void"/>
</f></update>
		<__onGamepadConnect set="method" line="805">
			<f a="gamepad">
				<c path="lime.ui.Gamepad"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</__onGamepadConnect>
		<__onJoystickConnect set="method" line="817">
			<f a="joystick">
				<c path="lime.ui.Joystick"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</__onJoystickConnect>
		<get_frameRate get="inline" set="null" line="838">
			<f a=""><x path="Float"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_frameRate>
		<set_frameRate get="inline" set="null" line="845">
			<f a="value">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_frameRate>
		<get_renderer get="inline" set="null" line="852">
			<f a=""><c path="lime.graphics.Renderer"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_renderer>
		<get_window get="inline" set="null" line="859">
			<f a=""><c path="lime.ui.Window"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_window>
		<new public="1" set="method" line="47"><f a=""><x path="Void"/></f></new>
		<haxe_doc>* The Application class forms the foundation for most Lime projects.
 * It is common to extend this class in a main class. It is then possible
 * to override "on" functions in the class in order to handle standard events
 * that are relevant.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<typedef path="lime.app._Application.ApplicationBackend" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/app/Application.hx" private="1" module="lime.app.Application">
		<c path="lime._backend.native.NativeApplication"/>
		<meta><m n=":noCompletion"/></meta>
	</typedef>
	<typedef path="lime.app.Config" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/app/Config.hx"><a>
	<windows>
		<t path="Null"><c path="Array"><t path="lime.app.WindowConfig"/></c></t>
		<meta><m n=":optional"/></meta>
	</windows>
	<version>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
	</version>
	<packageName>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
	</packageName>
	<orientation>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
	</orientation>
	<name>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
	</name>
	<fps>
		<t path="Null"><x path="Int"/></t>
		<meta><m n=":optional"/></meta>
	</fps>
	<file>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
	</file>
	<company>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
	</company>
	<build>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
	</build>
</a></typedef>
	<typedef path="lime.app.WindowConfig" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/app/Config.hx" module="lime.app.Config"><a>
	<y>
		<t path="Null"><x path="Int"/></t>
		<meta><m n=":optional"/></meta>
	</y>
	<x>
		<t path="Null"><x path="Int"/></t>
		<meta><m n=":optional"/></meta>
	</x>
	<width>
		<t path="Null"><x path="Int"/></t>
		<meta><m n=":optional"/></meta>
	</width>
	<vsync>
		<t path="Null"><x path="Bool"/></t>
		<meta><m n=":optional"/></meta>
	</vsync>
	<title>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
	</title>
	<stencilBuffer>
		<t path="Null"><x path="Bool"/></t>
		<meta><m n=":optional"/></meta>
	</stencilBuffer>
	<resizable>
		<t path="Null"><x path="Bool"/></t>
		<meta><m n=":optional"/></meta>
	</resizable>
	<parameters>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
	</parameters>
	<height>
		<t path="Null"><x path="Int"/></t>
		<meta><m n=":optional"/></meta>
	</height>
	<hardware>
		<t path="Null"><x path="Bool"/></t>
		<meta><m n=":optional"/></meta>
	</hardware>
	<fullscreen>
		<t path="Null"><x path="Bool"/></t>
		<meta><m n=":optional"/></meta>
	</fullscreen>
	<display>
		<t path="Null"><x path="Int"/></t>
		<meta><m n=":optional"/></meta>
	</display>
	<depthBuffer>
		<t path="Null"><x path="Bool"/></t>
		<meta><m n=":optional"/></meta>
	</depthBuffer>
	<borderless>
		<t path="Null"><x path="Bool"/></t>
		<meta><m n=":optional"/></meta>
	</borderless>
	<background>
		<t path="Null"><x path="Int"/></t>
		<meta><m n=":optional"/></meta>
	</background>
	<antialiasing>
		<t path="Null"><x path="Int"/></t>
		<meta><m n=":optional"/></meta>
	</antialiasing>
	<allowHighDPI>
		<t path="Null"><x path="Bool"/></t>
		<meta><m n=":optional"/></meta>
	</allowHighDPI>
</a></typedef>
	<class path="lime.app.Event" params="T" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/app/Event.hx">
		<canceled public="1" set="null"><x path="Bool"/></canceled>
		<__listeners public="1">
			<c path="Array"><c path="lime.app.Event.T"/></c>
			<meta>
				<m n=":noCompletion"/>
				<m n=":dox"><e>hide</e></m>
			</meta>
		</__listeners>
		<__repeat public="1">
			<c path="Array"><x path="Bool"/></c>
			<meta>
				<m n=":noCompletion"/>
				<m n=":dox"><e>hide</e></m>
			</meta>
		</__repeat>
		<__priorities><c path="Array"><x path="Int"/></c></__priorities>
		<add public="1" set="method" line="38">
			<f a="listener:?once:?priority" v=":false:0">
				<c path="lime.app.Event.T"/>
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ priority : 0, once : false }</e></m></meta>
		</add>
		<cancel public="1" set="method" line="209"><f a=""><x path="Void"/></f></cancel>
		<dispatch public="1"><d/></dispatch>
		<has public="1" set="method" line="247"><f a="listener">
	<c path="lime.app.Event.T"/>
	<x path="Bool"/>
</f></has>
		<remove public="1" set="method" line="262"><f a="listener">
	<c path="lime.app.Event.T"/>
	<x path="Void"/>
</f></remove>
		<new public="1" set="method" line="26"><f a=""><x path="Void"/></f></new>
		<meta><m n=":genericBuild"><e>lime.app.Event.build()</e></m></meta>
	</class>
	<class path="lime.app.Event_Dynamic_Void" params="T" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/system/ThreadPool.hx">
		<canceled public="1" set="null"><x path="Bool"/></canceled>
		<__repeat public="1">
			<c path="Array"><x path="Bool"/></c>
			<meta>
				<m n=":noCompletion"/>
				<m n=":dox"><e>hide</e></m>
			</meta>
		</__repeat>
		<__priorities><c path="Array"><x path="Int"/></c></__priorities>
		<add public="1" set="method" line="38">
			<f a="listener:?once:?priority" v=":false:0">
				<c path="lime.app.Event_Dynamic_Void.T"/>
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ priority : 0, once : false }</e></m></meta>
		</add>
		<cancel public="1" set="method" line="209"><f a=""><x path="Void"/></f></cancel>
		<has public="1" set="method" line="247"><f a="listener">
	<c path="lime.app.Event_Dynamic_Void.T"/>
	<x path="Bool"/>
</f></has>
		<remove public="1" set="method" line="262"><f a="listener">
	<c path="lime.app.Event_Dynamic_Void.T"/>
	<x path="Void"/>
</f></remove>
		<__listeners public="1"><c path="Array"><f a="">
	<d/>
	<x path="Void"/>
</f></c></__listeners>
		<dispatch public="1" set="method" line="20"><f a="a">
	<d/>
	<x path="Void"/>
</f></dispatch>
		<new public="1" set="method" line="26"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":dox"><e>hide</e></m>
			<m n=":noCompletion"/>
		</meta>
	</class>
	<class path="lime.app.Event_Float_Float_Float_Void" params="T" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/system/Sensor.hx">
		<canceled public="1" set="null"><x path="Bool"/></canceled>
		<__repeat public="1">
			<c path="Array"><x path="Bool"/></c>
			<meta>
				<m n=":noCompletion"/>
				<m n=":dox"><e>hide</e></m>
			</meta>
		</__repeat>
		<__priorities><c path="Array"><x path="Int"/></c></__priorities>
		<add public="1" set="method" line="38">
			<f a="listener:?once:?priority" v=":false:0">
				<c path="lime.app.Event_Float_Float_Float_Void.T"/>
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ priority : 0, once : false }</e></m></meta>
		</add>
		<cancel public="1" set="method" line="209"><f a=""><x path="Void"/></f></cancel>
		<has public="1" set="method" line="247"><f a="listener">
	<c path="lime.app.Event_Float_Float_Float_Void.T"/>
	<x path="Bool"/>
</f></has>
		<remove public="1" set="method" line="262"><f a="listener">
	<c path="lime.app.Event_Float_Float_Float_Void.T"/>
	<x path="Void"/>
</f></remove>
		<__listeners public="1"><c path="Array"><f a="::">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></c></__listeners>
		<dispatch public="1" set="method" line="14"><f a="a:a1:a2">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></dispatch>
		<new public="1" set="method" line="26"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":dox"><e>hide</e></m>
			<m n=":noCompletion"/>
		</meta>
	</class>
	<class path="lime.app.Event_Float_Float_Int_Void" params="T" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/ui/Window.hx">
		<canceled public="1" set="null"><x path="Bool"/></canceled>
		<__repeat public="1">
			<c path="Array"><x path="Bool"/></c>
			<meta>
				<m n=":noCompletion"/>
				<m n=":dox"><e>hide</e></m>
			</meta>
		</__repeat>
		<__priorities><c path="Array"><x path="Int"/></c></__priorities>
		<add public="1" set="method" line="38">
			<f a="listener:?once:?priority" v=":false:0">
				<c path="lime.app.Event_Float_Float_Int_Void.T"/>
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ priority : 0, once : false }</e></m></meta>
		</add>
		<cancel public="1" set="method" line="209"><f a=""><x path="Void"/></f></cancel>
		<has public="1" set="method" line="247"><f a="listener">
	<c path="lime.app.Event_Float_Float_Int_Void.T"/>
	<x path="Bool"/>
</f></has>
		<remove public="1" set="method" line="262"><f a="listener">
	<c path="lime.app.Event_Float_Float_Int_Void.T"/>
	<x path="Void"/>
</f></remove>
		<__listeners public="1"><c path="Array"><f a="::">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Int"/>
	<x path="Void"/>
</f></c></__listeners>
		<dispatch public="1" set="method" line="46"><f a="a:a1:a2">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Int"/>
	<x path="Void"/>
</f></dispatch>
		<new public="1" set="method" line="26"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":dox"><e>hide</e></m>
			<m n=":noCompletion"/>
		</meta>
	</class>
	<class path="lime.app.Event_Float_Float_Void" params="T" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/ui/Window.hx">
		<canceled public="1" set="null"><x path="Bool"/></canceled>
		<__repeat public="1">
			<c path="Array"><x path="Bool"/></c>
			<meta>
				<m n=":noCompletion"/>
				<m n=":dox"><e>hide</e></m>
			</meta>
		</__repeat>
		<__priorities><c path="Array"><x path="Int"/></c></__priorities>
		<add public="1" set="method" line="38">
			<f a="listener:?once:?priority" v=":false:0">
				<c path="lime.app.Event_Float_Float_Void.T"/>
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ priority : 0, once : false }</e></m></meta>
		</add>
		<cancel public="1" set="method" line="209"><f a=""><x path="Void"/></f></cancel>
		<has public="1" set="method" line="247"><f a="listener">
	<c path="lime.app.Event_Float_Float_Void.T"/>
	<x path="Bool"/>
</f></has>
		<remove public="1" set="method" line="262"><f a="listener">
	<c path="lime.app.Event_Float_Float_Void.T"/>
	<x path="Void"/>
</f></remove>
		<__listeners public="1"><c path="Array"><f a=":">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></c></__listeners>
		<dispatch public="1" set="method" line="47"><f a="a:a1">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></dispatch>
		<new public="1" set="method" line="26"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":dox"><e>hide</e></m>
			<m n=":noCompletion"/>
		</meta>
	</class>
	<class path="lime.app.Event_Int_Float_Void" params="T" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/ui/Joystick.hx">
		<canceled public="1" set="null"><x path="Bool"/></canceled>
		<__repeat public="1">
			<c path="Array"><x path="Bool"/></c>
			<meta>
				<m n=":noCompletion"/>
				<m n=":dox"><e>hide</e></m>
			</meta>
		</__repeat>
		<__priorities><c path="Array"><x path="Int"/></c></__priorities>
		<add public="1" set="method" line="38">
			<f a="listener:?once:?priority" v=":false:0">
				<c path="lime.app.Event_Int_Float_Void.T"/>
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ priority : 0, once : false }</e></m></meta>
		</add>
		<cancel public="1" set="method" line="209"><f a=""><x path="Void"/></f></cancel>
		<has public="1" set="method" line="247"><f a="listener">
	<c path="lime.app.Event_Int_Float_Void.T"/>
	<x path="Bool"/>
</f></has>
		<remove public="1" set="method" line="262"><f a="listener">
	<c path="lime.app.Event_Int_Float_Void.T"/>
	<x path="Void"/>
</f></remove>
		<__listeners public="1"><c path="Array"><f a=":">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Void"/>
</f></c></__listeners>
		<dispatch public="1" set="method" line="25"><f a="a:a1">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Void"/>
</f></dispatch>
		<new public="1" set="method" line="26"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":dox"><e>hide</e></m>
			<m n=":noCompletion"/>
		</meta>
	</class>
	<class path="lime.app.Event_Int_Int_Void" params="T" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/ui/Window.hx">
		<canceled public="1" set="null"><x path="Bool"/></canceled>
		<__repeat public="1">
			<c path="Array"><x path="Bool"/></c>
			<meta>
				<m n=":noCompletion"/>
				<m n=":dox"><e>hide</e></m>
			</meta>
		</__repeat>
		<__priorities><c path="Array"><x path="Int"/></c></__priorities>
		<add public="1" set="method" line="38">
			<f a="listener:?once:?priority" v=":false:0">
				<c path="lime.app.Event_Int_Int_Void.T"/>
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ priority : 0, once : false }</e></m></meta>
		</add>
		<cancel public="1" set="method" line="209"><f a=""><x path="Void"/></f></cancel>
		<has public="1" set="method" line="247"><f a="listener">
	<c path="lime.app.Event_Int_Int_Void.T"/>
	<x path="Bool"/>
</f></has>
		<remove public="1" set="method" line="262"><f a="listener">
	<c path="lime.app.Event_Int_Int_Void.T"/>
	<x path="Void"/>
</f></remove>
		<__listeners public="1"><c path="Array"><f a=":">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></c></__listeners>
		<dispatch public="1" set="method" line="52"><f a="a:a1">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></dispatch>
		<new public="1" set="method" line="26"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":dox"><e>hide</e></m>
			<m n=":noCompletion"/>
		</meta>
	</class>
	<class path="lime.app.Event_Int_Void" params="T" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/app/Module.hx">
		<canceled public="1" set="null"><x path="Bool"/></canceled>
		<__repeat public="1">
			<c path="Array"><x path="Bool"/></c>
			<meta>
				<m n=":noCompletion"/>
				<m n=":dox"><e>hide</e></m>
			</meta>
		</__repeat>
		<__priorities><c path="Array"><x path="Int"/></c></__priorities>
		<add public="1" set="method" line="38">
			<f a="listener:?once:?priority" v=":false:0">
				<c path="lime.app.Event_Int_Void.T"/>
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ priority : 0, once : false }</e></m></meta>
		</add>
		<cancel public="1" set="method" line="209"><f a=""><x path="Void"/></f></cancel>
		<has public="1" set="method" line="247"><f a="listener">
	<c path="lime.app.Event_Int_Void.T"/>
	<x path="Bool"/>
</f></has>
		<remove public="1" set="method" line="262"><f a="listener">
	<c path="lime.app.Event_Int_Void.T"/>
	<x path="Void"/>
</f></remove>
		<__listeners public="1"><c path="Array"><f a="">
	<x path="Int"/>
	<x path="Void"/>
</f></c></__listeners>
		<dispatch public="1" set="method" line="23"><f a="a">
	<x path="Int"/>
	<x path="Void"/>
</f></dispatch>
		<new public="1" set="method" line="26"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":dox"><e>hide</e></m>
			<m n=":noCompletion"/>
		</meta>
	</class>
	<class path="lime.app.Event_Int_lime_ui_JoystickHatPosition_Void" params="T" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/ui/Joystick.hx">
		<canceled public="1" set="null"><x path="Bool"/></canceled>
		<__repeat public="1">
			<c path="Array"><x path="Bool"/></c>
			<meta>
				<m n=":noCompletion"/>
				<m n=":dox"><e>hide</e></m>
			</meta>
		</__repeat>
		<__priorities><c path="Array"><x path="Int"/></c></__priorities>
		<add public="1" set="method" line="38">
			<f a="listener:?once:?priority" v=":false:0">
				<c path="lime.app.Event_Int_lime_ui_JoystickHatPosition_Void.T"/>
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ priority : 0, once : false }</e></m></meta>
		</add>
		<cancel public="1" set="method" line="209"><f a=""><x path="Void"/></f></cancel>
		<has public="1" set="method" line="247"><f a="listener">
	<c path="lime.app.Event_Int_lime_ui_JoystickHatPosition_Void.T"/>
	<x path="Bool"/>
</f></has>
		<remove public="1" set="method" line="262"><f a="listener">
	<c path="lime.app.Event_Int_lime_ui_JoystickHatPosition_Void.T"/>
	<x path="Void"/>
</f></remove>
		<__listeners public="1"><c path="Array"><f a=":">
	<x path="Int"/>
	<x path="lime.ui.JoystickHatPosition"/>
	<x path="Void"/>
</f></c></__listeners>
		<dispatch public="1" set="method" line="29"><f a="a:a1">
	<x path="Int"/>
	<x path="lime.ui.JoystickHatPosition"/>
	<x path="Void"/>
</f></dispatch>
		<new public="1" set="method" line="26"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":dox"><e>hide</e></m>
			<m n=":noCompletion"/>
		</meta>
	</class>
	<class path="lime.app.Event_String_Int_Int_Void" params="T" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/ui/Window.hx">
		<canceled public="1" set="null"><x path="Bool"/></canceled>
		<__repeat public="1">
			<c path="Array"><x path="Bool"/></c>
			<meta>
				<m n=":noCompletion"/>
				<m n=":dox"><e>hide</e></m>
			</meta>
		</__repeat>
		<__priorities><c path="Array"><x path="Int"/></c></__priorities>
		<add public="1" set="method" line="38">
			<f a="listener:?once:?priority" v=":false:0">
				<c path="lime.app.Event_String_Int_Int_Void.T"/>
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ priority : 0, once : false }</e></m></meta>
		</add>
		<cancel public="1" set="method" line="209"><f a=""><x path="Void"/></f></cancel>
		<has public="1" set="method" line="247"><f a="listener">
	<c path="lime.app.Event_String_Int_Int_Void.T"/>
	<x path="Bool"/>
</f></has>
		<remove public="1" set="method" line="262"><f a="listener">
	<c path="lime.app.Event_String_Int_Int_Void.T"/>
	<x path="Void"/>
</f></remove>
		<__listeners public="1"><c path="Array"><f a="::">
	<c path="String"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></c></__listeners>
		<dispatch public="1" set="method" line="54"><f a="a:a1:a2">
	<c path="String"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></dispatch>
		<new public="1" set="method" line="26"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":dox"><e>hide</e></m>
			<m n=":noCompletion"/>
		</meta>
	</class>
	<class path="lime.app.Event_String_Void" params="T" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/ui/Window.hx">
		<canceled public="1" set="null"><x path="Bool"/></canceled>
		<__repeat public="1">
			<c path="Array"><x path="Bool"/></c>
			<meta>
				<m n=":noCompletion"/>
				<m n=":dox"><e>hide</e></m>
			</meta>
		</__repeat>
		<__priorities><c path="Array"><x path="Int"/></c></__priorities>
		<add public="1" set="method" line="38">
			<f a="listener:?once:?priority" v=":false:0">
				<c path="lime.app.Event_String_Void.T"/>
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ priority : 0, once : false }</e></m></meta>
		</add>
		<cancel public="1" set="method" line="209"><f a=""><x path="Void"/></f></cancel>
		<has public="1" set="method" line="247"><f a="listener">
	<c path="lime.app.Event_String_Void.T"/>
	<x path="Bool"/>
</f></has>
		<remove public="1" set="method" line="262"><f a="listener">
	<c path="lime.app.Event_String_Void.T"/>
	<x path="Void"/>
</f></remove>
		<__listeners public="1"><c path="Array"><f a="">
	<c path="String"/>
	<x path="Void"/>
</f></c></__listeners>
		<dispatch public="1" set="method" line="55"><f a="a">
	<c path="String"/>
	<x path="Void"/>
</f></dispatch>
		<new public="1" set="method" line="26"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":dox"><e>hide</e></m>
			<m n=":noCompletion"/>
		</meta>
	</class>
	<class path="lime.app.Event_lime_graphics_RenderContext_Void" params="T" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/graphics/Renderer.hx">
		<canceled public="1" set="null"><x path="Bool"/></canceled>
		<__repeat public="1">
			<c path="Array"><x path="Bool"/></c>
			<meta>
				<m n=":noCompletion"/>
				<m n=":dox"><e>hide</e></m>
			</meta>
		</__repeat>
		<__priorities><c path="Array"><x path="Int"/></c></__priorities>
		<add public="1" set="method" line="38">
			<f a="listener:?once:?priority" v=":false:0">
				<c path="lime.app.Event_lime_graphics_RenderContext_Void.T"/>
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ priority : 0, once : false }</e></m></meta>
		</add>
		<cancel public="1" set="method" line="209"><f a=""><x path="Void"/></f></cancel>
		<has public="1" set="method" line="247"><f a="listener">
	<c path="lime.app.Event_lime_graphics_RenderContext_Void.T"/>
	<x path="Bool"/>
</f></has>
		<remove public="1" set="method" line="262"><f a="listener">
	<c path="lime.app.Event_lime_graphics_RenderContext_Void.T"/>
	<x path="Void"/>
</f></remove>
		<__listeners public="1"><c path="Array"><f a="">
	<e path="lime.graphics.RenderContext"/>
	<x path="Void"/>
</f></c></__listeners>
		<dispatch public="1" set="method" line="14"><f a="a">
	<e path="lime.graphics.RenderContext"/>
	<x path="Void"/>
</f></dispatch>
		<new public="1" set="method" line="26"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":dox"><e>hide</e></m>
			<m n=":noCompletion"/>
		</meta>
	</class>
	<class path="lime.app.Event_lime_ui_GamepadAxis_Float_Void" params="T" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/ui/Gamepad.hx">
		<canceled public="1" set="null"><x path="Bool"/></canceled>
		<__repeat public="1">
			<c path="Array"><x path="Bool"/></c>
			<meta>
				<m n=":noCompletion"/>
				<m n=":dox"><e>hide</e></m>
			</meta>
		</__repeat>
		<__priorities><c path="Array"><x path="Int"/></c></__priorities>
		<add public="1" set="method" line="38">
			<f a="listener:?once:?priority" v=":false:0">
				<c path="lime.app.Event_lime_ui_GamepadAxis_Float_Void.T"/>
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ priority : 0, once : false }</e></m></meta>
		</add>
		<cancel public="1" set="method" line="209"><f a=""><x path="Void"/></f></cancel>
		<has public="1" set="method" line="247"><f a="listener">
	<c path="lime.app.Event_lime_ui_GamepadAxis_Float_Void.T"/>
	<x path="Bool"/>
</f></has>
		<remove public="1" set="method" line="262"><f a="listener">
	<c path="lime.app.Event_lime_ui_GamepadAxis_Float_Void.T"/>
	<x path="Void"/>
</f></remove>
		<__listeners public="1"><c path="Array"><f a=":">
	<x path="lime.ui.GamepadAxis"/>
	<x path="Float"/>
	<x path="Void"/>
</f></c></__listeners>
		<dispatch public="1" set="method" line="23"><f a="a:a1">
	<x path="lime.ui.GamepadAxis"/>
	<x path="Float"/>
	<x path="Void"/>
</f></dispatch>
		<new public="1" set="method" line="26"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":dox"><e>hide</e></m>
			<m n=":noCompletion"/>
		</meta>
	</class>
	<class path="lime.app.Event_lime_ui_GamepadButton_Void" params="T" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/ui/Gamepad.hx">
		<canceled public="1" set="null"><x path="Bool"/></canceled>
		<__repeat public="1">
			<c path="Array"><x path="Bool"/></c>
			<meta>
				<m n=":noCompletion"/>
				<m n=":dox"><e>hide</e></m>
			</meta>
		</__repeat>
		<__priorities><c path="Array"><x path="Int"/></c></__priorities>
		<add public="1" set="method" line="38">
			<f a="listener:?once:?priority" v=":false:0">
				<c path="lime.app.Event_lime_ui_GamepadButton_Void.T"/>
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ priority : 0, once : false }</e></m></meta>
		</add>
		<cancel public="1" set="method" line="209"><f a=""><x path="Void"/></f></cancel>
		<has public="1" set="method" line="247"><f a="listener">
	<c path="lime.app.Event_lime_ui_GamepadButton_Void.T"/>
	<x path="Bool"/>
</f></has>
		<remove public="1" set="method" line="262"><f a="listener">
	<c path="lime.app.Event_lime_ui_GamepadButton_Void.T"/>
	<x path="Void"/>
</f></remove>
		<__listeners public="1"><c path="Array"><f a="">
	<x path="lime.ui.GamepadButton"/>
	<x path="Void"/>
</f></c></__listeners>
		<dispatch public="1" set="method" line="24"><f a="a">
	<x path="lime.ui.GamepadButton"/>
	<x path="Void"/>
</f></dispatch>
		<new public="1" set="method" line="26"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":dox"><e>hide</e></m>
			<m n=":noCompletion"/>
		</meta>
	</class>
	<class path="lime.app.Event_lime_ui_Gamepad_Void" params="T" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/ui/Gamepad.hx">
		<canceled public="1" set="null"><x path="Bool"/></canceled>
		<__repeat public="1">
			<c path="Array"><x path="Bool"/></c>
			<meta>
				<m n=":noCompletion"/>
				<m n=":dox"><e>hide</e></m>
			</meta>
		</__repeat>
		<__priorities><c path="Array"><x path="Int"/></c></__priorities>
		<add public="1" set="method" line="38">
			<f a="listener:?once:?priority" v=":false:0">
				<c path="lime.app.Event_lime_ui_Gamepad_Void.T"/>
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ priority : 0, once : false }</e></m></meta>
		</add>
		<cancel public="1" set="method" line="209"><f a=""><x path="Void"/></f></cancel>
		<has public="1" set="method" line="247"><f a="listener">
	<c path="lime.app.Event_lime_ui_Gamepad_Void.T"/>
	<x path="Bool"/>
</f></has>
		<remove public="1" set="method" line="262"><f a="listener">
	<c path="lime.app.Event_lime_ui_Gamepad_Void.T"/>
	<x path="Void"/>
</f></remove>
		<__listeners public="1"><c path="Array"><f a="">
	<c path="lime.ui.Gamepad"/>
	<x path="Void"/>
</f></c></__listeners>
		<dispatch public="1" set="method" line="17"><f a="a">
	<c path="lime.ui.Gamepad"/>
	<x path="Void"/>
</f></dispatch>
		<new public="1" set="method" line="26"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":dox"><e>hide</e></m>
			<m n=":noCompletion"/>
		</meta>
	</class>
	<class path="lime.app.Event_lime_ui_Joystick_Void" params="T" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/ui/Joystick.hx">
		<canceled public="1" set="null"><x path="Bool"/></canceled>
		<__repeat public="1">
			<c path="Array"><x path="Bool"/></c>
			<meta>
				<m n=":noCompletion"/>
				<m n=":dox"><e>hide</e></m>
			</meta>
		</__repeat>
		<__priorities><c path="Array"><x path="Int"/></c></__priorities>
		<add public="1" set="method" line="38">
			<f a="listener:?once:?priority" v=":false:0">
				<c path="lime.app.Event_lime_ui_Joystick_Void.T"/>
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ priority : 0, once : false }</e></m></meta>
		</add>
		<cancel public="1" set="method" line="209"><f a=""><x path="Void"/></f></cancel>
		<has public="1" set="method" line="247"><f a="listener">
	<c path="lime.app.Event_lime_ui_Joystick_Void.T"/>
	<x path="Bool"/>
</f></has>
		<remove public="1" set="method" line="262"><f a="listener">
	<c path="lime.app.Event_lime_ui_Joystick_Void.T"/>
	<x path="Void"/>
</f></remove>
		<__listeners public="1"><c path="Array"><f a="">
	<c path="lime.ui.Joystick"/>
	<x path="Void"/>
</f></c></__listeners>
		<dispatch public="1" set="method" line="15"><f a="a">
	<c path="lime.ui.Joystick"/>
	<x path="Void"/>
</f></dispatch>
		<new public="1" set="method" line="26"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":dox"><e>hide</e></m>
			<m n=":noCompletion"/>
		</meta>
	</class>
	<class path="lime.app.Event_lime_ui_KeyCode_lime_ui_KeyModifier_Void" params="T" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/ui/Window.hx">
		<canceled public="1" set="null"><x path="Bool"/></canceled>
		<__repeat public="1">
			<c path="Array"><x path="Bool"/></c>
			<meta>
				<m n=":noCompletion"/>
				<m n=":dox"><e>hide</e></m>
			</meta>
		</__repeat>
		<__priorities><c path="Array"><x path="Int"/></c></__priorities>
		<add public="1" set="method" line="38">
			<f a="listener:?once:?priority" v=":false:0">
				<c path="lime.app.Event_lime_ui_KeyCode_lime_ui_KeyModifier_Void.T"/>
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ priority : 0, once : false }</e></m></meta>
		</add>
		<cancel public="1" set="method" line="209"><f a=""><x path="Void"/></f></cancel>
		<has public="1" set="method" line="247"><f a="listener">
	<c path="lime.app.Event_lime_ui_KeyCode_lime_ui_KeyModifier_Void.T"/>
	<x path="Bool"/>
</f></has>
		<remove public="1" set="method" line="262"><f a="listener">
	<c path="lime.app.Event_lime_ui_KeyCode_lime_ui_KeyModifier_Void.T"/>
	<x path="Void"/>
</f></remove>
		<__listeners public="1"><c path="Array"><f a=":">
	<x path="lime.ui.KeyCode"/>
	<x path="lime.ui.KeyModifier"/>
	<x path="Void"/>
</f></c></__listeners>
		<dispatch public="1" set="method" line="42"><f a="a:a1">
	<x path="lime.ui.KeyCode"/>
	<x path="lime.ui.KeyModifier"/>
	<x path="Void"/>
</f></dispatch>
		<new public="1" set="method" line="26"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":dox"><e>hide</e></m>
			<m n=":noCompletion"/>
		</meta>
	</class>
	<class path="lime.app.Event_lime_ui_Touch_Void" params="T" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/ui/Touch.hx">
		<canceled public="1" set="null"><x path="Bool"/></canceled>
		<__repeat public="1">
			<c path="Array"><x path="Bool"/></c>
			<meta>
				<m n=":noCompletion"/>
				<m n=":dox"><e>hide</e></m>
			</meta>
		</__repeat>
		<__priorities><c path="Array"><x path="Int"/></c></__priorities>
		<add public="1" set="method" line="38">
			<f a="listener:?once:?priority" v=":false:0">
				<c path="lime.app.Event_lime_ui_Touch_Void.T"/>
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ priority : 0, once : false }</e></m></meta>
		</add>
		<cancel public="1" set="method" line="209"><f a=""><x path="Void"/></f></cancel>
		<has public="1" set="method" line="247"><f a="listener">
	<c path="lime.app.Event_lime_ui_Touch_Void.T"/>
	<x path="Bool"/>
</f></has>
		<remove public="1" set="method" line="262"><f a="listener">
	<c path="lime.app.Event_lime_ui_Touch_Void.T"/>
	<x path="Void"/>
</f></remove>
		<__listeners public="1"><c path="Array"><f a="">
	<c path="lime.ui.Touch"/>
	<x path="Void"/>
</f></c></__listeners>
		<dispatch public="1" set="method" line="10"><f a="a">
	<c path="lime.ui.Touch"/>
	<x path="Void"/>
</f></dispatch>
		<new public="1" set="method" line="26"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":dox"><e>hide</e></m>
			<m n=":noCompletion"/>
		</meta>
	</class>
	<class path="lime.app.Future" params="T" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/app/Future.hx">
		<__threadPool static="1"><c path="lime.system.ThreadPool"/></__threadPool>
		<threadPool_doWork set="method" line="162" static="1"><f a="state">
	<d/>
	<x path="Void"/>
</f></threadPool_doWork>
		<threadPool_onComplete set="method" line="178" static="1"><f a="state">
	<d/>
	<x path="Void"/>
</f></threadPool_onComplete>
		<threadPool_onError set="method" line="185" static="1"><f a="state">
	<d/>
	<x path="Void"/>
</f></threadPool_onError>
		<isCompleted public="1" get="accessor" set="null"><x path="Bool"/></isCompleted>
		<value public="1" set="null"><c path="lime.app.Future.T"/></value>
		<__completed><x path="Bool"/></__completed>
		<__completeListeners><c path="Array"><f a="">
	<c path="lime.app.Future.T"/>
	<x path="Void"/>
</f></c></__completeListeners>
		<__errored><x path="Bool"/></__errored>
		<__errorListeners><c path="Array"><f a="">
	<d/>
	<x path="Void"/>
</f></c></__errorListeners>
		<__errorMessage><d/></__errorMessage>
		<__progressListeners><c path="Array"><f a="">
	<x path="Float"/>
	<x path="Void"/>
</f></c></__progressListeners>
		<onComplete public="1" set="method" line="48"><f a="listener">
	<f a="">
		<c path="lime.app.Future.T"/>
		<x path="Void"/>
	</f>
	<c path="lime.app.Future"><c path="lime.app.Future.T"/></c>
</f></onComplete>
		<onError public="1" set="method" line="75"><f a="listener">
	<f a="">
		<d/>
		<x path="Void"/>
	</f>
	<c path="lime.app.Future"><c path="lime.app.Future.T"/></c>
</f></onError>
		<onProgress public="1" set="method" line="102"><f a="listener">
	<f a="">
		<x path="Float"/>
		<x path="Void"/>
	</f>
	<c path="lime.app.Future"><c path="lime.app.Future.T"/></c>
</f></onProgress>
		<then public="1" params="U" set="method" line="121"><f a="next">
	<f a="">
		<c path="lime.app.Future.T"/>
		<c path="lime.app.Future"><c path="then.U"/></c>
	</f>
	<c path="lime.app.Future"><c path="then.U"/></c>
</f></then>
		<get_isCompleted set="method" line="199"><f a=""><x path="Bool"/></f></get_isCompleted>
		<new public="1" set="method" line="25">
			<f a="?work" v="null">
				<f a=""><c path="lime.app.Future.T"/></f>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ work : null }</e></m></meta>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":allow"><e>lime.app.Promise</e></m>
		</meta>
	</class>
	<class path="lime.app.Preloader" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/app/Preloader.hx">
		<complete public="1"><x path="Bool"/></complete>
		<onComplete public="1" expr="new Event&lt;Void&gt;()">
			<c path="lime.app.Event_Void_Void"><f a=""><x path="Void"/></f></c>
			<meta><m n=":value"><e><![CDATA[new Event<Void>()]]></e></m></meta>
		</onComplete>
		<onProgress public="1" expr="new Event&lt;Int -&gt; Int&gt;()">
			<c path="lime.app.Event_Int_Int_Void"><f a=":">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></c>
			<meta><m n=":value"><e><![CDATA[new Event<Int -> Int>()]]></e></m></meta>
		</onProgress>
		<create public="1" set="method" line="46"><f a="config">
	<t path="lime.app.Config"/>
	<x path="Void"/>
</f></create>
		<load public="1" set="method" line="64"><f a="urls:types">
	<c path="Array"><c path="String"/></c>
	<c path="Array"><x path="lime.AssetType"/></c>
	<x path="Void"/>
</f></load>
		<start set="method" line="230"><f a=""><x path="Void"/></f></start>
		<update set="method" line="247"><f a="loaded:total">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></update>
		<new public="1" set="method" line="35"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="lime.app.Promise" params="T" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/app/Promise.hx">
		<future public="1" set="null"><c path="lime.app.Future"><c path="lime.app.Promise.T"/></c></future>
		<isCompleted public="1" get="accessor" set="null"><x path="Bool"/></isCompleted>
		<complete public="1" set="method" line="21"><f a="data">
	<c path="lime.app.Promise.T"/>
	<c path="lime.app.Promise"><c path="lime.app.Promise.T"/></c>
</f></complete>
		<completeWith public="1" set="method" line="47"><f a="future">
	<c path="lime.app.Future"><c path="lime.app.Promise.T"/></c>
	<c path="lime.app.Promise"><c path="lime.app.Promise.T"/></c>
</f></completeWith>
		<error public="1" set="method" line="59"><f a="msg">
	<d/>
	<c path="lime.app.Promise"><c path="lime.app.Promise.T"/></c>
</f></error>
		<progress public="1" set="method" line="85"><f a="progress">
	<x path="Float"/>
	<c path="lime.app.Promise"><c path="lime.app.Promise.T"/></c>
</f></progress>
		<get_isCompleted set="method" line="113"><f a=""><x path="Bool"/></f></get_isCompleted>
		<new public="1" set="method" line="14"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":allow"><e>lime.app.Future</e></m>
		</meta>
	</class>
	<class path="lime.audio.ALAudioContext" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/audio/ALAudioContext.hx">
		<NONE public="1" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</NONE>
		<FALSE public="1" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</FALSE>
		<TRUE public="1" expr="1">
			<x path="Int"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</TRUE>
		<SOURCE_RELATIVE public="1" expr="0x202">
			<x path="Int"/>
			<meta><m n=":value"><e>0x202</e></m></meta>
		</SOURCE_RELATIVE>
		<CONE_INNER_ANGLE public="1" expr="0x1001">
			<x path="Int"/>
			<meta><m n=":value"><e>0x1001</e></m></meta>
		</CONE_INNER_ANGLE>
		<CONE_OUTER_ANGLE public="1" expr="0x1002">
			<x path="Int"/>
			<meta><m n=":value"><e>0x1002</e></m></meta>
		</CONE_OUTER_ANGLE>
		<PITCH public="1" expr="0x1003">
			<x path="Int"/>
			<meta><m n=":value"><e>0x1003</e></m></meta>
		</PITCH>
		<POSITION public="1" expr="0x1004">
			<x path="Int"/>
			<meta><m n=":value"><e>0x1004</e></m></meta>
		</POSITION>
		<DIRECTION public="1" expr="0x1005">
			<x path="Int"/>
			<meta><m n=":value"><e>0x1005</e></m></meta>
		</DIRECTION>
		<VELOCITY public="1" expr="0x1006">
			<x path="Int"/>
			<meta><m n=":value"><e>0x1006</e></m></meta>
		</VELOCITY>
		<LOOPING public="1" expr="0x1007">
			<x path="Int"/>
			<meta><m n=":value"><e>0x1007</e></m></meta>
		</LOOPING>
		<BUFFER public="1" expr="0x1009">
			<x path="Int"/>
			<meta><m n=":value"><e>0x1009</e></m></meta>
		</BUFFER>
		<GAIN public="1" expr="0x100A">
			<x path="Int"/>
			<meta><m n=":value"><e>0x100A</e></m></meta>
		</GAIN>
		<MIN_GAIN public="1" expr="0x100D">
			<x path="Int"/>
			<meta><m n=":value"><e>0x100D</e></m></meta>
		</MIN_GAIN>
		<MAX_GAIN public="1" expr="0x100E">
			<x path="Int"/>
			<meta><m n=":value"><e>0x100E</e></m></meta>
		</MAX_GAIN>
		<ORIENTATION public="1" expr="0x100F">
			<x path="Int"/>
			<meta><m n=":value"><e>0x100F</e></m></meta>
		</ORIENTATION>
		<SOURCE_STATE public="1" expr="0x1010">
			<x path="Int"/>
			<meta><m n=":value"><e>0x1010</e></m></meta>
		</SOURCE_STATE>
		<INITIAL public="1" expr="0x1011">
			<x path="Int"/>
			<meta><m n=":value"><e>0x1011</e></m></meta>
		</INITIAL>
		<PLAYING public="1" expr="0x1012">
			<x path="Int"/>
			<meta><m n=":value"><e>0x1012</e></m></meta>
		</PLAYING>
		<PAUSED public="1" expr="0x1013">
			<x path="Int"/>
			<meta><m n=":value"><e>0x1013</e></m></meta>
		</PAUSED>
		<STOPPED public="1" expr="0x1014">
			<x path="Int"/>
			<meta><m n=":value"><e>0x1014</e></m></meta>
		</STOPPED>
		<BUFFERS_QUEUED public="1" expr="0x1015">
			<x path="Int"/>
			<meta><m n=":value"><e>0x1015</e></m></meta>
		</BUFFERS_QUEUED>
		<BUFFERS_PROCESSED public="1" expr="0x1016">
			<x path="Int"/>
			<meta><m n=":value"><e>0x1016</e></m></meta>
		</BUFFERS_PROCESSED>
		<REFERENCE_DISTANCE public="1" expr="0x1020">
			<x path="Int"/>
			<meta><m n=":value"><e>0x1020</e></m></meta>
		</REFERENCE_DISTANCE>
		<ROLLOFF_FACTOR public="1" expr="0x1021">
			<x path="Int"/>
			<meta><m n=":value"><e>0x1021</e></m></meta>
		</ROLLOFF_FACTOR>
		<CONE_OUTER_GAIN public="1" expr="0x1022">
			<x path="Int"/>
			<meta><m n=":value"><e>0x1022</e></m></meta>
		</CONE_OUTER_GAIN>
		<MAX_DISTANCE public="1" expr="0x1023">
			<x path="Int"/>
			<meta><m n=":value"><e>0x1023</e></m></meta>
		</MAX_DISTANCE>
		<SEC_OFFSET public="1" expr="0x1024">
			<x path="Int"/>
			<meta><m n=":value"><e>0x1024</e></m></meta>
		</SEC_OFFSET>
		<SAMPLE_OFFSET public="1" expr="0x1025">
			<x path="Int"/>
			<meta><m n=":value"><e>0x1025</e></m></meta>
		</SAMPLE_OFFSET>
		<BYTE_OFFSET public="1" expr="0x1026">
			<x path="Int"/>
			<meta><m n=":value"><e>0x1026</e></m></meta>
		</BYTE_OFFSET>
		<SOURCE_TYPE public="1" expr="0x1027">
			<x path="Int"/>
			<meta><m n=":value"><e>0x1027</e></m></meta>
		</SOURCE_TYPE>
		<STATIC public="1" expr="0x1028">
			<x path="Int"/>
			<meta><m n=":value"><e>0x1028</e></m></meta>
		</STATIC>
		<STREAMING public="1" expr="0x1029">
			<x path="Int"/>
			<meta><m n=":value"><e>0x1029</e></m></meta>
		</STREAMING>
		<UNDETERMINED public="1" expr="0x1030">
			<x path="Int"/>
			<meta><m n=":value"><e>0x1030</e></m></meta>
		</UNDETERMINED>
		<FORMAT_MONO8 public="1" expr="0x1100">
			<x path="Int"/>
			<meta><m n=":value"><e>0x1100</e></m></meta>
		</FORMAT_MONO8>
		<FORMAT_MONO16 public="1" expr="0x1101">
			<x path="Int"/>
			<meta><m n=":value"><e>0x1101</e></m></meta>
		</FORMAT_MONO16>
		<FORMAT_STEREO8 public="1" expr="0x1102">
			<x path="Int"/>
			<meta><m n=":value"><e>0x1102</e></m></meta>
		</FORMAT_STEREO8>
		<FORMAT_STEREO16 public="1" expr="0x1103">
			<x path="Int"/>
			<meta><m n=":value"><e>0x1103</e></m></meta>
		</FORMAT_STEREO16>
		<FREQUENCY public="1" expr="0x2001">
			<x path="Int"/>
			<meta><m n=":value"><e>0x2001</e></m></meta>
		</FREQUENCY>
		<BITS public="1" expr="0x2002">
			<x path="Int"/>
			<meta><m n=":value"><e>0x2002</e></m></meta>
		</BITS>
		<CHANNELS public="1" expr="0x2003">
			<x path="Int"/>
			<meta><m n=":value"><e>0x2003</e></m></meta>
		</CHANNELS>
		<SIZE public="1" expr="0x2004">
			<x path="Int"/>
			<meta><m n=":value"><e>0x2004</e></m></meta>
		</SIZE>
		<NO_ERROR public="1" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</NO_ERROR>
		<INVALID_NAME public="1" expr="0xA001">
			<x path="Int"/>
			<meta><m n=":value"><e>0xA001</e></m></meta>
		</INVALID_NAME>
		<INVALID_ENUM public="1" expr="0xA002">
			<x path="Int"/>
			<meta><m n=":value"><e>0xA002</e></m></meta>
		</INVALID_ENUM>
		<INVALID_VALUE public="1" expr="0xA003">
			<x path="Int"/>
			<meta><m n=":value"><e>0xA003</e></m></meta>
		</INVALID_VALUE>
		<INVALID_OPERATION public="1" expr="0xA004">
			<x path="Int"/>
			<meta><m n=":value"><e>0xA004</e></m></meta>
		</INVALID_OPERATION>
		<OUT_OF_MEMORY public="1" expr="0xA005">
			<x path="Int"/>
			<meta><m n=":value"><e>0xA005</e></m></meta>
		</OUT_OF_MEMORY>
		<VENDOR public="1" expr="0xB001">
			<x path="Int"/>
			<meta><m n=":value"><e>0xB001</e></m></meta>
		</VENDOR>
		<VERSION public="1" expr="0xB002">
			<x path="Int"/>
			<meta><m n=":value"><e>0xB002</e></m></meta>
		</VERSION>
		<RENDERER public="1" expr="0xB003">
			<x path="Int"/>
			<meta><m n=":value"><e>0xB003</e></m></meta>
		</RENDERER>
		<EXTENSIONS public="1" expr="0xB004">
			<x path="Int"/>
			<meta><m n=":value"><e>0xB004</e></m></meta>
		</EXTENSIONS>
		<DOPPLER_FACTOR public="1" expr="0xC000">
			<x path="Int"/>
			<meta><m n=":value"><e>0xC000</e></m></meta>
		</DOPPLER_FACTOR>
		<SPEED_OF_SOUND public="1" expr="0xC003">
			<x path="Int"/>
			<meta><m n=":value"><e>0xC003</e></m></meta>
		</SPEED_OF_SOUND>
		<DOPPLER_VELOCITY public="1" expr="0xC001">
			<x path="Int"/>
			<meta><m n=":value"><e>0xC001</e></m></meta>
		</DOPPLER_VELOCITY>
		<DISTANCE_MODEL public="1" expr="0xD000">
			<x path="Int"/>
			<meta><m n=":value"><e>0xD000</e></m></meta>
		</DISTANCE_MODEL>
		<INVERSE_DISTANCE public="1" expr="0xD001">
			<x path="Int"/>
			<meta><m n=":value"><e>0xD001</e></m></meta>
		</INVERSE_DISTANCE>
		<INVERSE_DISTANCE_CLAMPED public="1" expr="0xD002">
			<x path="Int"/>
			<meta><m n=":value"><e>0xD002</e></m></meta>
		</INVERSE_DISTANCE_CLAMPED>
		<LINEAR_DISTANCE public="1" expr="0xD003">
			<x path="Int"/>
			<meta><m n=":value"><e>0xD003</e></m></meta>
		</LINEAR_DISTANCE>
		<LINEAR_DISTANCE_CLAMPED public="1" expr="0xD004">
			<x path="Int"/>
			<meta><m n=":value"><e>0xD004</e></m></meta>
		</LINEAR_DISTANCE_CLAMPED>
		<EXPONENT_DISTANCE public="1" expr="0xD005">
			<x path="Int"/>
			<meta><m n=":value"><e>0xD005</e></m></meta>
		</EXPONENT_DISTANCE>
		<EXPONENT_DISTANCE_CLAMPED public="1" expr="0xD006">
			<x path="Int"/>
			<meta><m n=":value"><e>0xD006</e></m></meta>
		</EXPONENT_DISTANCE_CLAMPED>
		<bufferData public="1" set="method" line="82"><f a="buffer:format:data:size:freq">
	<x path="Int"/>
	<x path="Int"/>
	<c path="lime.utils.ArrayBufferView"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></bufferData>
		<buffer3f public="1" set="method" line="89"><f a="buffer:param:value1:value2:value3">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></buffer3f>
		<buffer3i public="1" set="method" line="96"><f a="buffer:param:value1:value2:value3">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></buffer3i>
		<bufferf public="1" set="method" line="103"><f a="buffer:param:value">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Float"/>
	<x path="Void"/>
</f></bufferf>
		<bufferfv public="1" set="method" line="110"><f a="buffer:param:values">
	<x path="Int"/>
	<x path="Int"/>
	<c path="Array"><x path="Float"/></c>
	<x path="Void"/>
</f></bufferfv>
		<bufferi public="1" set="method" line="117"><f a="buffer:param:value">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></bufferi>
		<bufferiv public="1" set="method" line="124"><f a="buffer:param:values">
	<x path="Int"/>
	<x path="Int"/>
	<c path="Array"><x path="Int"/></c>
	<x path="Void"/>
</f></bufferiv>
		<deleteBuffer public="1" set="method" line="131"><f a="buffer">
	<x path="Int"/>
	<x path="Void"/>
</f></deleteBuffer>
		<deleteBuffers public="1" set="method" line="138"><f a="buffers">
	<c path="Array"><x path="Int"/></c>
	<x path="Void"/>
</f></deleteBuffers>
		<deleteSource public="1" set="method" line="145"><f a="source">
	<x path="Int"/>
	<x path="Void"/>
</f></deleteSource>
		<deleteSources public="1" set="method" line="152"><f a="sources">
	<c path="Array"><x path="Int"/></c>
	<x path="Void"/>
</f></deleteSources>
		<disable public="1" set="method" line="159"><f a="capability">
	<x path="Int"/>
	<x path="Void"/>
</f></disable>
		<distanceModel public="1" set="method" line="166"><f a="distanceModel">
	<x path="Int"/>
	<x path="Void"/>
</f></distanceModel>
		<dopplerFactor public="1" set="method" line="173"><f a="value">
	<x path="Float"/>
	<x path="Void"/>
</f></dopplerFactor>
		<dopplerVelocity public="1" set="method" line="180"><f a="value">
	<x path="Float"/>
	<x path="Void"/>
</f></dopplerVelocity>
		<enable public="1" set="method" line="187"><f a="capability">
	<x path="Int"/>
	<x path="Void"/>
</f></enable>
		<genSource public="1" set="method" line="194"><f a=""><x path="Int"/></f></genSource>
		<genSources public="1" set="method" line="201"><f a="n">
	<x path="Int"/>
	<c path="Array"><x path="Int"/></c>
</f></genSources>
		<genBuffer public="1" set="method" line="208"><f a=""><x path="Int"/></f></genBuffer>
		<genBuffers public="1" set="method" line="215"><f a="n">
	<x path="Int"/>
	<c path="Array"><x path="Int"/></c>
</f></genBuffers>
		<getBoolean public="1" set="method" line="222"><f a="param">
	<x path="Int"/>
	<x path="Bool"/>
</f></getBoolean>
		<getBooleanv public="1" set="method" line="229">
			<f a="param:?count" v=":1">
				<x path="Int"/>
				<x path="Int"/>
				<c path="Array"><x path="Bool"/></c>
			</f>
			<meta><m n=":value"><e>{ count : 1 }</e></m></meta>
		</getBooleanv>
		<getBuffer3f public="1" set="method" line="236"><f a="buffer:param">
	<x path="Int"/>
	<x path="Int"/>
	<c path="Array"><x path="Float"/></c>
</f></getBuffer3f>
		<getBuffer3i public="1" set="method" line="243"><f a="buffer:param">
	<x path="Int"/>
	<x path="Int"/>
	<c path="Array"><x path="Int"/></c>
</f></getBuffer3i>
		<getBufferf public="1" set="method" line="250"><f a="buffer:param">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Float"/>
</f></getBufferf>
		<getBufferfv public="1" set="method" line="257">
			<f a="buffer:param:?count" v="::1">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<c path="Array"><x path="Float"/></c>
			</f>
			<meta><m n=":value"><e>{ count : 1 }</e></m></meta>
		</getBufferfv>
		<getBufferi public="1" set="method" line="264"><f a="buffer:param">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></getBufferi>
		<getBufferiv public="1" set="method" line="271">
			<f a="buffer:param:?count" v="::1">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<c path="Array"><x path="Int"/></c>
			</f>
			<meta><m n=":value"><e>{ count : 1 }</e></m></meta>
		</getBufferiv>
		<getDouble public="1" set="method" line="278"><f a="param">
	<x path="Int"/>
	<x path="Float"/>
</f></getDouble>
		<getDoublev public="1" set="method" line="285">
			<f a="param:?count" v=":1">
				<x path="Int"/>
				<x path="Int"/>
				<c path="Array"><x path="Float"/></c>
			</f>
			<meta><m n=":value"><e>{ count : 1 }</e></m></meta>
		</getDoublev>
		<getEnumValue public="1" set="method" line="292"><f a="ename">
	<c path="String"/>
	<x path="Int"/>
</f></getEnumValue>
		<getError public="1" set="method" line="299"><f a=""><x path="Int"/></f></getError>
		<getErrorString public="1" set="method" line="306"><f a=""><c path="String"/></f></getErrorString>
		<getFloat public="1" set="method" line="313"><f a="param">
	<x path="Int"/>
	<x path="Float"/>
</f></getFloat>
		<getFloatv public="1" set="method" line="320">
			<f a="param:?count" v=":1">
				<x path="Int"/>
				<x path="Int"/>
				<c path="Array"><x path="Float"/></c>
			</f>
			<meta><m n=":value"><e>{ count : 1 }</e></m></meta>
		</getFloatv>
		<getInteger public="1" set="method" line="327"><f a="param">
	<x path="Int"/>
	<x path="Int"/>
</f></getInteger>
		<getIntegerv public="1" set="method" line="334">
			<f a="param:?count" v=":1">
				<x path="Int"/>
				<x path="Int"/>
				<c path="Array"><x path="Int"/></c>
			</f>
			<meta><m n=":value"><e>{ count : 1 }</e></m></meta>
		</getIntegerv>
		<getListener3f public="1" set="method" line="341"><f a="param">
	<x path="Int"/>
	<c path="Array"><x path="Float"/></c>
</f></getListener3f>
		<getListener3i public="1" set="method" line="348"><f a="param">
	<x path="Int"/>
	<c path="Array"><x path="Int"/></c>
</f></getListener3i>
		<getListenerf public="1" set="method" line="355"><f a="param">
	<x path="Int"/>
	<x path="Float"/>
</f></getListenerf>
		<getListenerfv public="1" set="method" line="362">
			<f a="param:?count" v=":1">
				<x path="Int"/>
				<x path="Int"/>
				<c path="Array"><x path="Float"/></c>
			</f>
			<meta><m n=":value"><e>{ count : 1 }</e></m></meta>
		</getListenerfv>
		<getListeneri public="1" set="method" line="369"><f a="param">
	<x path="Int"/>
	<x path="Int"/>
</f></getListeneri>
		<getListeneriv public="1" set="method" line="376">
			<f a="param:?count" v=":1">
				<x path="Int"/>
				<x path="Int"/>
				<c path="Array"><x path="Int"/></c>
			</f>
			<meta><m n=":value"><e>{ count : 1 }</e></m></meta>
		</getListeneriv>
		<getProcAddress public="1" set="method" line="383"><f a="fname">
	<c path="String"/>
	<d/>
</f></getProcAddress>
		<getSource3f public="1" set="method" line="390"><f a="source:param">
	<x path="Int"/>
	<x path="Int"/>
	<c path="Array"><x path="Float"/></c>
</f></getSource3f>
		<getSourcef public="1" set="method" line="397"><f a="source:param">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Float"/>
</f></getSourcef>
		<getSource3i public="1" set="method" line="404"><f a="source:param">
	<x path="Int"/>
	<x path="Int"/>
	<c path="Array"><x path="Int"/></c>
</f></getSource3i>
		<getSourcefv public="1" set="method" line="411">
			<f a="source:param:?count" v="::1">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<c path="Array"><x path="Float"/></c>
			</f>
			<meta><m n=":value"><e>{ count : 1 }</e></m></meta>
		</getSourcefv>
		<getSourcei public="1" set="method" line="418"><f a="source:param">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></getSourcei>
		<getSourceiv public="1" set="method" line="425">
			<f a="source:param:?count" v="::1">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<c path="Array"><x path="Int"/></c>
			</f>
			<meta><m n=":value"><e>{ count : 1 }</e></m></meta>
		</getSourceiv>
		<getString public="1" set="method" line="432"><f a="param">
	<x path="Int"/>
	<c path="String"/>
</f></getString>
		<isBuffer public="1" set="method" line="439"><f a="buffer">
	<x path="Int"/>
	<x path="Bool"/>
</f></isBuffer>
		<isEnabled public="1" set="method" line="446"><f a="capability">
	<x path="Int"/>
	<x path="Bool"/>
</f></isEnabled>
		<isExtensionPresent public="1" set="method" line="453"><f a="extname">
	<c path="String"/>
	<x path="Bool"/>
</f></isExtensionPresent>
		<isSource public="1" set="method" line="460"><f a="source">
	<x path="Int"/>
	<x path="Bool"/>
</f></isSource>
		<listener3f public="1" set="method" line="467"><f a="param:value1:value2:value3">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></listener3f>
		<listener3i public="1" set="method" line="474"><f a="param:value1:value2:value3">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></listener3i>
		<listenerf public="1" set="method" line="481"><f a="param:value">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Void"/>
</f></listenerf>
		<listenerfv public="1" set="method" line="488"><f a="param:values">
	<x path="Int"/>
	<c path="Array"><x path="Float"/></c>
	<x path="Void"/>
</f></listenerfv>
		<listeneri public="1" set="method" line="495"><f a="param:value">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></listeneri>
		<listeneriv public="1" set="method" line="502"><f a="param:values">
	<x path="Int"/>
	<c path="Array"><x path="Int"/></c>
	<x path="Void"/>
</f></listeneriv>
		<source3f public="1" set="method" line="509"><f a="source:param:value1:value2:value3">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></source3f>
		<source3i public="1" set="method" line="516"><f a="source:param:value1:value2:value3">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></source3i>
		<sourcef public="1" set="method" line="523"><f a="source:param:value">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Float"/>
	<x path="Void"/>
</f></sourcef>
		<sourcefv public="1" set="method" line="530"><f a="source:param:values">
	<x path="Int"/>
	<x path="Int"/>
	<c path="Array"><x path="Float"/></c>
	<x path="Void"/>
</f></sourcefv>
		<sourcei public="1" set="method" line="537"><f a="source:param:value">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></sourcei>
		<sourceiv public="1" set="method" line="544"><f a="source:param:values">
	<x path="Int"/>
	<x path="Int"/>
	<c path="Array"><x path="Int"/></c>
	<x path="Void"/>
</f></sourceiv>
		<sourcePlay public="1" set="method" line="551"><f a="source">
	<x path="Int"/>
	<x path="Void"/>
</f></sourcePlay>
		<sourcePlayv public="1" set="method" line="558"><f a="sources">
	<c path="Array"><x path="Int"/></c>
	<x path="Void"/>
</f></sourcePlayv>
		<sourceStop public="1" set="method" line="565"><f a="source">
	<x path="Int"/>
	<x path="Void"/>
</f></sourceStop>
		<sourceStopv public="1" set="method" line="572"><f a="sources">
	<c path="Array"><x path="Int"/></c>
	<x path="Void"/>
</f></sourceStopv>
		<sourceRewind public="1" set="method" line="579"><f a="source">
	<x path="Int"/>
	<x path="Void"/>
</f></sourceRewind>
		<sourceRewindv public="1" set="method" line="586"><f a="sources">
	<c path="Array"><x path="Int"/></c>
	<x path="Void"/>
</f></sourceRewindv>
		<sourcePause public="1" set="method" line="593"><f a="source">
	<x path="Int"/>
	<x path="Void"/>
</f></sourcePause>
		<sourcePausev public="1" set="method" line="600"><f a="sources">
	<c path="Array"><x path="Int"/></c>
	<x path="Void"/>
</f></sourcePausev>
		<sourceQueueBuffer public="1" set="method" line="607"><f a="source:buffer">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></sourceQueueBuffer>
		<sourceQueueBuffers public="1" set="method" line="614"><f a="source:nb:buffers">
	<x path="Int"/>
	<x path="Int"/>
	<c path="Array"><x path="Int"/></c>
	<x path="Void"/>
</f></sourceQueueBuffers>
		<sourceUnqueueBuffer public="1" set="method" line="621"><f a="source">
	<x path="Int"/>
	<x path="Int"/>
</f></sourceUnqueueBuffer>
		<sourceUnqueueBuffers public="1" set="method" line="628"><f a="source:nb">
	<x path="Int"/>
	<x path="Int"/>
	<c path="Array"><x path="Int"/></c>
</f></sourceUnqueueBuffers>
		<speedOfSound public="1" set="method" line="635"><f a="value">
	<x path="Float"/>
	<x path="Void"/>
</f></speedOfSound>
		<new public="1" set="method" line="75"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="lime.audio.ALCAudioContext" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/audio/ALCAudioContext.hx">
		<FALSE public="1" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</FALSE>
		<TRUE public="1" expr="1">
			<x path="Int"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</TRUE>
		<FREQUENCY public="1" expr="0x1007">
			<x path="Int"/>
			<meta><m n=":value"><e>0x1007</e></m></meta>
		</FREQUENCY>
		<REFRESH public="1" expr="0x1008">
			<x path="Int"/>
			<meta><m n=":value"><e>0x1008</e></m></meta>
		</REFRESH>
		<SYNC public="1" expr="0x1009">
			<x path="Int"/>
			<meta><m n=":value"><e>0x1009</e></m></meta>
		</SYNC>
		<MONO_SOURCES public="1" expr="0x1010">
			<x path="Int"/>
			<meta><m n=":value"><e>0x1010</e></m></meta>
		</MONO_SOURCES>
		<STEREO_SOURCES public="1" expr="0x1011">
			<x path="Int"/>
			<meta><m n=":value"><e>0x1011</e></m></meta>
		</STEREO_SOURCES>
		<NO_ERROR public="1" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</NO_ERROR>
		<INVALID_DEVICE public="1" expr="0xA001">
			<x path="Int"/>
			<meta><m n=":value"><e>0xA001</e></m></meta>
		</INVALID_DEVICE>
		<INVALID_CONTEXT public="1" expr="0xA002">
			<x path="Int"/>
			<meta><m n=":value"><e>0xA002</e></m></meta>
		</INVALID_CONTEXT>
		<INVALID_ENUM public="1" expr="0xA003">
			<x path="Int"/>
			<meta><m n=":value"><e>0xA003</e></m></meta>
		</INVALID_ENUM>
		<INVALID_VALUE public="1" expr="0xA004">
			<x path="Int"/>
			<meta><m n=":value"><e>0xA004</e></m></meta>
		</INVALID_VALUE>
		<OUT_OF_MEMORY public="1" expr="0xA005">
			<x path="Int"/>
			<meta><m n=":value"><e>0xA005</e></m></meta>
		</OUT_OF_MEMORY>
		<ATTRIBUTES_SIZE public="1" expr="0x1002">
			<x path="Int"/>
			<meta><m n=":value"><e>0x1002</e></m></meta>
		</ATTRIBUTES_SIZE>
		<ALL_ATTRIBUTES public="1" expr="0x1003">
			<x path="Int"/>
			<meta><m n=":value"><e>0x1003</e></m></meta>
		</ALL_ATTRIBUTES>
		<DEFAULT_DEVICE_SPECIFIER public="1" expr="0x1004">
			<x path="Int"/>
			<meta><m n=":value"><e>0x1004</e></m></meta>
		</DEFAULT_DEVICE_SPECIFIER>
		<DEVICE_SPECIFIER public="1" expr="0x1005">
			<x path="Int"/>
			<meta><m n=":value"><e>0x1005</e></m></meta>
		</DEVICE_SPECIFIER>
		<EXTENSIONS public="1" expr="0x1006">
			<x path="Int"/>
			<meta><m n=":value"><e>0x1006</e></m></meta>
		</EXTENSIONS>
		<ENUMERATE_ALL_EXT public="1" expr="1">
			<x path="Int"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</ENUMERATE_ALL_EXT>
		<DEFAULT_ALL_DEVICES_SPECIFIER public="1" expr="0x1012">
			<x path="Int"/>
			<meta><m n=":value"><e>0x1012</e></m></meta>
		</DEFAULT_ALL_DEVICES_SPECIFIER>
		<ALL_DEVICES_SPECIFIER public="1" expr="0x1013">
			<x path="Int"/>
			<meta><m n=":value"><e>0x1013</e></m></meta>
		</ALL_DEVICES_SPECIFIER>
		<closeDevice public="1" set="method" line="42"><f a="device">
	<x path="lime.audio.openal.ALDevice"/>
	<x path="Bool"/>
</f></closeDevice>
		<createContext public="1" set="method" line="49">
			<f a="device:?attrlist" v=":null">
				<x path="lime.audio.openal.ALDevice"/>
				<c path="Array"><x path="Int"/></c>
				<x path="lime.audio.openal.ALContext"/>
			</f>
			<meta><m n=":value"><e>{ attrlist : null }</e></m></meta>
		</createContext>
		<destroyContext public="1" set="method" line="56"><f a="context">
	<x path="lime.audio.openal.ALContext"/>
	<x path="Void"/>
</f></destroyContext>
		<getContextsDevice public="1" set="method" line="63"><f a="context">
	<x path="lime.audio.openal.ALContext"/>
	<x path="lime.audio.openal.ALDevice"/>
</f></getContextsDevice>
		<getCurrentContext public="1" set="method" line="70"><f a=""><x path="lime.audio.openal.ALContext"/></f></getCurrentContext>
		<getError public="1" set="method" line="77"><f a="device">
	<x path="lime.audio.openal.ALDevice"/>
	<x path="Int"/>
</f></getError>
		<getErrorString public="1" set="method" line="84"><f a="device">
	<x path="lime.audio.openal.ALDevice"/>
	<c path="String"/>
</f></getErrorString>
		<getIntegerv public="1" set="method" line="91">
			<f a="device:param:?count" v="::1">
				<x path="lime.audio.openal.ALDevice"/>
				<x path="Int"/>
				<x path="Int"/>
				<c path="Array"><x path="Int"/></c>
			</f>
			<meta><m n=":value"><e>{ count : 1 }</e></m></meta>
		</getIntegerv>
		<getString public="1" set="method" line="98"><f a="device:param">
	<x path="lime.audio.openal.ALDevice"/>
	<x path="Int"/>
	<c path="String"/>
</f></getString>
		<makeContextCurrent public="1" set="method" line="105"><f a="context">
	<x path="lime.audio.openal.ALContext"/>
	<x path="Bool"/>
</f></makeContextCurrent>
		<openDevice public="1" set="method" line="112">
			<f a="?deviceName" v="null">
				<c path="String"/>
				<x path="lime.audio.openal.ALDevice"/>
			</f>
			<meta><m n=":value"><e>{ deviceName : null }</e></m></meta>
		</openDevice>
		<processContext public="1" set="method" line="119"><f a="context">
	<x path="lime.audio.openal.ALContext"/>
	<x path="Void"/>
</f></processContext>
		<suspendContext public="1" set="method" line="126"><f a="context">
	<x path="lime.audio.openal.ALContext"/>
	<x path="Void"/>
</f></suspendContext>
		<new public="1" set="method" line="35"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="lime.audio.AudioBuffer" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/audio/AudioBuffer.hx">
		<fromBytes public="1" set="method" line="72" static="1"><f a="bytes">
	<c path="haxe.io.Bytes"/>
	<c path="lime.audio.AudioBuffer"/>
</f></fromBytes>
		<fromFile public="1" set="method" line="100" static="1"><f a="path">
	<c path="String"/>
	<c path="lime.audio.AudioBuffer"/>
</f></fromFile>
		<fromURL public="1" set="method" line="148" static="1"><f a="url:handler">
	<c path="String"/>
	<f a="">
		<c path="lime.audio.AudioBuffer"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></fromURL>
		<lime_audio_load get="inline" set="null" line="189" static="1">
			<f a="data">
				<d/>
				<d/>
			</f>
			<meta><m n=":cffi"/></meta>
		</lime_audio_load>
		<cffi_lime_audio_load expr="new cpp.Callable&lt;Dynamic&gt;(lime.system.CFFI.load(&quot;lime&quot;, &quot;lime_audio_load&quot;, 1, false))" line="189" static="1">
			<x path="cpp.Callable"><f a="">
	<d/>
	<d/>
</f></x>
			<meta><m n=":value"><e><![CDATA[new cpp.Callable<Dynamic>(lime.system.CFFI.load("lime", "lime_audio_load", 1, false))]]></e></m></meta>
		</cffi_lime_audio_load>
		<bitsPerSample public="1"><x path="Int"/></bitsPerSample>
		<channels public="1"><x path="Int"/></channels>
		<data public="1"><x path="lime.utils.UInt8Array"/></data>
		<id public="1"><x path="UInt"/></id>
		<sampleRate public="1"><x path="Int"/></sampleRate>
		<src public="1"><d/></src>
		<dispose public="1" set="method" line="50"><f a=""><x path="Void"/></f></dispose>
		<new public="1" set="method" line="43"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>lime.system.CFFI.build()</e></m>
		</meta>
	</class>
	<enum path="lime.audio.AudioContext" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/audio/AudioContext.hx">
		<OPENAL a="alc:al">
			<c path="lime.audio.ALCAudioContext"/>
			<c path="lime.audio.ALAudioContext"/>
		</OPENAL>
		<HTML5 a="context"><c path="lime.audio.HTML5AudioContext"/></HTML5>
		<WEB a="context"><c path="lime.audio.WebAudioContext"/></WEB>
		<FLASH a="context"><c path="lime.audio.FlashAudioContext"/></FLASH>
		<CUSTOM a="data"><d/></CUSTOM>
		<meta><m n=":directlyUsed"/></meta>
	</enum>
	<class path="lime.audio.AudioManager" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/audio/AudioManager.hx">
		<context public="1" static="1"><e path="lime.audio.AudioContext"/></context>
		<init public="1" set="method" line="20" static="1">
			<f a="?context" v="null">
				<e path="lime.audio.AudioContext"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ context : null }</e></m></meta>
		</init>
		<resume public="1" set="method" line="70" static="1"><f a=""><x path="Void"/></f></resume>
		<shutdown public="1" set="method" line="89" static="1"><f a=""><x path="Void"/></f></shutdown>
		<suspend public="1" set="method" line="117" static="1"><f a=""><x path="Void"/></f></suspend>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="lime.audio.AudioSource" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/audio/AudioSource.hx">
		<onComplete public="1" expr="new Event&lt;Void&gt;()">
			<c path="lime.app.Event_Void_Void"><f a=""><x path="Void"/></f></c>
			<meta><m n=":value"><e><![CDATA[new Event<Void>()]]></e></m></meta>
		</onComplete>
		<buffer public="1"><c path="lime.audio.AudioBuffer"/></buffer>
		<currentTime public="1" get="accessor" set="accessor"><x path="Int"/></currentTime>
		<gain public="1" get="accessor" set="accessor"><x path="Float"/></gain>
		<length public="1" get="accessor" set="accessor"><x path="Int"/></length>
		<loops public="1" get="accessor" set="accessor"><x path="Int"/></loops>
		<offset public="1"><x path="Int"/></offset>
		<id><x path="UInt"/></id>
		<playing><x path="Bool"/></playing>
		<pauseTime><x path="Int"/></pauseTime>
		<__length><t path="Null"><x path="Int"/></t></__length>
		<__loops><x path="Int"/></__loops>
		<timer><c path="haxe.Timer"/></timer>
		<dispose public="1" set="method" line="79"><f a=""><x path="Void"/></f></dispose>
		<init set="method" line="98"><f a=""><x path="Void"/></f></init>
		<play public="1" set="method" line="150"><f a=""><x path="Void"/></f></play>
		<pause public="1" set="method" line="200"><f a=""><x path="Void"/></f></pause>
		<stop public="1" set="method" line="236"><f a=""><x path="Void"/></f></stop>
		<timer_onRun set="method" line="362"><f a=""><x path="Void"/></f></timer_onRun>
		<get_currentTime set="method" line="396"><f a=""><x path="Int"/></f></get_currentTime>
		<set_currentTime set="method" line="422"><f a="value">
	<x path="Int"/>
	<x path="Int"/>
</f></set_currentTime>
		<get_gain set="method" line="475"><f a=""><x path="Float"/></f></get_gain>
		<set_gain set="method" line="499"><f a="value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_gain>
		<get_length set="method" line="527"><f a=""><x path="Int"/></f></get_length>
		<set_length set="method" line="558"><f a="value">
	<x path="Int"/>
	<x path="Int"/>
</f></set_length>
		<get_loops set="method" line="593"><f a=""><x path="Int"/></f></get_loops>
		<set_loops set="method" line="610"><f a="loops">
	<x path="Int"/>
	<x path="Int"/>
</f></set_loops>
		<new public="1" set="method" line="56">
			<f a="?buffer:?offset:?length:?loops" v="null:0:null:0">
				<c path="lime.audio.AudioBuffer"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ loops : 0, length : null, offset : 0, buffer : null }</e></m></meta>
		</new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="lime.audio.FlashAudioContext" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/audio/FlashAudioContext.hx">
		<createBuffer public="1" set="method" line="19">
			<f a="?stream:?context" v="null:null">
				<d/>
				<d/>
				<c path="lime.audio.AudioBuffer"/>
			</f>
			<meta><m n=":value"><e>{ context : null, stream : null }</e></m></meta>
		</createBuffer>
		<getBytesLoaded public="1" set="method" line="32"><f a="buffer">
	<c path="lime.audio.AudioBuffer"/>
	<x path="UInt"/>
</f></getBytesLoaded>
		<getBytesTotal public="1" set="method" line="47"><f a="buffer">
	<c path="lime.audio.AudioBuffer"/>
	<x path="Int"/>
</f></getBytesTotal>
		<getID3 public="1" set="method" line="62"><f a="buffer">
	<c path="lime.audio.AudioBuffer"/>
	<d/>
</f></getID3>
		<getIsBuffering public="1" set="method" line="77"><f a="buffer">
	<c path="lime.audio.AudioBuffer"/>
	<x path="Bool"/>
</f></getIsBuffering>
		<getIsURLInaccessible public="1" set="method" line="92"><f a="buffer">
	<c path="lime.audio.AudioBuffer"/>
	<x path="Bool"/>
</f></getIsURLInaccessible>
		<getLength public="1" set="method" line="107"><f a="buffer">
	<c path="lime.audio.AudioBuffer"/>
	<x path="Float"/>
</f></getLength>
		<getURL public="1" set="method" line="122"><f a="buffer">
	<c path="lime.audio.AudioBuffer"/>
	<c path="String"/>
</f></getURL>
		<close public="1" set="method" line="137"><f a="buffer">
	<c path="lime.audio.AudioBuffer"/>
	<x path="Void"/>
</f></close>
		<extract public="1" set="method" line="150">
			<f a="buffer:target:length:?startPosition" v=":::-1">
				<c path="lime.audio.AudioBuffer"/>
				<d/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":value"><e>{ startPosition : -1 }</e></m></meta>
		</extract>
		<load public="1" set="method" line="165">
			<f a="buffer:stream:?context" v="::null">
				<c path="lime.audio.AudioBuffer"/>
				<d/>
				<d/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ context : null }</e></m></meta>
		</load>
		<loadCompressedDataFromByteArray public="1" set="method" line="178"><f a="buffer:bytes:bytesLength">
	<c path="lime.audio.AudioBuffer"/>
	<d/>
	<x path="UInt"/>
	<x path="Void"/>
</f></loadCompressedDataFromByteArray>
		<loadPCMFromByteArray public="1" set="method" line="191">
			<f a="buffer:bytes:samples:?format:?stereo:?sampleRate" v=":::null:true:44100">
				<c path="lime.audio.AudioBuffer"/>
				<d/>
				<x path="UInt"/>
				<c path="String"/>
				<x path="Bool"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ sampleRate : 44100, stereo : true, format : null }</e></m></meta>
		</loadPCMFromByteArray>
		<play public="1" set="method" line="204">
			<f a="buffer:?startTime:?loops:?sndTransform" v=":0:0:null">
				<c path="lime.audio.AudioBuffer"/>
				<x path="Float"/>
				<x path="Int"/>
				<d/>
				<d/>
			</f>
			<meta><m n=":value"><e>{ sndTransform : null, loops : 0, startTime : 0 }</e></m></meta>
		</play>
		<new public="1" set="method" line="12"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="lime.audio.HTML5AudioContext" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/audio/HTML5AudioContext.hx">
		<HAVE_CURRENT_DATA public="1" expr="2">
			<x path="Int"/>
			<meta><m n=":value"><e>2</e></m></meta>
		</HAVE_CURRENT_DATA>
		<HAVE_ENOUGH_DATA public="1" expr="4">
			<x path="Int"/>
			<meta><m n=":value"><e>4</e></m></meta>
		</HAVE_ENOUGH_DATA>
		<HAVE_FUTURE_DATA public="1" expr="3">
			<x path="Int"/>
			<meta><m n=":value"><e>3</e></m></meta>
		</HAVE_FUTURE_DATA>
		<HAVE_METADATA public="1" expr="1">
			<x path="Int"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</HAVE_METADATA>
		<HAVE_NOTHING public="1" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</HAVE_NOTHING>
		<NETWORK_EMPTY public="1" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</NETWORK_EMPTY>
		<NETWORK_IDLE public="1" expr="1">
			<x path="Int"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</NETWORK_IDLE>
		<NETWORK_LOADING public="1" expr="2">
			<x path="Int"/>
			<meta><m n=":value"><e>2</e></m></meta>
		</NETWORK_LOADING>
		<NETWORK_NO_SOURCE public="1" expr="3">
			<x path="Int"/>
			<meta><m n=":value"><e>3</e></m></meta>
		</NETWORK_NO_SOURCE>
		<canPlayType public="1" set="method" line="30"><f a="buffer:type">
	<c path="lime.audio.AudioBuffer"/>
	<c path="String"/>
	<c path="String"/>
</f></canPlayType>
		<createBuffer public="1" set="method" line="45">
			<f a="?urlString" v="null">
				<c path="String"/>
				<c path="lime.audio.AudioBuffer"/>
			</f>
			<meta><m n=":value"><e>{ urlString : null }</e></m></meta>
		</createBuffer>
		<getAutoplay public="1" set="method" line="76"><f a="buffer">
	<c path="lime.audio.AudioBuffer"/>
	<x path="Bool"/>
</f></getAutoplay>
		<getBuffered public="1" set="method" line="91"><f a="buffer">
	<c path="lime.audio.AudioBuffer"/>
	<d/>
</f></getBuffered>
		<getCurrentSrc public="1" set="method" line="123"><f a="buffer">
	<c path="lime.audio.AudioBuffer"/>
	<c path="String"/>
</f></getCurrentSrc>
		<getCurrentTime public="1" set="method" line="138"><f a="buffer">
	<c path="lime.audio.AudioBuffer"/>
	<x path="Float"/>
</f></getCurrentTime>
		<getDefaultPlaybackRate public="1" set="method" line="153"><f a="buffer">
	<c path="lime.audio.AudioBuffer"/>
	<x path="Float"/>
</f></getDefaultPlaybackRate>
		<getDuration public="1" set="method" line="168"><f a="buffer">
	<c path="lime.audio.AudioBuffer"/>
	<x path="Float"/>
</f></getDuration>
		<getEnded public="1" set="method" line="183"><f a="buffer">
	<c path="lime.audio.AudioBuffer"/>
	<x path="Bool"/>
</f></getEnded>
		<getError public="1" set="method" line="198"><f a="buffer">
	<c path="lime.audio.AudioBuffer"/>
	<d/>
</f></getError>
		<getLoop public="1" set="method" line="230"><f a="buffer">
	<c path="lime.audio.AudioBuffer"/>
	<x path="Bool"/>
</f></getLoop>
		<getMuted public="1" set="method" line="262"><f a="buffer">
	<c path="lime.audio.AudioBuffer"/>
	<x path="Bool"/>
</f></getMuted>
		<getNetworkState public="1" set="method" line="277"><f a="buffer">
	<c path="lime.audio.AudioBuffer"/>
	<x path="Int"/>
</f></getNetworkState>
		<getPaused public="1" set="method" line="292"><f a="buffer">
	<c path="lime.audio.AudioBuffer"/>
	<x path="Bool"/>
</f></getPaused>
		<getPlaybackRate public="1" set="method" line="307"><f a="buffer">
	<c path="lime.audio.AudioBuffer"/>
	<x path="Float"/>
</f></getPlaybackRate>
		<getPlayed public="1" set="method" line="322"><f a="buffer">
	<c path="lime.audio.AudioBuffer"/>
	<d/>
</f></getPlayed>
		<getPreload public="1" set="method" line="337"><f a="buffer">
	<c path="lime.audio.AudioBuffer"/>
	<c path="String"/>
</f></getPreload>
		<getReadyState public="1" set="method" line="352"><f a="buffer">
	<c path="lime.audio.AudioBuffer"/>
	<x path="Int"/>
</f></getReadyState>
		<getSeekable public="1" set="method" line="367"><f a="buffer">
	<c path="lime.audio.AudioBuffer"/>
	<d/>
</f></getSeekable>
		<getSeeking public="1" set="method" line="382"><f a="buffer">
	<c path="lime.audio.AudioBuffer"/>
	<x path="Bool"/>
</f></getSeeking>
		<getSrc public="1" set="method" line="397"><f a="buffer">
	<c path="lime.audio.AudioBuffer"/>
	<c path="String"/>
</f></getSrc>
		<getStartTime public="1" set="method" line="412"><f a="buffer">
	<c path="lime.audio.AudioBuffer"/>
	<x path="Float"/>
</f></getStartTime>
		<getVolume public="1" set="method" line="427"><f a="buffer">
	<c path="lime.audio.AudioBuffer"/>
	<x path="Float"/>
</f></getVolume>
		<load public="1" set="method" line="442"><f a="buffer">
	<c path="lime.audio.AudioBuffer"/>
	<x path="Void"/>
</f></load>
		<pause public="1" set="method" line="455"><f a="buffer">
	<c path="lime.audio.AudioBuffer"/>
	<x path="Void"/>
</f></pause>
		<play public="1" set="method" line="468"><f a="buffer">
	<c path="lime.audio.AudioBuffer"/>
	<x path="Void"/>
</f></play>
		<setAutoplay public="1" set="method" line="481"><f a="buffer:value">
	<c path="lime.audio.AudioBuffer"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></setAutoplay>
		<setCurrentTime public="1" set="method" line="509"><f a="buffer:value">
	<c path="lime.audio.AudioBuffer"/>
	<x path="Float"/>
	<x path="Void"/>
</f></setCurrentTime>
		<setDefaultPlaybackRate public="1" set="method" line="522"><f a="buffer:value">
	<c path="lime.audio.AudioBuffer"/>
	<x path="Float"/>
	<x path="Void"/>
</f></setDefaultPlaybackRate>
		<setLoop public="1" set="method" line="535"><f a="buffer:value">
	<c path="lime.audio.AudioBuffer"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></setLoop>
		<setMuted public="1" set="method" line="563"><f a="buffer:value">
	<c path="lime.audio.AudioBuffer"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></setMuted>
		<setPlaybackRate public="1" set="method" line="576"><f a="buffer:value">
	<c path="lime.audio.AudioBuffer"/>
	<x path="Float"/>
	<x path="Void"/>
</f></setPlaybackRate>
		<setPreload public="1" set="method" line="589"><f a="buffer:value">
	<c path="lime.audio.AudioBuffer"/>
	<c path="String"/>
	<x path="Void"/>
</f></setPreload>
		<setSrc public="1" set="method" line="602"><f a="buffer:value">
	<c path="lime.audio.AudioBuffer"/>
	<c path="String"/>
	<x path="Void"/>
</f></setSrc>
		<setVolume public="1" set="method" line="615"><f a="buffer:value">
	<c path="lime.audio.AudioBuffer"/>
	<x path="Float"/>
	<x path="Void"/>
</f></setVolume>
		<new public="1" set="method" line="23"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="lime.audio.WebAudioContext" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/audio/WebAudioContext.hx">
		<activeSourceCount public="1" set="null"><x path="Int"/></activeSourceCount>
		<currentTime public="1" set="null"><x path="Float"/></currentTime>
		<destination public="1" set="null"><d/></destination>
		<listener public="1" set="null"><d/></listener>
		<oncomplete public="1"><d/></oncomplete>
		<sampleRate public="1" set="null"><x path="Float"/></sampleRate>
		<createAnalyser public="1" set="method" line="22"><f a=""><d/></f></createAnalyser>
		<createBiquadFilter public="1" set="method" line="23"><f a=""><d/></f></createBiquadFilter>
		<createBuffer public="1" set="method" line="25">
			<f a="buffer:mixToMono">
				<d/>
				<x path="Bool"/>
				<d/>
			</f>
			<overloads><createBuffer public="1" set="method"><f a="numberOfChannels:numberOfFrames:sampleRate">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Float"/>
	<d/>
</f></createBuffer></overloads>
		</createBuffer>
		<createBufferSource public="1" set="method" line="26"><f a=""><d/></f></createBufferSource>
		<createChannelMerger public="1" set="method" line="27"><f a="?numberOfInputs">
	<x path="Int"/>
	<d/>
</f></createChannelMerger>
		<createChannelSplitter public="1" set="method" line="28"><f a="?numberOfOutputs">
	<x path="Int"/>
	<d/>
</f></createChannelSplitter>
		<createConvolver public="1" set="method" line="29"><f a=""><d/></f></createConvolver>
		<createDelay public="1" set="method" line="30"><f a="?maxDelayTime">
	<x path="Float"/>
	<d/>
</f></createDelay>
		<createDynamicsCompressor public="1" set="method" line="31"><f a=""><d/></f></createDynamicsCompressor>
		<createGain public="1" set="method" line="32"><f a=""><d/></f></createGain>
		<createMediaElementSource public="1" set="method" line="33"><f a="mediaElement">
	<d/>
	<d/>
</f></createMediaElementSource>
		<createMediaStreamSource public="1" set="method" line="34"><f a="mediaStream">
	<d/>
	<d/>
</f></createMediaStreamSource>
		<createOscillator public="1" set="method" line="35"><f a=""><d/></f></createOscillator>
		<createPanner public="1" set="method" line="36"><f a=""><d/></f></createPanner>
		<createScriptProcessor public="1" set="method" line="37"><f a="bufferSize:?numberOfInputChannels:?numberOfOutputChannels">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<d/>
</f></createScriptProcessor>
		<createWaveShaper public="1" set="method" line="38"><f a=""><d/></f></createWaveShaper>
		<createWaveTable public="1" set="method" line="39"><f a="real:imag">
	<d/>
	<d/>
	<d/>
</f></createWaveTable>
		<decodeAudioData public="1" set="method" line="40"><f a="audioData:successCallback:?errorCallback">
	<d/>
	<d/>
	<d/>
	<x path="Void"/>
</f></decodeAudioData>
		<startRendering public="1" set="method" line="41"><f a=""><x path="Void"/></f></startRendering>
		<new public="1" set="method" line="15"><f a=""><x path="Void"/></f></new>
	</class>
	<typedef path="lime.audio.openal.Float32" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/audio/openal/AL.hx" module="lime.audio.openal.AL"><x path="Float"/></typedef>
	<class path="lime.audio.openal.AL" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/audio/openal/AL.hx">
		<NONE public="1" get="inline" set="null" expr="0" line="20" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</NONE>
		<FALSE public="1" get="inline" set="null" expr="0" line="21" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</FALSE>
		<TRUE public="1" get="inline" set="null" expr="1" line="22" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</TRUE>
		<SOURCE_RELATIVE public="1" get="inline" set="null" expr="0x202" line="23" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x202</e></m></meta>
		</SOURCE_RELATIVE>
		<CONE_INNER_ANGLE public="1" get="inline" set="null" expr="0x1001" line="24" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x1001</e></m></meta>
		</CONE_INNER_ANGLE>
		<CONE_OUTER_ANGLE public="1" get="inline" set="null" expr="0x1002" line="25" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x1002</e></m></meta>
		</CONE_OUTER_ANGLE>
		<PITCH public="1" get="inline" set="null" expr="0x1003" line="26" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x1003</e></m></meta>
		</PITCH>
		<POSITION public="1" get="inline" set="null" expr="0x1004" line="27" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x1004</e></m></meta>
		</POSITION>
		<DIRECTION public="1" get="inline" set="null" expr="0x1005" line="28" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x1005</e></m></meta>
		</DIRECTION>
		<VELOCITY public="1" get="inline" set="null" expr="0x1006" line="29" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x1006</e></m></meta>
		</VELOCITY>
		<LOOPING public="1" get="inline" set="null" expr="0x1007" line="30" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x1007</e></m></meta>
		</LOOPING>
		<BUFFER public="1" get="inline" set="null" expr="0x1009" line="31" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x1009</e></m></meta>
		</BUFFER>
		<GAIN public="1" get="inline" set="null" expr="0x100A" line="32" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x100A</e></m></meta>
		</GAIN>
		<MIN_GAIN public="1" get="inline" set="null" expr="0x100D" line="33" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x100D</e></m></meta>
		</MIN_GAIN>
		<MAX_GAIN public="1" get="inline" set="null" expr="0x100E" line="34" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x100E</e></m></meta>
		</MAX_GAIN>
		<ORIENTATION public="1" get="inline" set="null" expr="0x100F" line="35" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x100F</e></m></meta>
		</ORIENTATION>
		<SOURCE_STATE public="1" get="inline" set="null" expr="0x1010" line="36" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x1010</e></m></meta>
		</SOURCE_STATE>
		<INITIAL public="1" get="inline" set="null" expr="0x1011" line="37" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x1011</e></m></meta>
		</INITIAL>
		<PLAYING public="1" get="inline" set="null" expr="0x1012" line="38" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x1012</e></m></meta>
		</PLAYING>
		<PAUSED public="1" get="inline" set="null" expr="0x1013" line="39" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x1013</e></m></meta>
		</PAUSED>
		<STOPPED public="1" get="inline" set="null" expr="0x1014" line="40" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x1014</e></m></meta>
		</STOPPED>
		<BUFFERS_QUEUED public="1" get="inline" set="null" expr="0x1015" line="41" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x1015</e></m></meta>
		</BUFFERS_QUEUED>
		<BUFFERS_PROCESSED public="1" get="inline" set="null" expr="0x1016" line="42" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x1016</e></m></meta>
		</BUFFERS_PROCESSED>
		<REFERENCE_DISTANCE public="1" get="inline" set="null" expr="0x1020" line="43" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x1020</e></m></meta>
		</REFERENCE_DISTANCE>
		<ROLLOFF_FACTOR public="1" get="inline" set="null" expr="0x1021" line="44" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x1021</e></m></meta>
		</ROLLOFF_FACTOR>
		<CONE_OUTER_GAIN public="1" get="inline" set="null" expr="0x1022" line="45" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x1022</e></m></meta>
		</CONE_OUTER_GAIN>
		<MAX_DISTANCE public="1" get="inline" set="null" expr="0x1023" line="46" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x1023</e></m></meta>
		</MAX_DISTANCE>
		<SEC_OFFSET public="1" get="inline" set="null" expr="0x1024" line="47" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x1024</e></m></meta>
		</SEC_OFFSET>
		<SAMPLE_OFFSET public="1" get="inline" set="null" expr="0x1025" line="48" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x1025</e></m></meta>
		</SAMPLE_OFFSET>
		<BYTE_OFFSET public="1" get="inline" set="null" expr="0x1026" line="49" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x1026</e></m></meta>
		</BYTE_OFFSET>
		<SOURCE_TYPE public="1" get="inline" set="null" expr="0x1027" line="50" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x1027</e></m></meta>
		</SOURCE_TYPE>
		<STATIC public="1" get="inline" set="null" expr="0x1028" line="51" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x1028</e></m></meta>
		</STATIC>
		<STREAMING public="1" get="inline" set="null" expr="0x1029" line="52" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x1029</e></m></meta>
		</STREAMING>
		<UNDETERMINED public="1" get="inline" set="null" expr="0x1030" line="53" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x1030</e></m></meta>
		</UNDETERMINED>
		<FORMAT_MONO8 public="1" get="inline" set="null" expr="0x1100" line="54" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x1100</e></m></meta>
		</FORMAT_MONO8>
		<FORMAT_MONO16 public="1" get="inline" set="null" expr="0x1101" line="55" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x1101</e></m></meta>
		</FORMAT_MONO16>
		<FORMAT_STEREO8 public="1" get="inline" set="null" expr="0x1102" line="56" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x1102</e></m></meta>
		</FORMAT_STEREO8>
		<FORMAT_STEREO16 public="1" get="inline" set="null" expr="0x1103" line="57" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x1103</e></m></meta>
		</FORMAT_STEREO16>
		<FREQUENCY public="1" get="inline" set="null" expr="0x2001" line="58" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x2001</e></m></meta>
		</FREQUENCY>
		<BITS public="1" get="inline" set="null" expr="0x2002" line="59" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x2002</e></m></meta>
		</BITS>
		<CHANNELS public="1" get="inline" set="null" expr="0x2003" line="60" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x2003</e></m></meta>
		</CHANNELS>
		<SIZE public="1" get="inline" set="null" expr="0x2004" line="61" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x2004</e></m></meta>
		</SIZE>
		<NO_ERROR public="1" get="inline" set="null" expr="0" line="62" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</NO_ERROR>
		<INVALID_NAME public="1" get="inline" set="null" expr="0xA001" line="63" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0xA001</e></m></meta>
		</INVALID_NAME>
		<INVALID_ENUM public="1" get="inline" set="null" expr="0xA002" line="64" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0xA002</e></m></meta>
		</INVALID_ENUM>
		<INVALID_VALUE public="1" get="inline" set="null" expr="0xA003" line="65" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0xA003</e></m></meta>
		</INVALID_VALUE>
		<INVALID_OPERATION public="1" get="inline" set="null" expr="0xA004" line="66" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0xA004</e></m></meta>
		</INVALID_OPERATION>
		<OUT_OF_MEMORY public="1" get="inline" set="null" expr="0xA005" line="67" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0xA005</e></m></meta>
		</OUT_OF_MEMORY>
		<VENDOR public="1" get="inline" set="null" expr="0xB001" line="68" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0xB001</e></m></meta>
		</VENDOR>
		<VERSION public="1" get="inline" set="null" expr="0xB002" line="69" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0xB002</e></m></meta>
		</VERSION>
		<RENDERER public="1" get="inline" set="null" expr="0xB003" line="70" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0xB003</e></m></meta>
		</RENDERER>
		<EXTENSIONS public="1" get="inline" set="null" expr="0xB004" line="71" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0xB004</e></m></meta>
		</EXTENSIONS>
		<DOPPLER_FACTOR public="1" get="inline" set="null" expr="0xC000" line="72" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0xC000</e></m></meta>
		</DOPPLER_FACTOR>
		<SPEED_OF_SOUND public="1" get="inline" set="null" expr="0xC003" line="73" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0xC003</e></m></meta>
		</SPEED_OF_SOUND>
		<DOPPLER_VELOCITY public="1" get="inline" set="null" expr="0xC001" line="74" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0xC001</e></m></meta>
		</DOPPLER_VELOCITY>
		<DISTANCE_MODEL public="1" get="inline" set="null" expr="0xD000" line="75" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0xD000</e></m></meta>
		</DISTANCE_MODEL>
		<INVERSE_DISTANCE public="1" get="inline" set="null" expr="0xD001" line="76" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0xD001</e></m></meta>
		</INVERSE_DISTANCE>
		<INVERSE_DISTANCE_CLAMPED public="1" get="inline" set="null" expr="0xD002" line="77" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0xD002</e></m></meta>
		</INVERSE_DISTANCE_CLAMPED>
		<LINEAR_DISTANCE public="1" get="inline" set="null" expr="0xD003" line="78" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0xD003</e></m></meta>
		</LINEAR_DISTANCE>
		<LINEAR_DISTANCE_CLAMPED public="1" get="inline" set="null" expr="0xD004" line="79" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0xD004</e></m></meta>
		</LINEAR_DISTANCE_CLAMPED>
		<EXPONENT_DISTANCE public="1" get="inline" set="null" expr="0xD005" line="80" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0xD005</e></m></meta>
		</EXPONENT_DISTANCE>
		<EXPONENT_DISTANCE_CLAMPED public="1" get="inline" set="null" expr="0xD006" line="81" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0xD006</e></m></meta>
		</EXPONENT_DISTANCE_CLAMPED>
		<bufferData public="1" set="method" line="84" static="1"><f a="buffer:format:data:size:freq">
	<x path="Int"/>
	<x path="Int"/>
	<c path="lime.utils.ArrayBufferView"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></bufferData>
		<buffer3f public="1" set="method" line="97" static="1"><f a="buffer:param:value1:value2:value3">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></buffer3f>
		<buffer3i public="1" set="method" line="106" static="1"><f a="buffer:param:value1:value2:value3">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></buffer3i>
		<bufferf public="1" set="method" line="115" static="1"><f a="buffer:param:value">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Float"/>
	<x path="Void"/>
</f></bufferf>
		<bufferfv public="1" set="method" line="124" static="1"><f a="buffer:param:values">
	<x path="Int"/>
	<x path="Int"/>
	<c path="Array"><x path="Float"/></c>
	<x path="Void"/>
</f></bufferfv>
		<bufferi public="1" set="method" line="133" static="1"><f a="buffer:param:value">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></bufferi>
		<bufferiv public="1" set="method" line="142" static="1"><f a="buffer:param:values">
	<x path="Int"/>
	<x path="Int"/>
	<c path="Array"><x path="Int"/></c>
	<x path="Void"/>
</f></bufferiv>
		<deleteBuffer public="1" set="method" line="151" static="1"><f a="buffer">
	<x path="Int"/>
	<x path="Void"/>
</f></deleteBuffer>
		<deleteBuffers public="1" set="method" line="160" static="1"><f a="buffers">
	<c path="Array"><x path="Int"/></c>
	<x path="Void"/>
</f></deleteBuffers>
		<deleteSource public="1" set="method" line="169" static="1"><f a="source">
	<x path="Int"/>
	<x path="Void"/>
</f></deleteSource>
		<deleteSources public="1" set="method" line="178" static="1"><f a="sources">
	<c path="Array"><x path="Int"/></c>
	<x path="Void"/>
</f></deleteSources>
		<disable public="1" set="method" line="187" static="1"><f a="capability">
	<x path="Int"/>
	<x path="Void"/>
</f></disable>
		<distanceModel public="1" set="method" line="196" static="1"><f a="distanceModel">
	<x path="Int"/>
	<x path="Void"/>
</f></distanceModel>
		<dopplerFactor public="1" set="method" line="205" static="1"><f a="value">
	<x path="Float"/>
	<x path="Void"/>
</f></dopplerFactor>
		<dopplerVelocity public="1" set="method" line="214" static="1"><f a="value">
	<x path="Float"/>
	<x path="Void"/>
</f></dopplerVelocity>
		<enable public="1" set="method" line="223" static="1"><f a="capability">
	<x path="Int"/>
	<x path="Void"/>
</f></enable>
		<genSource public="1" set="method" line="232" static="1"><f a=""><x path="Int"/></f></genSource>
		<genSources public="1" set="method" line="243" static="1"><f a="n">
	<x path="Int"/>
	<c path="Array"><x path="Int"/></c>
</f></genSources>
		<genBuffer public="1" set="method" line="254" static="1"><f a=""><x path="Int"/></f></genBuffer>
		<genBuffers public="1" set="method" line="265" static="1"><f a="n">
	<x path="Int"/>
	<c path="Array"><x path="Int"/></c>
</f></genBuffers>
		<getBoolean public="1" set="method" line="276" static="1"><f a="param">
	<x path="Int"/>
	<x path="Bool"/>
</f></getBoolean>
		<getBooleanv public="1" set="method" line="287" static="1">
			<f a="param:?count" v=":1">
				<x path="Int"/>
				<x path="Int"/>
				<c path="Array"><x path="Bool"/></c>
			</f>
			<meta><m n=":value"><e>{ count : 1 }</e></m></meta>
		</getBooleanv>
		<getBuffer3f public="1" set="method" line="298" static="1"><f a="buffer:param">
	<x path="Int"/>
	<x path="Int"/>
	<c path="Array"><x path="Float"/></c>
</f></getBuffer3f>
		<getBuffer3i public="1" set="method" line="309" static="1"><f a="buffer:param">
	<x path="Int"/>
	<x path="Int"/>
	<c path="Array"><x path="Int"/></c>
</f></getBuffer3i>
		<getBufferf public="1" set="method" line="320" static="1"><f a="buffer:param">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Float"/>
</f></getBufferf>
		<getBufferfv public="1" set="method" line="331" static="1">
			<f a="buffer:param:?count" v="::1">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<c path="Array"><x path="Float"/></c>
			</f>
			<meta><m n=":value"><e>{ count : 1 }</e></m></meta>
		</getBufferfv>
		<getBufferi public="1" set="method" line="342" static="1"><f a="buffer:param">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></getBufferi>
		<getBufferiv public="1" set="method" line="353" static="1">
			<f a="buffer:param:?count" v="::1">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<c path="Array"><x path="Int"/></c>
			</f>
			<meta><m n=":value"><e>{ count : 1 }</e></m></meta>
		</getBufferiv>
		<getDouble public="1" set="method" line="364" static="1"><f a="param">
	<x path="Int"/>
	<x path="Float"/>
</f></getDouble>
		<getDoublev public="1" set="method" line="375" static="1">
			<f a="param:?count" v=":1">
				<x path="Int"/>
				<x path="Int"/>
				<c path="Array"><x path="Float"/></c>
			</f>
			<meta><m n=":value"><e>{ count : 1 }</e></m></meta>
		</getDoublev>
		<getEnumValue public="1" set="method" line="386" static="1"><f a="ename">
	<c path="String"/>
	<x path="Int"/>
</f></getEnumValue>
		<getError public="1" set="method" line="397" static="1"><f a=""><x path="Int"/></f></getError>
		<getErrorString public="1" set="method" line="408" static="1"><f a=""><c path="String"/></f></getErrorString>
		<getFloat public="1" set="method" line="424" static="1"><f a="param">
	<x path="Int"/>
	<x path="Float"/>
</f></getFloat>
		<getFloatv public="1" set="method" line="435" static="1">
			<f a="param:?count" v=":1">
				<x path="Int"/>
				<x path="Int"/>
				<c path="Array"><x path="Float"/></c>
			</f>
			<meta><m n=":value"><e>{ count : 1 }</e></m></meta>
		</getFloatv>
		<getInteger public="1" set="method" line="446" static="1"><f a="param">
	<x path="Int"/>
	<x path="Int"/>
</f></getInteger>
		<getIntegerv public="1" set="method" line="457" static="1">
			<f a="param:?count" v=":1">
				<x path="Int"/>
				<x path="Int"/>
				<c path="Array"><x path="Int"/></c>
			</f>
			<meta><m n=":value"><e>{ count : 1 }</e></m></meta>
		</getIntegerv>
		<getListener3f public="1" set="method" line="468" static="1"><f a="param">
	<x path="Int"/>
	<c path="Array"><x path="Float"/></c>
</f></getListener3f>
		<getListener3i public="1" set="method" line="479" static="1"><f a="param">
	<x path="Int"/>
	<c path="Array"><x path="Int"/></c>
</f></getListener3i>
		<getListenerf public="1" set="method" line="490" static="1"><f a="param">
	<x path="Int"/>
	<x path="Float"/>
</f></getListenerf>
		<getListenerfv public="1" set="method" line="501" static="1">
			<f a="param:?count" v=":1">
				<x path="Int"/>
				<x path="Int"/>
				<c path="Array"><x path="Float"/></c>
			</f>
			<meta><m n=":value"><e>{ count : 1 }</e></m></meta>
		</getListenerfv>
		<getListeneri public="1" set="method" line="512" static="1"><f a="param">
	<x path="Int"/>
	<x path="Int"/>
</f></getListeneri>
		<getListeneriv public="1" set="method" line="523" static="1">
			<f a="param:?count" v=":1">
				<x path="Int"/>
				<x path="Int"/>
				<c path="Array"><x path="Int"/></c>
			</f>
			<meta><m n=":value"><e>{ count : 1 }</e></m></meta>
		</getListeneriv>
		<getProcAddress public="1" set="method" line="534" static="1"><f a="fname">
	<c path="String"/>
	<d/>
</f></getProcAddress>
		<getSource3f public="1" set="method" line="545" static="1"><f a="source:param">
	<x path="Int"/>
	<x path="Int"/>
	<c path="Array"><x path="Float"/></c>
</f></getSource3f>
		<getSourcef public="1" set="method" line="556" static="1"><f a="source:param">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Float"/>
</f></getSourcef>
		<getSource3i public="1" set="method" line="567" static="1"><f a="source:param">
	<x path="Int"/>
	<x path="Int"/>
	<c path="Array"><x path="Int"/></c>
</f></getSource3i>
		<getSourcefv public="1" set="method" line="578" static="1">
			<f a="source:param:?count" v="::1">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<c path="Array"><x path="Float"/></c>
			</f>
			<meta><m n=":value"><e>{ count : 1 }</e></m></meta>
		</getSourcefv>
		<getSourcei public="1" set="method" line="589" static="1"><f a="source:param">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></getSourcei>
		<getSourceiv public="1" set="method" line="600" static="1">
			<f a="source:param:?count" v="::1">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<c path="Array"><x path="Int"/></c>
			</f>
			<meta><m n=":value"><e>{ count : 1 }</e></m></meta>
		</getSourceiv>
		<getString public="1" set="method" line="611" static="1"><f a="param">
	<x path="Int"/>
	<c path="String"/>
</f></getString>
		<isBuffer public="1" set="method" line="622" static="1"><f a="buffer">
	<x path="Int"/>
	<x path="Bool"/>
</f></isBuffer>
		<isEnabled public="1" set="method" line="633" static="1"><f a="capability">
	<x path="Int"/>
	<x path="Bool"/>
</f></isEnabled>
		<isExtensionPresent public="1" set="method" line="644" static="1"><f a="extname">
	<c path="String"/>
	<x path="Bool"/>
</f></isExtensionPresent>
		<isSource public="1" set="method" line="655" static="1"><f a="source">
	<x path="Int"/>
	<x path="Bool"/>
</f></isSource>
		<listener3f public="1" set="method" line="666" static="1"><f a="param:value1:value2:value3">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></listener3f>
		<listener3i public="1" set="method" line="675" static="1"><f a="param:value1:value2:value3">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></listener3i>
		<listenerf public="1" set="method" line="684" static="1"><f a="param:value">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Void"/>
</f></listenerf>
		<listenerfv public="1" set="method" line="693" static="1"><f a="param:values">
	<x path="Int"/>
	<c path="Array"><x path="Float"/></c>
	<x path="Void"/>
</f></listenerfv>
		<listeneri public="1" set="method" line="702" static="1"><f a="param:value">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></listeneri>
		<listeneriv public="1" set="method" line="711" static="1"><f a="param:values">
	<x path="Int"/>
	<c path="Array"><x path="Int"/></c>
	<x path="Void"/>
</f></listeneriv>
		<source3f public="1" set="method" line="720" static="1"><f a="source:param:value1:value2:value3">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></source3f>
		<source3i public="1" set="method" line="729" static="1"><f a="source:param:value1:value2:value3">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></source3i>
		<sourcef public="1" set="method" line="738" static="1"><f a="source:param:value">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Float"/>
	<x path="Void"/>
</f></sourcef>
		<sourcefv public="1" set="method" line="747" static="1"><f a="source:param:values">
	<x path="Int"/>
	<x path="Int"/>
	<c path="Array"><x path="Float"/></c>
	<x path="Void"/>
</f></sourcefv>
		<sourcei public="1" set="method" line="756" static="1"><f a="source:param:value">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></sourcei>
		<sourceiv public="1" set="method" line="765" static="1"><f a="source:param:values">
	<x path="Int"/>
	<x path="Int"/>
	<c path="Array"><x path="Int"/></c>
	<x path="Void"/>
</f></sourceiv>
		<sourcePlay public="1" set="method" line="774" static="1"><f a="source">
	<x path="Int"/>
	<x path="Void"/>
</f></sourcePlay>
		<sourcePlayv public="1" set="method" line="783" static="1"><f a="sources">
	<c path="Array"><x path="Int"/></c>
	<x path="Void"/>
</f></sourcePlayv>
		<sourceStop public="1" set="method" line="792" static="1"><f a="source">
	<x path="Int"/>
	<x path="Void"/>
</f></sourceStop>
		<sourceStopv public="1" set="method" line="801" static="1"><f a="sources">
	<c path="Array"><x path="Int"/></c>
	<x path="Void"/>
</f></sourceStopv>
		<sourceRewind public="1" set="method" line="810" static="1"><f a="source">
	<x path="Int"/>
	<x path="Void"/>
</f></sourceRewind>
		<sourceRewindv public="1" set="method" line="819" static="1"><f a="sources">
	<c path="Array"><x path="Int"/></c>
	<x path="Void"/>
</f></sourceRewindv>
		<sourcePause public="1" set="method" line="828" static="1"><f a="source">
	<x path="Int"/>
	<x path="Void"/>
</f></sourcePause>
		<sourcePausev public="1" set="method" line="837" static="1"><f a="sources">
	<c path="Array"><x path="Int"/></c>
	<x path="Void"/>
</f></sourcePausev>
		<sourceQueueBuffer public="1" set="method" line="846" static="1"><f a="source:buffer">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></sourceQueueBuffer>
		<sourceQueueBuffers public="1" set="method" line="855" static="1"><f a="source:nb:buffers">
	<x path="Int"/>
	<x path="Int"/>
	<c path="Array"><x path="Int"/></c>
	<x path="Void"/>
</f></sourceQueueBuffers>
		<sourceUnqueueBuffer public="1" set="method" line="864" static="1"><f a="source">
	<x path="Int"/>
	<x path="Int"/>
</f></sourceUnqueueBuffer>
		<sourceUnqueueBuffers public="1" set="method" line="876" static="1"><f a="source:nb">
	<x path="Int"/>
	<x path="Int"/>
	<c path="Array"><x path="Int"/></c>
</f></sourceUnqueueBuffers>
		<speedOfSound public="1" set="method" line="887" static="1"><f a="value">
	<x path="Float"/>
	<x path="Void"/>
</f></speedOfSound>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>lime.system.CFFI.build()</e></m>
		</meta>
	</class>
	<class path="lime.audio.openal.ALC" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/audio/openal/ALC.hx">
		<FALSE public="1" get="inline" set="null" expr="0" line="14" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</FALSE>
		<TRUE public="1" get="inline" set="null" expr="1" line="15" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</TRUE>
		<FREQUENCY public="1" get="inline" set="null" expr="0x1007" line="16" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x1007</e></m></meta>
		</FREQUENCY>
		<REFRESH public="1" get="inline" set="null" expr="0x1008" line="17" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x1008</e></m></meta>
		</REFRESH>
		<SYNC public="1" get="inline" set="null" expr="0x1009" line="18" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x1009</e></m></meta>
		</SYNC>
		<MONO_SOURCES public="1" get="inline" set="null" expr="0x1010" line="19" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x1010</e></m></meta>
		</MONO_SOURCES>
		<STEREO_SOURCES public="1" get="inline" set="null" expr="0x1011" line="20" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x1011</e></m></meta>
		</STEREO_SOURCES>
		<NO_ERROR public="1" get="inline" set="null" expr="0" line="21" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</NO_ERROR>
		<INVALID_DEVICE public="1" get="inline" set="null" expr="0xA001" line="22" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0xA001</e></m></meta>
		</INVALID_DEVICE>
		<INVALID_CONTEXT public="1" get="inline" set="null" expr="0xA002" line="23" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0xA002</e></m></meta>
		</INVALID_CONTEXT>
		<INVALID_ENUM public="1" get="inline" set="null" expr="0xA003" line="24" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0xA003</e></m></meta>
		</INVALID_ENUM>
		<INVALID_VALUE public="1" get="inline" set="null" expr="0xA004" line="25" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0xA004</e></m></meta>
		</INVALID_VALUE>
		<OUT_OF_MEMORY public="1" get="inline" set="null" expr="0xA005" line="26" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0xA005</e></m></meta>
		</OUT_OF_MEMORY>
		<ATTRIBUTES_SIZE public="1" get="inline" set="null" expr="0x1002" line="27" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x1002</e></m></meta>
		</ATTRIBUTES_SIZE>
		<ALL_ATTRIBUTES public="1" get="inline" set="null" expr="0x1003" line="28" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x1003</e></m></meta>
		</ALL_ATTRIBUTES>
		<DEFAULT_DEVICE_SPECIFIER public="1" get="inline" set="null" expr="0x1004" line="29" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x1004</e></m></meta>
		</DEFAULT_DEVICE_SPECIFIER>
		<DEVICE_SPECIFIER public="1" get="inline" set="null" expr="0x1005" line="30" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x1005</e></m></meta>
		</DEVICE_SPECIFIER>
		<EXTENSIONS public="1" get="inline" set="null" expr="0x1006" line="31" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x1006</e></m></meta>
		</EXTENSIONS>
		<ENUMERATE_ALL_EXT public="1" get="inline" set="null" expr="1" line="32" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</ENUMERATE_ALL_EXT>
		<DEFAULT_ALL_DEVICES_SPECIFIER public="1" get="inline" set="null" expr="0x1012" line="33" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x1012</e></m></meta>
		</DEFAULT_ALL_DEVICES_SPECIFIER>
		<ALL_DEVICES_SPECIFIER public="1" get="inline" set="null" expr="0x1013" line="34" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x1013</e></m></meta>
		</ALL_DEVICES_SPECIFIER>
		<closeDevice public="1" set="method" line="37" static="1"><f a="device">
	<x path="lime.audio.openal.ALDevice"/>
	<x path="Bool"/>
</f></closeDevice>
		<createContext public="1" set="method" line="48" static="1">
			<f a="device:?attrlist" v=":null">
				<x path="lime.audio.openal.ALDevice"/>
				<c path="Array"><x path="Int"/></c>
				<x path="lime.audio.openal.ALContext"/>
			</f>
			<meta><m n=":value"><e>{ attrlist : null }</e></m></meta>
		</createContext>
		<destroyContext public="1" set="method" line="65" static="1"><f a="context">
	<x path="lime.audio.openal.ALContext"/>
	<x path="Void"/>
</f></destroyContext>
		<getContextsDevice public="1" set="method" line="74" static="1"><f a="context">
	<x path="lime.audio.openal.ALContext"/>
	<x path="lime.audio.openal.ALDevice"/>
</f></getContextsDevice>
		<getCurrentContext public="1" set="method" line="91" static="1"><f a=""><x path="lime.audio.openal.ALContext"/></f></getCurrentContext>
		<getError public="1" set="method" line="108" static="1"><f a="device">
	<x path="lime.audio.openal.ALDevice"/>
	<x path="Int"/>
</f></getError>
		<getErrorString public="1" set="method" line="119" static="1"><f a="device">
	<x path="lime.audio.openal.ALDevice"/>
	<c path="String"/>
</f></getErrorString>
		<getIntegerv public="1" set="method" line="135" static="1"><f a="device:param:size">
	<x path="lime.audio.openal.ALDevice"/>
	<x path="Int"/>
	<x path="Int"/>
	<c path="Array"><x path="Int"/></c>
</f></getIntegerv>
		<getString public="1" set="method" line="146" static="1"><f a="device:param">
	<x path="lime.audio.openal.ALDevice"/>
	<x path="Int"/>
	<c path="String"/>
</f></getString>
		<makeContextCurrent public="1" set="method" line="157" static="1"><f a="context">
	<x path="lime.audio.openal.ALContext"/>
	<x path="Bool"/>
</f></makeContextCurrent>
		<openDevice public="1" set="method" line="168" static="1">
			<f a="?deviceName" v="null">
				<c path="String"/>
				<x path="lime.audio.openal.ALDevice"/>
			</f>
			<meta><m n=":value"><e>{ deviceName : null }</e></m></meta>
		</openDevice>
		<processContext public="1" set="method" line="185" static="1"><f a="context">
	<x path="lime.audio.openal.ALContext"/>
	<x path="Void"/>
</f></processContext>
		<suspendContext public="1" set="method" line="194" static="1"><f a="context">
	<x path="lime.audio.openal.ALContext"/>
	<x path="Void"/>
</f></suspendContext>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>lime.system.CFFI.build()</e></m>
		</meta>
	</class>
	<abstract path="lime.audio.openal.ALContext" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/audio/openal/ALContext.hx">
		<from><icast><x path="lime.system.CFFIPointer"/></icast></from>
		<this><x path="lime.system.CFFIPointer"/></this>
		<to><icast><x path="lime.system.CFFIPointer"/></icast></to>
		<meta>
			<m n=":allow"><e>lime.audio.openal.AL</e></m>
			<m n=":allow"><e>lime.audio.openal.ALC</e></m>
		</meta>
		<impl><class path="lime.audio.openal._ALContext.ALContext_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/audio/openal/ALContext.hx" private="1" module="lime.audio.openal.ALContext">
	<_new get="inline" set="null" line="13" static="1">
		<f a="handle">
			<x path="lime.system.CFFIPointer"/>
			<x path="lime.audio.openal.ALContext"/>
		</f>
		<meta><m n=":impl"/></meta>
	</_new>
	<meta>
		<m n=":final"/>
		<m n=":allow"><e>lime.audio.openal.ALC</e></m>
		<m n=":allow"><e>lime.audio.openal.AL</e></m>
	</meta>
</class></impl>
	</abstract>
	<class path="lime.audio.openal._ALContext.ALContext_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/audio/openal/ALContext.hx" private="1" module="lime.audio.openal.ALContext">
		<_new get="inline" set="null" line="13" static="1">
			<f a="handle">
				<x path="lime.system.CFFIPointer"/>
				<x path="lime.audio.openal.ALContext"/>
			</f>
			<meta><m n=":impl"/></meta>
		</_new>
		<meta>
			<m n=":final"/>
			<m n=":allow"><e>lime.audio.openal.ALC</e></m>
			<m n=":allow"><e>lime.audio.openal.AL</e></m>
		</meta>
	</class>
	<abstract path="lime.audio.openal.ALDevice" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/audio/openal/ALDevice.hx">
		<from><icast><x path="lime.system.CFFIPointer"/></icast></from>
		<this><x path="lime.system.CFFIPointer"/></this>
		<to><icast><x path="lime.system.CFFIPointer"/></icast></to>
		<meta>
			<m n=":allow"><e>lime.audio.openal.AL</e></m>
			<m n=":allow"><e>lime.audio.openal.ALC</e></m>
		</meta>
		<impl><class path="lime.audio.openal._ALDevice.ALDevice_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/audio/openal/ALDevice.hx" private="1" module="lime.audio.openal.ALDevice">
	<_new get="inline" set="null" line="13" static="1">
		<f a="handle">
			<x path="lime.system.CFFIPointer"/>
			<x path="lime.audio.openal.ALDevice"/>
		</f>
		<meta><m n=":impl"/></meta>
	</_new>
	<meta>
		<m n=":final"/>
		<m n=":allow"><e>lime.audio.openal.ALC</e></m>
		<m n=":allow"><e>lime.audio.openal.AL</e></m>
	</meta>
</class></impl>
	</abstract>
	<class path="lime.audio.openal._ALDevice.ALDevice_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/audio/openal/ALDevice.hx" private="1" module="lime.audio.openal.ALDevice">
		<_new get="inline" set="null" line="13" static="1">
			<f a="handle">
				<x path="lime.system.CFFIPointer"/>
				<x path="lime.audio.openal.ALDevice"/>
			</f>
			<meta><m n=":impl"/></meta>
		</_new>
		<meta>
			<m n=":final"/>
			<m n=":allow"><e>lime.audio.openal.ALC</e></m>
			<m n=":allow"><e>lime.audio.openal.AL</e></m>
		</meta>
	</class>
	<typedef path="lime.graphics.CairoRenderContext" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/graphics/CairoRenderContext.hx"><c path="lime.graphics.cairo.Cairo"/></typedef>
	<class path="lime.graphics.CanvasRenderContext" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/graphics/CanvasRenderContext.hx">
		<backingStorePixelRatio public="1" set="null"><x path="Float"/></backingStorePixelRatio>
		<canvas public="1"><d/></canvas>
		<fillStyle public="1"><d/></fillStyle>
		<font public="1"><c path="String"/></font>
		<globalAlpha public="1"><x path="Float"/></globalAlpha>
		<globalCompositeOperation public="1"><c path="String"/></globalCompositeOperation>
		<imageSmoothingEnabled public="1"><x path="Bool"/></imageSmoothingEnabled>
		<lineCap public="1"><c path="String"/></lineCap>
		<lineDash public="1"><c path="Array"><d/></c></lineDash>
		<lineDashOffset public="1"><x path="Float"/></lineDashOffset>
		<lineJoin public="1"><c path="String"/></lineJoin>
		<lineWidth public="1"><x path="Float"/></lineWidth>
		<miterLimit public="1"><x path="Float"/></miterLimit>
		<shadowBlur public="1"><x path="Float"/></shadowBlur>
		<shadowColor public="1"><c path="String"/></shadowColor>
		<shadowOffsetX public="1"><x path="Float"/></shadowOffsetX>
		<shadowOffsetY public="1"><x path="Float"/></shadowOffsetY>
		<strokeStyle public="1"><d/></strokeStyle>
		<textAlign public="1"><c path="String"/></textAlign>
		<textBaseline public="1"><c path="String"/></textBaseline>
		<arc public="1" set="method" line="39"><f a="x:y:radius:startAngle:endAngle:anticlockwise">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></arc>
		<arcTo public="1" set="method" line="40"><f a="x1:y1:x2:y2:radius">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></arcTo>
		<beginPath public="1" set="method" line="41"><f a=""><x path="Void"/></f></beginPath>
		<bezierCurveTo public="1" set="method" line="42"><f a="cp1x:cp1y:cp2x:cp2y:x:y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></bezierCurveTo>
		<clearRect public="1" set="method" line="43"><f a="x:y:width:height">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></clearRect>
		<clearShadow public="1" set="method" line="44"><f a=""><x path="Void"/></f></clearShadow>
		<clip public="1" set="method" line="45"><f a=""><x path="Void"/></f></clip>
		<closePath public="1" set="method" line="46"><f a=""><x path="Void"/></f></closePath>
		<createDynamicImageData public="1" set="method" line="48">
			<f a="sw:sh">
				<x path="Float"/>
				<x path="Float"/>
				<d/>
			</f>
			<overloads><createDynamicImageData public="1" set="method"><f a="dynamicImageData">
	<d/>
	<d/>
</f></createDynamicImageData></overloads>
		</createDynamicImageData>
		<createLinearGradient public="1" set="method" line="49"><f a="x0:y0:x1:y1">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<d/>
</f></createLinearGradient>
		<createPattern public="1" set="method" line="51">
			<f a="image:repetitionType">
				<d/>
				<c path="String"/>
				<d/>
			</f>
			<overloads><createPattern public="1" set="method"><f a="canvas:repetitionType">
	<d/>
	<c path="String"/>
	<d/>
</f></createPattern></overloads>
		</createPattern>
		<createRadialGradient public="1" set="method" line="52"><f a="x0:y0:r0:x1:y1:r1">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<d/>
</f></createRadialGradient>
		<drawImage public="1" set="method" line="61"><f a="element:sx:sy:?sw:?sh:?dx:?dy:?dw:?dh">
	<d/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></drawImage>
		<drawImageFromRect public="1" set="method" line="62"><f a="image:?sx:?sy:?sw:?sh:?dx:?dy:?dw:?dh:?compositeOperation">
	<d/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<c path="String"/>
	<x path="Void"/>
</f></drawImageFromRect>
		<fill public="1" set="method" line="63"><f a=""><x path="Void"/></f></fill>
		<fillRect public="1" set="method" line="64"><f a="x:y:width:height">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></fillRect>
		<fillText public="1" set="method" line="65"><f a="text:x:y:?maxWidth">
	<c path="String"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></fillText>
		<getDynamicImageData public="1" set="method" line="66"><f a="sx:sy:sw:sh">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<d/>
</f></getDynamicImageData>
		<getDynamicImageDataHD public="1" set="method" line="67"><f a="sx:sy:sw:sh">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<d/>
</f></getDynamicImageDataHD>
		<getLineDash public="1" set="method" line="68"><f a=""><c path="Array"><x path="Float"/></c></f></getLineDash>
		<isPointInPath public="1" set="method" line="69"><f a="x:y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Bool"/>
</f></isPointInPath>
		<lineTo public="1" set="method" line="70"><f a="x:y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></lineTo>
		<measureText public="1" set="method" line="71"><f a="text">
	<c path="String"/>
	<d/>
</f></measureText>
		<moveTo public="1" set="method" line="72"><f a="x:y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></moveTo>
		<putDynamicImageData public="1" set="method" line="74">
			<f a="dynamicImageData:dx:dy:dirtyX:dirtyY:dirtyWidth:dirtyHeight">
				<d/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<overloads><putDynamicImageData public="1" set="method"><f a="dynamicImageData:dx:dy">
	<d/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></putDynamicImageData></overloads>
		</putDynamicImageData>
		<putDynamicImageDataHD public="1" set="method" line="76">
			<f a="dynamicImageData:dx:dy:dirtyX:dirtyY:dirtyWidth:dirtyHeight">
				<d/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<overloads><putDynamicImageDataHD public="1" set="method"><f a="dynamicImageData:dx:dy">
	<d/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></putDynamicImageDataHD></overloads>
		</putDynamicImageDataHD>
		<quadraticCurveTo public="1" set="method" line="77"><f a="cpx:cpy:x:y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></quadraticCurveTo>
		<rect public="1" set="method" line="78"><f a="x:y:width:height">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></rect>
		<restore public="1" set="method" line="79"><f a=""><x path="Void"/></f></restore>
		<rotate public="1" set="method" line="80"><f a="angle">
	<x path="Float"/>
	<x path="Void"/>
</f></rotate>
		<save public="1" set="method" line="81"><f a=""><x path="Void"/></f></save>
		<scale public="1" set="method" line="82"><f a="sx:sy">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></scale>
		<setAlpha public="1" set="method" line="83"><f a="alpha">
	<x path="Float"/>
	<x path="Void"/>
</f></setAlpha>
		<setCompositeOperation public="1" set="method" line="84"><f a="compositeOperation">
	<c path="String"/>
	<x path="Void"/>
</f></setCompositeOperation>
		<setFillColor public="1" set="method" line="88">
			<f a="c:m:y:k:a">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<overloads>
				<setFillColor public="1" set="method"><f a="color:?alpha">
	<c path="String"/>
	<x path="Float"/>
	<x path="Void"/>
</f></setFillColor>
				<setFillColor public="1" set="method"><f a="grayLevel:?alpha">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></setFillColor>
				<setFillColor public="1" set="method"><f a="r:g:b:a">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></setFillColor>
			</overloads>
		</setFillColor>
		<setLineCap public="1" set="method" line="89"><f a="cap">
	<c path="String"/>
	<x path="Void"/>
</f></setLineCap>
		<setLineDash public="1" set="method" line="90"><f a="dash">
	<c path="Array"><x path="Float"/></c>
	<x path="Void"/>
</f></setLineDash>
		<setLineJoin public="1" set="method" line="91"><f a="join">
	<c path="String"/>
	<x path="Void"/>
</f></setLineJoin>
		<setLineWidth public="1" set="method" line="92"><f a="width">
	<x path="Float"/>
	<x path="Void"/>
</f></setLineWidth>
		<setMiterLimit public="1" set="method" line="93"><f a="limit">
	<x path="Float"/>
	<x path="Void"/>
</f></setMiterLimit>
		<setShadow public="1" set="method" line="97">
			<f a="width:height:blur:c:m:y:k:a">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<overloads>
				<setShadow public="1" set="method"><f a="width:height:blur:?color:?alpha">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<c path="String"/>
	<x path="Float"/>
	<x path="Void"/>
</f></setShadow>
				<setShadow public="1" set="method"><f a="width:height:blur:grayLevel:?alpha">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></setShadow>
				<setShadow public="1" set="method"><f a="width:height:blur:r:g:b:a">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></setShadow>
			</overloads>
		</setShadow>
		<setStrokeColor public="1" set="method" line="101">
			<f a="c:m:y:k:a">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<overloads>
				<setStrokeColor public="1" set="method"><f a="color:?alpha">
	<c path="String"/>
	<x path="Float"/>
	<x path="Void"/>
</f></setStrokeColor>
				<setStrokeColor public="1" set="method"><f a="grayLevel:?alpha">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></setStrokeColor>
				<setStrokeColor public="1" set="method"><f a="r:g:b:a">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></setStrokeColor>
			</overloads>
		</setStrokeColor>
		<setTransform public="1" set="method" line="102"><f a="m11:m12:m21:m22:dx:dy">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></setTransform>
		<stroke public="1" set="method" line="103"><f a=""><x path="Void"/></f></stroke>
		<strokeRect public="1" set="method" line="104"><f a="x:y:width:height:?lineWidth">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></strokeRect>
		<strokeText public="1" set="method" line="105"><f a="text:x:y:?maxWidth">
	<c path="String"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></strokeText>
		<transform public="1" set="method" line="106"><f a="m11:m12:m21:m22:dx:dy">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></transform>
		<translate public="1" set="method" line="107"><f a="tx:ty">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></translate>
		<new public="1" set="method" line="32"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="lime.graphics.ConsoleRenderContext" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/graphics/ConsoleRenderContext.hx">
		<width public="1" get="accessor" set="null"><x path="Int"/></width>
		<height public="1" get="accessor" set="null"><x path="Int"/></height>
		<createIndexBuffer public="1" set="method" line="343"><f a="indices:count">
	<unknown/>
	<x path="Int"/>
	<c path="lime.graphics.console.IndexBuffer"/>
</f></createIndexBuffer>
		<createVertexBuffer public="1" set="method" line="344"><f a="decl:count">
	<unknown/>
	<x path="Int"/>
	<c path="lime.graphics.console.VertexBuffer"/>
</f></createVertexBuffer>
		<lookupShader public="1" set="method" line="345"><f a="name">
	<c path="String"/>
	<c path="lime.graphics.console.Shader"/>
</f></lookupShader>
		<clear public="1" set="method" line="347">
			<f a="r:g:b:a:?depth:?stencil" v="::::1.0:0">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ stencil : 0, depth : 1.0 }</e></m></meta>
		</clear>
		<bindShader public="1" set="method" line="349"><f a="shader">
	<c path="lime.graphics.console.Shader"/>
	<x path="Void"/>
</f></bindShader>
		<setViewport public="1" set="method" line="351">
			<f a="x:y:width:height:?nearPlane:?farPlane" v="::::0.0:1.0">
				<unknown/>
				<unknown/>
				<unknown/>
				<unknown/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ farPlane : 1.0, nearPlane : 0.0 }</e></m></meta>
		</setViewport>
		<setVertexShaderConstantF public="1" set="method" line="353"><f a="startRegister:vec4:vec4count">
	<unknown/>
	<unknown/>
	<unknown/>
	<x path="Void"/>
</f></setVertexShaderConstantF>
		<setVertexSource public="1" set="method" line="355"><f a="vb">
	<c path="lime.graphics.console.VertexBuffer"/>
	<x path="Void"/>
</f></setVertexSource>
		<setIndexSource public="1" set="method" line="356"><f a="ib">
	<c path="lime.graphics.console.IndexBuffer"/>
	<x path="Void"/>
</f></setIndexSource>
		<draw public="1" set="method" line="358"><f a="primitive:startVertex:primitiveCount">
	<unknown/>
	<unknown/>
	<unknown/>
	<x path="Void"/>
</f></draw>
		<drawIndexed public="1" set="method" line="359"><f a="primitive:vertexCount:startIndex:primitiveCount">
	<unknown/>
	<unknown/>
	<unknown/>
	<unknown/>
	<x path="Void"/>
</f></drawIndexed>
		<get_width set="method" line="361"><f a=""><x path="Int"/></f></get_width>
		<get_height set="method" line="362"><f a=""><x path="Int"/></f></get_height>
		<new public="1" set="method" line="333"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="lime.graphics.DOMRenderContext" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/graphics/DOMRenderContext.hx">
		<accessKey public="1"><c path="String"/></accessKey>
		<align public="1"><c path="String"/></align>
		<attributes public="1" set="null"><d/></attributes>
		<baseURI public="1" set="null"><c path="String"/></baseURI>
		<childElementCount public="1" set="null"><x path="Int"/></childElementCount>
		<childNodes public="1" set="null"><d/></childNodes>
		<children public="1" set="null"><d/></children>
		<classList public="1" set="null"><d/></classList>
		<className public="1"><c path="String"/></className>
		<clientHeight public="1" set="null"><x path="Int"/></clientHeight>
		<clientLeft public="1" set="null"><x path="Int"/></clientLeft>
		<clientTop public="1" set="null"><x path="Int"/></clientTop>
		<clientWidth public="1" set="null"><x path="Int"/></clientWidth>
		<contentEditable public="1"><c path="String"/></contentEditable>
		<dataset public="1" set="null"><d><c path="String"/></d></dataset>
		<dir public="1"><c path="String"/></dir>
		<draggable public="1"><x path="Bool"/></draggable>
		<dropzone public="1"><c path="String"/></dropzone>
		<firstChild public="1" set="null"><d/></firstChild>
		<firstElementChild public="1" set="null"><d/></firstElementChild>
		<hidden public="1"><x path="Bool"/></hidden>
		<id public="1"><c path="String"/></id>
		<innerHTML public="1"><c path="String"/></innerHTML>
		<innerText public="1"><c path="String"/></innerText>
		<isContentEditable public="1" set="null"><x path="Bool"/></isContentEditable>
		<lang public="1"><c path="String"/></lang>
		<lastChild public="1" set="null"><d/></lastChild>
		<lastElementChild public="1" set="null"><d/></lastElementChild>
		<localName public="1" set="null"><c path="String"/></localName>
		<namespaceURI public="1" set="null"><c path="String"/></namespaceURI>
		<nextElementSibling public="1" set="null"><d/></nextElementSibling>
		<nextSibling public="1" set="null"><d/></nextSibling>
		<nodeName public="1" set="null"><c path="String"/></nodeName>
		<nodeType public="1" set="null"><x path="Int"/></nodeType>
		<nodeValue public="1"><c path="String"/></nodeValue>
		<offsetHeight public="1" set="null"><x path="Int"/></offsetHeight>
		<offsetLeft public="1" set="null"><x path="Int"/></offsetLeft>
		<offsetParent public="1" set="null"><d/></offsetParent>
		<offsetTop public="1" set="null"><x path="Int"/></offsetTop>
		<offsetWidth public="1" set="null"><x path="Int"/></offsetWidth>
		<onabort public="1"><d/></onabort>
		<onbeforecopy public="1"><d/></onbeforecopy>
		<onbeforecut public="1"><d/></onbeforecut>
		<onbeforepaste public="1"><d/></onbeforepaste>
		<onblur public="1"><d/></onblur>
		<onchange public="1"><d/></onchange>
		<onclick public="1"><d/></onclick>
		<oncontextmenu public="1"><d/></oncontextmenu>
		<oncopy public="1"><d/></oncopy>
		<oncut public="1"><d/></oncut>
		<ondblclick public="1"><d/></ondblclick>
		<ondrag public="1"><d/></ondrag>
		<ondragend public="1"><d/></ondragend>
		<ondragenter public="1"><d/></ondragenter>
		<ondragleave public="1"><d/></ondragleave>
		<ondragover public="1"><d/></ondragover>
		<ondragstart public="1"><d/></ondragstart>
		<ondrop public="1"><d/></ondrop>
		<onerror public="1"><d/></onerror>
		<onfocus public="1"><d/></onfocus>
		<onfullscreenchange public="1"><d/></onfullscreenchange>
		<onfullscreenerror public="1"><d/></onfullscreenerror>
		<oninput public="1"><d/></oninput>
		<oninvalid public="1"><d/></oninvalid>
		<onkeydown public="1"><d/></onkeydown>
		<onkeypress public="1"><d/></onkeypress>
		<onkeyup public="1"><d/></onkeyup>
		<onload public="1"><d/></onload>
		<onmousedown public="1"><d/></onmousedown>
		<onmousemove public="1"><d/></onmousemove>
		<onmouseout public="1"><d/></onmouseout>
		<onmouseover public="1"><d/></onmouseover>
		<onmouseup public="1"><d/></onmouseup>
		<onmousewheel public="1"><d/></onmousewheel>
		<onpaste public="1"><d/></onpaste>
		<onreset public="1"><d/></onreset>
		<onscroll public="1"><d/></onscroll>
		<onsearch public="1"><d/></onsearch>
		<onselect public="1"><d/></onselect>
		<onselectstart public="1"><d/></onselectstart>
		<onsubmit public="1"><d/></onsubmit>
		<ontouchcancel public="1"><d/></ontouchcancel>
		<ontouchend public="1"><d/></ontouchend>
		<ontouchmove public="1"><d/></ontouchmove>
		<ontouchstart public="1"><d/></ontouchstart>
		<outerHTML public="1"><c path="String"/></outerHTML>
		<outerText public="1"><c path="String"/></outerText>
		<ownerDocument public="1" set="null"><d/></ownerDocument>
		<parentElement public="1" set="null"><d/></parentElement>
		<parentNode public="1" set="null"><d/></parentNode>
		<prefix public="1"><c path="String"/></prefix>
		<previousElementSibling public="1" set="null"><d/></previousElementSibling>
		<previousSibling public="1" set="null"><d/></previousSibling>
		<pseudo public="1"><c path="String"/></pseudo>
		<scrollHeight public="1" set="null"><x path="Int"/></scrollHeight>
		<scrollLeft public="1"><x path="Int"/></scrollLeft>
		<scrollTop public="1"><x path="Int"/></scrollTop>
		<scrollWidth public="1" set="null"><x path="Int"/></scrollWidth>
		<spellcheck public="1"><x path="Bool"/></spellcheck>
		<style public="1" set="null"><d/></style>
		<tabIndex public="1"><x path="Int"/></tabIndex>
		<tagName public="1" set="null"><c path="String"/></tagName>
		<textContent public="1"><c path="String"/></textContent>
		<title public="1"><c path="String"/></title>
		<translate public="1"><x path="Bool"/></translate>
		<addEventListener public="1" set="method" line="124"><f a="type:listener:?useCapture">
	<c path="String"/>
	<d/>
	<x path="Bool"/>
	<x path="Void"/>
</f></addEventListener>
		<appendChild public="1" set="method" line="125"><f a="newChild">
	<d/>
	<d/>
</f></appendChild>
		<blur public="1" set="method" line="126"><f a=""><x path="Void"/></f></blur>
		<click public="1" set="method" line="127"><f a=""><x path="Void"/></f></click>
		<cloneNode public="1" set="method" line="128"><f a="deep">
	<x path="Bool"/>
	<d/>
</f></cloneNode>
		<compareDocumentPosition public="1" set="method" line="129"><f a="other">
	<d/>
	<x path="Int"/>
</f></compareDocumentPosition>
		<contains public="1" set="method" line="130"><f a="other">
	<d/>
	<x path="Bool"/>
</f></contains>
		<dispatchEvent public="1" set="method" line="131"><f a="event">
	<d/>
	<x path="Bool"/>
</f></dispatchEvent>
		<focus public="1" set="method" line="132"><f a=""><x path="Void"/></f></focus>
		<getAttribute public="1" set="method" line="133"><f a="name">
	<c path="String"/>
	<c path="String"/>
</f></getAttribute>
		<getAttributeNS public="1" set="method" line="134"><f a="?namespaceURI:localName">
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
</f></getAttributeNS>
		<getAttributeNode public="1" set="method" line="135"><f a="name">
	<c path="String"/>
	<d/>
</f></getAttributeNode>
		<getAttributeNodeNS public="1" set="method" line="136"><f a="?namespaceURI:localName">
	<c path="String"/>
	<c path="String"/>
	<d/>
</f></getAttributeNodeNS>
		<getBoundingClientRect public="1" set="method" line="137"><f a=""><d/></f></getBoundingClientRect>
		<getClientRects public="1" set="method" line="138"><f a=""><d/></f></getClientRects>
		<getElementsByClassName public="1" set="method" line="139"><f a="name">
	<c path="String"/>
	<d/>
</f></getElementsByClassName>
		<getElementsByTagName public="1" set="method" line="140"><f a="name">
	<c path="String"/>
	<d/>
</f></getElementsByTagName>
		<getElementsByTagNameNS public="1" set="method" line="141"><f a="?namespaceURI:localName">
	<c path="String"/>
	<c path="String"/>
	<d/>
</f></getElementsByTagNameNS>
		<hasAttribute public="1" set="method" line="142"><f a="name">
	<c path="String"/>
	<x path="Bool"/>
</f></hasAttribute>
		<hasAttributeNS public="1" set="method" line="143"><f a="?namespaceURI:localName">
	<c path="String"/>
	<c path="String"/>
	<x path="Bool"/>
</f></hasAttributeNS>
		<hasAttributes public="1" set="method" line="144"><f a=""><x path="Bool"/></f></hasAttributes>
		<hasChildNodes public="1" set="method" line="145"><f a=""><x path="Bool"/></f></hasChildNodes>
		<insertAdjacentElement public="1" set="method" line="146"><f a="where:element">
	<c path="String"/>
	<d/>
	<d/>
</f></insertAdjacentElement>
		<insertAdjacentHTML public="1" set="method" line="147"><f a="where:html">
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></insertAdjacentHTML>
		<insertAdjacentText public="1" set="method" line="148"><f a="where:text">
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></insertAdjacentText>
		<insertBefore public="1" set="method" line="149"><f a="newChild:refChild">
	<d/>
	<d/>
	<d/>
</f></insertBefore>
		<isDefaultNamespace public="1" set="method" line="150"><f a="?namespaceURI">
	<c path="String"/>
	<x path="Bool"/>
</f></isDefaultNamespace>
		<isEqualNode public="1" set="method" line="151"><f a="other">
	<d/>
	<x path="Bool"/>
</f></isEqualNode>
		<isSameNode public="1" set="method" line="152"><f a="other">
	<d/>
	<x path="Bool"/>
</f></isSameNode>
		<isSupported public="1" set="method" line="153"><f a="feature:?version">
	<c path="String"/>
	<c path="String"/>
	<x path="Bool"/>
</f></isSupported>
		<lookupNamespaceURI public="1" set="method" line="154"><f a="?prefix">
	<c path="String"/>
	<c path="String"/>
</f></lookupNamespaceURI>
		<lookupPrefix public="1" set="method" line="155"><f a="?namespaceURI">
	<c path="String"/>
	<c path="String"/>
</f></lookupPrefix>
		<matchesSelector public="1" set="method" line="156"><f a="selectors">
	<c path="String"/>
	<x path="Bool"/>
</f></matchesSelector>
		<normalize public="1" set="method" line="157"><f a=""><x path="Void"/></f></normalize>
		<querySelector public="1" set="method" line="158"><f a="selectors">
	<c path="String"/>
	<d/>
</f></querySelector>
		<querySelectorAll public="1" set="method" line="159"><f a="selectors">
	<c path="String"/>
	<d/>
</f></querySelectorAll>
		<remove public="1" set="method" line="160"><f a=""><x path="Void"/></f></remove>
		<removeAttribute public="1" set="method" line="161"><f a="name">
	<c path="String"/>
	<x path="Void"/>
</f></removeAttribute>
		<removeAttributeNS public="1" set="method" line="162"><f a="namespaceURI:localName">
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></removeAttributeNS>
		<removeAttributeNode public="1" set="method" line="163"><f a="oldAttr">
	<d/>
	<d/>
</f></removeAttributeNode>
		<removeChild public="1" set="method" line="164"><f a="oldChild">
	<d/>
	<d/>
</f></removeChild>
		<removeEventListener public="1" set="method" line="165"><f a="type:listener:?useCapture">
	<c path="String"/>
	<d/>
	<x path="Bool"/>
	<x path="Void"/>
</f></removeEventListener>
		<replaceChild public="1" set="method" line="166"><f a="newChild:oldChild">
	<d/>
	<d/>
	<d/>
</f></replaceChild>
		<requestFullScreen public="1" set="method" line="167"><f a="flags">
	<x path="Int"/>
	<x path="Void"/>
</f></requestFullScreen>
		<requestFullscreen public="1" set="method" line="168"><f a=""><x path="Void"/></f></requestFullscreen>
		<requestPointerLock public="1" set="method" line="169"><f a=""><x path="Void"/></f></requestPointerLock>
		<scrollByLines public="1" set="method" line="170"><f a="lines">
	<x path="Int"/>
	<x path="Void"/>
</f></scrollByLines>
		<scrollByPages public="1" set="method" line="171"><f a="pages">
	<x path="Int"/>
	<x path="Void"/>
</f></scrollByPages>
		<scrollIntoView public="1" set="method" line="172"><f a="?alignWithTop">
	<x path="Bool"/>
	<x path="Void"/>
</f></scrollIntoView>
		<scrollIntoViewIfNeeded public="1" set="method" line="173"><f a="?centerIfNeeded">
	<x path="Bool"/>
	<x path="Void"/>
</f></scrollIntoViewIfNeeded>
		<setAttribute public="1" set="method" line="174"><f a="name:value">
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></setAttribute>
		<setAttributeNS public="1" set="method" line="175"><f a="?namespaceURI:qualifiedName:value">
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></setAttributeNS>
		<setAttributeNode public="1" set="method" line="176"><f a="newAttr">
	<d/>
	<d/>
</f></setAttributeNode>
		<setAttributeNodeNS public="1" set="method" line="177"><f a="newAttr">
	<d/>
	<d/>
</f></setAttributeNodeNS>
		<new public="1" set="method" line="117"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="lime.graphics.FlashRenderContext" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/graphics/FlashRenderContext.hx">
		<accessibilityImplementation public="1"><d/></accessibilityImplementation>
		<accessibilityProperties public="1"><d/></accessibilityProperties>
		<alpha public="1"><x path="Float"/></alpha>
		<blendMode public="1"><d/></blendMode>
		<blendShader public="1" get="null"><d/></blendShader>
		<buttonMode public="1"><x path="Bool"/></buttonMode>
		<cacheAsBitmap public="1"><x path="Bool"/></cacheAsBitmap>
		<contextMenu public="1"><d/></contextMenu>
		<doubleClickEnabled public="1"><x path="Bool"/></doubleClickEnabled>
		<dropTarget public="1" set="null"><d/></dropTarget>
		<filters public="1"><c path="Array"><d/></c></filters>
		<focusRect public="1"><d/></focusRect>
		<graphics public="1" set="null"><d/></graphics>
		<height public="1"><x path="Float"/></height>
		<hitArea public="1"><d/></hitArea>
		<loaderInfo public="1" set="null"><d/></loaderInfo>
		<mask public="1"><d/></mask>
		<mouseChildren public="1"><x path="Bool"/></mouseChildren>
		<mouseEnabled public="1"><x path="Bool"/></mouseEnabled>
		<mouseX public="1" set="null"><x path="Float"/></mouseX>
		<mouseY public="1" set="null"><x path="Float"/></mouseY>
		<name public="1"><c path="String"/></name>
		<needsSoftKeyboard public="1"><x path="Bool"/></needsSoftKeyboard>
		<numChildren public="1" set="null"><x path="Int"/></numChildren>
		<opaqueBackground public="1"><t path="Null"><x path="UInt"/></t></opaqueBackground>
		<parent public="1" set="null"><d/></parent>
		<root public="1" set="null"><d/></root>
		<rotation public="1"><x path="Float"/></rotation>
		<rotationX public="1"><x path="Float"/></rotationX>
		<rotationY public="1"><x path="Float"/></rotationY>
		<rotationZ public="1"><x path="Float"/></rotationZ>
		<scale9Grid public="1"><d/></scale9Grid>
		<scaleX public="1"><x path="Float"/></scaleX>
		<scaleY public="1"><x path="Float"/></scaleY>
		<scaleZ public="1"><x path="Float"/></scaleZ>
		<scrollRect public="1"><d/></scrollRect>
		<softKeyboardInputAreaOfInterest public="1"><d/></softKeyboardInputAreaOfInterest>
		<soundTransform public="1"><d/></soundTransform>
		<stage public="1" set="null"><d/></stage>
		<tabChildren public="1"><x path="Bool"/></tabChildren>
		<tabEnabled public="1"><x path="Bool"/></tabEnabled>
		<tabIndex public="1"><x path="Int"/></tabIndex>
		<textSnapshot public="1" set="null"><d/></textSnapshot>
		<transform public="1"><d/></transform>
		<useHandCursor public="1"><x path="Bool"/></useHandCursor>
		<visible public="1"><x path="Bool"/></visible>
		<width public="1"><x path="Float"/></width>
		<x public="1"><x path="Float"/></x>
		<y public="1"><x path="Float"/></y>
		<z public="1"><x path="Float"/></z>
		<addChild public="1" set="method" line="69"><f a="child">
	<d/>
	<d/>
</f></addChild>
		<addChildAt public="1" set="method" line="70"><f a="child:index">
	<d/>
	<x path="Int"/>
	<d/>
</f></addChildAt>
		<addEventListener public="1" set="method" line="71">
			<f a="type:listener:?useCapture:?priority:?useWeakReference" v="::false:0:false">
				<c path="String"/>
				<f a="">
					<d/>
					<x path="Void"/>
				</f>
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ useWeakReference : false, priority : 0, useCapture : false }</e></m></meta>
		</addEventListener>
		<areInaccessibleObjectsUnderPoint public="1" set="method" line="72"><f a="point">
	<d/>
	<x path="Bool"/>
</f></areInaccessibleObjectsUnderPoint>
		<contains public="1" set="method" line="73"><f a="child">
	<d/>
	<x path="Bool"/>
</f></contains>
		<dispatchEvent public="1" set="method" line="74"><f a="event">
	<d/>
	<x path="Bool"/>
</f></dispatchEvent>
		<getBounds public="1" set="method" line="75"><f a="targetCoordinateSpace">
	<d/>
	<d/>
</f></getBounds>
		<getChildAt public="1" set="method" line="76"><f a="index">
	<x path="Int"/>
	<d/>
</f></getChildAt>
		<getChildByName public="1" set="method" line="77"><f a="name">
	<c path="String"/>
	<d/>
</f></getChildByName>
		<getChildIndex public="1" set="method" line="78"><f a="child">
	<d/>
	<x path="Int"/>
</f></getChildIndex>
		<getObjectsUnderPoint public="1" set="method" line="79"><f a="point">
	<d/>
	<c path="Array"><d/></c>
</f></getObjectsUnderPoint>
		<getRect public="1" set="method" line="80"><f a="targetCoordinateSpace">
	<d/>
	<d/>
</f></getRect>
		<globalToLocal public="1" set="method" line="81"><f a="point">
	<d/>
	<d/>
</f></globalToLocal>
		<globalToLocal3D public="1" set="method" line="82"><f a="point">
	<d/>
	<d/>
</f></globalToLocal3D>
		<hasEventListener public="1" set="method" line="83"><f a="type">
	<c path="String"/>
	<x path="Bool"/>
</f></hasEventListener>
		<hitTestObject public="1" set="method" line="84"><f a="obj">
	<d/>
	<x path="Bool"/>
</f></hitTestObject>
		<hitTestPoint public="1" set="method" line="85">
			<f a="x:y:?shapeFlag" v="::false">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":value"><e>{ shapeFlag : false }</e></m></meta>
		</hitTestPoint>
		<local3DToGlobal public="1" set="method" line="86"><f a="point3d">
	<d/>
	<d/>
</f></local3DToGlobal>
		<localToGlobal public="1" set="method" line="87"><f a="point">
	<d/>
	<d/>
</f></localToGlobal>
		<removeChild public="1" set="method" line="88"><f a="child">
	<d/>
	<d/>
</f></removeChild>
		<removeChildAt public="1" set="method" line="89"><f a="index">
	<x path="Int"/>
	<d/>
</f></removeChildAt>
		<removeChildren public="1" set="method" line="90">
			<f a="?beginIndex:?endIndex" v="0:2147483647">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ endIndex : 2147483647, beginIndex : 0 }</e></m></meta>
		</removeChildren>
		<removeEventListener public="1" set="method" line="91">
			<f a="type:listener:?useCapture" v="::false">
				<c path="String"/>
				<f a="">
					<d/>
					<x path="Void"/>
				</f>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ useCapture : false }</e></m></meta>
		</removeEventListener>
		<requestSoftKeyboard public="1" set="method" line="92"><f a=""><x path="Bool"/></f></requestSoftKeyboard>
		<setChildIndex public="1" set="method" line="93"><f a="child:index">
	<d/>
	<x path="Int"/>
	<x path="Void"/>
</f></setChildIndex>
		<startDrag public="1" set="method" line="94">
			<f a="?lockCenter:?bounds" v="false:">
				<x path="Bool"/>
				<d/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ lockCenter : false }</e></m></meta>
		</startDrag>
		<startTouchDrag public="1" set="method" line="95">
			<f a="touchPointID:?lockCenter:?bounds" v=":false:">
				<x path="Int"/>
				<x path="Bool"/>
				<d/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ lockCenter : false }</e></m></meta>
		</startTouchDrag>
		<stopAllMovieClips public="1" set="method" line="96"><f a=""><x path="Void"/></f></stopAllMovieClips>
		<stopDrag public="1" set="method" line="97"><f a=""><x path="Void"/></f></stopDrag>
		<stopTouchDrag public="1" set="method" line="98"><f a="touchPointID">
	<x path="Int"/>
	<x path="Void"/>
</f></stopTouchDrag>
		<swapChildren public="1" set="method" line="99"><f a="child1:child2">
	<d/>
	<d/>
	<x path="Void"/>
</f></swapChildren>
		<swapChildrenAt public="1" set="method" line="100"><f a="index1:index2">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></swapChildrenAt>
		<toString public="1" set="method" line="101"><f a=""><c path="String"/></f></toString>
		<willTrigger public="1" set="method" line="102"><f a="type">
	<c path="String"/>
	<x path="Bool"/>
</f></willTrigger>
		<new public="1" set="method" line="62"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="lime.graphics.GLRenderContext" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/graphics/GLRenderContext.hx">
		<DEPTH_BUFFER_BIT public="1" expr="0x00000100">
			<x path="Int"/>
			<meta><m n=":value"><e>0x00000100</e></m></meta>
		</DEPTH_BUFFER_BIT>
		<STENCIL_BUFFER_BIT public="1" expr="0x00000400">
			<x path="Int"/>
			<meta><m n=":value"><e>0x00000400</e></m></meta>
		</STENCIL_BUFFER_BIT>
		<COLOR_BUFFER_BIT public="1" expr="0x00004000">
			<x path="Int"/>
			<meta><m n=":value"><e>0x00004000</e></m></meta>
		</COLOR_BUFFER_BIT>
		<POINTS public="1" expr="0x0000">
			<x path="Int"/>
			<meta><m n=":value"><e>0x0000</e></m></meta>
		</POINTS>
		<LINES public="1" expr="0x0001">
			<x path="Int"/>
			<meta><m n=":value"><e>0x0001</e></m></meta>
		</LINES>
		<LINE_LOOP public="1" expr="0x0002">
			<x path="Int"/>
			<meta><m n=":value"><e>0x0002</e></m></meta>
		</LINE_LOOP>
		<LINE_STRIP public="1" expr="0x0003">
			<x path="Int"/>
			<meta><m n=":value"><e>0x0003</e></m></meta>
		</LINE_STRIP>
		<TRIANGLES public="1" expr="0x0004">
			<x path="Int"/>
			<meta><m n=":value"><e>0x0004</e></m></meta>
		</TRIANGLES>
		<TRIANGLE_STRIP public="1" expr="0x0005">
			<x path="Int"/>
			<meta><m n=":value"><e>0x0005</e></m></meta>
		</TRIANGLE_STRIP>
		<TRIANGLE_FAN public="1" expr="0x0006">
			<x path="Int"/>
			<meta><m n=":value"><e>0x0006</e></m></meta>
		</TRIANGLE_FAN>
		<ZERO public="1" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</ZERO>
		<ONE public="1" expr="1">
			<x path="Int"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</ONE>
		<SRC_COLOR public="1" expr="0x0300">
			<x path="Int"/>
			<meta><m n=":value"><e>0x0300</e></m></meta>
		</SRC_COLOR>
		<ONE_MINUS_SRC_COLOR public="1" expr="0x0301">
			<x path="Int"/>
			<meta><m n=":value"><e>0x0301</e></m></meta>
		</ONE_MINUS_SRC_COLOR>
		<SRC_ALPHA public="1" expr="0x0302">
			<x path="Int"/>
			<meta><m n=":value"><e>0x0302</e></m></meta>
		</SRC_ALPHA>
		<ONE_MINUS_SRC_ALPHA public="1" expr="0x0303">
			<x path="Int"/>
			<meta><m n=":value"><e>0x0303</e></m></meta>
		</ONE_MINUS_SRC_ALPHA>
		<DST_ALPHA public="1" expr="0x0304">
			<x path="Int"/>
			<meta><m n=":value"><e>0x0304</e></m></meta>
		</DST_ALPHA>
		<ONE_MINUS_DST_ALPHA public="1" expr="0x0305">
			<x path="Int"/>
			<meta><m n=":value"><e>0x0305</e></m></meta>
		</ONE_MINUS_DST_ALPHA>
		<DST_COLOR public="1" expr="0x0306">
			<x path="Int"/>
			<meta><m n=":value"><e>0x0306</e></m></meta>
		</DST_COLOR>
		<ONE_MINUS_DST_COLOR public="1" expr="0x0307">
			<x path="Int"/>
			<meta><m n=":value"><e>0x0307</e></m></meta>
		</ONE_MINUS_DST_COLOR>
		<SRC_ALPHA_SATURATE public="1" expr="0x0308">
			<x path="Int"/>
			<meta><m n=":value"><e>0x0308</e></m></meta>
		</SRC_ALPHA_SATURATE>
		<FUNC_ADD public="1" expr="0x8006">
			<x path="Int"/>
			<meta><m n=":value"><e>0x8006</e></m></meta>
		</FUNC_ADD>
		<BLEND_EQUATION public="1" expr="0x8009">
			<x path="Int"/>
			<meta><m n=":value"><e>0x8009</e></m></meta>
		</BLEND_EQUATION>
		<BLEND_EQUATION_RGB public="1" expr="0x8009">
			<x path="Int"/>
			<meta><m n=":value"><e>0x8009</e></m></meta>
		</BLEND_EQUATION_RGB>
		<BLEND_EQUATION_ALPHA public="1" expr="0x883D">
			<x path="Int"/>
			<meta><m n=":value"><e>0x883D</e></m></meta>
		</BLEND_EQUATION_ALPHA>
		<FUNC_SUBTRACT public="1" expr="0x800A">
			<x path="Int"/>
			<meta><m n=":value"><e>0x800A</e></m></meta>
		</FUNC_SUBTRACT>
		<FUNC_REVERSE_SUBTRACT public="1" expr="0x800B">
			<x path="Int"/>
			<meta><m n=":value"><e>0x800B</e></m></meta>
		</FUNC_REVERSE_SUBTRACT>
		<BLEND_DST_RGB public="1" expr="0x80C8">
			<x path="Int"/>
			<meta><m n=":value"><e>0x80C8</e></m></meta>
		</BLEND_DST_RGB>
		<BLEND_SRC_RGB public="1" expr="0x80C9">
			<x path="Int"/>
			<meta><m n=":value"><e>0x80C9</e></m></meta>
		</BLEND_SRC_RGB>
		<BLEND_DST_ALPHA public="1" expr="0x80CA">
			<x path="Int"/>
			<meta><m n=":value"><e>0x80CA</e></m></meta>
		</BLEND_DST_ALPHA>
		<BLEND_SRC_ALPHA public="1" expr="0x80CB">
			<x path="Int"/>
			<meta><m n=":value"><e>0x80CB</e></m></meta>
		</BLEND_SRC_ALPHA>
		<CONSTANT_COLOR public="1" expr="0x8001">
			<x path="Int"/>
			<meta><m n=":value"><e>0x8001</e></m></meta>
		</CONSTANT_COLOR>
		<ONE_MINUS_CONSTANT_COLOR public="1" expr="0x8002">
			<x path="Int"/>
			<meta><m n=":value"><e>0x8002</e></m></meta>
		</ONE_MINUS_CONSTANT_COLOR>
		<CONSTANT_ALPHA public="1" expr="0x8003">
			<x path="Int"/>
			<meta><m n=":value"><e>0x8003</e></m></meta>
		</CONSTANT_ALPHA>
		<ONE_MINUS_CONSTANT_ALPHA public="1" expr="0x8004">
			<x path="Int"/>
			<meta><m n=":value"><e>0x8004</e></m></meta>
		</ONE_MINUS_CONSTANT_ALPHA>
		<BLEND_COLOR public="1" expr="0x8005">
			<x path="Int"/>
			<meta><m n=":value"><e>0x8005</e></m></meta>
		</BLEND_COLOR>
		<ARRAY_BUFFER public="1" expr="0x8892">
			<x path="Int"/>
			<meta><m n=":value"><e>0x8892</e></m></meta>
		</ARRAY_BUFFER>
		<ELEMENT_ARRAY_BUFFER public="1" expr="0x8893">
			<x path="Int"/>
			<meta><m n=":value"><e>0x8893</e></m></meta>
		</ELEMENT_ARRAY_BUFFER>
		<ARRAY_BUFFER_BINDING public="1" expr="0x8894">
			<x path="Int"/>
			<meta><m n=":value"><e>0x8894</e></m></meta>
		</ARRAY_BUFFER_BINDING>
		<ELEMENT_ARRAY_BUFFER_BINDING public="1" expr="0x8895">
			<x path="Int"/>
			<meta><m n=":value"><e>0x8895</e></m></meta>
		</ELEMENT_ARRAY_BUFFER_BINDING>
		<STREAM_DRAW public="1" expr="0x88E0">
			<x path="Int"/>
			<meta><m n=":value"><e>0x88E0</e></m></meta>
		</STREAM_DRAW>
		<STATIC_DRAW public="1" expr="0x88E4">
			<x path="Int"/>
			<meta><m n=":value"><e>0x88E4</e></m></meta>
		</STATIC_DRAW>
		<DYNAMIC_DRAW public="1" expr="0x88E8">
			<x path="Int"/>
			<meta><m n=":value"><e>0x88E8</e></m></meta>
		</DYNAMIC_DRAW>
		<BUFFER_SIZE public="1" expr="0x8764">
			<x path="Int"/>
			<meta><m n=":value"><e>0x8764</e></m></meta>
		</BUFFER_SIZE>
		<BUFFER_USAGE public="1" expr="0x8765">
			<x path="Int"/>
			<meta><m n=":value"><e>0x8765</e></m></meta>
		</BUFFER_USAGE>
		<CURRENT_VERTEX_ATTRIB public="1" expr="0x8626">
			<x path="Int"/>
			<meta><m n=":value"><e>0x8626</e></m></meta>
		</CURRENT_VERTEX_ATTRIB>
		<FRONT public="1" expr="0x0404">
			<x path="Int"/>
			<meta><m n=":value"><e>0x0404</e></m></meta>
		</FRONT>
		<BACK public="1" expr="0x0405">
			<x path="Int"/>
			<meta><m n=":value"><e>0x0405</e></m></meta>
		</BACK>
		<FRONT_AND_BACK public="1" expr="0x0408">
			<x path="Int"/>
			<meta><m n=":value"><e>0x0408</e></m></meta>
		</FRONT_AND_BACK>
		<CULL_FACE public="1" expr="0x0B44">
			<x path="Int"/>
			<meta><m n=":value"><e>0x0B44</e></m></meta>
		</CULL_FACE>
		<BLEND public="1" expr="0x0BE2">
			<x path="Int"/>
			<meta><m n=":value"><e>0x0BE2</e></m></meta>
		</BLEND>
		<DITHER public="1" expr="0x0BD0">
			<x path="Int"/>
			<meta><m n=":value"><e>0x0BD0</e></m></meta>
		</DITHER>
		<STENCIL_TEST public="1" expr="0x0B90">
			<x path="Int"/>
			<meta><m n=":value"><e>0x0B90</e></m></meta>
		</STENCIL_TEST>
		<DEPTH_TEST public="1" expr="0x0B71">
			<x path="Int"/>
			<meta><m n=":value"><e>0x0B71</e></m></meta>
		</DEPTH_TEST>
		<SCISSOR_TEST public="1" expr="0x0C11">
			<x path="Int"/>
			<meta><m n=":value"><e>0x0C11</e></m></meta>
		</SCISSOR_TEST>
		<POLYGON_OFFSET_FILL public="1" expr="0x8037">
			<x path="Int"/>
			<meta><m n=":value"><e>0x8037</e></m></meta>
		</POLYGON_OFFSET_FILL>
		<SAMPLE_ALPHA_TO_COVERAGE public="1" expr="0x809E">
			<x path="Int"/>
			<meta><m n=":value"><e>0x809E</e></m></meta>
		</SAMPLE_ALPHA_TO_COVERAGE>
		<SAMPLE_COVERAGE public="1" expr="0x80A0">
			<x path="Int"/>
			<meta><m n=":value"><e>0x80A0</e></m></meta>
		</SAMPLE_COVERAGE>
		<NO_ERROR public="1" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</NO_ERROR>
		<INVALID_ENUM public="1" expr="0x0500">
			<x path="Int"/>
			<meta><m n=":value"><e>0x0500</e></m></meta>
		</INVALID_ENUM>
		<INVALID_VALUE public="1" expr="0x0501">
			<x path="Int"/>
			<meta><m n=":value"><e>0x0501</e></m></meta>
		</INVALID_VALUE>
		<INVALID_OPERATION public="1" expr="0x0502">
			<x path="Int"/>
			<meta><m n=":value"><e>0x0502</e></m></meta>
		</INVALID_OPERATION>
		<OUT_OF_MEMORY public="1" expr="0x0505">
			<x path="Int"/>
			<meta><m n=":value"><e>0x0505</e></m></meta>
		</OUT_OF_MEMORY>
		<CW public="1" expr="0x0900">
			<x path="Int"/>
			<meta><m n=":value"><e>0x0900</e></m></meta>
		</CW>
		<CCW public="1" expr="0x0901">
			<x path="Int"/>
			<meta><m n=":value"><e>0x0901</e></m></meta>
		</CCW>
		<LINE_WIDTH public="1" expr="0x0B21">
			<x path="Int"/>
			<meta><m n=":value"><e>0x0B21</e></m></meta>
		</LINE_WIDTH>
		<ALIASED_POINT_SIZE_RANGE public="1" expr="0x846D">
			<x path="Int"/>
			<meta><m n=":value"><e>0x846D</e></m></meta>
		</ALIASED_POINT_SIZE_RANGE>
		<ALIASED_LINE_WIDTH_RANGE public="1" expr="0x846E">
			<x path="Int"/>
			<meta><m n=":value"><e>0x846E</e></m></meta>
		</ALIASED_LINE_WIDTH_RANGE>
		<CULL_FACE_MODE public="1" expr="0x0B45">
			<x path="Int"/>
			<meta><m n=":value"><e>0x0B45</e></m></meta>
		</CULL_FACE_MODE>
		<FRONT_FACE public="1" expr="0x0B46">
			<x path="Int"/>
			<meta><m n=":value"><e>0x0B46</e></m></meta>
		</FRONT_FACE>
		<DEPTH_RANGE public="1" expr="0x0B70">
			<x path="Int"/>
			<meta><m n=":value"><e>0x0B70</e></m></meta>
		</DEPTH_RANGE>
		<DEPTH_WRITEMASK public="1" expr="0x0B72">
			<x path="Int"/>
			<meta><m n=":value"><e>0x0B72</e></m></meta>
		</DEPTH_WRITEMASK>
		<DEPTH_CLEAR_VALUE public="1" expr="0x0B73">
			<x path="Int"/>
			<meta><m n=":value"><e>0x0B73</e></m></meta>
		</DEPTH_CLEAR_VALUE>
		<DEPTH_FUNC public="1" expr="0x0B74">
			<x path="Int"/>
			<meta><m n=":value"><e>0x0B74</e></m></meta>
		</DEPTH_FUNC>
		<STENCIL_CLEAR_VALUE public="1" expr="0x0B91">
			<x path="Int"/>
			<meta><m n=":value"><e>0x0B91</e></m></meta>
		</STENCIL_CLEAR_VALUE>
		<STENCIL_FUNC public="1" expr="0x0B92">
			<x path="Int"/>
			<meta><m n=":value"><e>0x0B92</e></m></meta>
		</STENCIL_FUNC>
		<STENCIL_FAIL public="1" expr="0x0B94">
			<x path="Int"/>
			<meta><m n=":value"><e>0x0B94</e></m></meta>
		</STENCIL_FAIL>
		<STENCIL_PASS_DEPTH_FAIL public="1" expr="0x0B95">
			<x path="Int"/>
			<meta><m n=":value"><e>0x0B95</e></m></meta>
		</STENCIL_PASS_DEPTH_FAIL>
		<STENCIL_PASS_DEPTH_PASS public="1" expr="0x0B96">
			<x path="Int"/>
			<meta><m n=":value"><e>0x0B96</e></m></meta>
		</STENCIL_PASS_DEPTH_PASS>
		<STENCIL_REF public="1" expr="0x0B97">
			<x path="Int"/>
			<meta><m n=":value"><e>0x0B97</e></m></meta>
		</STENCIL_REF>
		<STENCIL_VALUE_MASK public="1" expr="0x0B93">
			<x path="Int"/>
			<meta><m n=":value"><e>0x0B93</e></m></meta>
		</STENCIL_VALUE_MASK>
		<STENCIL_WRITEMASK public="1" expr="0x0B98">
			<x path="Int"/>
			<meta><m n=":value"><e>0x0B98</e></m></meta>
		</STENCIL_WRITEMASK>
		<STENCIL_BACK_FUNC public="1" expr="0x8800">
			<x path="Int"/>
			<meta><m n=":value"><e>0x8800</e></m></meta>
		</STENCIL_BACK_FUNC>
		<STENCIL_BACK_FAIL public="1" expr="0x8801">
			<x path="Int"/>
			<meta><m n=":value"><e>0x8801</e></m></meta>
		</STENCIL_BACK_FAIL>
		<STENCIL_BACK_PASS_DEPTH_FAIL public="1" expr="0x8802">
			<x path="Int"/>
			<meta><m n=":value"><e>0x8802</e></m></meta>
		</STENCIL_BACK_PASS_DEPTH_FAIL>
		<STENCIL_BACK_PASS_DEPTH_PASS public="1" expr="0x8803">
			<x path="Int"/>
			<meta><m n=":value"><e>0x8803</e></m></meta>
		</STENCIL_BACK_PASS_DEPTH_PASS>
		<STENCIL_BACK_REF public="1" expr="0x8CA3">
			<x path="Int"/>
			<meta><m n=":value"><e>0x8CA3</e></m></meta>
		</STENCIL_BACK_REF>
		<STENCIL_BACK_VALUE_MASK public="1" expr="0x8CA4">
			<x path="Int"/>
			<meta><m n=":value"><e>0x8CA4</e></m></meta>
		</STENCIL_BACK_VALUE_MASK>
		<STENCIL_BACK_WRITEMASK public="1" expr="0x8CA5">
			<x path="Int"/>
			<meta><m n=":value"><e>0x8CA5</e></m></meta>
		</STENCIL_BACK_WRITEMASK>
		<VIEWPORT public="1" expr="0x0BA2">
			<x path="Int"/>
			<meta><m n=":value"><e>0x0BA2</e></m></meta>
		</VIEWPORT>
		<SCISSOR_BOX public="1" expr="0x0C10">
			<x path="Int"/>
			<meta><m n=":value"><e>0x0C10</e></m></meta>
		</SCISSOR_BOX>
		<COLOR_CLEAR_VALUE public="1" expr="0x0C22">
			<x path="Int"/>
			<meta><m n=":value"><e>0x0C22</e></m></meta>
		</COLOR_CLEAR_VALUE>
		<COLOR_WRITEMASK public="1" expr="0x0C23">
			<x path="Int"/>
			<meta><m n=":value"><e>0x0C23</e></m></meta>
		</COLOR_WRITEMASK>
		<UNPACK_ALIGNMENT public="1" expr="0x0CF5">
			<x path="Int"/>
			<meta><m n=":value"><e>0x0CF5</e></m></meta>
		</UNPACK_ALIGNMENT>
		<PACK_ALIGNMENT public="1" expr="0x0D05">
			<x path="Int"/>
			<meta><m n=":value"><e>0x0D05</e></m></meta>
		</PACK_ALIGNMENT>
		<MAX_TEXTURE_SIZE public="1" expr="0x0D33">
			<x path="Int"/>
			<meta><m n=":value"><e>0x0D33</e></m></meta>
		</MAX_TEXTURE_SIZE>
		<MAX_VIEWPORT_DIMS public="1" expr="0x0D3A">
			<x path="Int"/>
			<meta><m n=":value"><e>0x0D3A</e></m></meta>
		</MAX_VIEWPORT_DIMS>
		<SUBPIXEL_BITS public="1" expr="0x0D50">
			<x path="Int"/>
			<meta><m n=":value"><e>0x0D50</e></m></meta>
		</SUBPIXEL_BITS>
		<RED_BITS public="1" expr="0x0D52">
			<x path="Int"/>
			<meta><m n=":value"><e>0x0D52</e></m></meta>
		</RED_BITS>
		<GREEN_BITS public="1" expr="0x0D53">
			<x path="Int"/>
			<meta><m n=":value"><e>0x0D53</e></m></meta>
		</GREEN_BITS>
		<BLUE_BITS public="1" expr="0x0D54">
			<x path="Int"/>
			<meta><m n=":value"><e>0x0D54</e></m></meta>
		</BLUE_BITS>
		<ALPHA_BITS public="1" expr="0x0D55">
			<x path="Int"/>
			<meta><m n=":value"><e>0x0D55</e></m></meta>
		</ALPHA_BITS>
		<DEPTH_BITS public="1" expr="0x0D56">
			<x path="Int"/>
			<meta><m n=":value"><e>0x0D56</e></m></meta>
		</DEPTH_BITS>
		<STENCIL_BITS public="1" expr="0x0D57">
			<x path="Int"/>
			<meta><m n=":value"><e>0x0D57</e></m></meta>
		</STENCIL_BITS>
		<POLYGON_OFFSET_UNITS public="1" expr="0x2A00">
			<x path="Int"/>
			<meta><m n=":value"><e>0x2A00</e></m></meta>
		</POLYGON_OFFSET_UNITS>
		<POLYGON_OFFSET_FACTOR public="1" expr="0x8038">
			<x path="Int"/>
			<meta><m n=":value"><e>0x8038</e></m></meta>
		</POLYGON_OFFSET_FACTOR>
		<TEXTURE_BINDING_2D public="1" expr="0x8069">
			<x path="Int"/>
			<meta><m n=":value"><e>0x8069</e></m></meta>
		</TEXTURE_BINDING_2D>
		<SAMPLE_BUFFERS public="1" expr="0x80A8">
			<x path="Int"/>
			<meta><m n=":value"><e>0x80A8</e></m></meta>
		</SAMPLE_BUFFERS>
		<SAMPLES public="1" expr="0x80A9">
			<x path="Int"/>
			<meta><m n=":value"><e>0x80A9</e></m></meta>
		</SAMPLES>
		<SAMPLE_COVERAGE_VALUE public="1" expr="0x80AA">
			<x path="Int"/>
			<meta><m n=":value"><e>0x80AA</e></m></meta>
		</SAMPLE_COVERAGE_VALUE>
		<SAMPLE_COVERAGE_INVERT public="1" expr="0x80AB">
			<x path="Int"/>
			<meta><m n=":value"><e>0x80AB</e></m></meta>
		</SAMPLE_COVERAGE_INVERT>
		<COMPRESSED_TEXTURE_FORMATS public="1" expr="0x86A3">
			<x path="Int"/>
			<meta><m n=":value"><e>0x86A3</e></m></meta>
		</COMPRESSED_TEXTURE_FORMATS>
		<DONT_CARE public="1" expr="0x1100">
			<x path="Int"/>
			<meta><m n=":value"><e>0x1100</e></m></meta>
		</DONT_CARE>
		<FASTEST public="1" expr="0x1101">
			<x path="Int"/>
			<meta><m n=":value"><e>0x1101</e></m></meta>
		</FASTEST>
		<NICEST public="1" expr="0x1102">
			<x path="Int"/>
			<meta><m n=":value"><e>0x1102</e></m></meta>
		</NICEST>
		<GENERATE_MIPMAP_HINT public="1" expr="0x8192">
			<x path="Int"/>
			<meta><m n=":value"><e>0x8192</e></m></meta>
		</GENERATE_MIPMAP_HINT>
		<BYTE public="1" expr="0x1400">
			<x path="Int"/>
			<meta><m n=":value"><e>0x1400</e></m></meta>
		</BYTE>
		<UNSIGNED_BYTE public="1" expr="0x1401">
			<x path="Int"/>
			<meta><m n=":value"><e>0x1401</e></m></meta>
		</UNSIGNED_BYTE>
		<SHORT public="1" expr="0x1402">
			<x path="Int"/>
			<meta><m n=":value"><e>0x1402</e></m></meta>
		</SHORT>
		<UNSIGNED_SHORT public="1" expr="0x1403">
			<x path="Int"/>
			<meta><m n=":value"><e>0x1403</e></m></meta>
		</UNSIGNED_SHORT>
		<INT public="1" expr="0x1404">
			<x path="Int"/>
			<meta><m n=":value"><e>0x1404</e></m></meta>
		</INT>
		<UNSIGNED_INT public="1" expr="0x1405">
			<x path="Int"/>
			<meta><m n=":value"><e>0x1405</e></m></meta>
		</UNSIGNED_INT>
		<FLOAT public="1" expr="0x1406">
			<x path="Int"/>
			<meta><m n=":value"><e>0x1406</e></m></meta>
		</FLOAT>
		<DEPTH_COMPONENT public="1" expr="0x1902">
			<x path="Int"/>
			<meta><m n=":value"><e>0x1902</e></m></meta>
		</DEPTH_COMPONENT>
		<ALPHA public="1" expr="0x1906">
			<x path="Int"/>
			<meta><m n=":value"><e>0x1906</e></m></meta>
		</ALPHA>
		<RGB public="1" expr="0x1907">
			<x path="Int"/>
			<meta><m n=":value"><e>0x1907</e></m></meta>
		</RGB>
		<RGBA public="1" expr="0x1908">
			<x path="Int"/>
			<meta><m n=":value"><e>0x1908</e></m></meta>
		</RGBA>
		<BGR_EXT public="1" expr="0x80E0">
			<x path="Int"/>
			<meta><m n=":value"><e>0x80E0</e></m></meta>
		</BGR_EXT>
		<BGRA_EXT public="1" expr="0x80E1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x80E1</e></m></meta>
		</BGRA_EXT>
		<LUMINANCE public="1" expr="0x1909">
			<x path="Int"/>
			<meta><m n=":value"><e>0x1909</e></m></meta>
		</LUMINANCE>
		<LUMINANCE_ALPHA public="1" expr="0x190A">
			<x path="Int"/>
			<meta><m n=":value"><e>0x190A</e></m></meta>
		</LUMINANCE_ALPHA>
		<UNSIGNED_SHORT_4_4_4_4 public="1" expr="0x8033">
			<x path="Int"/>
			<meta><m n=":value"><e>0x8033</e></m></meta>
		</UNSIGNED_SHORT_4_4_4_4>
		<UNSIGNED_SHORT_5_5_5_1 public="1" expr="0x8034">
			<x path="Int"/>
			<meta><m n=":value"><e>0x8034</e></m></meta>
		</UNSIGNED_SHORT_5_5_5_1>
		<UNSIGNED_SHORT_5_6_5 public="1" expr="0x8363">
			<x path="Int"/>
			<meta><m n=":value"><e>0x8363</e></m></meta>
		</UNSIGNED_SHORT_5_6_5>
		<FRAGMENT_SHADER public="1" expr="0x8B30">
			<x path="Int"/>
			<meta><m n=":value"><e>0x8B30</e></m></meta>
		</FRAGMENT_SHADER>
		<VERTEX_SHADER public="1" expr="0x8B31">
			<x path="Int"/>
			<meta><m n=":value"><e>0x8B31</e></m></meta>
		</VERTEX_SHADER>
		<MAX_VERTEX_ATTRIBS public="1" expr="0x8869">
			<x path="Int"/>
			<meta><m n=":value"><e>0x8869</e></m></meta>
		</MAX_VERTEX_ATTRIBS>
		<MAX_VERTEX_UNIFORM_VECTORS public="1" expr="0x8DFB">
			<x path="Int"/>
			<meta><m n=":value"><e>0x8DFB</e></m></meta>
		</MAX_VERTEX_UNIFORM_VECTORS>
		<MAX_VARYING_VECTORS public="1" expr="0x8DFC">
			<x path="Int"/>
			<meta><m n=":value"><e>0x8DFC</e></m></meta>
		</MAX_VARYING_VECTORS>
		<MAX_COMBINED_TEXTURE_IMAGE_UNITS public="1" expr="0x8B4D">
			<x path="Int"/>
			<meta><m n=":value"><e>0x8B4D</e></m></meta>
		</MAX_COMBINED_TEXTURE_IMAGE_UNITS>
		<MAX_VERTEX_TEXTURE_IMAGE_UNITS public="1" expr="0x8B4C">
			<x path="Int"/>
			<meta><m n=":value"><e>0x8B4C</e></m></meta>
		</MAX_VERTEX_TEXTURE_IMAGE_UNITS>
		<MAX_TEXTURE_IMAGE_UNITS public="1" expr="0x8872">
			<x path="Int"/>
			<meta><m n=":value"><e>0x8872</e></m></meta>
		</MAX_TEXTURE_IMAGE_UNITS>
		<MAX_FRAGMENT_UNIFORM_VECTORS public="1" expr="0x8DFD">
			<x path="Int"/>
			<meta><m n=":value"><e>0x8DFD</e></m></meta>
		</MAX_FRAGMENT_UNIFORM_VECTORS>
		<SHADER_TYPE public="1" expr="0x8B4F">
			<x path="Int"/>
			<meta><m n=":value"><e>0x8B4F</e></m></meta>
		</SHADER_TYPE>
		<DELETE_STATUS public="1" expr="0x8B80">
			<x path="Int"/>
			<meta><m n=":value"><e>0x8B80</e></m></meta>
		</DELETE_STATUS>
		<LINK_STATUS public="1" expr="0x8B82">
			<x path="Int"/>
			<meta><m n=":value"><e>0x8B82</e></m></meta>
		</LINK_STATUS>
		<VALIDATE_STATUS public="1" expr="0x8B83">
			<x path="Int"/>
			<meta><m n=":value"><e>0x8B83</e></m></meta>
		</VALIDATE_STATUS>
		<ATTACHED_SHADERS public="1" expr="0x8B85">
			<x path="Int"/>
			<meta><m n=":value"><e>0x8B85</e></m></meta>
		</ATTACHED_SHADERS>
		<ACTIVE_UNIFORMS public="1" expr="0x8B86">
			<x path="Int"/>
			<meta><m n=":value"><e>0x8B86</e></m></meta>
		</ACTIVE_UNIFORMS>
		<ACTIVE_ATTRIBUTES public="1" expr="0x8B89">
			<x path="Int"/>
			<meta><m n=":value"><e>0x8B89</e></m></meta>
		</ACTIVE_ATTRIBUTES>
		<SHADING_LANGUAGE_VERSION public="1" expr="0x8B8C">
			<x path="Int"/>
			<meta><m n=":value"><e>0x8B8C</e></m></meta>
		</SHADING_LANGUAGE_VERSION>
		<CURRENT_PROGRAM public="1" expr="0x8B8D">
			<x path="Int"/>
			<meta><m n=":value"><e>0x8B8D</e></m></meta>
		</CURRENT_PROGRAM>
		<NEVER public="1" expr="0x0200">
			<x path="Int"/>
			<meta><m n=":value"><e>0x0200</e></m></meta>
		</NEVER>
		<LESS public="1" expr="0x0201">
			<x path="Int"/>
			<meta><m n=":value"><e>0x0201</e></m></meta>
		</LESS>
		<EQUAL public="1" expr="0x0202">
			<x path="Int"/>
			<meta><m n=":value"><e>0x0202</e></m></meta>
		</EQUAL>
		<LEQUAL public="1" expr="0x0203">
			<x path="Int"/>
			<meta><m n=":value"><e>0x0203</e></m></meta>
		</LEQUAL>
		<GREATER public="1" expr="0x0204">
			<x path="Int"/>
			<meta><m n=":value"><e>0x0204</e></m></meta>
		</GREATER>
		<NOTEQUAL public="1" expr="0x0205">
			<x path="Int"/>
			<meta><m n=":value"><e>0x0205</e></m></meta>
		</NOTEQUAL>
		<GEQUAL public="1" expr="0x0206">
			<x path="Int"/>
			<meta><m n=":value"><e>0x0206</e></m></meta>
		</GEQUAL>
		<ALWAYS public="1" expr="0x0207">
			<x path="Int"/>
			<meta><m n=":value"><e>0x0207</e></m></meta>
		</ALWAYS>
		<KEEP public="1" expr="0x1E00">
			<x path="Int"/>
			<meta><m n=":value"><e>0x1E00</e></m></meta>
		</KEEP>
		<REPLACE public="1" expr="0x1E01">
			<x path="Int"/>
			<meta><m n=":value"><e>0x1E01</e></m></meta>
		</REPLACE>
		<INCR public="1" expr="0x1E02">
			<x path="Int"/>
			<meta><m n=":value"><e>0x1E02</e></m></meta>
		</INCR>
		<DECR public="1" expr="0x1E03">
			<x path="Int"/>
			<meta><m n=":value"><e>0x1E03</e></m></meta>
		</DECR>
		<INVERT public="1" expr="0x150A">
			<x path="Int"/>
			<meta><m n=":value"><e>0x150A</e></m></meta>
		</INVERT>
		<INCR_WRAP public="1" expr="0x8507">
			<x path="Int"/>
			<meta><m n=":value"><e>0x8507</e></m></meta>
		</INCR_WRAP>
		<DECR_WRAP public="1" expr="0x8508">
			<x path="Int"/>
			<meta><m n=":value"><e>0x8508</e></m></meta>
		</DECR_WRAP>
		<VENDOR public="1" expr="0x1F00">
			<x path="Int"/>
			<meta><m n=":value"><e>0x1F00</e></m></meta>
		</VENDOR>
		<RENDERER public="1" expr="0x1F01">
			<x path="Int"/>
			<meta><m n=":value"><e>0x1F01</e></m></meta>
		</RENDERER>
		<VERSION public="1" expr="0x1F02">
			<x path="Int"/>
			<meta><m n=":value"><e>0x1F02</e></m></meta>
		</VERSION>
		<NEAREST public="1" expr="0x2600">
			<x path="Int"/>
			<meta><m n=":value"><e>0x2600</e></m></meta>
		</NEAREST>
		<LINEAR public="1" expr="0x2601">
			<x path="Int"/>
			<meta><m n=":value"><e>0x2601</e></m></meta>
		</LINEAR>
		<NEAREST_MIPMAP_NEAREST public="1" expr="0x2700">
			<x path="Int"/>
			<meta><m n=":value"><e>0x2700</e></m></meta>
		</NEAREST_MIPMAP_NEAREST>
		<LINEAR_MIPMAP_NEAREST public="1" expr="0x2701">
			<x path="Int"/>
			<meta><m n=":value"><e>0x2701</e></m></meta>
		</LINEAR_MIPMAP_NEAREST>
		<NEAREST_MIPMAP_LINEAR public="1" expr="0x2702">
			<x path="Int"/>
			<meta><m n=":value"><e>0x2702</e></m></meta>
		</NEAREST_MIPMAP_LINEAR>
		<LINEAR_MIPMAP_LINEAR public="1" expr="0x2703">
			<x path="Int"/>
			<meta><m n=":value"><e>0x2703</e></m></meta>
		</LINEAR_MIPMAP_LINEAR>
		<TEXTURE_MAG_FILTER public="1" expr="0x2800">
			<x path="Int"/>
			<meta><m n=":value"><e>0x2800</e></m></meta>
		</TEXTURE_MAG_FILTER>
		<TEXTURE_MIN_FILTER public="1" expr="0x2801">
			<x path="Int"/>
			<meta><m n=":value"><e>0x2801</e></m></meta>
		</TEXTURE_MIN_FILTER>
		<TEXTURE_WRAP_S public="1" expr="0x2802">
			<x path="Int"/>
			<meta><m n=":value"><e>0x2802</e></m></meta>
		</TEXTURE_WRAP_S>
		<TEXTURE_WRAP_T public="1" expr="0x2803">
			<x path="Int"/>
			<meta><m n=":value"><e>0x2803</e></m></meta>
		</TEXTURE_WRAP_T>
		<TEXTURE_2D public="1" expr="0x0DE1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x0DE1</e></m></meta>
		</TEXTURE_2D>
		<TEXTURE public="1" expr="0x1702">
			<x path="Int"/>
			<meta><m n=":value"><e>0x1702</e></m></meta>
		</TEXTURE>
		<TEXTURE_CUBE_MAP public="1" expr="0x8513">
			<x path="Int"/>
			<meta><m n=":value"><e>0x8513</e></m></meta>
		</TEXTURE_CUBE_MAP>
		<TEXTURE_BINDING_CUBE_MAP public="1" expr="0x8514">
			<x path="Int"/>
			<meta><m n=":value"><e>0x8514</e></m></meta>
		</TEXTURE_BINDING_CUBE_MAP>
		<TEXTURE_CUBE_MAP_POSITIVE_X public="1" expr="0x8515">
			<x path="Int"/>
			<meta><m n=":value"><e>0x8515</e></m></meta>
		</TEXTURE_CUBE_MAP_POSITIVE_X>
		<TEXTURE_CUBE_MAP_NEGATIVE_X public="1" expr="0x8516">
			<x path="Int"/>
			<meta><m n=":value"><e>0x8516</e></m></meta>
		</TEXTURE_CUBE_MAP_NEGATIVE_X>
		<TEXTURE_CUBE_MAP_POSITIVE_Y public="1" expr="0x8517">
			<x path="Int"/>
			<meta><m n=":value"><e>0x8517</e></m></meta>
		</TEXTURE_CUBE_MAP_POSITIVE_Y>
		<TEXTURE_CUBE_MAP_NEGATIVE_Y public="1" expr="0x8518">
			<x path="Int"/>
			<meta><m n=":value"><e>0x8518</e></m></meta>
		</TEXTURE_CUBE_MAP_NEGATIVE_Y>
		<TEXTURE_CUBE_MAP_POSITIVE_Z public="1" expr="0x8519">
			<x path="Int"/>
			<meta><m n=":value"><e>0x8519</e></m></meta>
		</TEXTURE_CUBE_MAP_POSITIVE_Z>
		<TEXTURE_CUBE_MAP_NEGATIVE_Z public="1" expr="0x851A">
			<x path="Int"/>
			<meta><m n=":value"><e>0x851A</e></m></meta>
		</TEXTURE_CUBE_MAP_NEGATIVE_Z>
		<MAX_CUBE_MAP_TEXTURE_SIZE public="1" expr="0x851C">
			<x path="Int"/>
			<meta><m n=":value"><e>0x851C</e></m></meta>
		</MAX_CUBE_MAP_TEXTURE_SIZE>
		<TEXTURE0 public="1" expr="0x84C0">
			<x path="Int"/>
			<meta><m n=":value"><e>0x84C0</e></m></meta>
		</TEXTURE0>
		<TEXTURE1 public="1" expr="0x84C1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x84C1</e></m></meta>
		</TEXTURE1>
		<TEXTURE2 public="1" expr="0x84C2">
			<x path="Int"/>
			<meta><m n=":value"><e>0x84C2</e></m></meta>
		</TEXTURE2>
		<TEXTURE3 public="1" expr="0x84C3">
			<x path="Int"/>
			<meta><m n=":value"><e>0x84C3</e></m></meta>
		</TEXTURE3>
		<TEXTURE4 public="1" expr="0x84C4">
			<x path="Int"/>
			<meta><m n=":value"><e>0x84C4</e></m></meta>
		</TEXTURE4>
		<TEXTURE5 public="1" expr="0x84C5">
			<x path="Int"/>
			<meta><m n=":value"><e>0x84C5</e></m></meta>
		</TEXTURE5>
		<TEXTURE6 public="1" expr="0x84C6">
			<x path="Int"/>
			<meta><m n=":value"><e>0x84C6</e></m></meta>
		</TEXTURE6>
		<TEXTURE7 public="1" expr="0x84C7">
			<x path="Int"/>
			<meta><m n=":value"><e>0x84C7</e></m></meta>
		</TEXTURE7>
		<TEXTURE8 public="1" expr="0x84C8">
			<x path="Int"/>
			<meta><m n=":value"><e>0x84C8</e></m></meta>
		</TEXTURE8>
		<TEXTURE9 public="1" expr="0x84C9">
			<x path="Int"/>
			<meta><m n=":value"><e>0x84C9</e></m></meta>
		</TEXTURE9>
		<TEXTURE10 public="1" expr="0x84CA">
			<x path="Int"/>
			<meta><m n=":value"><e>0x84CA</e></m></meta>
		</TEXTURE10>
		<TEXTURE11 public="1" expr="0x84CB">
			<x path="Int"/>
			<meta><m n=":value"><e>0x84CB</e></m></meta>
		</TEXTURE11>
		<TEXTURE12 public="1" expr="0x84CC">
			<x path="Int"/>
			<meta><m n=":value"><e>0x84CC</e></m></meta>
		</TEXTURE12>
		<TEXTURE13 public="1" expr="0x84CD">
			<x path="Int"/>
			<meta><m n=":value"><e>0x84CD</e></m></meta>
		</TEXTURE13>
		<TEXTURE14 public="1" expr="0x84CE">
			<x path="Int"/>
			<meta><m n=":value"><e>0x84CE</e></m></meta>
		</TEXTURE14>
		<TEXTURE15 public="1" expr="0x84CF">
			<x path="Int"/>
			<meta><m n=":value"><e>0x84CF</e></m></meta>
		</TEXTURE15>
		<TEXTURE16 public="1" expr="0x84D0">
			<x path="Int"/>
			<meta><m n=":value"><e>0x84D0</e></m></meta>
		</TEXTURE16>
		<TEXTURE17 public="1" expr="0x84D1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x84D1</e></m></meta>
		</TEXTURE17>
		<TEXTURE18 public="1" expr="0x84D2">
			<x path="Int"/>
			<meta><m n=":value"><e>0x84D2</e></m></meta>
		</TEXTURE18>
		<TEXTURE19 public="1" expr="0x84D3">
			<x path="Int"/>
			<meta><m n=":value"><e>0x84D3</e></m></meta>
		</TEXTURE19>
		<TEXTURE20 public="1" expr="0x84D4">
			<x path="Int"/>
			<meta><m n=":value"><e>0x84D4</e></m></meta>
		</TEXTURE20>
		<TEXTURE21 public="1" expr="0x84D5">
			<x path="Int"/>
			<meta><m n=":value"><e>0x84D5</e></m></meta>
		</TEXTURE21>
		<TEXTURE22 public="1" expr="0x84D6">
			<x path="Int"/>
			<meta><m n=":value"><e>0x84D6</e></m></meta>
		</TEXTURE22>
		<TEXTURE23 public="1" expr="0x84D7">
			<x path="Int"/>
			<meta><m n=":value"><e>0x84D7</e></m></meta>
		</TEXTURE23>
		<TEXTURE24 public="1" expr="0x84D8">
			<x path="Int"/>
			<meta><m n=":value"><e>0x84D8</e></m></meta>
		</TEXTURE24>
		<TEXTURE25 public="1" expr="0x84D9">
			<x path="Int"/>
			<meta><m n=":value"><e>0x84D9</e></m></meta>
		</TEXTURE25>
		<TEXTURE26 public="1" expr="0x84DA">
			<x path="Int"/>
			<meta><m n=":value"><e>0x84DA</e></m></meta>
		</TEXTURE26>
		<TEXTURE27 public="1" expr="0x84DB">
			<x path="Int"/>
			<meta><m n=":value"><e>0x84DB</e></m></meta>
		</TEXTURE27>
		<TEXTURE28 public="1" expr="0x84DC">
			<x path="Int"/>
			<meta><m n=":value"><e>0x84DC</e></m></meta>
		</TEXTURE28>
		<TEXTURE29 public="1" expr="0x84DD">
			<x path="Int"/>
			<meta><m n=":value"><e>0x84DD</e></m></meta>
		</TEXTURE29>
		<TEXTURE30 public="1" expr="0x84DE">
			<x path="Int"/>
			<meta><m n=":value"><e>0x84DE</e></m></meta>
		</TEXTURE30>
		<TEXTURE31 public="1" expr="0x84DF">
			<x path="Int"/>
			<meta><m n=":value"><e>0x84DF</e></m></meta>
		</TEXTURE31>
		<ACTIVE_TEXTURE public="1" expr="0x84E0">
			<x path="Int"/>
			<meta><m n=":value"><e>0x84E0</e></m></meta>
		</ACTIVE_TEXTURE>
		<REPEAT public="1" expr="0x2901">
			<x path="Int"/>
			<meta><m n=":value"><e>0x2901</e></m></meta>
		</REPEAT>
		<CLAMP_TO_EDGE public="1" expr="0x812F">
			<x path="Int"/>
			<meta><m n=":value"><e>0x812F</e></m></meta>
		</CLAMP_TO_EDGE>
		<MIRRORED_REPEAT public="1" expr="0x8370">
			<x path="Int"/>
			<meta><m n=":value"><e>0x8370</e></m></meta>
		</MIRRORED_REPEAT>
		<FLOAT_VEC2 public="1" expr="0x8B50">
			<x path="Int"/>
			<meta><m n=":value"><e>0x8B50</e></m></meta>
		</FLOAT_VEC2>
		<FLOAT_VEC3 public="1" expr="0x8B51">
			<x path="Int"/>
			<meta><m n=":value"><e>0x8B51</e></m></meta>
		</FLOAT_VEC3>
		<FLOAT_VEC4 public="1" expr="0x8B52">
			<x path="Int"/>
			<meta><m n=":value"><e>0x8B52</e></m></meta>
		</FLOAT_VEC4>
		<INT_VEC2 public="1" expr="0x8B53">
			<x path="Int"/>
			<meta><m n=":value"><e>0x8B53</e></m></meta>
		</INT_VEC2>
		<INT_VEC3 public="1" expr="0x8B54">
			<x path="Int"/>
			<meta><m n=":value"><e>0x8B54</e></m></meta>
		</INT_VEC3>
		<INT_VEC4 public="1" expr="0x8B55">
			<x path="Int"/>
			<meta><m n=":value"><e>0x8B55</e></m></meta>
		</INT_VEC4>
		<BOOL public="1" expr="0x8B56">
			<x path="Int"/>
			<meta><m n=":value"><e>0x8B56</e></m></meta>
		</BOOL>
		<BOOL_VEC2 public="1" expr="0x8B57">
			<x path="Int"/>
			<meta><m n=":value"><e>0x8B57</e></m></meta>
		</BOOL_VEC2>
		<BOOL_VEC3 public="1" expr="0x8B58">
			<x path="Int"/>
			<meta><m n=":value"><e>0x8B58</e></m></meta>
		</BOOL_VEC3>
		<BOOL_VEC4 public="1" expr="0x8B59">
			<x path="Int"/>
			<meta><m n=":value"><e>0x8B59</e></m></meta>
		</BOOL_VEC4>
		<FLOAT_MAT2 public="1" expr="0x8B5A">
			<x path="Int"/>
			<meta><m n=":value"><e>0x8B5A</e></m></meta>
		</FLOAT_MAT2>
		<FLOAT_MAT3 public="1" expr="0x8B5B">
			<x path="Int"/>
			<meta><m n=":value"><e>0x8B5B</e></m></meta>
		</FLOAT_MAT3>
		<FLOAT_MAT4 public="1" expr="0x8B5C">
			<x path="Int"/>
			<meta><m n=":value"><e>0x8B5C</e></m></meta>
		</FLOAT_MAT4>
		<SAMPLER_2D public="1" expr="0x8B5E">
			<x path="Int"/>
			<meta><m n=":value"><e>0x8B5E</e></m></meta>
		</SAMPLER_2D>
		<SAMPLER_CUBE public="1" expr="0x8B60">
			<x path="Int"/>
			<meta><m n=":value"><e>0x8B60</e></m></meta>
		</SAMPLER_CUBE>
		<VERTEX_ATTRIB_ARRAY_ENABLED public="1" expr="0x8622">
			<x path="Int"/>
			<meta><m n=":value"><e>0x8622</e></m></meta>
		</VERTEX_ATTRIB_ARRAY_ENABLED>
		<VERTEX_ATTRIB_ARRAY_SIZE public="1" expr="0x8623">
			<x path="Int"/>
			<meta><m n=":value"><e>0x8623</e></m></meta>
		</VERTEX_ATTRIB_ARRAY_SIZE>
		<VERTEX_ATTRIB_ARRAY_STRIDE public="1" expr="0x8624">
			<x path="Int"/>
			<meta><m n=":value"><e>0x8624</e></m></meta>
		</VERTEX_ATTRIB_ARRAY_STRIDE>
		<VERTEX_ATTRIB_ARRAY_TYPE public="1" expr="0x8625">
			<x path="Int"/>
			<meta><m n=":value"><e>0x8625</e></m></meta>
		</VERTEX_ATTRIB_ARRAY_TYPE>
		<VERTEX_ATTRIB_ARRAY_NORMALIZED public="1" expr="0x886A">
			<x path="Int"/>
			<meta><m n=":value"><e>0x886A</e></m></meta>
		</VERTEX_ATTRIB_ARRAY_NORMALIZED>
		<VERTEX_ATTRIB_ARRAY_POINTER public="1" expr="0x8645">
			<x path="Int"/>
			<meta><m n=":value"><e>0x8645</e></m></meta>
		</VERTEX_ATTRIB_ARRAY_POINTER>
		<VERTEX_ATTRIB_ARRAY_BUFFER_BINDING public="1" expr="0x889F">
			<x path="Int"/>
			<meta><m n=":value"><e>0x889F</e></m></meta>
		</VERTEX_ATTRIB_ARRAY_BUFFER_BINDING>
		<VERTEX_PROGRAM_POINT_SIZE public="1" expr="0x8642">
			<x path="Int"/>
			<meta><m n=":value"><e>0x8642</e></m></meta>
		</VERTEX_PROGRAM_POINT_SIZE>
		<POINT_SPRITE public="1" expr="0x8861">
			<x path="Int"/>
			<meta><m n=":value"><e>0x8861</e></m></meta>
		</POINT_SPRITE>
		<COMPILE_STATUS public="1" expr="0x8B81">
			<x path="Int"/>
			<meta><m n=":value"><e>0x8B81</e></m></meta>
		</COMPILE_STATUS>
		<LOW_FLOAT public="1" expr="0x8DF0">
			<x path="Int"/>
			<meta><m n=":value"><e>0x8DF0</e></m></meta>
		</LOW_FLOAT>
		<MEDIUM_FLOAT public="1" expr="0x8DF1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x8DF1</e></m></meta>
		</MEDIUM_FLOAT>
		<HIGH_FLOAT public="1" expr="0x8DF2">
			<x path="Int"/>
			<meta><m n=":value"><e>0x8DF2</e></m></meta>
		</HIGH_FLOAT>
		<LOW_INT public="1" expr="0x8DF3">
			<x path="Int"/>
			<meta><m n=":value"><e>0x8DF3</e></m></meta>
		</LOW_INT>
		<MEDIUM_INT public="1" expr="0x8DF4">
			<x path="Int"/>
			<meta><m n=":value"><e>0x8DF4</e></m></meta>
		</MEDIUM_INT>
		<HIGH_INT public="1" expr="0x8DF5">
			<x path="Int"/>
			<meta><m n=":value"><e>0x8DF5</e></m></meta>
		</HIGH_INT>
		<FRAMEBUFFER public="1" expr="0x8D40">
			<x path="Int"/>
			<meta><m n=":value"><e>0x8D40</e></m></meta>
		</FRAMEBUFFER>
		<RENDERBUFFER public="1" expr="0x8D41">
			<x path="Int"/>
			<meta><m n=":value"><e>0x8D41</e></m></meta>
		</RENDERBUFFER>
		<RGBA4 public="1" expr="0x8056">
			<x path="Int"/>
			<meta><m n=":value"><e>0x8056</e></m></meta>
		</RGBA4>
		<RGB5_A1 public="1" expr="0x8057">
			<x path="Int"/>
			<meta><m n=":value"><e>0x8057</e></m></meta>
		</RGB5_A1>
		<RGB565 public="1" expr="0x8D62">
			<x path="Int"/>
			<meta><m n=":value"><e>0x8D62</e></m></meta>
		</RGB565>
		<DEPTH_COMPONENT16 public="1" expr="0x81A5">
			<x path="Int"/>
			<meta><m n=":value"><e>0x81A5</e></m></meta>
		</DEPTH_COMPONENT16>
		<STENCIL_INDEX public="1" expr="0x1901">
			<x path="Int"/>
			<meta><m n=":value"><e>0x1901</e></m></meta>
		</STENCIL_INDEX>
		<STENCIL_INDEX8 public="1" expr="0x8D48">
			<x path="Int"/>
			<meta><m n=":value"><e>0x8D48</e></m></meta>
		</STENCIL_INDEX8>
		<DEPTH_STENCIL public="1" expr="0x84F9">
			<x path="Int"/>
			<meta><m n=":value"><e>0x84F9</e></m></meta>
		</DEPTH_STENCIL>
		<RENDERBUFFER_WIDTH public="1" expr="0x8D42">
			<x path="Int"/>
			<meta><m n=":value"><e>0x8D42</e></m></meta>
		</RENDERBUFFER_WIDTH>
		<RENDERBUFFER_HEIGHT public="1" expr="0x8D43">
			<x path="Int"/>
			<meta><m n=":value"><e>0x8D43</e></m></meta>
		</RENDERBUFFER_HEIGHT>
		<RENDERBUFFER_INTERNAL_FORMAT public="1" expr="0x8D44">
			<x path="Int"/>
			<meta><m n=":value"><e>0x8D44</e></m></meta>
		</RENDERBUFFER_INTERNAL_FORMAT>
		<RENDERBUFFER_RED_SIZE public="1" expr="0x8D50">
			<x path="Int"/>
			<meta><m n=":value"><e>0x8D50</e></m></meta>
		</RENDERBUFFER_RED_SIZE>
		<RENDERBUFFER_GREEN_SIZE public="1" expr="0x8D51">
			<x path="Int"/>
			<meta><m n=":value"><e>0x8D51</e></m></meta>
		</RENDERBUFFER_GREEN_SIZE>
		<RENDERBUFFER_BLUE_SIZE public="1" expr="0x8D52">
			<x path="Int"/>
			<meta><m n=":value"><e>0x8D52</e></m></meta>
		</RENDERBUFFER_BLUE_SIZE>
		<RENDERBUFFER_ALPHA_SIZE public="1" expr="0x8D53">
			<x path="Int"/>
			<meta><m n=":value"><e>0x8D53</e></m></meta>
		</RENDERBUFFER_ALPHA_SIZE>
		<RENDERBUFFER_DEPTH_SIZE public="1" expr="0x8D54">
			<x path="Int"/>
			<meta><m n=":value"><e>0x8D54</e></m></meta>
		</RENDERBUFFER_DEPTH_SIZE>
		<RENDERBUFFER_STENCIL_SIZE public="1" expr="0x8D55">
			<x path="Int"/>
			<meta><m n=":value"><e>0x8D55</e></m></meta>
		</RENDERBUFFER_STENCIL_SIZE>
		<FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE public="1" expr="0x8CD0">
			<x path="Int"/>
			<meta><m n=":value"><e>0x8CD0</e></m></meta>
		</FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE>
		<FRAMEBUFFER_ATTACHMENT_OBJECT_NAME public="1" expr="0x8CD1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x8CD1</e></m></meta>
		</FRAMEBUFFER_ATTACHMENT_OBJECT_NAME>
		<FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL public="1" expr="0x8CD2">
			<x path="Int"/>
			<meta><m n=":value"><e>0x8CD2</e></m></meta>
		</FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL>
		<FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE public="1" expr="0x8CD3">
			<x path="Int"/>
			<meta><m n=":value"><e>0x8CD3</e></m></meta>
		</FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE>
		<COLOR_ATTACHMENT0 public="1" expr="0x8CE0">
			<x path="Int"/>
			<meta><m n=":value"><e>0x8CE0</e></m></meta>
		</COLOR_ATTACHMENT0>
		<DEPTH_ATTACHMENT public="1" expr="0x8D00">
			<x path="Int"/>
			<meta><m n=":value"><e>0x8D00</e></m></meta>
		</DEPTH_ATTACHMENT>
		<STENCIL_ATTACHMENT public="1" expr="0x8D20">
			<x path="Int"/>
			<meta><m n=":value"><e>0x8D20</e></m></meta>
		</STENCIL_ATTACHMENT>
		<DEPTH_STENCIL_ATTACHMENT public="1" expr="0x821A">
			<x path="Int"/>
			<meta><m n=":value"><e>0x821A</e></m></meta>
		</DEPTH_STENCIL_ATTACHMENT>
		<NONE public="1" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</NONE>
		<FRAMEBUFFER_COMPLETE public="1" expr="0x8CD5">
			<x path="Int"/>
			<meta><m n=":value"><e>0x8CD5</e></m></meta>
		</FRAMEBUFFER_COMPLETE>
		<FRAMEBUFFER_INCOMPLETE_ATTACHMENT public="1" expr="0x8CD6">
			<x path="Int"/>
			<meta><m n=":value"><e>0x8CD6</e></m></meta>
		</FRAMEBUFFER_INCOMPLETE_ATTACHMENT>
		<FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT public="1" expr="0x8CD7">
			<x path="Int"/>
			<meta><m n=":value"><e>0x8CD7</e></m></meta>
		</FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT>
		<FRAMEBUFFER_INCOMPLETE_DIMENSIONS public="1" expr="0x8CD9">
			<x path="Int"/>
			<meta><m n=":value"><e>0x8CD9</e></m></meta>
		</FRAMEBUFFER_INCOMPLETE_DIMENSIONS>
		<FRAMEBUFFER_UNSUPPORTED public="1" expr="0x8CDD">
			<x path="Int"/>
			<meta><m n=":value"><e>0x8CDD</e></m></meta>
		</FRAMEBUFFER_UNSUPPORTED>
		<FRAMEBUFFER_BINDING public="1" expr="0x8CA6">
			<x path="Int"/>
			<meta><m n=":value"><e>0x8CA6</e></m></meta>
		</FRAMEBUFFER_BINDING>
		<RENDERBUFFER_BINDING public="1" expr="0x8CA7">
			<x path="Int"/>
			<meta><m n=":value"><e>0x8CA7</e></m></meta>
		</RENDERBUFFER_BINDING>
		<MAX_RENDERBUFFER_SIZE public="1" expr="0x84E8">
			<x path="Int"/>
			<meta><m n=":value"><e>0x84E8</e></m></meta>
		</MAX_RENDERBUFFER_SIZE>
		<INVALID_FRAMEBUFFER_OPERATION public="1" expr="0x0506">
			<x path="Int"/>
			<meta><m n=":value"><e>0x0506</e></m></meta>
		</INVALID_FRAMEBUFFER_OPERATION>
		<UNPACK_FLIP_Y_WEBGL public="1" expr="0x9240">
			<x path="Int"/>
			<meta><m n=":value"><e>0x9240</e></m></meta>
		</UNPACK_FLIP_Y_WEBGL>
		<UNPACK_PREMULTIPLY_ALPHA_WEBGL public="1" expr="0x9241">
			<x path="Int"/>
			<meta><m n=":value"><e>0x9241</e></m></meta>
		</UNPACK_PREMULTIPLY_ALPHA_WEBGL>
		<CONTEXT_LOST_WEBGL public="1" expr="0x9242">
			<x path="Int"/>
			<meta><m n=":value"><e>0x9242</e></m></meta>
		</CONTEXT_LOST_WEBGL>
		<UNPACK_COLORSPACE_CONVERSION_WEBGL public="1" expr="0x9243">
			<x path="Int"/>
			<meta><m n=":value"><e>0x9243</e></m></meta>
		</UNPACK_COLORSPACE_CONVERSION_WEBGL>
		<BROWSER_DEFAULT_WEBGL public="1" expr="0x9244">
			<x path="Int"/>
			<meta><m n=":value"><e>0x9244</e></m></meta>
		</BROWSER_DEFAULT_WEBGL>
		<version public="1" get="accessor" set="null"><x path="Int"/></version>
		<activeTexture public="1" get="inline" set="null" line="373"><f a="texture">
	<x path="Int"/>
	<x path="Void"/>
</f></activeTexture>
		<attachShader public="1" get="inline" set="null" line="380"><f a="program:shader">
	<c path="lime.graphics.opengl.GLProgram"/>
	<c path="lime.graphics.opengl.GLShader"/>
	<x path="Void"/>
</f></attachShader>
		<bindAttribLocation public="1" get="inline" set="null" line="387"><f a="program:index:name">
	<c path="lime.graphics.opengl.GLProgram"/>
	<x path="Int"/>
	<c path="String"/>
	<x path="Void"/>
</f></bindAttribLocation>
		<bindBuffer public="1" get="inline" set="null" line="394"><f a="target:buffer">
	<x path="Int"/>
	<c path="lime.graphics.opengl.GLBuffer"/>
	<x path="Void"/>
</f></bindBuffer>
		<bindFramebuffer public="1" get="inline" set="null" line="401"><f a="target:framebuffer">
	<x path="Int"/>
	<c path="lime.graphics.opengl.GLFramebuffer"/>
	<x path="Void"/>
</f></bindFramebuffer>
		<bindRenderbuffer public="1" get="inline" set="null" line="408"><f a="target:renderbuffer">
	<x path="Int"/>
	<c path="lime.graphics.opengl.GLRenderbuffer"/>
	<x path="Void"/>
</f></bindRenderbuffer>
		<bindTexture public="1" get="inline" set="null" line="415"><f a="target:texture">
	<x path="Int"/>
	<c path="lime.graphics.opengl.GLTexture"/>
	<x path="Void"/>
</f></bindTexture>
		<blendColor public="1" get="inline" set="null" line="422"><f a="red:green:blue:alpha">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></blendColor>
		<blendEquation public="1" get="inline" set="null" line="429"><f a="mode">
	<x path="Int"/>
	<x path="Void"/>
</f></blendEquation>
		<blendEquationSeparate public="1" get="inline" set="null" line="436"><f a="modeRGB:modeAlpha">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></blendEquationSeparate>
		<blendFunc public="1" get="inline" set="null" line="443"><f a="sfactor:dfactor">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></blendFunc>
		<blendFuncSeparate public="1" get="inline" set="null" line="450"><f a="srcRGB:dstRGB:srcAlpha:dstAlpha">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></blendFuncSeparate>
		<bufferData public="1" get="inline" set="null" line="457"><f a="target:data:usage">
	<x path="Int"/>
	<c path="lime.utils.ArrayBufferView"/>
	<x path="Int"/>
	<x path="Void"/>
</f></bufferData>
		<bufferSubData public="1" get="inline" set="null" line="464"><f a="target:offset:data">
	<x path="Int"/>
	<x path="Int"/>
	<c path="lime.utils.ArrayBufferView"/>
	<x path="Void"/>
</f></bufferSubData>
		<checkFramebufferStatus public="1" get="inline" set="null" line="471"><f a="target">
	<x path="Int"/>
	<x path="Int"/>
</f></checkFramebufferStatus>
		<clear public="1" get="inline" set="null" line="478"><f a="mask">
	<x path="Int"/>
	<x path="Void"/>
</f></clear>
		<clearColor public="1" get="inline" set="null" line="485"><f a="red:green:blue:alpha">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></clearColor>
		<clearDepth public="1" get="inline" set="null" line="492"><f a="depth">
	<x path="Float"/>
	<x path="Void"/>
</f></clearDepth>
		<clearStencil public="1" get="inline" set="null" line="499"><f a="s">
	<x path="Int"/>
	<x path="Void"/>
</f></clearStencil>
		<colorMask public="1" get="inline" set="null" line="506"><f a="red:green:blue:alpha">
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></colorMask>
		<compileShader public="1" get="inline" set="null" line="513"><f a="shader">
	<c path="lime.graphics.opengl.GLShader"/>
	<x path="Void"/>
</f></compileShader>
		<compressedTexImage2D public="1" get="inline" set="null" line="520"><f a="target:level:internalformat:width:height:border:data">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<c path="lime.utils.ArrayBufferView"/>
	<x path="Void"/>
</f></compressedTexImage2D>
		<compressedTexSubImage2D public="1" get="inline" set="null" line="527"><f a="target:level:xoffset:yoffset:width:height:format:data">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<c path="lime.utils.ArrayBufferView"/>
	<x path="Void"/>
</f></compressedTexSubImage2D>
		<copyTexImage2D public="1" get="inline" set="null" line="534"><f a="target:level:internalformat:x:y:width:height:border">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></copyTexImage2D>
		<copyTexSubImage2D public="1" get="inline" set="null" line="541"><f a="target:level:xoffset:yoffset:x:y:width:height">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></copyTexSubImage2D>
		<createBuffer public="1" get="inline" set="null" line="548"><f a=""><c path="lime.graphics.opengl.GLBuffer"/></f></createBuffer>
		<createFramebuffer public="1" get="inline" set="null" line="555"><f a=""><c path="lime.graphics.opengl.GLFramebuffer"/></f></createFramebuffer>
		<createProgram public="1" get="inline" set="null" line="562"><f a=""><c path="lime.graphics.opengl.GLProgram"/></f></createProgram>
		<createRenderbuffer public="1" get="inline" set="null" line="569"><f a=""><c path="lime.graphics.opengl.GLRenderbuffer"/></f></createRenderbuffer>
		<createShader public="1" get="inline" set="null" line="576"><f a="type">
	<x path="Int"/>
	<c path="lime.graphics.opengl.GLShader"/>
</f></createShader>
		<createTexture public="1" get="inline" set="null" line="583"><f a=""><c path="lime.graphics.opengl.GLTexture"/></f></createTexture>
		<cullFace public="1" get="inline" set="null" line="590"><f a="mode">
	<x path="Int"/>
	<x path="Void"/>
</f></cullFace>
		<deleteBuffer public="1" get="inline" set="null" line="597"><f a="buffer">
	<c path="lime.graphics.opengl.GLBuffer"/>
	<x path="Void"/>
</f></deleteBuffer>
		<deleteFramebuffer public="1" get="inline" set="null" line="604"><f a="framebuffer">
	<c path="lime.graphics.opengl.GLFramebuffer"/>
	<x path="Void"/>
</f></deleteFramebuffer>
		<deleteProgram public="1" get="inline" set="null" line="611"><f a="program">
	<c path="lime.graphics.opengl.GLProgram"/>
	<x path="Void"/>
</f></deleteProgram>
		<deleteRenderbuffer public="1" get="inline" set="null" line="618"><f a="renderbuffer">
	<c path="lime.graphics.opengl.GLRenderbuffer"/>
	<x path="Void"/>
</f></deleteRenderbuffer>
		<deleteShader public="1" get="inline" set="null" line="625"><f a="shader">
	<c path="lime.graphics.opengl.GLShader"/>
	<x path="Void"/>
</f></deleteShader>
		<deleteTexture public="1" get="inline" set="null" line="632"><f a="texture">
	<c path="lime.graphics.opengl.GLTexture"/>
	<x path="Void"/>
</f></deleteTexture>
		<depthFunc public="1" get="inline" set="null" line="639"><f a="func">
	<x path="Int"/>
	<x path="Void"/>
</f></depthFunc>
		<depthMask public="1" get="inline" set="null" line="646"><f a="flag">
	<x path="Bool"/>
	<x path="Void"/>
</f></depthMask>
		<depthRange public="1" get="inline" set="null" line="653"><f a="zNear:zFar">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></depthRange>
		<detachShader public="1" get="inline" set="null" line="660"><f a="program:shader">
	<c path="lime.graphics.opengl.GLProgram"/>
	<c path="lime.graphics.opengl.GLShader"/>
	<x path="Void"/>
</f></detachShader>
		<disable public="1" get="inline" set="null" line="667"><f a="cap">
	<x path="Int"/>
	<x path="Void"/>
</f></disable>
		<disableVertexAttribArray public="1" get="inline" set="null" line="674"><f a="index">
	<x path="Int"/>
	<x path="Void"/>
</f></disableVertexAttribArray>
		<drawArrays public="1" get="inline" set="null" line="681"><f a="mode:first:count">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></drawArrays>
		<drawElements public="1" get="inline" set="null" line="688"><f a="mode:count:type:offset">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></drawElements>
		<enable public="1" get="inline" set="null" line="695"><f a="cap">
	<x path="Int"/>
	<x path="Void"/>
</f></enable>
		<enableVertexAttribArray public="1" get="inline" set="null" line="702"><f a="index">
	<x path="Int"/>
	<x path="Void"/>
</f></enableVertexAttribArray>
		<finish public="1" get="inline" set="null" line="709"><f a=""><x path="Void"/></f></finish>
		<flush public="1" get="inline" set="null" line="716"><f a=""><x path="Void"/></f></flush>
		<framebufferRenderbuffer public="1" get="inline" set="null" line="723"><f a="target:attachment:renderbuffertarget:renderbuffer">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<c path="lime.graphics.opengl.GLRenderbuffer"/>
	<x path="Void"/>
</f></framebufferRenderbuffer>
		<framebufferTexture2D public="1" get="inline" set="null" line="730"><f a="target:attachment:textarget:texture:level">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<c path="lime.graphics.opengl.GLTexture"/>
	<x path="Int"/>
	<x path="Void"/>
</f></framebufferTexture2D>
		<frontFace public="1" get="inline" set="null" line="737"><f a="mode">
	<x path="Int"/>
	<x path="Void"/>
</f></frontFace>
		<generateMipmap public="1" get="inline" set="null" line="744"><f a="target">
	<x path="Int"/>
	<x path="Void"/>
</f></generateMipmap>
		<getActiveAttrib public="1" get="inline" set="null" line="751"><f a="program:index">
	<c path="lime.graphics.opengl.GLProgram"/>
	<x path="Int"/>
	<t path="lime.graphics.opengl.GLActiveInfo"/>
</f></getActiveAttrib>
		<getActiveUniform public="1" get="inline" set="null" line="758"><f a="program:index">
	<c path="lime.graphics.opengl.GLProgram"/>
	<x path="Int"/>
	<t path="lime.graphics.opengl.GLActiveInfo"/>
</f></getActiveUniform>
		<getAttachedShaders public="1" get="inline" set="null" line="765"><f a="program">
	<c path="lime.graphics.opengl.GLProgram"/>
	<c path="Array"><c path="lime.graphics.opengl.GLShader"/></c>
</f></getAttachedShaders>
		<getAttribLocation public="1" get="inline" set="null" line="772"><f a="program:name">
	<c path="lime.graphics.opengl.GLProgram"/>
	<c path="String"/>
	<x path="Int"/>
</f></getAttribLocation>
		<getBufferParameter public="1" get="inline" set="null" line="779"><f a="target:pname">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></getBufferParameter>
		<getContextAttributes public="1" get="inline" set="null" line="786"><f a=""><t path="lime.graphics.opengl.GLContextAttributes"/></f></getContextAttributes>
		<getError public="1" get="inline" set="null" line="793"><f a=""><x path="Int"/></f></getError>
		<getExtension public="1" get="inline" set="null" line="800"><f a="name">
	<c path="String"/>
	<d/>
</f></getExtension>
		<getFramebufferAttachmentParameter public="1" get="inline" set="null" line="807"><f a="target:attachment:pname">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></getFramebufferAttachmentParameter>
		<getParameter public="1" get="inline" set="null" line="814"><f a="pname">
	<x path="Int"/>
	<d/>
</f></getParameter>
		<getProgramInfoLog public="1" get="inline" set="null" line="821"><f a="program">
	<c path="lime.graphics.opengl.GLProgram"/>
	<c path="String"/>
</f></getProgramInfoLog>
		<getProgramParameter public="1" get="inline" set="null" line="828"><f a="program:pname">
	<c path="lime.graphics.opengl.GLProgram"/>
	<x path="Int"/>
	<x path="Int"/>
</f></getProgramParameter>
		<getRenderbufferParameter public="1" get="inline" set="null" line="835"><f a="target:pname">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></getRenderbufferParameter>
		<getShaderInfoLog public="1" get="inline" set="null" line="842"><f a="shader">
	<c path="lime.graphics.opengl.GLShader"/>
	<c path="String"/>
</f></getShaderInfoLog>
		<getShaderParameter public="1" get="inline" set="null" line="849"><f a="shader:pname">
	<c path="lime.graphics.opengl.GLShader"/>
	<x path="Int"/>
	<x path="Int"/>
</f></getShaderParameter>
		<getShaderPrecisionFormat public="1" get="inline" set="null" line="856"><f a="shadertype:precisiontype">
	<x path="Int"/>
	<x path="Int"/>
	<t path="lime.graphics.opengl.GLShaderPrecisionFormat"/>
</f></getShaderPrecisionFormat>
		<getShaderSource public="1" get="inline" set="null" line="863"><f a="shader">
	<c path="lime.graphics.opengl.GLShader"/>
	<c path="String"/>
</f></getShaderSource>
		<getSupportedExtensions public="1" get="inline" set="null" line="870"><f a=""><c path="Array"><c path="String"/></c></f></getSupportedExtensions>
		<getTexParameter public="1" get="inline" set="null" line="877"><f a="target:pname">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></getTexParameter>
		<getUniform public="1" get="inline" set="null" line="884"><f a="program:location">
	<c path="lime.graphics.opengl.GLProgram"/>
	<t path="lime.graphics.opengl.GLUniformLocation"/>
	<d/>
</f></getUniform>
		<getUniformLocation public="1" get="inline" set="null" line="891"><f a="program:name">
	<c path="lime.graphics.opengl.GLProgram"/>
	<c path="String"/>
	<t path="lime.graphics.opengl.GLUniformLocation"/>
</f></getUniformLocation>
		<getVertexAttrib public="1" get="inline" set="null" line="898"><f a="index:pname">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></getVertexAttrib>
		<getVertexAttribOffset public="1" get="inline" set="null" line="905"><f a="index:pname">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></getVertexAttribOffset>
		<hint public="1" get="inline" set="null" line="912"><f a="target:mode">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></hint>
		<isBuffer public="1" get="inline" set="null" line="919"><f a="buffer">
	<c path="lime.graphics.opengl.GLBuffer"/>
	<x path="Bool"/>
</f></isBuffer>
		<isContextLost public="1" get="inline" set="null" line="926"><f a=""><x path="Bool"/></f></isContextLost>
		<isEnabled public="1" get="inline" set="null" line="933"><f a="cap">
	<x path="Int"/>
	<x path="Bool"/>
</f></isEnabled>
		<isFramebuffer public="1" get="inline" set="null" line="940"><f a="framebuffer">
	<c path="lime.graphics.opengl.GLFramebuffer"/>
	<x path="Bool"/>
</f></isFramebuffer>
		<isProgram public="1" get="inline" set="null" line="947"><f a="program">
	<c path="lime.graphics.opengl.GLProgram"/>
	<x path="Bool"/>
</f></isProgram>
		<isRenderbuffer public="1" get="inline" set="null" line="954"><f a="renderbuffer">
	<c path="lime.graphics.opengl.GLRenderbuffer"/>
	<x path="Bool"/>
</f></isRenderbuffer>
		<isShader public="1" get="inline" set="null" line="961"><f a="shader">
	<c path="lime.graphics.opengl.GLShader"/>
	<x path="Bool"/>
</f></isShader>
		<isTexture public="1" get="inline" set="null" line="968"><f a="texture">
	<c path="lime.graphics.opengl.GLTexture"/>
	<x path="Bool"/>
</f></isTexture>
		<lineWidth public="1" get="inline" set="null" line="975"><f a="width">
	<x path="Float"/>
	<x path="Void"/>
</f></lineWidth>
		<linkProgram public="1" get="inline" set="null" line="982"><f a="program">
	<c path="lime.graphics.opengl.GLProgram"/>
	<x path="Void"/>
</f></linkProgram>
		<pixelStorei public="1" get="inline" set="null" line="989"><f a="pname:param">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></pixelStorei>
		<polygonOffset public="1" get="inline" set="null" line="996"><f a="factor:units">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></polygonOffset>
		<readPixels public="1" get="inline" set="null" line="1003"><f a="x:y:width:height:format:type:pixels">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<c path="lime.utils.ArrayBufferView"/>
	<x path="Void"/>
</f></readPixels>
		<renderbufferStorage public="1" get="inline" set="null" line="1010"><f a="target:internalformat:width:height">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></renderbufferStorage>
		<sampleCoverage public="1" get="inline" set="null" line="1017"><f a="value:invert">
	<x path="Float"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></sampleCoverage>
		<scissor public="1" get="inline" set="null" line="1024"><f a="x:y:width:height">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></scissor>
		<shaderSource public="1" get="inline" set="null" line="1031"><f a="shader:source">
	<c path="lime.graphics.opengl.GLShader"/>
	<c path="String"/>
	<x path="Void"/>
</f></shaderSource>
		<stencilFunc public="1" get="inline" set="null" line="1038"><f a="func:ref:mask">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></stencilFunc>
		<stencilFuncSeparate public="1" get="inline" set="null" line="1045"><f a="face:func:ref:mask">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></stencilFuncSeparate>
		<stencilMask public="1" get="inline" set="null" line="1052"><f a="mask">
	<x path="Int"/>
	<x path="Void"/>
</f></stencilMask>
		<stencilMaskSeparate public="1" get="inline" set="null" line="1059"><f a="face:mask">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></stencilMaskSeparate>
		<stencilOp public="1" get="inline" set="null" line="1066"><f a="fail:zfail:zpass">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></stencilOp>
		<stencilOpSeparate public="1" get="inline" set="null" line="1073"><f a="face:fail:zfail:zpass">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></stencilOpSeparate>
		<texImage2D public="1" get="inline" set="null" line="1080"><f a="target:level:internalformat:width:height:border:format:type:pixels">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<c path="lime.utils.ArrayBufferView"/>
	<x path="Void"/>
</f></texImage2D>
		<texParameterf public="1" get="inline" set="null" line="1087"><f a="target:pname:param">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Float"/>
	<x path="Void"/>
</f></texParameterf>
		<texParameteri public="1" get="inline" set="null" line="1094"><f a="target:pname:param">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></texParameteri>
		<texSubImage2D public="1" get="inline" set="null" line="1101"><f a="target:level:xoffset:yoffset:width:height:format:type:pixels">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<c path="lime.utils.ArrayBufferView"/>
	<x path="Void"/>
</f></texSubImage2D>
		<uniform1f public="1" get="inline" set="null" line="1108"><f a="location:x">
	<t path="lime.graphics.opengl.GLUniformLocation"/>
	<x path="Float"/>
	<x path="Void"/>
</f></uniform1f>
		<uniform1fv public="1" get="inline" set="null" line="1115"><f a="location:x">
	<t path="lime.graphics.opengl.GLUniformLocation"/>
	<x path="lime.utils.Float32Array"/>
	<x path="Void"/>
</f></uniform1fv>
		<uniform1i public="1" get="inline" set="null" line="1122"><f a="location:x">
	<t path="lime.graphics.opengl.GLUniformLocation"/>
	<x path="Int"/>
	<x path="Void"/>
</f></uniform1i>
		<uniform1iv public="1" get="inline" set="null" line="1129"><f a="location:v">
	<t path="lime.graphics.opengl.GLUniformLocation"/>
	<x path="lime.utils.Int32Array"/>
	<x path="Void"/>
</f></uniform1iv>
		<uniform2f public="1" get="inline" set="null" line="1136"><f a="location:x:y">
	<t path="lime.graphics.opengl.GLUniformLocation"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></uniform2f>
		<uniform2fv public="1" get="inline" set="null" line="1143"><f a="location:v">
	<t path="lime.graphics.opengl.GLUniformLocation"/>
	<x path="lime.utils.Float32Array"/>
	<x path="Void"/>
</f></uniform2fv>
		<uniform2i public="1" get="inline" set="null" line="1150"><f a="location:x:y">
	<t path="lime.graphics.opengl.GLUniformLocation"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></uniform2i>
		<uniform2iv public="1" get="inline" set="null" line="1157"><f a="location:v">
	<t path="lime.graphics.opengl.GLUniformLocation"/>
	<x path="lime.utils.Int32Array"/>
	<x path="Void"/>
</f></uniform2iv>
		<uniform3f public="1" get="inline" set="null" line="1164"><f a="location:x:y:z">
	<t path="lime.graphics.opengl.GLUniformLocation"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></uniform3f>
		<uniform3fv public="1" get="inline" set="null" line="1171"><f a="location:v">
	<t path="lime.graphics.opengl.GLUniformLocation"/>
	<x path="lime.utils.Float32Array"/>
	<x path="Void"/>
</f></uniform3fv>
		<uniform3i public="1" get="inline" set="null" line="1178"><f a="location:x:y:z">
	<t path="lime.graphics.opengl.GLUniformLocation"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></uniform3i>
		<uniform3iv public="1" get="inline" set="null" line="1185"><f a="location:v">
	<t path="lime.graphics.opengl.GLUniformLocation"/>
	<x path="lime.utils.Int32Array"/>
	<x path="Void"/>
</f></uniform3iv>
		<uniform4f public="1" get="inline" set="null" line="1192"><f a="location:x:y:z:w">
	<t path="lime.graphics.opengl.GLUniformLocation"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></uniform4f>
		<uniform4fv public="1" get="inline" set="null" line="1199"><f a="location:v">
	<t path="lime.graphics.opengl.GLUniformLocation"/>
	<x path="lime.utils.Float32Array"/>
	<x path="Void"/>
</f></uniform4fv>
		<uniform4i public="1" get="inline" set="null" line="1206"><f a="location:x:y:z:w">
	<t path="lime.graphics.opengl.GLUniformLocation"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></uniform4i>
		<uniform4iv public="1" get="inline" set="null" line="1213"><f a="location:v">
	<t path="lime.graphics.opengl.GLUniformLocation"/>
	<x path="lime.utils.Int32Array"/>
	<x path="Void"/>
</f></uniform4iv>
		<uniformMatrix2fv public="1" get="inline" set="null" line="1220"><f a="location:transpose:v">
	<t path="lime.graphics.opengl.GLUniformLocation"/>
	<x path="Bool"/>
	<x path="lime.utils.Float32Array"/>
	<x path="Void"/>
</f></uniformMatrix2fv>
		<uniformMatrix3fv public="1" get="inline" set="null" line="1227"><f a="location:transpose:v">
	<t path="lime.graphics.opengl.GLUniformLocation"/>
	<x path="Bool"/>
	<x path="lime.utils.Float32Array"/>
	<x path="Void"/>
</f></uniformMatrix3fv>
		<uniformMatrix4fv public="1" get="inline" set="null" line="1234"><f a="location:transpose:v">
	<t path="lime.graphics.opengl.GLUniformLocation"/>
	<x path="Bool"/>
	<x path="lime.utils.Float32Array"/>
	<x path="Void"/>
</f></uniformMatrix4fv>
		<useProgram public="1" get="inline" set="null" line="1248"><f a="program">
	<c path="lime.graphics.opengl.GLProgram"/>
	<x path="Void"/>
</f></useProgram>
		<validateProgram public="1" get="inline" set="null" line="1255"><f a="program">
	<c path="lime.graphics.opengl.GLProgram"/>
	<x path="Void"/>
</f></validateProgram>
		<vertexAttrib1f public="1" get="inline" set="null" line="1262"><f a="indx:x">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Void"/>
</f></vertexAttrib1f>
		<vertexAttrib1fv public="1" get="inline" set="null" line="1269"><f a="indx:values">
	<x path="Int"/>
	<x path="lime.utils.Float32Array"/>
	<x path="Void"/>
</f></vertexAttrib1fv>
		<vertexAttrib2f public="1" get="inline" set="null" line="1276"><f a="indx:x:y">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></vertexAttrib2f>
		<vertexAttrib2fv public="1" get="inline" set="null" line="1283"><f a="indx:values">
	<x path="Int"/>
	<x path="lime.utils.Float32Array"/>
	<x path="Void"/>
</f></vertexAttrib2fv>
		<vertexAttrib3f public="1" get="inline" set="null" line="1290"><f a="indx:x:y:z">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></vertexAttrib3f>
		<vertexAttrib3fv public="1" get="inline" set="null" line="1297"><f a="indx:values">
	<x path="Int"/>
	<x path="lime.utils.Float32Array"/>
	<x path="Void"/>
</f></vertexAttrib3fv>
		<vertexAttrib4f public="1" get="inline" set="null" line="1304"><f a="indx:x:y:z:w">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></vertexAttrib4f>
		<vertexAttrib4fv public="1" get="inline" set="null" line="1311"><f a="indx:values">
	<x path="Int"/>
	<x path="lime.utils.Float32Array"/>
	<x path="Void"/>
</f></vertexAttrib4fv>
		<vertexAttribPointer public="1" get="inline" set="null" line="1318"><f a="indx:size:type:normalized:stride:offset">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Bool"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></vertexAttribPointer>
		<viewport public="1" get="inline" set="null" line="1325"><f a="x:y:width:height">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></viewport>
		<get_version set="method" line="1332"><f a=""><x path="Int"/></f></get_version>
		<new public="1" set="method" line="366"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="lime.graphics.Image" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/graphics/Image.hx">
		<__base64Chars expr="&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;" line="67" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"</e></m></meta>
		</__base64Chars>
		<__base64Encoder static="1"><c path="haxe.crypto.BaseCode"/></__base64Encoder>
		<fromBase64 public="1" set="method" line="452" static="1"><f a="base64:type:onload">
	<c path="String"/>
	<c path="String"/>
	<f a="">
		<c path="lime.graphics.Image"/>
		<x path="Void"/>
	</f>
	<c path="lime.graphics.Image"/>
</f></fromBase64>
		<fromBitmapData public="1" set="method" line="465" static="1"><f a="bitmapData">
	<d/>
	<c path="lime.graphics.Image"/>
</f></fromBitmapData>
		<fromBytes public="1" set="method" line="480" static="1">
			<f a="bytes:?onload" v=":null">
				<c path="haxe.io.Bytes"/>
				<f a="">
					<c path="lime.graphics.Image"/>
					<x path="Void"/>
				</f>
				<c path="lime.graphics.Image"/>
			</f>
			<meta><m n=":value"><e>{ onload : null }</e></m></meta>
		</fromBytes>
		<fromCanvas public="1" set="method" line="493" static="1"><f a="canvas">
	<d/>
	<c path="lime.graphics.Image"/>
</f></fromCanvas>
		<fromFile public="1" set="method" line="504" static="1">
			<f a="path:?onload:?onerror" v=":null:null">
				<c path="String"/>
				<f a="">
					<c path="lime.graphics.Image"/>
					<x path="Void"/>
				</f>
				<f a=""><x path="Void"/></f>
				<c path="lime.graphics.Image"/>
			</f>
			<meta><m n=":value"><e>{ onerror : null, onload : null }</e></m></meta>
		</fromFile>
		<fromImageElement public="1" set="method" line="516" static="1"><f a="image">
	<d/>
	<c path="lime.graphics.Image"/>
</f></fromImageElement>
		<__base64Encode set="method" line="1011" static="1"><f a="bytes">
	<c path="haxe.io.Bytes"/>
	<c path="String"/>
</f></__base64Encode>
		<__isJPG set="method" line="1362" static="1"><f a="bytes">
	<c path="haxe.io.Bytes"/>
	<x path="Bool"/>
</f></__isJPG>
		<__isPNG set="method" line="1369" static="1"><f a="bytes">
	<c path="haxe.io.Bytes"/>
	<x path="Bool"/>
</f></__isPNG>
		<__isGIF set="method" line="1375" static="1"><f a="bytes">
	<c path="haxe.io.Bytes"/>
	<x path="Bool"/>
</f></__isGIF>
		<lime_image_load get="inline" set="null" line="1618" static="1">
			<f a="data">
				<d/>
				<d/>
			</f>
			<meta><m n=":cffi"/></meta>
		</lime_image_load>
		<cffi_lime_image_load expr="new cpp.Callable&lt;Dynamic&gt;(lime.system.CFFI.load(&quot;lime&quot;, &quot;lime_image_load&quot;, 1, false))" line="1618" static="1">
			<x path="cpp.Callable"><f a="">
	<d/>
	<d/>
</f></x>
			<meta><m n=":value"><e><![CDATA[new cpp.Callable<Dynamic>(lime.system.CFFI.load("lime", "lime_image_load", 1, false))]]></e></m></meta>
		</cffi_lime_image_load>
		<buffer public="1"><c path="lime.graphics.ImageBuffer"/></buffer>
		<data public="1" get="accessor" set="accessor"><x path="lime.utils.UInt8Array"/></data>
		<dirty public="1"><x path="Bool"/></dirty>
		<format public="1" get="accessor" set="accessor"><x path="lime.graphics.PixelFormat"/></format>
		<height public="1"><x path="Int"/></height>
		<offsetX public="1"><x path="Int"/></offsetX>
		<offsetY public="1"><x path="Int"/></offsetY>
		<powerOfTwo public="1" get="accessor" set="accessor"><x path="Bool"/></powerOfTwo>
		<premultiplied public="1" get="accessor" set="accessor"><x path="Bool"/></premultiplied>
		<rect public="1" get="accessor" set="null"><c path="lime.math.Rectangle"/></rect>
		<src public="1" get="accessor" set="accessor"><d/></src>
		<transparent public="1" get="accessor" set="accessor"><x path="Bool"/></transparent>
		<type public="1"><e path="lime.graphics.ImageType"/></type>
		<width public="1"><x path="Int"/></width>
		<x public="1"><x path="Float"/></x>
		<y public="1"><x path="Float"/></y>
		<clone public="1" set="method" line="168"><f a=""><c path="lime.graphics.Image"/></f></clone>
		<colorTransform public="1" set="method" line="192"><f a="rect:colorMatrix">
	<c path="lime.math.Rectangle"/>
	<x path="lime.math.ColorMatrix"/>
	<x path="Void"/>
</f></colorTransform>
		<copyChannel public="1" set="method" line="223"><f a="sourceImage:sourceRect:destPoint:sourceChannel:destChannel">
	<c path="lime.graphics.Image"/>
	<c path="lime.math.Rectangle"/>
	<c path="lime.math.Vector2"/>
	<e path="lime.graphics.ImageChannel"/>
	<e path="lime.graphics.ImageChannel"/>
	<x path="Void"/>
</f></copyChannel>
		<copyPixels public="1" set="method" line="275">
			<f a="sourceImage:sourceRect:destPoint:?alphaImage:?alphaPoint:?mergeAlpha" v=":::null:null:false">
				<c path="lime.graphics.Image"/>
				<c path="lime.math.Rectangle"/>
				<c path="lime.math.Vector2"/>
				<c path="lime.graphics.Image"/>
				<c path="lime.math.Vector2"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ mergeAlpha : false, alphaPoint : null, alphaImage : null }</e></m></meta>
		</copyPixels>
		<encode public="1" set="method" line="348">
			<f a="?format:?quality" v="&quot;png&quot;:90">
				<c path="String"/>
				<x path="Int"/>
				<c path="haxe.io.Bytes"/>
			</f>
			<meta><m n=":value"><e>{ quality : 90, format : "png" }</e></m></meta>
		</encode>
		<fillRect public="1" set="method" line="373">
			<f a="rect:color:?format" v="::null">
				<c path="lime.math.Rectangle"/>
				<x path="Int"/>
				<x path="lime.graphics.PixelFormat"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ format : null }</e></m></meta>
		</fillRect>
		<floodFill public="1" set="method" line="415">
			<f a="x:y:color:?format" v=":::null">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="lime.graphics.PixelFormat"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ format : null }</e></m></meta>
		</floodFill>
		<getColorBoundsRect public="1" set="method" line="526">
			<f a="mask:color:?findColor:?format" v="::true:null">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="lime.graphics.PixelFormat"/>
				<c path="lime.math.Rectangle"/>
			</f>
			<meta><m n=":value"><e>{ format : null, findColor : true }</e></m></meta>
		</getColorBoundsRect>
		<getPixel public="1" set="method" line="556">
			<f a="x:y:?format" v="::null">
				<x path="Int"/>
				<x path="Int"/>
				<x path="lime.graphics.PixelFormat"/>
				<x path="Int"/>
			</f>
			<meta><m n=":value"><e>{ format : null }</e></m></meta>
		</getPixel>
		<getPixel32 public="1" set="method" line="595">
			<f a="x:y:?format" v="::null">
				<x path="Int"/>
				<x path="Int"/>
				<x path="lime.graphics.PixelFormat"/>
				<x path="Int"/>
			</f>
			<meta><m n=":value"><e>{ format : null }</e></m></meta>
		</getPixel32>
		<getPixels public="1" set="method" line="634">
			<f a="rect:?format" v=":null">
				<c path="lime.math.Rectangle"/>
				<x path="lime.graphics.PixelFormat"/>
				<c path="haxe.io.Bytes"/>
			</f>
			<meta><m n=":value"><e>{ format : null }</e></m></meta>
		</getPixels>
		<merge public="1" set="method" line="707"><f a="sourceImage:sourceRect:destPoint:redMultiplier:greenMultiplier:blueMultiplier:alphaMultiplier">
	<c path="lime.graphics.Image"/>
	<c path="lime.math.Rectangle"/>
	<c path="lime.math.Vector2"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></merge>
		<resize public="1" set="method" line="741"><f a="newWidth:newHeight">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></resize>
		<scroll public="1" set="method" line="778"><f a="x:y">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></scroll>
		<setPixel public="1" set="method" line="809">
			<f a="x:y:color:?format" v=":::null">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="lime.graphics.PixelFormat"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ format : null }</e></m></meta>
		</setPixel>
		<setPixel32 public="1" set="method" line="846">
			<f a="x:y:color:?format" v=":::null">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="lime.graphics.PixelFormat"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ format : null }</e></m></meta>
		</setPixel32>
		<setPixels public="1" set="method" line="883">
			<f a="rect:bytes:?format" v="::null">
				<c path="lime.math.Rectangle"/>
				<c path="haxe.io.Bytes"/>
				<x path="lime.graphics.PixelFormat"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ format : null }</e></m></meta>
		</setPixels>
		<threshold public="1" set="method" line="965">
			<f a="sourceImage:sourceRect:destPoint:operation:threshold:?color:?mask:?copySource:?format" v=":::::0x00000000:0xFFFFFFFF:false:null">
				<c path="lime.graphics.Image"/>
				<c path="lime.math.Rectangle"/>
				<c path="lime.math.Vector2"/>
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="lime.graphics.PixelFormat"/>
				<x path="Int"/>
			</f>
			<meta><m n=":value"><e>{ format : null, copySource : false, mask : 0xFFFFFFFF, color : 0x00000000 }</e></m></meta>
		</threshold>
		<__clipRect set="method" line="1040"><f a="r">
	<c path="lime.math.Rectangle"/>
	<c path="lime.math.Rectangle"/>
</f></__clipRect>
		<__fromBase64 set="method" line="1083">
			<f a="base64:type:?onload" v="::null">
				<c path="String"/>
				<c path="String"/>
				<f a="">
					<c path="lime.graphics.Image"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ onload : null }</e></m></meta>
		</__fromBase64>
		<__fromBytes set="method" line="1114"><f a="bytes:onload">
	<c path="haxe.io.Bytes"/>
	<f a="">
		<c path="lime.graphics.Image"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></__fromBytes>
		<__fromFile set="method" line="1169"><f a="path:onload:onerror">
	<c path="String"/>
	<f a="">
		<c path="lime.graphics.Image"/>
		<x path="Void"/>
	</f>
	<f a=""><x path="Void"/></f>
	<x path="Void"/>
</f></__fromFile>
		<__fromImageBuffer set="method" line="1339"><f a="buffer">
	<c path="lime.graphics.ImageBuffer"/>
	<x path="Void"/>
</f></__fromImageBuffer>
		<get_data set="method" line="1396"><f a=""><x path="lime.utils.UInt8Array"/></f></get_data>
		<set_data set="method" line="1420"><f a="value">
	<x path="lime.utils.UInt8Array"/>
	<x path="lime.utils.UInt8Array"/>
</f></set_data>
		<get_format set="method" line="1427"><f a=""><x path="lime.graphics.PixelFormat"/></f></get_format>
		<set_format set="method" line="1434"><f a="value">
	<x path="lime.graphics.PixelFormat"/>
	<x path="lime.graphics.PixelFormat"/>
</f></set_format>
		<get_powerOfTwo set="method" line="1455"><f a=""><x path="Bool"/></f></get_powerOfTwo>
		<set_powerOfTwo set="method" line="1462"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_powerOfTwo>
		<get_premultiplied set="method" line="1512"><f a=""><x path="Bool"/></f></get_premultiplied>
		<set_premultiplied set="method" line="1519"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_premultiplied>
		<get_rect set="method" line="1564"><f a=""><c path="lime.math.Rectangle"/></f></get_rect>
		<get_src set="method" line="1571"><f a=""><d/></f></get_src>
		<set_src set="method" line="1586"><f a="value">
	<d/>
	<d/>
</f></set_src>
		<get_transparent set="method" line="1593"><f a=""><x path="Bool"/></f></get_transparent>
		<set_transparent set="method" line="1601"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_transparent>
		<new public="1" set="method" line="88">
			<f a="?buffer:?offsetX:?offsetY:?width:?height:?color:?type" v="null:0:0:-1:-1:null:null">
				<c path="lime.graphics.ImageBuffer"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<e path="lime.graphics.ImageType"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ type : null, color : null, height : -1, width : -1, offsetY : 0, offsetX : 0, buffer : null }</e></m></meta>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>lime.system.CFFI.build()</e></m>
			<m n=":autoBuild"><e>lime.Assets.embedImage()</e></m>
			<m n=":allow"><e>lime.graphics.util.ImageCanvasUtil</e></m>
			<m n=":allow"><e>lime.graphics.util.ImageDataUtil</e></m>
			<m n=":access"><e>lime.app.Application</e></m>
			<m n=":access"><e>lime.math.ColorMatrix</e></m>
			<m n=":access"><e>lime.math.Rectangle</e></m>
			<m n=":access"><e>lime.math.Vector2</e></m>
		</meta>
	</class>
	<class path="lime.graphics.ImageBuffer" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/graphics/ImageBuffer.hx">
		<bitsPerPixel public="1"><x path="Int"/></bitsPerPixel>
		<data public="1"><x path="lime.utils.UInt8Array"/></data>
		<format public="1"><x path="lime.graphics.PixelFormat"/></format>
		<height public="1"><x path="Int"/></height>
		<premultiplied public="1"><x path="Bool"/></premultiplied>
		<src public="1" get="accessor" set="accessor"><d/></src>
		<stride public="1" get="accessor" set="null"><x path="Int"/></stride>
		<transparent public="1"><x path="Bool"/></transparent>
		<width public="1"><x path="Int"/></width>
		<__srcBitmapData>
			<d/>
			<meta><m n=":noCompletion"/></meta>
		</__srcBitmapData>
		<__srcCanvas>
			<d/>
			<meta><m n=":noCompletion"/></meta>
		</__srcCanvas>
		<__srcContext>
			<d/>
			<meta><m n=":noCompletion"/></meta>
		</__srcContext>
		<__srcCustom>
			<d/>
			<meta><m n=":noCompletion"/></meta>
		</__srcCustom>
		<__srcImage>
			<d/>
			<meta><m n=":noCompletion"/></meta>
		</__srcImage>
		<__srcImageData>
			<d/>
			<meta><m n=":noCompletion"/></meta>
		</__srcImageData>
		<clone public="1" set="method" line="55"><f a=""><c path="lime.graphics.ImageBuffer"/></f></clone>
		<get_src set="method" line="126"><f a=""><d/></f></get_src>
		<set_src set="method" line="146"><f a="value">
	<d/>
	<d/>
</f></set_src>
		<get_stride set="method" line="176"><f a=""><x path="Int"/></f></get_stride>
		<new public="1" set="method" line="43">
			<f a="?data:?width:?height:?bitsPerPixel:?format" v="null:0:0:32:null">
				<x path="lime.utils.UInt8Array"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="lime.graphics.PixelFormat"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ format : null, bitsPerPixel : 32, height : 0, width : 0, data : null }</e></m></meta>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":allow"><e>lime.graphics.Image</e></m>
		</meta>
	</class>
	<enum path="lime.graphics.ImageChannel" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/graphics/ImageChannel.hx">
		<RED/>
		<GREEN/>
		<BLUE/>
		<ALPHA/>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<enum path="lime.graphics.ImageType" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/graphics/ImageType.hx">
		<CANVAS/>
		<DATA/>
		<FLASH/>
		<CUSTOM/>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<abstract path="lime.graphics.PixelFormat" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/graphics/PixelFormat.hx">
		<from>
			<icast><x path="UInt"/></icast>
			<icast><x path="Int"/></icast>
		</from>
		<this><x path="Int"/></this>
		<to>
			<icast><x path="UInt"/></icast>
			<icast><x path="Int"/></icast>
		</to>
		<meta><m n=":enum"/></meta>
		<impl><class path="lime.graphics._PixelFormat.PixelFormat_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/graphics/PixelFormat.hx" private="1" module="lime.graphics.PixelFormat" extern="1">
	<RGBA32 public="1" get="inline" set="null" expr="cast 0" line="6" static="1">
		<x path="lime.graphics.PixelFormat"/>
		<meta>
			<m n=":value"><e>cast 0</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</RGBA32>
	<ARGB32 public="1" get="inline" set="null" expr="cast 1" line="7" static="1">
		<x path="lime.graphics.PixelFormat"/>
		<meta>
			<m n=":value"><e>cast 1</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</ARGB32>
	<BGRA32 public="1" get="inline" set="null" expr="cast 2" line="8" static="1">
		<x path="lime.graphics.PixelFormat"/>
		<meta>
			<m n=":value"><e>cast 2</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</BGRA32>
	<meta>
		<m n=":final"/>
		<m n=":enum"/>
	</meta>
</class></impl>
	</abstract>
	<class path="lime.graphics._PixelFormat.PixelFormat_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/graphics/PixelFormat.hx" private="1" module="lime.graphics.PixelFormat" extern="1">
		<RGBA32 public="1" get="inline" set="null" expr="cast 0" line="6" static="1">
			<x path="lime.graphics.PixelFormat"/>
			<meta>
				<m n=":value"><e>cast 0</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</RGBA32>
		<ARGB32 public="1" get="inline" set="null" expr="cast 1" line="7" static="1">
			<x path="lime.graphics.PixelFormat"/>
			<meta>
				<m n=":value"><e>cast 1</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</ARGB32>
		<BGRA32 public="1" get="inline" set="null" expr="cast 2" line="8" static="1">
			<x path="lime.graphics.PixelFormat"/>
			<meta>
				<m n=":value"><e>cast 2</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</BGRA32>
		<meta>
			<m n=":final"/>
			<m n=":enum"/>
		</meta>
	</class>
	<enum path="lime.graphics.RenderContext" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/graphics/RenderContext.hx">
		<OPENGL a="gl"><c path="lime.graphics.GLRenderContext"/></OPENGL>
		<CANVAS a="context"><c path="lime.graphics.CanvasRenderContext"/></CANVAS>
		<DOM a="element"><c path="lime.graphics.DOMRenderContext"/></DOM>
		<FLASH a="stage"><c path="lime.graphics.FlashRenderContext"/></FLASH>
		<CAIRO a="cairo"><t path="lime.graphics.CairoRenderContext"/></CAIRO>
		<CONSOLE a="context"><c path="lime.graphics.ConsoleRenderContext"/></CONSOLE>
		<CUSTOM a="data"><d/></CUSTOM>
		<NONE/>
		<meta><m n=":directlyUsed"/></meta>
	</enum>
	<class path="lime.graphics.Renderer" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/graphics/Renderer.hx">
		<context public="1"><e path="lime.graphics.RenderContext"/></context>
		<onContextLost public="1" expr="new Event&lt;Void&gt;()">
			<c path="lime.app.Event_Void_Void"><f a=""><x path="Void"/></f></c>
			<meta><m n=":value"><e><![CDATA[new Event<Void>()]]></e></m></meta>
		</onContextLost>
		<onContextRestored public="1" expr="new Event&lt;RenderContext&gt;()">
			<c path="lime.app.Event_lime_graphics_RenderContext_Void"><f a="">
	<e path="lime.graphics.RenderContext"/>
	<x path="Void"/>
</f></c>
			<meta><m n=":value"><e><![CDATA[new Event<RenderContext>()]]></e></m></meta>
		</onContextRestored>
		<onRender public="1" expr="new Event&lt;Void&gt;()">
			<c path="lime.app.Event_Void_Void"><f a=""><x path="Void"/></f></c>
			<meta><m n=":value"><e><![CDATA[new Event<Void>()]]></e></m></meta>
		</onRender>
		<type public="1"><e path="lime.graphics.RendererType"/></type>
		<window public="1"><c path="lime.ui.Window"/></window>
		<backend>
			<t path="lime.graphics._Renderer.RendererBackend"/>
			<meta><m n=":noCompletion"/></meta>
		</backend>
		<create public="1" set="method" line="33"><f a=""><x path="Void"/></f></create>
		<flip public="1" set="method" line="40"><f a=""><x path="Void"/></f></flip>
		<readPixels public="1" set="method" line="47">
			<f a="?rect" v="null">
				<c path="lime.math.Rectangle"/>
				<c path="lime.graphics.Image"/>
			</f>
			<meta><m n=":value"><e>{ rect : null }</e></m></meta>
		</readPixels>
		<render set="method" line="54"><f a=""><x path="Void"/></f></render>
		<new public="1" set="method" line="22"><f a="window">
	<c path="lime.ui.Window"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<typedef path="lime.graphics._Renderer.RendererBackend" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/graphics/Renderer.hx" private="1" module="lime.graphics.Renderer">
		<c path="lime._backend.native.NativeRenderer"/>
		<meta><m n=":noCompletion"/></meta>
	</typedef>
	<enum path="lime.graphics.RendererType" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/graphics/RendererType.hx">
		<OPENGL/>
		<CANVAS/>
		<DOM/>
		<FLASH/>
		<CAIRO/>
		<CONSOLE/>
		<CUSTOM/>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<class path="lime.graphics.cairo.Cairo" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/graphics/cairo/Cairo.hx">
		<version public="1" get="accessor" set="null" static="1"><x path="Int"/></version>
		<versionString public="1" get="accessor" set="null" static="1"><c path="String"/></versionString>
		<get_version set="method" line="848" static="1"><f a=""><x path="Int"/></f></get_version>
		<get_versionString set="method" line="859" static="1"><f a=""><c path="String"/></f></get_versionString>
		<antialias public="1" get="accessor" set="accessor"><x path="lime.graphics.cairo.CairoAntialias"/></antialias>
		<currentPoint public="1" get="accessor" set="null"><c path="lime.math.Vector2"/></currentPoint>
		<dash public="1" get="accessor" set="accessor"><c path="Array"><x path="Float"/></c></dash>
		<dashCount public="1" get="accessor" set="null"><x path="Int"/></dashCount>
		<fillRule public="1" get="accessor" set="accessor"><x path="lime.graphics.cairo.CairoFillRule"/></fillRule>
		<fontFace public="1" get="accessor" set="accessor"><x path="lime.graphics.cairo.CairoFontFace"/></fontFace>
		<fontOptions public="1" get="accessor" set="accessor"><x path="lime.graphics.cairo.CairoFontOptions"/></fontOptions>
		<groupTarget public="1" get="accessor" set="null"><x path="lime.graphics.cairo.CairoSurface"/></groupTarget>
		<hasCurrentPoint public="1" get="accessor" set="null"><x path="Bool"/></hasCurrentPoint>
		<lineCap public="1" get="accessor" set="accessor"><x path="lime.graphics.cairo.CairoLineCap"/></lineCap>
		<lineJoin public="1" get="accessor" set="accessor"><x path="lime.graphics.cairo.CairoLineJoin"/></lineJoin>
		<lineWidth public="1" get="accessor" set="accessor"><x path="Float"/></lineWidth>
		<matrix public="1" get="accessor" set="accessor"><c path="lime.math.Matrix3"/></matrix>
		<miterLimit public="1" get="accessor" set="accessor"><x path="Float"/></miterLimit>
		<operator public="1" get="accessor" set="accessor"><x path="lime.graphics.cairo.CairoOperator"/></operator>
		<source public="1" get="accessor" set="accessor"><x path="lime.graphics.cairo.CairoPattern"/></source>
		<target public="1" get="accessor" set="null"><x path="lime.graphics.cairo.CairoSurface"/></target>
		<tolerance public="1" get="accessor" set="accessor"><x path="Float"/></tolerance>
		<userData public="1"><d/></userData>
		<handle>
			<x path="lime.system.CFFIPointer"/>
			<meta><m n=":noCompletion"/></meta>
		</handle>
		<arc public="1" set="method" line="56"><f a="xc:yc:radius:angle1:angle2">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></arc>
		<arcNegative public="1" set="method" line="65"><f a="xc:yc:radius:angle1:angle2">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></arcNegative>
		<clip public="1" set="method" line="74"><f a=""><x path="Void"/></f></clip>
		<clipExtents public="1" set="method" line="83"><f a="x1:y1:x2:y2">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></clipExtents>
		<clipPreserve public="1" set="method" line="92"><f a=""><x path="Void"/></f></clipPreserve>
		<closePath public="1" set="method" line="101"><f a=""><x path="Void"/></f></closePath>
		<copyPage public="1" set="method" line="110"><f a=""><x path="Void"/></f></copyPage>
		<curveTo public="1" set="method" line="119"><f a="x1:y1:x2:y2:x3:y3">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></curveTo>
		<fill public="1" set="method" line="128"><f a=""><x path="Void"/></f></fill>
		<fillExtents public="1" set="method" line="137"><f a="x1:y1:x2:y2">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></fillExtents>
		<fillPreserve public="1" set="method" line="146"><f a=""><x path="Void"/></f></fillPreserve>
		<identityMatrix public="1" set="method" line="155"><f a=""><x path="Void"/></f></identityMatrix>
		<inClip public="1" set="method" line="164"><f a="x:y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Bool"/>
</f></inClip>
		<inFill public="1" set="method" line="175"><f a="x:y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Bool"/>
</f></inFill>
		<inStroke public="1" set="method" line="186"><f a="x:y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Bool"/>
</f></inStroke>
		<lineTo public="1" set="method" line="197"><f a="x:y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></lineTo>
		<moveTo public="1" set="method" line="206"><f a="x:y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></moveTo>
		<mask public="1" set="method" line="215"><f a="pattern">
	<x path="lime.graphics.cairo.CairoPattern"/>
	<x path="Void"/>
</f></mask>
		<maskSurface public="1" set="method" line="224"><f a="surface:x:y">
	<x path="lime.graphics.cairo.CairoSurface"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></maskSurface>
		<newPath public="1" set="method" line="233"><f a=""><x path="Void"/></f></newPath>
		<paint public="1" set="method" line="242"><f a=""><x path="Void"/></f></paint>
		<paintWithAlpha public="1" set="method" line="251"><f a="alpha">
	<x path="Float"/>
	<x path="Void"/>
</f></paintWithAlpha>
		<popGroup public="1" set="method" line="260"><f a=""><x path="lime.graphics.cairo.CairoPattern"/></f></popGroup>
		<popGroupToSource public="1" set="method" line="271"><f a=""><x path="Void"/></f></popGroupToSource>
		<pushGroup public="1" set="method" line="280"><f a=""><x path="Void"/></f></pushGroup>
		<pushGroupWithContent public="1" set="method" line="289"><f a="content">
	<x path="lime.graphics.cairo.CairoContent"/>
	<x path="Void"/>
</f></pushGroupWithContent>
		<recreate set="method" line="298"><f a="surface">
	<x path="lime.graphics.cairo.CairoSurface"/>
	<x path="Void"/>
</f></recreate>
		<rectangle public="1" set="method" line="306"><f a="x:y:width:height">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></rectangle>
		<relCurveTo public="1" set="method" line="315"><f a="dx1:dy1:dx2:dy2:dx3:dy3">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></relCurveTo>
		<relLineTo public="1" set="method" line="324"><f a="dx:dy">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></relLineTo>
		<relMoveTo public="1" set="method" line="333"><f a="dx:dy">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></relMoveTo>
		<resetClip public="1" set="method" line="342"><f a=""><x path="Void"/></f></resetClip>
		<restore public="1" set="method" line="351"><f a=""><x path="Void"/></f></restore>
		<save public="1" set="method" line="360"><f a=""><x path="Void"/></f></save>
		<setFontSize public="1" set="method" line="369"><f a="size">
	<x path="Float"/>
	<x path="Void"/>
</f></setFontSize>
		<setSourceRGB public="1" set="method" line="378"><f a="r:g:b">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></setSourceRGB>
		<setSourceRGBA public="1" set="method" line="387"><f a="r:g:b:a">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></setSourceRGBA>
		<setSourceSurface public="1" set="method" line="396"><f a="surface:x:y">
	<x path="lime.graphics.cairo.CairoSurface"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></setSourceSurface>
		<showPage public="1" set="method" line="405"><f a=""><x path="Void"/></f></showPage>
		<showText public="1" set="method" line="414"><f a="utf8">
	<c path="String"/>
	<x path="Void"/>
</f></showText>
		<status public="1" set="method" line="423"><f a=""><x path="lime.graphics.cairo.CairoStatus"/></f></status>
		<stroke public="1" set="method" line="434"><f a=""><x path="Void"/></f></stroke>
		<strokeExtents public="1" set="method" line="443"><f a="x1:y1:x2:y2">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></strokeExtents>
		<strokePreserve public="1" set="method" line="452"><f a=""><x path="Void"/></f></strokePreserve>
		<transform public="1" set="method" line="461"><f a="matrix">
	<c path="lime.math.Matrix3"/>
	<x path="Void"/>
</f></transform>
		<rotate public="1" set="method" line="469"><f a="amount">
	<x path="Float"/>
	<x path="Void"/>
</f></rotate>
		<scale public="1" set="method" line="477"><f a="x:y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></scale>
		<translate public="1" set="method" line="486"><f a="x:y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></translate>
		<get_antialias set="method" line="504">
			<f a=""><x path="lime.graphics.cairo.CairoAntialias"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_antialias>
		<set_antialias set="method" line="515">
			<f a="value">
				<x path="lime.graphics.cairo.CairoAntialias"/>
				<x path="lime.graphics.cairo.CairoAntialias"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_antialias>
		<get_currentPoint set="method" line="526">
			<f a=""><c path="lime.math.Vector2"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_currentPoint>
		<get_dash set="method" line="538">
			<f a=""><c path="Array"><x path="Float"/></c></f>
			<meta><m n=":noCompletion"/></meta>
		</get_dash>
		<set_dash set="method" line="550">
			<f a="value">
				<c path="Array"><x path="Float"/></c>
				<c path="Array"><x path="Float"/></c>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_dash>
		<get_dashCount set="method" line="561">
			<f a=""><x path="Int"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_dashCount>
		<get_fillRule set="method" line="572">
			<f a=""><x path="lime.graphics.cairo.CairoFillRule"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_fillRule>
		<set_fillRule set="method" line="583">
			<f a="value">
				<x path="lime.graphics.cairo.CairoFillRule"/>
				<x path="lime.graphics.cairo.CairoFillRule"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_fillRule>
		<get_fontFace set="method" line="594">
			<f a=""><x path="lime.graphics.cairo.CairoFontFace"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_fontFace>
		<set_fontFace set="method" line="605">
			<f a="value">
				<x path="lime.graphics.cairo.CairoFontFace"/>
				<x path="lime.graphics.cairo.CairoFontFace"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_fontFace>
		<get_fontOptions set="method" line="616">
			<f a=""><x path="lime.graphics.cairo.CairoFontOptions"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_fontOptions>
		<set_fontOptions set="method" line="627">
			<f a="value">
				<x path="lime.graphics.cairo.CairoFontOptions"/>
				<x path="lime.graphics.cairo.CairoFontOptions"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_fontOptions>
		<get_groupTarget set="method" line="638">
			<f a=""><x path="lime.graphics.cairo.CairoSurface"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_groupTarget>
		<get_hasCurrentPoint set="method" line="649">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_hasCurrentPoint>
		<get_lineCap set="method" line="660">
			<f a=""><x path="lime.graphics.cairo.CairoLineCap"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_lineCap>
		<set_lineCap set="method" line="671">
			<f a="value">
				<x path="lime.graphics.cairo.CairoLineCap"/>
				<x path="lime.graphics.cairo.CairoLineCap"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_lineCap>
		<get_lineJoin set="method" line="682">
			<f a=""><x path="lime.graphics.cairo.CairoLineJoin"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_lineJoin>
		<set_lineJoin set="method" line="693">
			<f a="value">
				<x path="lime.graphics.cairo.CairoLineJoin"/>
				<x path="lime.graphics.cairo.CairoLineJoin"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_lineJoin>
		<get_lineWidth set="method" line="704">
			<f a=""><x path="Float"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_lineWidth>
		<set_lineWidth set="method" line="715">
			<f a="value">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_lineWidth>
		<get_matrix set="method" line="726">
			<f a=""><c path="lime.math.Matrix3"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_matrix>
		<set_matrix set="method" line="738">
			<f a="value">
				<c path="lime.math.Matrix3"/>
				<c path="lime.math.Matrix3"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_matrix>
		<get_miterLimit set="method" line="749">
			<f a=""><x path="Float"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_miterLimit>
		<set_miterLimit set="method" line="760">
			<f a="value">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_miterLimit>
		<get_operator set="method" line="771">
			<f a=""><x path="lime.graphics.cairo.CairoOperator"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_operator>
		<set_operator set="method" line="782">
			<f a="value">
				<x path="lime.graphics.cairo.CairoOperator"/>
				<x path="lime.graphics.cairo.CairoOperator"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_operator>
		<get_source set="method" line="793">
			<f a=""><x path="lime.graphics.cairo.CairoPattern"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_source>
		<set_source set="method" line="804">
			<f a="value">
				<x path="lime.graphics.cairo.CairoPattern"/>
				<x path="lime.graphics.cairo.CairoPattern"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_source>
		<get_target set="method" line="815">
			<f a=""><x path="lime.graphics.cairo.CairoSurface"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_target>
		<get_tolerance set="method" line="826">
			<f a=""><x path="Float"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_tolerance>
		<set_tolerance set="method" line="837">
			<f a="value">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_tolerance>
		<new public="1" set="method" line="43">
			<f a="?surface" v="null">
				<x path="lime.graphics.cairo.CairoSurface"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ surface : null }</e></m></meta>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>lime.system.CFFI.build()</e></m>
		</meta>
	</class>
	<abstract path="lime.graphics.cairo.CairoAntialias" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/graphics/cairo/CairoAntialias.hx">
		<from>
			<icast><x path="UInt"/></icast>
			<icast><x path="Int"/></icast>
		</from>
		<this><x path="Int"/></this>
		<to>
			<icast><x path="UInt"/></icast>
			<icast><x path="Int"/></icast>
		</to>
		<meta><m n=":enum"/></meta>
		<impl><class path="lime.graphics.cairo._CairoAntialias.CairoAntialias_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/graphics/cairo/CairoAntialias.hx" private="1" module="lime.graphics.cairo.CairoAntialias" extern="1">
	<DEFAULT public="1" get="inline" set="null" expr="cast 0" line="6" static="1">
		<x path="lime.graphics.cairo.CairoAntialias"/>
		<meta>
			<m n=":value"><e>cast 0</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</DEFAULT>
	<NONE public="1" get="inline" set="null" expr="cast 1" line="7" static="1">
		<x path="lime.graphics.cairo.CairoAntialias"/>
		<meta>
			<m n=":value"><e>cast 1</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NONE>
	<GRAY public="1" get="inline" set="null" expr="cast 2" line="8" static="1">
		<x path="lime.graphics.cairo.CairoAntialias"/>
		<meta>
			<m n=":value"><e>cast 2</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</GRAY>
	<SUBPIXEL public="1" get="inline" set="null" expr="cast 3" line="9" static="1">
		<x path="lime.graphics.cairo.CairoAntialias"/>
		<meta>
			<m n=":value"><e>cast 3</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</SUBPIXEL>
	<FAST public="1" get="inline" set="null" expr="cast 4" line="10" static="1">
		<x path="lime.graphics.cairo.CairoAntialias"/>
		<meta>
			<m n=":value"><e>cast 4</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</FAST>
	<GOOD public="1" get="inline" set="null" expr="cast 5" line="11" static="1">
		<x path="lime.graphics.cairo.CairoAntialias"/>
		<meta>
			<m n=":value"><e>cast 5</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</GOOD>
	<BEST public="1" get="inline" set="null" expr="cast 6" line="12" static="1">
		<x path="lime.graphics.cairo.CairoAntialias"/>
		<meta>
			<m n=":value"><e>cast 6</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</BEST>
	<meta>
		<m n=":final"/>
		<m n=":enum"/>
	</meta>
</class></impl>
	</abstract>
	<class path="lime.graphics.cairo._CairoAntialias.CairoAntialias_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/graphics/cairo/CairoAntialias.hx" private="1" module="lime.graphics.cairo.CairoAntialias" extern="1">
		<DEFAULT public="1" get="inline" set="null" expr="cast 0" line="6" static="1">
			<x path="lime.graphics.cairo.CairoAntialias"/>
			<meta>
				<m n=":value"><e>cast 0</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</DEFAULT>
		<NONE public="1" get="inline" set="null" expr="cast 1" line="7" static="1">
			<x path="lime.graphics.cairo.CairoAntialias"/>
			<meta>
				<m n=":value"><e>cast 1</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NONE>
		<GRAY public="1" get="inline" set="null" expr="cast 2" line="8" static="1">
			<x path="lime.graphics.cairo.CairoAntialias"/>
			<meta>
				<m n=":value"><e>cast 2</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</GRAY>
		<SUBPIXEL public="1" get="inline" set="null" expr="cast 3" line="9" static="1">
			<x path="lime.graphics.cairo.CairoAntialias"/>
			<meta>
				<m n=":value"><e>cast 3</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</SUBPIXEL>
		<FAST public="1" get="inline" set="null" expr="cast 4" line="10" static="1">
			<x path="lime.graphics.cairo.CairoAntialias"/>
			<meta>
				<m n=":value"><e>cast 4</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</FAST>
		<GOOD public="1" get="inline" set="null" expr="cast 5" line="11" static="1">
			<x path="lime.graphics.cairo.CairoAntialias"/>
			<meta>
				<m n=":value"><e>cast 5</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</GOOD>
		<BEST public="1" get="inline" set="null" expr="cast 6" line="12" static="1">
			<x path="lime.graphics.cairo.CairoAntialias"/>
			<meta>
				<m n=":value"><e>cast 6</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</BEST>
		<meta>
			<m n=":final"/>
			<m n=":enum"/>
		</meta>
	</class>
	<abstract path="lime.graphics.cairo.CairoContent" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/graphics/cairo/CairoContent.hx">
		<from>
			<icast><x path="UInt"/></icast>
			<icast><x path="Int"/></icast>
		</from>
		<this><x path="Int"/></this>
		<to>
			<icast><x path="UInt"/></icast>
			<icast><x path="Int"/></icast>
		</to>
		<meta><m n=":enum"/></meta>
		<impl><class path="lime.graphics.cairo._CairoContent.CairoContent_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/graphics/cairo/CairoContent.hx" private="1" module="lime.graphics.cairo.CairoContent" extern="1">
	<COLOR public="1" get="inline" set="null" expr="cast 0x1000" line="6" static="1">
		<x path="lime.graphics.cairo.CairoContent"/>
		<meta>
			<m n=":value"><e>cast 0x1000</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</COLOR>
	<ALPHA public="1" get="inline" set="null" expr="cast 0x2000" line="7" static="1">
		<x path="lime.graphics.cairo.CairoContent"/>
		<meta>
			<m n=":value"><e>cast 0x2000</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</ALPHA>
	<COLOR_ALPHA public="1" get="inline" set="null" expr="cast 0x3000" line="8" static="1">
		<x path="lime.graphics.cairo.CairoContent"/>
		<meta>
			<m n=":value"><e>cast 0x3000</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</COLOR_ALPHA>
	<meta>
		<m n=":final"/>
		<m n=":enum"/>
	</meta>
</class></impl>
	</abstract>
	<class path="lime.graphics.cairo._CairoContent.CairoContent_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/graphics/cairo/CairoContent.hx" private="1" module="lime.graphics.cairo.CairoContent" extern="1">
		<COLOR public="1" get="inline" set="null" expr="cast 0x1000" line="6" static="1">
			<x path="lime.graphics.cairo.CairoContent"/>
			<meta>
				<m n=":value"><e>cast 0x1000</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</COLOR>
		<ALPHA public="1" get="inline" set="null" expr="cast 0x2000" line="7" static="1">
			<x path="lime.graphics.cairo.CairoContent"/>
			<meta>
				<m n=":value"><e>cast 0x2000</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</ALPHA>
		<COLOR_ALPHA public="1" get="inline" set="null" expr="cast 0x3000" line="8" static="1">
			<x path="lime.graphics.cairo.CairoContent"/>
			<meta>
				<m n=":value"><e>cast 0x3000</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</COLOR_ALPHA>
		<meta>
			<m n=":final"/>
			<m n=":enum"/>
		</meta>
	</class>
	<abstract path="lime.graphics.cairo.CairoExtend" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/graphics/cairo/CairoExtend.hx">
		<from>
			<icast><x path="UInt"/></icast>
			<icast><x path="Int"/></icast>
		</from>
		<this><x path="Int"/></this>
		<to>
			<icast><x path="UInt"/></icast>
			<icast><x path="Int"/></icast>
		</to>
		<meta><m n=":enum"/></meta>
		<impl><class path="lime.graphics.cairo._CairoExtend.CairoExtend_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/graphics/cairo/CairoExtend.hx" private="1" module="lime.graphics.cairo.CairoExtend" extern="1">
	<NONE public="1" get="inline" set="null" expr="cast 0" line="6" static="1">
		<x path="lime.graphics.cairo.CairoExtend"/>
		<meta>
			<m n=":value"><e>cast 0</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NONE>
	<REPEAT public="1" get="inline" set="null" expr="cast 1" line="7" static="1">
		<x path="lime.graphics.cairo.CairoExtend"/>
		<meta>
			<m n=":value"><e>cast 1</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</REPEAT>
	<REFLECT public="1" get="inline" set="null" expr="cast 2" line="8" static="1">
		<x path="lime.graphics.cairo.CairoExtend"/>
		<meta>
			<m n=":value"><e>cast 2</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</REFLECT>
	<PAD public="1" get="inline" set="null" expr="cast 3" line="9" static="1">
		<x path="lime.graphics.cairo.CairoExtend"/>
		<meta>
			<m n=":value"><e>cast 3</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</PAD>
	<meta>
		<m n=":final"/>
		<m n=":enum"/>
	</meta>
</class></impl>
	</abstract>
	<class path="lime.graphics.cairo._CairoExtend.CairoExtend_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/graphics/cairo/CairoExtend.hx" private="1" module="lime.graphics.cairo.CairoExtend" extern="1">
		<NONE public="1" get="inline" set="null" expr="cast 0" line="6" static="1">
			<x path="lime.graphics.cairo.CairoExtend"/>
			<meta>
				<m n=":value"><e>cast 0</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NONE>
		<REPEAT public="1" get="inline" set="null" expr="cast 1" line="7" static="1">
			<x path="lime.graphics.cairo.CairoExtend"/>
			<meta>
				<m n=":value"><e>cast 1</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</REPEAT>
		<REFLECT public="1" get="inline" set="null" expr="cast 2" line="8" static="1">
			<x path="lime.graphics.cairo.CairoExtend"/>
			<meta>
				<m n=":value"><e>cast 2</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</REFLECT>
		<PAD public="1" get="inline" set="null" expr="cast 3" line="9" static="1">
			<x path="lime.graphics.cairo.CairoExtend"/>
			<meta>
				<m n=":value"><e>cast 3</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</PAD>
		<meta>
			<m n=":final"/>
			<m n=":enum"/>
		</meta>
	</class>
	<abstract path="lime.graphics.cairo.CairoFTFontFace" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/graphics/cairo/CairoFTFontFace.hx">
		<from>
			<icast><x path="lime.system.CFFIPointer"/></icast>
			<icast><x path="lime.graphics.cairo.CairoFontFace"/></icast>
		</from>
		<this><x path="lime.graphics.cairo.CairoFontFace"/></this>
		<to>
			<icast><x path="lime.system.CFFIPointer"/></icast>
			<icast><x path="lime.graphics.cairo.CairoFontFace"/></icast>
		</to>
		<meta><m n=":build"><e>lime.system.CFFI.build()</e></m></meta>
		<impl><class path="lime.graphics.cairo._CairoFTFontFace.CairoFTFontFace_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/graphics/cairo/CairoFTFontFace.hx" private="1" module="lime.graphics.cairo.CairoFTFontFace">
	<FT_LOAD_FORCE_AUTOHINT public="1" get="inline" set="null" expr="(1 &lt;&lt; 5)" line="15" static="1">
		<x path="Int"/>
		<meta><m n=":value"><e><![CDATA[(1 << 5)]]></e></m></meta>
	</FT_LOAD_FORCE_AUTOHINT>
	<_new set="method" line="18" static="1">
		<f a=""><x path="lime.graphics.cairo.CairoFTFontFace"/></f>
		<meta><m n=":impl"/></meta>
	</_new>
	<create public="1" set="method" line="25" static="1"><f a="face:loadFlags">
	<c path="lime.text.Font"/>
	<x path="Int"/>
	<x path="lime.graphics.cairo.CairoFTFontFace"/>
</f></create>
	<lime_cairo_ft_font_face_create get="inline" set="null" line="44" static="1">
		<f a="face:flags">
			<x path="lime.system.CFFIPointer"/>
			<x path="Int"/>
			<x path="lime.system.CFFIPointer"/>
		</f>
		<meta><m n=":cffi"/></meta>
	</lime_cairo_ft_font_face_create>
	<cffi_lime_cairo_ft_font_face_create expr="new cpp.Callable&lt;Dynamic -&gt; Int&gt;(lime.system.CFFI.load(&quot;lime&quot;, &quot;lime_cairo_ft_font_face_create&quot;, 2, false))" line="44" static="1">
		<x path="cpp.Callable"><f a=":">
	<d/>
	<x path="Int"/>
	<d/>
</f></x>
		<meta><m n=":value"><e><![CDATA[new cpp.Callable<Dynamic -> Int>(lime.system.CFFI.load("lime", "lime_cairo_ft_font_face_create", 2, false))]]></e></m></meta>
	</cffi_lime_cairo_ft_font_face_create>
	<meta>
		<m n=":directlyUsed"/>
		<m n=":final"/>
		<m n=":build"><e>lime.system.CFFI.build()</e></m>
	</meta>
</class></impl>
	</abstract>
	<class path="lime.graphics.cairo._CairoFTFontFace.CairoFTFontFace_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/graphics/cairo/CairoFTFontFace.hx" private="1" module="lime.graphics.cairo.CairoFTFontFace">
		<FT_LOAD_FORCE_AUTOHINT public="1" get="inline" set="null" expr="(1 &lt;&lt; 5)" line="15" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e><![CDATA[(1 << 5)]]></e></m></meta>
		</FT_LOAD_FORCE_AUTOHINT>
		<_new set="method" line="18" static="1">
			<f a=""><x path="lime.graphics.cairo.CairoFTFontFace"/></f>
			<meta><m n=":impl"/></meta>
		</_new>
		<create public="1" set="method" line="25" static="1"><f a="face:loadFlags">
	<c path="lime.text.Font"/>
	<x path="Int"/>
	<x path="lime.graphics.cairo.CairoFTFontFace"/>
</f></create>
		<lime_cairo_ft_font_face_create get="inline" set="null" line="44" static="1">
			<f a="face:flags">
				<x path="lime.system.CFFIPointer"/>
				<x path="Int"/>
				<x path="lime.system.CFFIPointer"/>
			</f>
			<meta><m n=":cffi"/></meta>
		</lime_cairo_ft_font_face_create>
		<cffi_lime_cairo_ft_font_face_create expr="new cpp.Callable&lt;Dynamic -&gt; Int&gt;(lime.system.CFFI.load(&quot;lime&quot;, &quot;lime_cairo_ft_font_face_create&quot;, 2, false))" line="44" static="1">
			<x path="cpp.Callable"><f a=":">
	<d/>
	<x path="Int"/>
	<d/>
</f></x>
			<meta><m n=":value"><e><![CDATA[new cpp.Callable<Dynamic -> Int>(lime.system.CFFI.load("lime", "lime_cairo_ft_font_face_create", 2, false))]]></e></m></meta>
		</cffi_lime_cairo_ft_font_face_create>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":final"/>
			<m n=":build"><e>lime.system.CFFI.build()</e></m>
		</meta>
	</class>
	<abstract path="lime.graphics.cairo.CairoFillRule" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/graphics/cairo/CairoFillRule.hx">
		<from>
			<icast><x path="UInt"/></icast>
			<icast><x path="Int"/></icast>
		</from>
		<this><x path="Int"/></this>
		<to>
			<icast><x path="UInt"/></icast>
			<icast><x path="Int"/></icast>
		</to>
		<meta><m n=":enum"/></meta>
		<impl><class path="lime.graphics.cairo._CairoFillRule.CairoFillRule_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/graphics/cairo/CairoFillRule.hx" private="1" module="lime.graphics.cairo.CairoFillRule" extern="1">
	<WINDING public="1" get="inline" set="null" expr="cast 0" line="6" static="1">
		<x path="lime.graphics.cairo.CairoFillRule"/>
		<meta>
			<m n=":value"><e>cast 0</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</WINDING>
	<EVEN_ODD public="1" get="inline" set="null" expr="cast 1" line="7" static="1">
		<x path="lime.graphics.cairo.CairoFillRule"/>
		<meta>
			<m n=":value"><e>cast 1</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</EVEN_ODD>
	<meta>
		<m n=":final"/>
		<m n=":enum"/>
	</meta>
</class></impl>
	</abstract>
	<class path="lime.graphics.cairo._CairoFillRule.CairoFillRule_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/graphics/cairo/CairoFillRule.hx" private="1" module="lime.graphics.cairo.CairoFillRule" extern="1">
		<WINDING public="1" get="inline" set="null" expr="cast 0" line="6" static="1">
			<x path="lime.graphics.cairo.CairoFillRule"/>
			<meta>
				<m n=":value"><e>cast 0</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</WINDING>
		<EVEN_ODD public="1" get="inline" set="null" expr="cast 1" line="7" static="1">
			<x path="lime.graphics.cairo.CairoFillRule"/>
			<meta>
				<m n=":value"><e>cast 1</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</EVEN_ODD>
		<meta>
			<m n=":final"/>
			<m n=":enum"/>
		</meta>
	</class>
	<abstract path="lime.graphics.cairo.CairoFilter" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/graphics/cairo/CairoFilter.hx">
		<from>
			<icast><x path="UInt"/></icast>
			<icast><x path="Int"/></icast>
		</from>
		<this><x path="Int"/></this>
		<to>
			<icast><x path="UInt"/></icast>
			<icast><x path="Int"/></icast>
		</to>
		<meta><m n=":enum"/></meta>
		<impl><class path="lime.graphics.cairo._CairoFilter.CairoFilter_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/graphics/cairo/CairoFilter.hx" private="1" module="lime.graphics.cairo.CairoFilter" extern="1">
	<FAST public="1" get="inline" set="null" expr="cast 0" line="6" static="1">
		<x path="lime.graphics.cairo.CairoFilter"/>
		<meta>
			<m n=":value"><e>cast 0</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</FAST>
	<GOOD public="1" get="inline" set="null" expr="cast 1" line="7" static="1">
		<x path="lime.graphics.cairo.CairoFilter"/>
		<meta>
			<m n=":value"><e>cast 1</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</GOOD>
	<BEST public="1" get="inline" set="null" expr="cast 2" line="8" static="1">
		<x path="lime.graphics.cairo.CairoFilter"/>
		<meta>
			<m n=":value"><e>cast 2</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</BEST>
	<NEAREST public="1" get="inline" set="null" expr="cast 3" line="9" static="1">
		<x path="lime.graphics.cairo.CairoFilter"/>
		<meta>
			<m n=":value"><e>cast 3</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NEAREST>
	<BILINEAR public="1" get="inline" set="null" expr="cast 4" line="10" static="1">
		<x path="lime.graphics.cairo.CairoFilter"/>
		<meta>
			<m n=":value"><e>cast 4</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</BILINEAR>
	<GAUSSIAN public="1" get="inline" set="null" expr="cast 5" line="11" static="1">
		<x path="lime.graphics.cairo.CairoFilter"/>
		<meta>
			<m n=":value"><e>cast 5</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</GAUSSIAN>
	<meta>
		<m n=":final"/>
		<m n=":enum"/>
	</meta>
</class></impl>
	</abstract>
	<class path="lime.graphics.cairo._CairoFilter.CairoFilter_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/graphics/cairo/CairoFilter.hx" private="1" module="lime.graphics.cairo.CairoFilter" extern="1">
		<FAST public="1" get="inline" set="null" expr="cast 0" line="6" static="1">
			<x path="lime.graphics.cairo.CairoFilter"/>
			<meta>
				<m n=":value"><e>cast 0</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</FAST>
		<GOOD public="1" get="inline" set="null" expr="cast 1" line="7" static="1">
			<x path="lime.graphics.cairo.CairoFilter"/>
			<meta>
				<m n=":value"><e>cast 1</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</GOOD>
		<BEST public="1" get="inline" set="null" expr="cast 2" line="8" static="1">
			<x path="lime.graphics.cairo.CairoFilter"/>
			<meta>
				<m n=":value"><e>cast 2</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</BEST>
		<NEAREST public="1" get="inline" set="null" expr="cast 3" line="9" static="1">
			<x path="lime.graphics.cairo.CairoFilter"/>
			<meta>
				<m n=":value"><e>cast 3</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NEAREST>
		<BILINEAR public="1" get="inline" set="null" expr="cast 4" line="10" static="1">
			<x path="lime.graphics.cairo.CairoFilter"/>
			<meta>
				<m n=":value"><e>cast 4</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</BILINEAR>
		<GAUSSIAN public="1" get="inline" set="null" expr="cast 5" line="11" static="1">
			<x path="lime.graphics.cairo.CairoFilter"/>
			<meta>
				<m n=":value"><e>cast 5</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</GAUSSIAN>
		<meta>
			<m n=":final"/>
			<m n=":enum"/>
		</meta>
	</class>
	<abstract path="lime.graphics.cairo.CairoFontFace" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/graphics/cairo/CairoFontFace.hx">
		<from><icast><x path="lime.system.CFFIPointer"/></icast></from>
		<this><x path="lime.system.CFFIPointer"/></this>
		<to><icast><x path="lime.system.CFFIPointer"/></icast></to>
		<meta><m n=":build"><e>lime.system.CFFI.build()</e></m></meta>
		<impl><class path="lime.graphics.cairo._CairoFontFace.CairoFontFace_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/graphics/cairo/CairoFontFace.hx" private="1" module="lime.graphics.cairo.CairoFontFace">
	<_new set="method" line="14" static="1">
		<f a=""><x path="lime.graphics.cairo.CairoFontFace"/></f>
		<meta><m n=":impl"/></meta>
	</_new>
	<status public="1" set="method" line="21" static="1">
		<f a="this">
			<x path="lime.system.CFFIPointer"/>
			<x path="lime.graphics.cairo.CairoStatus"/>
		</f>
		<meta><m n=":impl"/></meta>
	</status>
	<lime_cairo_font_face_status get="inline" set="null" line="40" static="1">
		<f a="handle">
			<x path="lime.system.CFFIPointer"/>
			<x path="Int"/>
		</f>
		<meta><m n=":cffi"/></meta>
	</lime_cairo_font_face_status>
	<cffi_lime_cairo_font_face_status expr="new cpp.Callable&lt;Dynamic&gt;(lime.system.CFFI.load(&quot;lime&quot;, &quot;lime_cairo_font_face_status&quot;, 1, false))" line="40" static="1">
		<x path="cpp.Callable"><f a="">
	<d/>
	<x path="Int"/>
</f></x>
		<meta><m n=":value"><e><![CDATA[new cpp.Callable<Dynamic>(lime.system.CFFI.load("lime", "lime_cairo_font_face_status", 1, false))]]></e></m></meta>
	</cffi_lime_cairo_font_face_status>
	<meta>
		<m n=":directlyUsed"/>
		<m n=":final"/>
		<m n=":build"><e>lime.system.CFFI.build()</e></m>
	</meta>
</class></impl>
	</abstract>
	<class path="lime.graphics.cairo._CairoFontFace.CairoFontFace_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/graphics/cairo/CairoFontFace.hx" private="1" module="lime.graphics.cairo.CairoFontFace">
		<_new set="method" line="14" static="1">
			<f a=""><x path="lime.graphics.cairo.CairoFontFace"/></f>
			<meta><m n=":impl"/></meta>
		</_new>
		<status public="1" set="method" line="21" static="1">
			<f a="this">
				<x path="lime.system.CFFIPointer"/>
				<x path="lime.graphics.cairo.CairoStatus"/>
			</f>
			<meta><m n=":impl"/></meta>
		</status>
		<lime_cairo_font_face_status get="inline" set="null" line="40" static="1">
			<f a="handle">
				<x path="lime.system.CFFIPointer"/>
				<x path="Int"/>
			</f>
			<meta><m n=":cffi"/></meta>
		</lime_cairo_font_face_status>
		<cffi_lime_cairo_font_face_status expr="new cpp.Callable&lt;Dynamic&gt;(lime.system.CFFI.load(&quot;lime&quot;, &quot;lime_cairo_font_face_status&quot;, 1, false))" line="40" static="1">
			<x path="cpp.Callable"><f a="">
	<d/>
	<x path="Int"/>
</f></x>
			<meta><m n=":value"><e><![CDATA[new cpp.Callable<Dynamic>(lime.system.CFFI.load("lime", "lime_cairo_font_face_status", 1, false))]]></e></m></meta>
		</cffi_lime_cairo_font_face_status>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":final"/>
			<m n=":build"><e>lime.system.CFFI.build()</e></m>
		</meta>
	</class>
	<abstract path="lime.graphics.cairo.CairoFontOptions" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/graphics/cairo/CairoFontOptions.hx">
		<from><icast><x path="lime.system.CFFIPointer"/></icast></from>
		<this><x path="lime.system.CFFIPointer"/></this>
		<to><icast><x path="lime.system.CFFIPointer"/></icast></to>
		<meta><m n=":build"><e>lime.system.CFFI.build()</e></m></meta>
		<impl><class path="lime.graphics.cairo._CairoFontOptions.CairoFontOptions_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/graphics/cairo/CairoFontOptions.hx" private="1" module="lime.graphics.cairo.CairoFontOptions">
	<antialias public="1" get="accessor" set="accessor" static="1">
		<x path="lime.graphics.cairo.CairoAntialias"/>
		<meta><m n=":impl"/></meta>
	</antialias>
	<hintMetrics public="1" get="accessor" set="accessor" static="1">
		<x path="lime.graphics.cairo.CairoHintMetrics"/>
		<meta><m n=":impl"/></meta>
	</hintMetrics>
	<hintStyle public="1" get="accessor" set="accessor" static="1">
		<x path="lime.graphics.cairo.CairoHintStyle"/>
		<meta><m n=":impl"/></meta>
	</hintStyle>
	<subpixelOrder public="1" get="accessor" set="accessor" static="1">
		<x path="lime.graphics.cairo.CairoSubpixelOrder"/>
		<meta><m n=":impl"/></meta>
	</subpixelOrder>
	<_new public="1" set="method" line="21" static="1">
		<f a=""><x path="lime.graphics.cairo.CairoFontOptions"/></f>
		<meta><m n=":impl"/></meta>
	</_new>
	<get_antialias set="method" line="39" static="1">
		<f a="this">
			<x path="lime.system.CFFIPointer"/>
			<x path="lime.graphics.cairo.CairoAntialias"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
	</get_antialias>
	<set_antialias set="method" line="50" static="1">
		<f a="this:value">
			<x path="lime.system.CFFIPointer"/>
			<x path="lime.graphics.cairo.CairoAntialias"/>
			<x path="lime.graphics.cairo.CairoAntialias"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
	</set_antialias>
	<get_hintMetrics set="method" line="61" static="1">
		<f a="this">
			<x path="lime.system.CFFIPointer"/>
			<x path="lime.graphics.cairo.CairoHintMetrics"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
	</get_hintMetrics>
	<set_hintMetrics set="method" line="72" static="1">
		<f a="this:value">
			<x path="lime.system.CFFIPointer"/>
			<x path="lime.graphics.cairo.CairoHintMetrics"/>
			<x path="lime.graphics.cairo.CairoHintMetrics"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
	</set_hintMetrics>
	<get_hintStyle set="method" line="84" static="1">
		<f a="this">
			<x path="lime.system.CFFIPointer"/>
			<x path="lime.graphics.cairo.CairoHintStyle"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
	</get_hintStyle>
	<set_hintStyle set="method" line="95" static="1">
		<f a="this:value">
			<x path="lime.system.CFFIPointer"/>
			<x path="lime.graphics.cairo.CairoHintStyle"/>
			<x path="lime.graphics.cairo.CairoHintStyle"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
	</set_hintStyle>
	<get_subpixelOrder set="method" line="106" static="1">
		<f a="this">
			<x path="lime.system.CFFIPointer"/>
			<x path="lime.graphics.cairo.CairoSubpixelOrder"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
	</get_subpixelOrder>
	<set_subpixelOrder set="method" line="117" static="1">
		<f a="this:value">
			<x path="lime.system.CFFIPointer"/>
			<x path="lime.graphics.cairo.CairoSubpixelOrder"/>
			<x path="lime.graphics.cairo.CairoSubpixelOrder"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
	</set_subpixelOrder>
	<lime_cairo_font_options_create get="inline" set="null" line="136" static="1">
		<f a=""><x path="lime.system.CFFIPointer"/></f>
		<meta><m n=":cffi"/></meta>
	</lime_cairo_font_options_create>
	<lime_cairo_font_options_get_antialias get="inline" set="null" line="137" static="1">
		<f a="handle">
			<x path="lime.system.CFFIPointer"/>
			<x path="Int"/>
		</f>
		<meta><m n=":cffi"/></meta>
	</lime_cairo_font_options_get_antialias>
	<lime_cairo_font_options_get_hint_metrics get="inline" set="null" line="138" static="1">
		<f a="handle">
			<x path="lime.system.CFFIPointer"/>
			<x path="Int"/>
		</f>
		<meta><m n=":cffi"/></meta>
	</lime_cairo_font_options_get_hint_metrics>
	<lime_cairo_font_options_get_hint_style get="inline" set="null" line="139" static="1">
		<f a="handle">
			<x path="lime.system.CFFIPointer"/>
			<x path="Int"/>
		</f>
		<meta><m n=":cffi"/></meta>
	</lime_cairo_font_options_get_hint_style>
	<lime_cairo_font_options_get_subpixel_order get="inline" set="null" line="140" static="1">
		<f a="handle">
			<x path="lime.system.CFFIPointer"/>
			<x path="Int"/>
		</f>
		<meta><m n=":cffi"/></meta>
	</lime_cairo_font_options_get_subpixel_order>
	<lime_cairo_font_options_set_antialias get="inline" set="null" line="141" static="1">
		<f a="handle:v">
			<x path="lime.system.CFFIPointer"/>
			<x path="Int"/>
			<x path="Void"/>
		</f>
		<meta><m n=":cffi"/></meta>
	</lime_cairo_font_options_set_antialias>
	<lime_cairo_font_options_set_hint_metrics get="inline" set="null" line="142" static="1">
		<f a="handle:v">
			<x path="lime.system.CFFIPointer"/>
			<x path="Int"/>
			<x path="Void"/>
		</f>
		<meta><m n=":cffi"/></meta>
	</lime_cairo_font_options_set_hint_metrics>
	<lime_cairo_font_options_set_hint_style get="inline" set="null" line="143" static="1">
		<f a="handle:v">
			<x path="lime.system.CFFIPointer"/>
			<x path="Int"/>
			<x path="Void"/>
		</f>
		<meta><m n=":cffi"/></meta>
	</lime_cairo_font_options_set_hint_style>
	<lime_cairo_font_options_set_subpixel_order get="inline" set="null" line="144" static="1">
		<f a="handle:v">
			<x path="lime.system.CFFIPointer"/>
			<x path="Int"/>
			<x path="Void"/>
		</f>
		<meta><m n=":cffi"/></meta>
	</lime_cairo_font_options_set_subpixel_order>
	<cffi_lime_cairo_font_options_create expr="new cpp.Callable&lt;Void&gt;(lime.system.CFFI.load(&quot;lime&quot;, &quot;lime_cairo_font_options_create&quot;, 0, false))" line="136" static="1">
		<x path="cpp.Callable"><f a=""><d/></f></x>
		<meta><m n=":value"><e><![CDATA[new cpp.Callable<Void>(lime.system.CFFI.load("lime", "lime_cairo_font_options_create", 0, false))]]></e></m></meta>
	</cffi_lime_cairo_font_options_create>
	<cffi_lime_cairo_font_options_get_antialias expr="new cpp.Callable&lt;Dynamic&gt;(lime.system.CFFI.load(&quot;lime&quot;, &quot;lime_cairo_font_options_get_antialias&quot;, 1, false))" line="137" static="1">
		<x path="cpp.Callable"><f a="">
	<d/>
	<x path="Int"/>
</f></x>
		<meta><m n=":value"><e><![CDATA[new cpp.Callable<Dynamic>(lime.system.CFFI.load("lime", "lime_cairo_font_options_get_antialias", 1, false))]]></e></m></meta>
	</cffi_lime_cairo_font_options_get_antialias>
	<cffi_lime_cairo_font_options_get_hint_metrics expr="new cpp.Callable&lt;Dynamic&gt;(lime.system.CFFI.load(&quot;lime&quot;, &quot;lime_cairo_font_options_get_hint_metrics&quot;, 1, false))" line="138" static="1">
		<x path="cpp.Callable"><f a="">
	<d/>
	<x path="Int"/>
</f></x>
		<meta><m n=":value"><e><![CDATA[new cpp.Callable<Dynamic>(lime.system.CFFI.load("lime", "lime_cairo_font_options_get_hint_metrics", 1, false))]]></e></m></meta>
	</cffi_lime_cairo_font_options_get_hint_metrics>
	<cffi_lime_cairo_font_options_get_hint_style expr="new cpp.Callable&lt;Dynamic&gt;(lime.system.CFFI.load(&quot;lime&quot;, &quot;lime_cairo_font_options_get_hint_style&quot;, 1, false))" line="139" static="1">
		<x path="cpp.Callable"><f a="">
	<d/>
	<x path="Int"/>
</f></x>
		<meta><m n=":value"><e><![CDATA[new cpp.Callable<Dynamic>(lime.system.CFFI.load("lime", "lime_cairo_font_options_get_hint_style", 1, false))]]></e></m></meta>
	</cffi_lime_cairo_font_options_get_hint_style>
	<cffi_lime_cairo_font_options_get_subpixel_order expr="new cpp.Callable&lt;Dynamic&gt;(lime.system.CFFI.load(&quot;lime&quot;, &quot;lime_cairo_font_options_get_subpixel_order&quot;, 1, false))" line="140" static="1">
		<x path="cpp.Callable"><f a="">
	<d/>
	<x path="Int"/>
</f></x>
		<meta><m n=":value"><e><![CDATA[new cpp.Callable<Dynamic>(lime.system.CFFI.load("lime", "lime_cairo_font_options_get_subpixel_order", 1, false))]]></e></m></meta>
	</cffi_lime_cairo_font_options_get_subpixel_order>
	<cffi_lime_cairo_font_options_set_antialias expr="new cpp.Callable&lt;Dynamic -&gt; Int&gt;(lime.system.CFFI.load(&quot;lime&quot;, &quot;lime_cairo_font_options_set_antialias&quot;, 2, false))" line="141" static="1">
		<x path="cpp.Callable"><f a=":">
	<d/>
	<x path="Int"/>
	<x path="Void"/>
</f></x>
		<meta><m n=":value"><e><![CDATA[new cpp.Callable<Dynamic -> Int>(lime.system.CFFI.load("lime", "lime_cairo_font_options_set_antialias", 2, false))]]></e></m></meta>
	</cffi_lime_cairo_font_options_set_antialias>
	<cffi_lime_cairo_font_options_set_hint_metrics expr="new cpp.Callable&lt;Dynamic -&gt; Int&gt;(lime.system.CFFI.load(&quot;lime&quot;, &quot;lime_cairo_font_options_set_hint_metrics&quot;, 2, false))" line="142" static="1">
		<x path="cpp.Callable"><f a=":">
	<d/>
	<x path="Int"/>
	<x path="Void"/>
</f></x>
		<meta><m n=":value"><e><![CDATA[new cpp.Callable<Dynamic -> Int>(lime.system.CFFI.load("lime", "lime_cairo_font_options_set_hint_metrics", 2, false))]]></e></m></meta>
	</cffi_lime_cairo_font_options_set_hint_metrics>
	<cffi_lime_cairo_font_options_set_hint_style expr="new cpp.Callable&lt;Dynamic -&gt; Int&gt;(lime.system.CFFI.load(&quot;lime&quot;, &quot;lime_cairo_font_options_set_hint_style&quot;, 2, false))" line="143" static="1">
		<x path="cpp.Callable"><f a=":">
	<d/>
	<x path="Int"/>
	<x path="Void"/>
</f></x>
		<meta><m n=":value"><e><![CDATA[new cpp.Callable<Dynamic -> Int>(lime.system.CFFI.load("lime", "lime_cairo_font_options_set_hint_style", 2, false))]]></e></m></meta>
	</cffi_lime_cairo_font_options_set_hint_style>
	<cffi_lime_cairo_font_options_set_subpixel_order expr="new cpp.Callable&lt;Dynamic -&gt; Int&gt;(lime.system.CFFI.load(&quot;lime&quot;, &quot;lime_cairo_font_options_set_subpixel_order&quot;, 2, false))" line="144" static="1">
		<x path="cpp.Callable"><f a=":">
	<d/>
	<x path="Int"/>
	<x path="Void"/>
</f></x>
		<meta><m n=":value"><e><![CDATA[new cpp.Callable<Dynamic -> Int>(lime.system.CFFI.load("lime", "lime_cairo_font_options_set_subpixel_order", 2, false))]]></e></m></meta>
	</cffi_lime_cairo_font_options_set_subpixel_order>
	<meta>
		<m n=":directlyUsed"/>
		<m n=":final"/>
		<m n=":build"><e>lime.system.CFFI.build()</e></m>
	</meta>
</class></impl>
	</abstract>
	<class path="lime.graphics.cairo._CairoFontOptions.CairoFontOptions_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/graphics/cairo/CairoFontOptions.hx" private="1" module="lime.graphics.cairo.CairoFontOptions">
		<antialias public="1" get="accessor" set="accessor" static="1">
			<x path="lime.graphics.cairo.CairoAntialias"/>
			<meta><m n=":impl"/></meta>
		</antialias>
		<hintMetrics public="1" get="accessor" set="accessor" static="1">
			<x path="lime.graphics.cairo.CairoHintMetrics"/>
			<meta><m n=":impl"/></meta>
		</hintMetrics>
		<hintStyle public="1" get="accessor" set="accessor" static="1">
			<x path="lime.graphics.cairo.CairoHintStyle"/>
			<meta><m n=":impl"/></meta>
		</hintStyle>
		<subpixelOrder public="1" get="accessor" set="accessor" static="1">
			<x path="lime.graphics.cairo.CairoSubpixelOrder"/>
			<meta><m n=":impl"/></meta>
		</subpixelOrder>
		<_new public="1" set="method" line="21" static="1">
			<f a=""><x path="lime.graphics.cairo.CairoFontOptions"/></f>
			<meta><m n=":impl"/></meta>
		</_new>
		<get_antialias set="method" line="39" static="1">
			<f a="this">
				<x path="lime.system.CFFIPointer"/>
				<x path="lime.graphics.cairo.CairoAntialias"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
		</get_antialias>
		<set_antialias set="method" line="50" static="1">
			<f a="this:value">
				<x path="lime.system.CFFIPointer"/>
				<x path="lime.graphics.cairo.CairoAntialias"/>
				<x path="lime.graphics.cairo.CairoAntialias"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
		</set_antialias>
		<get_hintMetrics set="method" line="61" static="1">
			<f a="this">
				<x path="lime.system.CFFIPointer"/>
				<x path="lime.graphics.cairo.CairoHintMetrics"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
		</get_hintMetrics>
		<set_hintMetrics set="method" line="72" static="1">
			<f a="this:value">
				<x path="lime.system.CFFIPointer"/>
				<x path="lime.graphics.cairo.CairoHintMetrics"/>
				<x path="lime.graphics.cairo.CairoHintMetrics"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
		</set_hintMetrics>
		<get_hintStyle set="method" line="84" static="1">
			<f a="this">
				<x path="lime.system.CFFIPointer"/>
				<x path="lime.graphics.cairo.CairoHintStyle"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
		</get_hintStyle>
		<set_hintStyle set="method" line="95" static="1">
			<f a="this:value">
				<x path="lime.system.CFFIPointer"/>
				<x path="lime.graphics.cairo.CairoHintStyle"/>
				<x path="lime.graphics.cairo.CairoHintStyle"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
		</set_hintStyle>
		<get_subpixelOrder set="method" line="106" static="1">
			<f a="this">
				<x path="lime.system.CFFIPointer"/>
				<x path="lime.graphics.cairo.CairoSubpixelOrder"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
		</get_subpixelOrder>
		<set_subpixelOrder set="method" line="117" static="1">
			<f a="this:value">
				<x path="lime.system.CFFIPointer"/>
				<x path="lime.graphics.cairo.CairoSubpixelOrder"/>
				<x path="lime.graphics.cairo.CairoSubpixelOrder"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
		</set_subpixelOrder>
		<lime_cairo_font_options_create get="inline" set="null" line="136" static="1">
			<f a=""><x path="lime.system.CFFIPointer"/></f>
			<meta><m n=":cffi"/></meta>
		</lime_cairo_font_options_create>
		<lime_cairo_font_options_get_antialias get="inline" set="null" line="137" static="1">
			<f a="handle">
				<x path="lime.system.CFFIPointer"/>
				<x path="Int"/>
			</f>
			<meta><m n=":cffi"/></meta>
		</lime_cairo_font_options_get_antialias>
		<lime_cairo_font_options_get_hint_metrics get="inline" set="null" line="138" static="1">
			<f a="handle">
				<x path="lime.system.CFFIPointer"/>
				<x path="Int"/>
			</f>
			<meta><m n=":cffi"/></meta>
		</lime_cairo_font_options_get_hint_metrics>
		<lime_cairo_font_options_get_hint_style get="inline" set="null" line="139" static="1">
			<f a="handle">
				<x path="lime.system.CFFIPointer"/>
				<x path="Int"/>
			</f>
			<meta><m n=":cffi"/></meta>
		</lime_cairo_font_options_get_hint_style>
		<lime_cairo_font_options_get_subpixel_order get="inline" set="null" line="140" static="1">
			<f a="handle">
				<x path="lime.system.CFFIPointer"/>
				<x path="Int"/>
			</f>
			<meta><m n=":cffi"/></meta>
		</lime_cairo_font_options_get_subpixel_order>
		<lime_cairo_font_options_set_antialias get="inline" set="null" line="141" static="1">
			<f a="handle:v">
				<x path="lime.system.CFFIPointer"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":cffi"/></meta>
		</lime_cairo_font_options_set_antialias>
		<lime_cairo_font_options_set_hint_metrics get="inline" set="null" line="142" static="1">
			<f a="handle:v">
				<x path="lime.system.CFFIPointer"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":cffi"/></meta>
		</lime_cairo_font_options_set_hint_metrics>
		<lime_cairo_font_options_set_hint_style get="inline" set="null" line="143" static="1">
			<f a="handle:v">
				<x path="lime.system.CFFIPointer"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":cffi"/></meta>
		</lime_cairo_font_options_set_hint_style>
		<lime_cairo_font_options_set_subpixel_order get="inline" set="null" line="144" static="1">
			<f a="handle:v">
				<x path="lime.system.CFFIPointer"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":cffi"/></meta>
		</lime_cairo_font_options_set_subpixel_order>
		<cffi_lime_cairo_font_options_create expr="new cpp.Callable&lt;Void&gt;(lime.system.CFFI.load(&quot;lime&quot;, &quot;lime_cairo_font_options_create&quot;, 0, false))" line="136" static="1">
			<x path="cpp.Callable"><f a=""><d/></f></x>
			<meta><m n=":value"><e><![CDATA[new cpp.Callable<Void>(lime.system.CFFI.load("lime", "lime_cairo_font_options_create", 0, false))]]></e></m></meta>
		</cffi_lime_cairo_font_options_create>
		<cffi_lime_cairo_font_options_get_antialias expr="new cpp.Callable&lt;Dynamic&gt;(lime.system.CFFI.load(&quot;lime&quot;, &quot;lime_cairo_font_options_get_antialias&quot;, 1, false))" line="137" static="1">
			<x path="cpp.Callable"><f a="">
	<d/>
	<x path="Int"/>
</f></x>
			<meta><m n=":value"><e><![CDATA[new cpp.Callable<Dynamic>(lime.system.CFFI.load("lime", "lime_cairo_font_options_get_antialias", 1, false))]]></e></m></meta>
		</cffi_lime_cairo_font_options_get_antialias>
		<cffi_lime_cairo_font_options_get_hint_metrics expr="new cpp.Callable&lt;Dynamic&gt;(lime.system.CFFI.load(&quot;lime&quot;, &quot;lime_cairo_font_options_get_hint_metrics&quot;, 1, false))" line="138" static="1">
			<x path="cpp.Callable"><f a="">
	<d/>
	<x path="Int"/>
</f></x>
			<meta><m n=":value"><e><![CDATA[new cpp.Callable<Dynamic>(lime.system.CFFI.load("lime", "lime_cairo_font_options_get_hint_metrics", 1, false))]]></e></m></meta>
		</cffi_lime_cairo_font_options_get_hint_metrics>
		<cffi_lime_cairo_font_options_get_hint_style expr="new cpp.Callable&lt;Dynamic&gt;(lime.system.CFFI.load(&quot;lime&quot;, &quot;lime_cairo_font_options_get_hint_style&quot;, 1, false))" line="139" static="1">
			<x path="cpp.Callable"><f a="">
	<d/>
	<x path="Int"/>
</f></x>
			<meta><m n=":value"><e><![CDATA[new cpp.Callable<Dynamic>(lime.system.CFFI.load("lime", "lime_cairo_font_options_get_hint_style", 1, false))]]></e></m></meta>
		</cffi_lime_cairo_font_options_get_hint_style>
		<cffi_lime_cairo_font_options_get_subpixel_order expr="new cpp.Callable&lt;Dynamic&gt;(lime.system.CFFI.load(&quot;lime&quot;, &quot;lime_cairo_font_options_get_subpixel_order&quot;, 1, false))" line="140" static="1">
			<x path="cpp.Callable"><f a="">
	<d/>
	<x path="Int"/>
</f></x>
			<meta><m n=":value"><e><![CDATA[new cpp.Callable<Dynamic>(lime.system.CFFI.load("lime", "lime_cairo_font_options_get_subpixel_order", 1, false))]]></e></m></meta>
		</cffi_lime_cairo_font_options_get_subpixel_order>
		<cffi_lime_cairo_font_options_set_antialias expr="new cpp.Callable&lt;Dynamic -&gt; Int&gt;(lime.system.CFFI.load(&quot;lime&quot;, &quot;lime_cairo_font_options_set_antialias&quot;, 2, false))" line="141" static="1">
			<x path="cpp.Callable"><f a=":">
	<d/>
	<x path="Int"/>
	<x path="Void"/>
</f></x>
			<meta><m n=":value"><e><![CDATA[new cpp.Callable<Dynamic -> Int>(lime.system.CFFI.load("lime", "lime_cairo_font_options_set_antialias", 2, false))]]></e></m></meta>
		</cffi_lime_cairo_font_options_set_antialias>
		<cffi_lime_cairo_font_options_set_hint_metrics expr="new cpp.Callable&lt;Dynamic -&gt; Int&gt;(lime.system.CFFI.load(&quot;lime&quot;, &quot;lime_cairo_font_options_set_hint_metrics&quot;, 2, false))" line="142" static="1">
			<x path="cpp.Callable"><f a=":">
	<d/>
	<x path="Int"/>
	<x path="Void"/>
</f></x>
			<meta><m n=":value"><e><![CDATA[new cpp.Callable<Dynamic -> Int>(lime.system.CFFI.load("lime", "lime_cairo_font_options_set_hint_metrics", 2, false))]]></e></m></meta>
		</cffi_lime_cairo_font_options_set_hint_metrics>
		<cffi_lime_cairo_font_options_set_hint_style expr="new cpp.Callable&lt;Dynamic -&gt; Int&gt;(lime.system.CFFI.load(&quot;lime&quot;, &quot;lime_cairo_font_options_set_hint_style&quot;, 2, false))" line="143" static="1">
			<x path="cpp.Callable"><f a=":">
	<d/>
	<x path="Int"/>
	<x path="Void"/>
</f></x>
			<meta><m n=":value"><e><![CDATA[new cpp.Callable<Dynamic -> Int>(lime.system.CFFI.load("lime", "lime_cairo_font_options_set_hint_style", 2, false))]]></e></m></meta>
		</cffi_lime_cairo_font_options_set_hint_style>
		<cffi_lime_cairo_font_options_set_subpixel_order expr="new cpp.Callable&lt;Dynamic -&gt; Int&gt;(lime.system.CFFI.load(&quot;lime&quot;, &quot;lime_cairo_font_options_set_subpixel_order&quot;, 2, false))" line="144" static="1">
			<x path="cpp.Callable"><f a=":">
	<d/>
	<x path="Int"/>
	<x path="Void"/>
</f></x>
			<meta><m n=":value"><e><![CDATA[new cpp.Callable<Dynamic -> Int>(lime.system.CFFI.load("lime", "lime_cairo_font_options_set_subpixel_order", 2, false))]]></e></m></meta>
		</cffi_lime_cairo_font_options_set_subpixel_order>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":final"/>
			<m n=":build"><e>lime.system.CFFI.build()</e></m>
		</meta>
	</class>
	<abstract path="lime.graphics.cairo.CairoFormat" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/graphics/cairo/CairoFormat.hx">
		<from>
			<icast><x path="UInt"/></icast>
			<icast><x path="Int"/></icast>
		</from>
		<this><x path="Int"/></this>
		<to>
			<icast><x path="UInt"/></icast>
			<icast><x path="Int"/></icast>
		</to>
		<meta><m n=":enum"/></meta>
		<impl><class path="lime.graphics.cairo._CairoFormat.CairoFormat_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/graphics/cairo/CairoFormat.hx" private="1" module="lime.graphics.cairo.CairoFormat" extern="1">
	<INVALID public="1" get="inline" set="null" expr="cast -1" line="6" static="1">
		<x path="lime.graphics.cairo.CairoFormat"/>
		<meta>
			<m n=":value"><e>cast -1</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</INVALID>
	<ARGB32 public="1" get="inline" set="null" expr="cast 0" line="7" static="1">
		<x path="lime.graphics.cairo.CairoFormat"/>
		<meta>
			<m n=":value"><e>cast 0</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</ARGB32>
	<RGB24 public="1" get="inline" set="null" expr="cast 1" line="8" static="1">
		<x path="lime.graphics.cairo.CairoFormat"/>
		<meta>
			<m n=":value"><e>cast 1</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</RGB24>
	<A8 public="1" get="inline" set="null" expr="cast 2" line="9" static="1">
		<x path="lime.graphics.cairo.CairoFormat"/>
		<meta>
			<m n=":value"><e>cast 2</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</A8>
	<A1 public="1" get="inline" set="null" expr="cast 3" line="10" static="1">
		<x path="lime.graphics.cairo.CairoFormat"/>
		<meta>
			<m n=":value"><e>cast 3</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</A1>
	<RGB16_565 public="1" get="inline" set="null" expr="cast 4" line="11" static="1">
		<x path="lime.graphics.cairo.CairoFormat"/>
		<meta>
			<m n=":value"><e>cast 4</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</RGB16_565>
	<RGB30 public="1" get="inline" set="null" expr="cast 5" line="12" static="1">
		<x path="lime.graphics.cairo.CairoFormat"/>
		<meta>
			<m n=":value"><e>cast 5</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</RGB30>
	<meta>
		<m n=":final"/>
		<m n=":enum"/>
	</meta>
</class></impl>
	</abstract>
	<class path="lime.graphics.cairo._CairoFormat.CairoFormat_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/graphics/cairo/CairoFormat.hx" private="1" module="lime.graphics.cairo.CairoFormat" extern="1">
		<INVALID public="1" get="inline" set="null" expr="cast -1" line="6" static="1">
			<x path="lime.graphics.cairo.CairoFormat"/>
			<meta>
				<m n=":value"><e>cast -1</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</INVALID>
		<ARGB32 public="1" get="inline" set="null" expr="cast 0" line="7" static="1">
			<x path="lime.graphics.cairo.CairoFormat"/>
			<meta>
				<m n=":value"><e>cast 0</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</ARGB32>
		<RGB24 public="1" get="inline" set="null" expr="cast 1" line="8" static="1">
			<x path="lime.graphics.cairo.CairoFormat"/>
			<meta>
				<m n=":value"><e>cast 1</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</RGB24>
		<A8 public="1" get="inline" set="null" expr="cast 2" line="9" static="1">
			<x path="lime.graphics.cairo.CairoFormat"/>
			<meta>
				<m n=":value"><e>cast 2</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</A8>
		<A1 public="1" get="inline" set="null" expr="cast 3" line="10" static="1">
			<x path="lime.graphics.cairo.CairoFormat"/>
			<meta>
				<m n=":value"><e>cast 3</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</A1>
		<RGB16_565 public="1" get="inline" set="null" expr="cast 4" line="11" static="1">
			<x path="lime.graphics.cairo.CairoFormat"/>
			<meta>
				<m n=":value"><e>cast 4</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</RGB16_565>
		<RGB30 public="1" get="inline" set="null" expr="cast 5" line="12" static="1">
			<x path="lime.graphics.cairo.CairoFormat"/>
			<meta>
				<m n=":value"><e>cast 5</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</RGB30>
		<meta>
			<m n=":final"/>
			<m n=":enum"/>
		</meta>
	</class>
	<abstract path="lime.graphics.cairo.CairoHintMetrics" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/graphics/cairo/CairoHintMetrics.hx">
		<from>
			<icast><x path="UInt"/></icast>
			<icast><x path="Int"/></icast>
		</from>
		<this><x path="Int"/></this>
		<to>
			<icast><x path="UInt"/></icast>
			<icast><x path="Int"/></icast>
		</to>
		<meta><m n=":enum"/></meta>
		<impl><class path="lime.graphics.cairo._CairoHintMetrics.CairoHintMetrics_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/graphics/cairo/CairoHintMetrics.hx" private="1" module="lime.graphics.cairo.CairoHintMetrics" extern="1">
	<DEFAULT public="1" get="inline" set="null" expr="cast 0" line="6" static="1">
		<x path="lime.graphics.cairo.CairoHintMetrics"/>
		<meta>
			<m n=":value"><e>cast 0</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</DEFAULT>
	<OFF public="1" get="inline" set="null" expr="cast 1" line="7" static="1">
		<x path="lime.graphics.cairo.CairoHintMetrics"/>
		<meta>
			<m n=":value"><e>cast 1</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</OFF>
	<ON public="1" get="inline" set="null" expr="cast 2" line="8" static="1">
		<x path="lime.graphics.cairo.CairoHintMetrics"/>
		<meta>
			<m n=":value"><e>cast 2</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</ON>
	<meta>
		<m n=":final"/>
		<m n=":enum"/>
	</meta>
</class></impl>
	</abstract>
	<class path="lime.graphics.cairo._CairoHintMetrics.CairoHintMetrics_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/graphics/cairo/CairoHintMetrics.hx" private="1" module="lime.graphics.cairo.CairoHintMetrics" extern="1">
		<DEFAULT public="1" get="inline" set="null" expr="cast 0" line="6" static="1">
			<x path="lime.graphics.cairo.CairoHintMetrics"/>
			<meta>
				<m n=":value"><e>cast 0</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</DEFAULT>
		<OFF public="1" get="inline" set="null" expr="cast 1" line="7" static="1">
			<x path="lime.graphics.cairo.CairoHintMetrics"/>
			<meta>
				<m n=":value"><e>cast 1</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</OFF>
		<ON public="1" get="inline" set="null" expr="cast 2" line="8" static="1">
			<x path="lime.graphics.cairo.CairoHintMetrics"/>
			<meta>
				<m n=":value"><e>cast 2</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</ON>
		<meta>
			<m n=":final"/>
			<m n=":enum"/>
		</meta>
	</class>
	<abstract path="lime.graphics.cairo.CairoHintStyle" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/graphics/cairo/CairoHintStyle.hx">
		<from>
			<icast><x path="UInt"/></icast>
			<icast><x path="Int"/></icast>
		</from>
		<this><x path="Int"/></this>
		<to>
			<icast><x path="UInt"/></icast>
			<icast><x path="Int"/></icast>
		</to>
		<meta><m n=":enum"/></meta>
		<impl><class path="lime.graphics.cairo._CairoHintStyle.CairoHintStyle_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/graphics/cairo/CairoHintStyle.hx" private="1" module="lime.graphics.cairo.CairoHintStyle" extern="1">
	<DEFAULT public="1" get="inline" set="null" expr="cast 0" line="6" static="1">
		<x path="lime.graphics.cairo.CairoHintStyle"/>
		<meta>
			<m n=":value"><e>cast 0</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</DEFAULT>
	<NONE public="1" get="inline" set="null" expr="cast 1" line="7" static="1">
		<x path="lime.graphics.cairo.CairoHintStyle"/>
		<meta>
			<m n=":value"><e>cast 1</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NONE>
	<SLIGHT public="1" get="inline" set="null" expr="cast 2" line="8" static="1">
		<x path="lime.graphics.cairo.CairoHintStyle"/>
		<meta>
			<m n=":value"><e>cast 2</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</SLIGHT>
	<MEDIUM public="1" get="inline" set="null" expr="cast 3" line="9" static="1">
		<x path="lime.graphics.cairo.CairoHintStyle"/>
		<meta>
			<m n=":value"><e>cast 3</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</MEDIUM>
	<FULL public="1" get="inline" set="null" expr="cast 4" line="10" static="1">
		<x path="lime.graphics.cairo.CairoHintStyle"/>
		<meta>
			<m n=":value"><e>cast 4</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</FULL>
	<meta>
		<m n=":final"/>
		<m n=":enum"/>
	</meta>
</class></impl>
	</abstract>
	<class path="lime.graphics.cairo._CairoHintStyle.CairoHintStyle_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/graphics/cairo/CairoHintStyle.hx" private="1" module="lime.graphics.cairo.CairoHintStyle" extern="1">
		<DEFAULT public="1" get="inline" set="null" expr="cast 0" line="6" static="1">
			<x path="lime.graphics.cairo.CairoHintStyle"/>
			<meta>
				<m n=":value"><e>cast 0</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</DEFAULT>
		<NONE public="1" get="inline" set="null" expr="cast 1" line="7" static="1">
			<x path="lime.graphics.cairo.CairoHintStyle"/>
			<meta>
				<m n=":value"><e>cast 1</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NONE>
		<SLIGHT public="1" get="inline" set="null" expr="cast 2" line="8" static="1">
			<x path="lime.graphics.cairo.CairoHintStyle"/>
			<meta>
				<m n=":value"><e>cast 2</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</SLIGHT>
		<MEDIUM public="1" get="inline" set="null" expr="cast 3" line="9" static="1">
			<x path="lime.graphics.cairo.CairoHintStyle"/>
			<meta>
				<m n=":value"><e>cast 3</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</MEDIUM>
		<FULL public="1" get="inline" set="null" expr="cast 4" line="10" static="1">
			<x path="lime.graphics.cairo.CairoHintStyle"/>
			<meta>
				<m n=":value"><e>cast 4</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</FULL>
		<meta>
			<m n=":final"/>
			<m n=":enum"/>
		</meta>
	</class>
	<abstract path="lime.graphics.cairo.CairoImageSurface" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/graphics/cairo/CairoImageSurface.hx">
		<from>
			<icast><x path="lime.system.CFFIPointer"/></icast>
			<icast><x path="lime.graphics.cairo.CairoSurface"/></icast>
		</from>
		<this><x path="lime.graphics.cairo.CairoSurface"/></this>
		<to>
			<icast><x path="lime.system.CFFIPointer"/></icast>
			<icast><x path="lime.graphics.cairo.CairoSurface"/></icast>
		</to>
		<meta>
			<m n=":build"><e>lime.system.CFFI.build()</e></m>
			<m n=":forward"/>
		</meta>
		<impl><class path="lime.graphics.cairo._CairoImageSurface.CairoImageSurface_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/graphics/cairo/CairoImageSurface.hx" private="1" module="lime.graphics.cairo.CairoImageSurface">
	<data public="1" get="accessor" set="null" static="1">
		<d/>
		<meta><m n=":impl"/></meta>
	</data>
	<format public="1" get="accessor" set="null" static="1">
		<x path="lime.graphics.cairo.CairoFormat"/>
		<meta><m n=":impl"/></meta>
	</format>
	<height public="1" get="accessor" set="null" static="1">
		<x path="Int"/>
		<meta><m n=":impl"/></meta>
	</height>
	<stride public="1" get="accessor" set="null" static="1">
		<x path="Int"/>
		<meta><m n=":impl"/></meta>
	</stride>
	<width public="1" get="accessor" set="null" static="1">
		<x path="Int"/>
		<meta><m n=":impl"/></meta>
	</width>
	<_new public="1" set="method" line="21" static="1">
		<f a="format:width:height">
			<x path="lime.graphics.cairo.CairoFormat"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="lime.graphics.cairo.CairoImageSurface"/>
		</f>
		<meta><m n=":impl"/></meta>
	</_new>
	<create public="1" set="method" line="32" static="1"><f a="data:format:width:height:stride">
	<d/>
	<x path="lime.graphics.cairo.CairoFormat"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="lime.graphics.cairo.CairoSurface"/>
</f></create>
	<fromImage public="1" set="method" line="43" static="1"><f a="image">
	<c path="lime.graphics.Image"/>
	<x path="lime.graphics.cairo.CairoSurface"/>
</f></fromImage>
	<get_data set="method" line="61" static="1">
		<f a="this">
			<x path="lime.graphics.cairo.CairoSurface"/>
			<d/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
	</get_data>
	<get_format set="method" line="72" static="1">
		<f a="this">
			<x path="lime.graphics.cairo.CairoSurface"/>
			<x path="lime.graphics.cairo.CairoFormat"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
	</get_format>
	<get_height set="method" line="83" static="1">
		<f a="this">
			<x path="lime.graphics.cairo.CairoSurface"/>
			<x path="Int"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
	</get_height>
	<get_stride set="method" line="94" static="1">
		<f a="this">
			<x path="lime.graphics.cairo.CairoSurface"/>
			<x path="Int"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
	</get_stride>
	<get_width set="method" line="105" static="1">
		<f a="this">
			<x path="lime.graphics.cairo.CairoSurface"/>
			<x path="Int"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
	</get_width>
	<meta>
		<m n=":directlyUsed"/>
		<m n=":final"/>
		<m n=":build"><e>lime.system.CFFI.build()</e></m>
	</meta>
</class></impl>
	</abstract>
	<class path="lime.graphics.cairo._CairoImageSurface.CairoImageSurface_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/graphics/cairo/CairoImageSurface.hx" private="1" module="lime.graphics.cairo.CairoImageSurface">
		<data public="1" get="accessor" set="null" static="1">
			<d/>
			<meta><m n=":impl"/></meta>
		</data>
		<format public="1" get="accessor" set="null" static="1">
			<x path="lime.graphics.cairo.CairoFormat"/>
			<meta><m n=":impl"/></meta>
		</format>
		<height public="1" get="accessor" set="null" static="1">
			<x path="Int"/>
			<meta><m n=":impl"/></meta>
		</height>
		<stride public="1" get="accessor" set="null" static="1">
			<x path="Int"/>
			<meta><m n=":impl"/></meta>
		</stride>
		<width public="1" get="accessor" set="null" static="1">
			<x path="Int"/>
			<meta><m n=":impl"/></meta>
		</width>
		<_new public="1" set="method" line="21" static="1">
			<f a="format:width:height">
				<x path="lime.graphics.cairo.CairoFormat"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="lime.graphics.cairo.CairoImageSurface"/>
			</f>
			<meta><m n=":impl"/></meta>
		</_new>
		<create public="1" set="method" line="32" static="1"><f a="data:format:width:height:stride">
	<d/>
	<x path="lime.graphics.cairo.CairoFormat"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="lime.graphics.cairo.CairoSurface"/>
</f></create>
		<fromImage public="1" set="method" line="43" static="1"><f a="image">
	<c path="lime.graphics.Image"/>
	<x path="lime.graphics.cairo.CairoSurface"/>
</f></fromImage>
		<get_data set="method" line="61" static="1">
			<f a="this">
				<x path="lime.graphics.cairo.CairoSurface"/>
				<d/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
		</get_data>
		<get_format set="method" line="72" static="1">
			<f a="this">
				<x path="lime.graphics.cairo.CairoSurface"/>
				<x path="lime.graphics.cairo.CairoFormat"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
		</get_format>
		<get_height set="method" line="83" static="1">
			<f a="this">
				<x path="lime.graphics.cairo.CairoSurface"/>
				<x path="Int"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
		</get_height>
		<get_stride set="method" line="94" static="1">
			<f a="this">
				<x path="lime.graphics.cairo.CairoSurface"/>
				<x path="Int"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
		</get_stride>
		<get_width set="method" line="105" static="1">
			<f a="this">
				<x path="lime.graphics.cairo.CairoSurface"/>
				<x path="Int"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
		</get_width>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":final"/>
			<m n=":build"><e>lime.system.CFFI.build()</e></m>
		</meta>
	</class>
	<abstract path="lime.graphics.cairo.CairoLineCap" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/graphics/cairo/CairoLineCap.hx">
		<from>
			<icast><x path="UInt"/></icast>
			<icast><x path="Int"/></icast>
		</from>
		<this><x path="Int"/></this>
		<to>
			<icast><x path="UInt"/></icast>
			<icast><x path="Int"/></icast>
		</to>
		<meta><m n=":enum"/></meta>
		<impl><class path="lime.graphics.cairo._CairoLineCap.CairoLineCap_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/graphics/cairo/CairoLineCap.hx" private="1" module="lime.graphics.cairo.CairoLineCap" extern="1">
	<BUTT public="1" get="inline" set="null" expr="cast 0" line="6" static="1">
		<x path="lime.graphics.cairo.CairoLineCap"/>
		<meta>
			<m n=":value"><e>cast 0</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</BUTT>
	<ROUND public="1" get="inline" set="null" expr="cast 1" line="7" static="1">
		<x path="lime.graphics.cairo.CairoLineCap"/>
		<meta>
			<m n=":value"><e>cast 1</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</ROUND>
	<SQUARE public="1" get="inline" set="null" expr="cast 2" line="8" static="1">
		<x path="lime.graphics.cairo.CairoLineCap"/>
		<meta>
			<m n=":value"><e>cast 2</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</SQUARE>
	<meta>
		<m n=":final"/>
		<m n=":enum"/>
	</meta>
</class></impl>
	</abstract>
	<class path="lime.graphics.cairo._CairoLineCap.CairoLineCap_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/graphics/cairo/CairoLineCap.hx" private="1" module="lime.graphics.cairo.CairoLineCap" extern="1">
		<BUTT public="1" get="inline" set="null" expr="cast 0" line="6" static="1">
			<x path="lime.graphics.cairo.CairoLineCap"/>
			<meta>
				<m n=":value"><e>cast 0</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</BUTT>
		<ROUND public="1" get="inline" set="null" expr="cast 1" line="7" static="1">
			<x path="lime.graphics.cairo.CairoLineCap"/>
			<meta>
				<m n=":value"><e>cast 1</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</ROUND>
		<SQUARE public="1" get="inline" set="null" expr="cast 2" line="8" static="1">
			<x path="lime.graphics.cairo.CairoLineCap"/>
			<meta>
				<m n=":value"><e>cast 2</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</SQUARE>
		<meta>
			<m n=":final"/>
			<m n=":enum"/>
		</meta>
	</class>
	<abstract path="lime.graphics.cairo.CairoLineJoin" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/graphics/cairo/CairoLineJoin.hx">
		<from>
			<icast><x path="UInt"/></icast>
			<icast><x path="Int"/></icast>
		</from>
		<this><x path="Int"/></this>
		<to>
			<icast><x path="UInt"/></icast>
			<icast><x path="Int"/></icast>
		</to>
		<meta><m n=":enum"/></meta>
		<impl><class path="lime.graphics.cairo._CairoLineJoin.CairoLineJoin_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/graphics/cairo/CairoLineJoin.hx" private="1" module="lime.graphics.cairo.CairoLineJoin" extern="1">
	<MITER public="1" get="inline" set="null" expr="cast 0" line="6" static="1">
		<x path="lime.graphics.cairo.CairoLineJoin"/>
		<meta>
			<m n=":value"><e>cast 0</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</MITER>
	<ROUND public="1" get="inline" set="null" expr="cast 1" line="7" static="1">
		<x path="lime.graphics.cairo.CairoLineJoin"/>
		<meta>
			<m n=":value"><e>cast 1</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</ROUND>
	<BEVEL public="1" get="inline" set="null" expr="cast 2" line="8" static="1">
		<x path="lime.graphics.cairo.CairoLineJoin"/>
		<meta>
			<m n=":value"><e>cast 2</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</BEVEL>
	<meta>
		<m n=":final"/>
		<m n=":enum"/>
	</meta>
</class></impl>
	</abstract>
	<class path="lime.graphics.cairo._CairoLineJoin.CairoLineJoin_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/graphics/cairo/CairoLineJoin.hx" private="1" module="lime.graphics.cairo.CairoLineJoin" extern="1">
		<MITER public="1" get="inline" set="null" expr="cast 0" line="6" static="1">
			<x path="lime.graphics.cairo.CairoLineJoin"/>
			<meta>
				<m n=":value"><e>cast 0</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</MITER>
		<ROUND public="1" get="inline" set="null" expr="cast 1" line="7" static="1">
			<x path="lime.graphics.cairo.CairoLineJoin"/>
			<meta>
				<m n=":value"><e>cast 1</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</ROUND>
		<BEVEL public="1" get="inline" set="null" expr="cast 2" line="8" static="1">
			<x path="lime.graphics.cairo.CairoLineJoin"/>
			<meta>
				<m n=":value"><e>cast 2</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</BEVEL>
		<meta>
			<m n=":final"/>
			<m n=":enum"/>
		</meta>
	</class>
	<abstract path="lime.graphics.cairo.CairoOperator" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/graphics/cairo/CairoOperator.hx">
		<from>
			<icast><x path="UInt"/></icast>
			<icast><x path="Int"/></icast>
		</from>
		<this><x path="Int"/></this>
		<to>
			<icast><x path="UInt"/></icast>
			<icast><x path="Int"/></icast>
		</to>
		<meta><m n=":enum"/></meta>
		<impl><class path="lime.graphics.cairo._CairoOperator.CairoOperator_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/graphics/cairo/CairoOperator.hx" private="1" module="lime.graphics.cairo.CairoOperator" extern="1">
	<CLEAR public="1" get="inline" set="null" expr="cast 0" line="6" static="1">
		<x path="lime.graphics.cairo.CairoOperator"/>
		<meta>
			<m n=":value"><e>cast 0</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</CLEAR>
	<SOURCE public="1" get="inline" set="null" expr="cast 1" line="7" static="1">
		<x path="lime.graphics.cairo.CairoOperator"/>
		<meta>
			<m n=":value"><e>cast 1</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</SOURCE>
	<OVER public="1" get="inline" set="null" expr="cast 2" line="8" static="1">
		<x path="lime.graphics.cairo.CairoOperator"/>
		<meta>
			<m n=":value"><e>cast 2</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</OVER>
	<IN public="1" get="inline" set="null" expr="cast 3" line="9" static="1">
		<x path="lime.graphics.cairo.CairoOperator"/>
		<meta>
			<m n=":value"><e>cast 3</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</IN>
	<OUT public="1" get="inline" set="null" expr="cast 4" line="10" static="1">
		<x path="lime.graphics.cairo.CairoOperator"/>
		<meta>
			<m n=":value"><e>cast 4</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</OUT>
	<ATOP public="1" get="inline" set="null" expr="cast 5" line="11" static="1">
		<x path="lime.graphics.cairo.CairoOperator"/>
		<meta>
			<m n=":value"><e>cast 5</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</ATOP>
	<DEST public="1" get="inline" set="null" expr="cast 6" line="12" static="1">
		<x path="lime.graphics.cairo.CairoOperator"/>
		<meta>
			<m n=":value"><e>cast 6</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</DEST>
	<DEST_OVER public="1" get="inline" set="null" expr="cast 7" line="13" static="1">
		<x path="lime.graphics.cairo.CairoOperator"/>
		<meta>
			<m n=":value"><e>cast 7</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</DEST_OVER>
	<DEST_IN public="1" get="inline" set="null" expr="cast 8" line="14" static="1">
		<x path="lime.graphics.cairo.CairoOperator"/>
		<meta>
			<m n=":value"><e>cast 8</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</DEST_IN>
	<DEST_OUT public="1" get="inline" set="null" expr="cast 9" line="15" static="1">
		<x path="lime.graphics.cairo.CairoOperator"/>
		<meta>
			<m n=":value"><e>cast 9</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</DEST_OUT>
	<DEST_ATOP public="1" get="inline" set="null" expr="cast 10" line="16" static="1">
		<x path="lime.graphics.cairo.CairoOperator"/>
		<meta>
			<m n=":value"><e>cast 10</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</DEST_ATOP>
	<XOR public="1" get="inline" set="null" expr="cast 11" line="17" static="1">
		<x path="lime.graphics.cairo.CairoOperator"/>
		<meta>
			<m n=":value"><e>cast 11</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</XOR>
	<ADD public="1" get="inline" set="null" expr="cast 12" line="18" static="1">
		<x path="lime.graphics.cairo.CairoOperator"/>
		<meta>
			<m n=":value"><e>cast 12</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</ADD>
	<SATURATE public="1" get="inline" set="null" expr="cast 13" line="19" static="1">
		<x path="lime.graphics.cairo.CairoOperator"/>
		<meta>
			<m n=":value"><e>cast 13</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</SATURATE>
	<MULTIPLY public="1" get="inline" set="null" expr="cast 14" line="20" static="1">
		<x path="lime.graphics.cairo.CairoOperator"/>
		<meta>
			<m n=":value"><e>cast 14</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</MULTIPLY>
	<SCREEN public="1" get="inline" set="null" expr="cast 15" line="21" static="1">
		<x path="lime.graphics.cairo.CairoOperator"/>
		<meta>
			<m n=":value"><e>cast 15</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</SCREEN>
	<OVERLAY public="1" get="inline" set="null" expr="cast 16" line="22" static="1">
		<x path="lime.graphics.cairo.CairoOperator"/>
		<meta>
			<m n=":value"><e>cast 16</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</OVERLAY>
	<DARKEN public="1" get="inline" set="null" expr="cast 17" line="23" static="1">
		<x path="lime.graphics.cairo.CairoOperator"/>
		<meta>
			<m n=":value"><e>cast 17</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</DARKEN>
	<LIGHTEN public="1" get="inline" set="null" expr="cast 18" line="24" static="1">
		<x path="lime.graphics.cairo.CairoOperator"/>
		<meta>
			<m n=":value"><e>cast 18</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</LIGHTEN>
	<COLOR_DODGE public="1" get="inline" set="null" expr="cast 19" line="25" static="1">
		<x path="lime.graphics.cairo.CairoOperator"/>
		<meta>
			<m n=":value"><e>cast 19</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</COLOR_DODGE>
	<COLOR_BURN public="1" get="inline" set="null" expr="cast 20" line="26" static="1">
		<x path="lime.graphics.cairo.CairoOperator"/>
		<meta>
			<m n=":value"><e>cast 20</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</COLOR_BURN>
	<HARD_LIGHT public="1" get="inline" set="null" expr="cast 21" line="27" static="1">
		<x path="lime.graphics.cairo.CairoOperator"/>
		<meta>
			<m n=":value"><e>cast 21</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</HARD_LIGHT>
	<SOFT_LIGHT public="1" get="inline" set="null" expr="cast 22" line="28" static="1">
		<x path="lime.graphics.cairo.CairoOperator"/>
		<meta>
			<m n=":value"><e>cast 22</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</SOFT_LIGHT>
	<DIFFERENCE public="1" get="inline" set="null" expr="cast 23" line="29" static="1">
		<x path="lime.graphics.cairo.CairoOperator"/>
		<meta>
			<m n=":value"><e>cast 23</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</DIFFERENCE>
	<EXCLUSION public="1" get="inline" set="null" expr="cast 24" line="30" static="1">
		<x path="lime.graphics.cairo.CairoOperator"/>
		<meta>
			<m n=":value"><e>cast 24</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</EXCLUSION>
	<HSL_HUE public="1" get="inline" set="null" expr="cast 25" line="31" static="1">
		<x path="lime.graphics.cairo.CairoOperator"/>
		<meta>
			<m n=":value"><e>cast 25</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</HSL_HUE>
	<HSL_SATURATION public="1" get="inline" set="null" expr="cast 26" line="32" static="1">
		<x path="lime.graphics.cairo.CairoOperator"/>
		<meta>
			<m n=":value"><e>cast 26</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</HSL_SATURATION>
	<HSL_COLOR public="1" get="inline" set="null" expr="cast 27" line="33" static="1">
		<x path="lime.graphics.cairo.CairoOperator"/>
		<meta>
			<m n=":value"><e>cast 27</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</HSL_COLOR>
	<HSL_LUMINOSITY public="1" get="inline" set="null" expr="cast 28" line="34" static="1">
		<x path="lime.graphics.cairo.CairoOperator"/>
		<meta>
			<m n=":value"><e>cast 28</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</HSL_LUMINOSITY>
	<meta>
		<m n=":final"/>
		<m n=":enum"/>
	</meta>
</class></impl>
	</abstract>
	<class path="lime.graphics.cairo._CairoOperator.CairoOperator_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/graphics/cairo/CairoOperator.hx" private="1" module="lime.graphics.cairo.CairoOperator" extern="1">
		<CLEAR public="1" get="inline" set="null" expr="cast 0" line="6" static="1">
			<x path="lime.graphics.cairo.CairoOperator"/>
			<meta>
				<m n=":value"><e>cast 0</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</CLEAR>
		<SOURCE public="1" get="inline" set="null" expr="cast 1" line="7" static="1">
			<x path="lime.graphics.cairo.CairoOperator"/>
			<meta>
				<m n=":value"><e>cast 1</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</SOURCE>
		<OVER public="1" get="inline" set="null" expr="cast 2" line="8" static="1">
			<x path="lime.graphics.cairo.CairoOperator"/>
			<meta>
				<m n=":value"><e>cast 2</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</OVER>
		<IN public="1" get="inline" set="null" expr="cast 3" line="9" static="1">
			<x path="lime.graphics.cairo.CairoOperator"/>
			<meta>
				<m n=":value"><e>cast 3</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</IN>
		<OUT public="1" get="inline" set="null" expr="cast 4" line="10" static="1">
			<x path="lime.graphics.cairo.CairoOperator"/>
			<meta>
				<m n=":value"><e>cast 4</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</OUT>
		<ATOP public="1" get="inline" set="null" expr="cast 5" line="11" static="1">
			<x path="lime.graphics.cairo.CairoOperator"/>
			<meta>
				<m n=":value"><e>cast 5</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</ATOP>
		<DEST public="1" get="inline" set="null" expr="cast 6" line="12" static="1">
			<x path="lime.graphics.cairo.CairoOperator"/>
			<meta>
				<m n=":value"><e>cast 6</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</DEST>
		<DEST_OVER public="1" get="inline" set="null" expr="cast 7" line="13" static="1">
			<x path="lime.graphics.cairo.CairoOperator"/>
			<meta>
				<m n=":value"><e>cast 7</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</DEST_OVER>
		<DEST_IN public="1" get="inline" set="null" expr="cast 8" line="14" static="1">
			<x path="lime.graphics.cairo.CairoOperator"/>
			<meta>
				<m n=":value"><e>cast 8</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</DEST_IN>
		<DEST_OUT public="1" get="inline" set="null" expr="cast 9" line="15" static="1">
			<x path="lime.graphics.cairo.CairoOperator"/>
			<meta>
				<m n=":value"><e>cast 9</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</DEST_OUT>
		<DEST_ATOP public="1" get="inline" set="null" expr="cast 10" line="16" static="1">
			<x path="lime.graphics.cairo.CairoOperator"/>
			<meta>
				<m n=":value"><e>cast 10</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</DEST_ATOP>
		<XOR public="1" get="inline" set="null" expr="cast 11" line="17" static="1">
			<x path="lime.graphics.cairo.CairoOperator"/>
			<meta>
				<m n=":value"><e>cast 11</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</XOR>
		<ADD public="1" get="inline" set="null" expr="cast 12" line="18" static="1">
			<x path="lime.graphics.cairo.CairoOperator"/>
			<meta>
				<m n=":value"><e>cast 12</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</ADD>
		<SATURATE public="1" get="inline" set="null" expr="cast 13" line="19" static="1">
			<x path="lime.graphics.cairo.CairoOperator"/>
			<meta>
				<m n=":value"><e>cast 13</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</SATURATE>
		<MULTIPLY public="1" get="inline" set="null" expr="cast 14" line="20" static="1">
			<x path="lime.graphics.cairo.CairoOperator"/>
			<meta>
				<m n=":value"><e>cast 14</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</MULTIPLY>
		<SCREEN public="1" get="inline" set="null" expr="cast 15" line="21" static="1">
			<x path="lime.graphics.cairo.CairoOperator"/>
			<meta>
				<m n=":value"><e>cast 15</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</SCREEN>
		<OVERLAY public="1" get="inline" set="null" expr="cast 16" line="22" static="1">
			<x path="lime.graphics.cairo.CairoOperator"/>
			<meta>
				<m n=":value"><e>cast 16</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</OVERLAY>
		<DARKEN public="1" get="inline" set="null" expr="cast 17" line="23" static="1">
			<x path="lime.graphics.cairo.CairoOperator"/>
			<meta>
				<m n=":value"><e>cast 17</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</DARKEN>
		<LIGHTEN public="1" get="inline" set="null" expr="cast 18" line="24" static="1">
			<x path="lime.graphics.cairo.CairoOperator"/>
			<meta>
				<m n=":value"><e>cast 18</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</LIGHTEN>
		<COLOR_DODGE public="1" get="inline" set="null" expr="cast 19" line="25" static="1">
			<x path="lime.graphics.cairo.CairoOperator"/>
			<meta>
				<m n=":value"><e>cast 19</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</COLOR_DODGE>
		<COLOR_BURN public="1" get="inline" set="null" expr="cast 20" line="26" static="1">
			<x path="lime.graphics.cairo.CairoOperator"/>
			<meta>
				<m n=":value"><e>cast 20</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</COLOR_BURN>
		<HARD_LIGHT public="1" get="inline" set="null" expr="cast 21" line="27" static="1">
			<x path="lime.graphics.cairo.CairoOperator"/>
			<meta>
				<m n=":value"><e>cast 21</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</HARD_LIGHT>
		<SOFT_LIGHT public="1" get="inline" set="null" expr="cast 22" line="28" static="1">
			<x path="lime.graphics.cairo.CairoOperator"/>
			<meta>
				<m n=":value"><e>cast 22</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</SOFT_LIGHT>
		<DIFFERENCE public="1" get="inline" set="null" expr="cast 23" line="29" static="1">
			<x path="lime.graphics.cairo.CairoOperator"/>
			<meta>
				<m n=":value"><e>cast 23</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</DIFFERENCE>
		<EXCLUSION public="1" get="inline" set="null" expr="cast 24" line="30" static="1">
			<x path="lime.graphics.cairo.CairoOperator"/>
			<meta>
				<m n=":value"><e>cast 24</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</EXCLUSION>
		<HSL_HUE public="1" get="inline" set="null" expr="cast 25" line="31" static="1">
			<x path="lime.graphics.cairo.CairoOperator"/>
			<meta>
				<m n=":value"><e>cast 25</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</HSL_HUE>
		<HSL_SATURATION public="1" get="inline" set="null" expr="cast 26" line="32" static="1">
			<x path="lime.graphics.cairo.CairoOperator"/>
			<meta>
				<m n=":value"><e>cast 26</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</HSL_SATURATION>
		<HSL_COLOR public="1" get="inline" set="null" expr="cast 27" line="33" static="1">
			<x path="lime.graphics.cairo.CairoOperator"/>
			<meta>
				<m n=":value"><e>cast 27</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</HSL_COLOR>
		<HSL_LUMINOSITY public="1" get="inline" set="null" expr="cast 28" line="34" static="1">
			<x path="lime.graphics.cairo.CairoOperator"/>
			<meta>
				<m n=":value"><e>cast 28</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</HSL_LUMINOSITY>
		<meta>
			<m n=":final"/>
			<m n=":enum"/>
		</meta>
	</class>
	<abstract path="lime.graphics.cairo.CairoPattern" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/graphics/cairo/CairoPattern.hx">
		<from><icast><x path="lime.system.CFFIPointer"/></icast></from>
		<this><x path="lime.system.CFFIPointer"/></this>
		<to><icast><x path="lime.system.CFFIPointer"/></icast></to>
		<meta><m n=":build"><e>lime.system.CFFI.build()</e></m></meta>
		<impl><class path="lime.graphics.cairo._CairoPattern.CairoPattern_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/graphics/cairo/CairoPattern.hx" private="1" module="lime.graphics.cairo.CairoPattern">
	<colorStopCount public="1" get="accessor" set="null" static="1">
		<x path="Int"/>
		<meta><m n=":impl"/></meta>
	</colorStopCount>
	<extend public="1" get="accessor" set="accessor" static="1">
		<x path="lime.graphics.cairo.CairoExtend"/>
		<meta><m n=":impl"/></meta>
	</extend>
	<filter public="1" get="accessor" set="accessor" static="1">
		<x path="lime.graphics.cairo.CairoFilter"/>
		<meta><m n=":impl"/></meta>
	</filter>
	<matrix public="1" get="accessor" set="accessor" static="1">
		<c path="lime.math.Matrix3"/>
		<meta><m n=":impl"/></meta>
	</matrix>
	<_new public="1" set="method" line="21" static="1">
		<f a="handle">
			<x path="lime.system.CFFIPointer"/>
			<x path="lime.graphics.cairo.CairoPattern"/>
		</f>
		<meta><m n=":impl"/></meta>
	</_new>
	<addColorStopRGB public="1" set="method" line="28" static="1">
		<f a="this:offset:r:g:b">
			<x path="lime.system.CFFIPointer"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Void"/>
		</f>
		<meta><m n=":impl"/></meta>
	</addColorStopRGB>
	<addColorStopRGBA public="1" set="method" line="37" static="1">
		<f a="this:offset:r:g:b:a">
			<x path="lime.system.CFFIPointer"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Void"/>
		</f>
		<meta><m n=":impl"/></meta>
	</addColorStopRGBA>
	<createForSurface public="1" set="method" line="46" static="1"><f a="surface">
	<x path="lime.graphics.cairo.CairoSurface"/>
	<x path="lime.graphics.cairo.CairoPattern"/>
</f></createForSurface>
	<createLinear public="1" set="method" line="57" static="1"><f a="x0:y0:x1:y1">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="lime.graphics.cairo.CairoPattern"/>
</f></createLinear>
	<createRadial public="1" set="method" line="68" static="1"><f a="cx0:cy0:radius0:cx1:cy1:radius1">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="lime.graphics.cairo.CairoPattern"/>
</f></createRadial>
	<createRGB public="1" set="method" line="79" static="1"><f a="r:g:b">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="lime.graphics.cairo.CairoPattern"/>
</f></createRGB>
	<createRGBA public="1" set="method" line="90" static="1"><f a="r:g:b:a">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="lime.graphics.cairo.CairoPattern"/>
</f></createRGBA>
	<get_colorStopCount set="method" line="108" static="1">
		<f a="this">
			<x path="lime.system.CFFIPointer"/>
			<x path="Int"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
	</get_colorStopCount>
	<get_extend set="method" line="119" static="1">
		<f a="this">
			<x path="lime.system.CFFIPointer"/>
			<x path="lime.graphics.cairo.CairoExtend"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
	</get_extend>
	<set_extend set="method" line="130" static="1">
		<f a="this:value">
			<x path="lime.system.CFFIPointer"/>
			<x path="lime.graphics.cairo.CairoExtend"/>
			<x path="lime.graphics.cairo.CairoExtend"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
	</set_extend>
	<get_filter set="method" line="141" static="1">
		<f a="this">
			<x path="lime.system.CFFIPointer"/>
			<x path="lime.graphics.cairo.CairoFilter"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
	</get_filter>
	<set_filter set="method" line="152" static="1">
		<f a="this:value">
			<x path="lime.system.CFFIPointer"/>
			<x path="lime.graphics.cairo.CairoFilter"/>
			<x path="lime.graphics.cairo.CairoFilter"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
	</set_filter>
	<get_matrix set="method" line="163" static="1">
		<f a="this">
			<x path="lime.system.CFFIPointer"/>
			<c path="lime.math.Matrix3"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
	</get_matrix>
	<set_matrix set="method" line="175" static="1">
		<f a="this:value">
			<x path="lime.system.CFFIPointer"/>
			<c path="lime.math.Matrix3"/>
			<c path="lime.math.Matrix3"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
	</set_matrix>
	<meta>
		<m n=":directlyUsed"/>
		<m n=":final"/>
		<m n=":build"><e>lime.system.CFFI.build()</e></m>
	</meta>
</class></impl>
	</abstract>
	<class path="lime.graphics.cairo._CairoPattern.CairoPattern_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/graphics/cairo/CairoPattern.hx" private="1" module="lime.graphics.cairo.CairoPattern">
		<colorStopCount public="1" get="accessor" set="null" static="1">
			<x path="Int"/>
			<meta><m n=":impl"/></meta>
		</colorStopCount>
		<extend public="1" get="accessor" set="accessor" static="1">
			<x path="lime.graphics.cairo.CairoExtend"/>
			<meta><m n=":impl"/></meta>
		</extend>
		<filter public="1" get="accessor" set="accessor" static="1">
			<x path="lime.graphics.cairo.CairoFilter"/>
			<meta><m n=":impl"/></meta>
		</filter>
		<matrix public="1" get="accessor" set="accessor" static="1">
			<c path="lime.math.Matrix3"/>
			<meta><m n=":impl"/></meta>
		</matrix>
		<_new public="1" set="method" line="21" static="1">
			<f a="handle">
				<x path="lime.system.CFFIPointer"/>
				<x path="lime.graphics.cairo.CairoPattern"/>
			</f>
			<meta><m n=":impl"/></meta>
		</_new>
		<addColorStopRGB public="1" set="method" line="28" static="1">
			<f a="this:offset:r:g:b">
				<x path="lime.system.CFFIPointer"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":impl"/></meta>
		</addColorStopRGB>
		<addColorStopRGBA public="1" set="method" line="37" static="1">
			<f a="this:offset:r:g:b:a">
				<x path="lime.system.CFFIPointer"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":impl"/></meta>
		</addColorStopRGBA>
		<createForSurface public="1" set="method" line="46" static="1"><f a="surface">
	<x path="lime.graphics.cairo.CairoSurface"/>
	<x path="lime.graphics.cairo.CairoPattern"/>
</f></createForSurface>
		<createLinear public="1" set="method" line="57" static="1"><f a="x0:y0:x1:y1">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="lime.graphics.cairo.CairoPattern"/>
</f></createLinear>
		<createRadial public="1" set="method" line="68" static="1"><f a="cx0:cy0:radius0:cx1:cy1:radius1">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="lime.graphics.cairo.CairoPattern"/>
</f></createRadial>
		<createRGB public="1" set="method" line="79" static="1"><f a="r:g:b">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="lime.graphics.cairo.CairoPattern"/>
</f></createRGB>
		<createRGBA public="1" set="method" line="90" static="1"><f a="r:g:b:a">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="lime.graphics.cairo.CairoPattern"/>
</f></createRGBA>
		<get_colorStopCount set="method" line="108" static="1">
			<f a="this">
				<x path="lime.system.CFFIPointer"/>
				<x path="Int"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
		</get_colorStopCount>
		<get_extend set="method" line="119" static="1">
			<f a="this">
				<x path="lime.system.CFFIPointer"/>
				<x path="lime.graphics.cairo.CairoExtend"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
		</get_extend>
		<set_extend set="method" line="130" static="1">
			<f a="this:value">
				<x path="lime.system.CFFIPointer"/>
				<x path="lime.graphics.cairo.CairoExtend"/>
				<x path="lime.graphics.cairo.CairoExtend"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
		</set_extend>
		<get_filter set="method" line="141" static="1">
			<f a="this">
				<x path="lime.system.CFFIPointer"/>
				<x path="lime.graphics.cairo.CairoFilter"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
		</get_filter>
		<set_filter set="method" line="152" static="1">
			<f a="this:value">
				<x path="lime.system.CFFIPointer"/>
				<x path="lime.graphics.cairo.CairoFilter"/>
				<x path="lime.graphics.cairo.CairoFilter"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
		</set_filter>
		<get_matrix set="method" line="163" static="1">
			<f a="this">
				<x path="lime.system.CFFIPointer"/>
				<c path="lime.math.Matrix3"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
		</get_matrix>
		<set_matrix set="method" line="175" static="1">
			<f a="this:value">
				<x path="lime.system.CFFIPointer"/>
				<c path="lime.math.Matrix3"/>
				<c path="lime.math.Matrix3"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
		</set_matrix>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":final"/>
			<m n=":build"><e>lime.system.CFFI.build()</e></m>
		</meta>
	</class>
	<abstract path="lime.graphics.cairo.CairoStatus" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/graphics/cairo/CairoStatus.hx">
		<from>
			<icast><x path="UInt"/></icast>
			<icast><x path="Int"/></icast>
		</from>
		<this><x path="Int"/></this>
		<to>
			<icast><x path="UInt"/></icast>
			<icast><x path="Int"/></icast>
		</to>
		<meta><m n=":enum"/></meta>
		<impl><class path="lime.graphics.cairo._CairoStatus.CairoStatus_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/graphics/cairo/CairoStatus.hx" private="1" module="lime.graphics.cairo.CairoStatus" extern="1">
	<SUCCESS public="1" get="inline" set="null" expr="cast 0" line="6" static="1">
		<x path="lime.graphics.cairo.CairoStatus"/>
		<meta>
			<m n=":value"><e>cast 0</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</SUCCESS>
	<NO_MEMORY public="1" get="inline" set="null" expr="cast 1" line="7" static="1">
		<x path="lime.graphics.cairo.CairoStatus"/>
		<meta>
			<m n=":value"><e>cast 1</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NO_MEMORY>
	<INVALID_RESTORE public="1" get="inline" set="null" expr="cast 2" line="8" static="1">
		<x path="lime.graphics.cairo.CairoStatus"/>
		<meta>
			<m n=":value"><e>cast 2</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</INVALID_RESTORE>
	<INVALID_POP_GROUP public="1" get="inline" set="null" expr="cast 3" line="9" static="1">
		<x path="lime.graphics.cairo.CairoStatus"/>
		<meta>
			<m n=":value"><e>cast 3</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</INVALID_POP_GROUP>
	<NO_CURRENT_POINT public="1" get="inline" set="null" expr="cast 4" line="10" static="1">
		<x path="lime.graphics.cairo.CairoStatus"/>
		<meta>
			<m n=":value"><e>cast 4</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NO_CURRENT_POINT>
	<INVALID_MATRIX public="1" get="inline" set="null" expr="cast 5" line="11" static="1">
		<x path="lime.graphics.cairo.CairoStatus"/>
		<meta>
			<m n=":value"><e>cast 5</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</INVALID_MATRIX>
	<INVALID_STATUS public="1" get="inline" set="null" expr="cast 6" line="12" static="1">
		<x path="lime.graphics.cairo.CairoStatus"/>
		<meta>
			<m n=":value"><e>cast 6</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</INVALID_STATUS>
	<NULL_POINTER public="1" get="inline" set="null" expr="cast 7" line="13" static="1">
		<x path="lime.graphics.cairo.CairoStatus"/>
		<meta>
			<m n=":value"><e>cast 7</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NULL_POINTER>
	<INVALID_STRING public="1" get="inline" set="null" expr="cast 8" line="14" static="1">
		<x path="lime.graphics.cairo.CairoStatus"/>
		<meta>
			<m n=":value"><e>cast 8</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</INVALID_STRING>
	<INVALID_PATH_DATA public="1" get="inline" set="null" expr="cast 9" line="15" static="1">
		<x path="lime.graphics.cairo.CairoStatus"/>
		<meta>
			<m n=":value"><e>cast 9</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</INVALID_PATH_DATA>
	<READ_ERROR public="1" get="inline" set="null" expr="cast 10" line="16" static="1">
		<x path="lime.graphics.cairo.CairoStatus"/>
		<meta>
			<m n=":value"><e>cast 10</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</READ_ERROR>
	<WRITE_ERROR public="1" get="inline" set="null" expr="cast 11" line="17" static="1">
		<x path="lime.graphics.cairo.CairoStatus"/>
		<meta>
			<m n=":value"><e>cast 11</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</WRITE_ERROR>
	<SURFACE_FINISHED public="1" get="inline" set="null" expr="cast 12" line="18" static="1">
		<x path="lime.graphics.cairo.CairoStatus"/>
		<meta>
			<m n=":value"><e>cast 12</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</SURFACE_FINISHED>
	<SURFACE_TYPE_MISMATCH public="1" get="inline" set="null" expr="cast 13" line="19" static="1">
		<x path="lime.graphics.cairo.CairoStatus"/>
		<meta>
			<m n=":value"><e>cast 13</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</SURFACE_TYPE_MISMATCH>
	<PATTERN_TYPE_MISMATCH public="1" get="inline" set="null" expr="cast 14" line="20" static="1">
		<x path="lime.graphics.cairo.CairoStatus"/>
		<meta>
			<m n=":value"><e>cast 14</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</PATTERN_TYPE_MISMATCH>
	<INVALID_CONTENT public="1" get="inline" set="null" expr="cast 15" line="21" static="1">
		<x path="lime.graphics.cairo.CairoStatus"/>
		<meta>
			<m n=":value"><e>cast 15</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</INVALID_CONTENT>
	<INVALID_FORMAT public="1" get="inline" set="null" expr="cast 16" line="22" static="1">
		<x path="lime.graphics.cairo.CairoStatus"/>
		<meta>
			<m n=":value"><e>cast 16</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</INVALID_FORMAT>
	<INVALID_VISUAL public="1" get="inline" set="null" expr="cast 17" line="23" static="1">
		<x path="lime.graphics.cairo.CairoStatus"/>
		<meta>
			<m n=":value"><e>cast 17</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</INVALID_VISUAL>
	<FILE_NOT_FOUND public="1" get="inline" set="null" expr="cast 18" line="24" static="1">
		<x path="lime.graphics.cairo.CairoStatus"/>
		<meta>
			<m n=":value"><e>cast 18</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</FILE_NOT_FOUND>
	<INVALID_DASH public="1" get="inline" set="null" expr="cast 19" line="25" static="1">
		<x path="lime.graphics.cairo.CairoStatus"/>
		<meta>
			<m n=":value"><e>cast 19</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</INVALID_DASH>
	<INVALID_DSC_COMMENT public="1" get="inline" set="null" expr="cast 20" line="26" static="1">
		<x path="lime.graphics.cairo.CairoStatus"/>
		<meta>
			<m n=":value"><e>cast 20</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</INVALID_DSC_COMMENT>
	<INVALID_INDEX public="1" get="inline" set="null" expr="cast 21" line="27" static="1">
		<x path="lime.graphics.cairo.CairoStatus"/>
		<meta>
			<m n=":value"><e>cast 21</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</INVALID_INDEX>
	<CLIP_NOT_REPRESENTABLE public="1" get="inline" set="null" expr="cast 22" line="28" static="1">
		<x path="lime.graphics.cairo.CairoStatus"/>
		<meta>
			<m n=":value"><e>cast 22</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</CLIP_NOT_REPRESENTABLE>
	<TEMP_FILE_ERROR public="1" get="inline" set="null" expr="cast 23" line="29" static="1">
		<x path="lime.graphics.cairo.CairoStatus"/>
		<meta>
			<m n=":value"><e>cast 23</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</TEMP_FILE_ERROR>
	<INVALID_STRIDE public="1" get="inline" set="null" expr="cast 24" line="30" static="1">
		<x path="lime.graphics.cairo.CairoStatus"/>
		<meta>
			<m n=":value"><e>cast 24</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</INVALID_STRIDE>
	<FONT_TYPE_MISMATCH public="1" get="inline" set="null" expr="cast 25" line="31" static="1">
		<x path="lime.graphics.cairo.CairoStatus"/>
		<meta>
			<m n=":value"><e>cast 25</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</FONT_TYPE_MISMATCH>
	<USER_FONT_IMMUTABLE public="1" get="inline" set="null" expr="cast 26" line="32" static="1">
		<x path="lime.graphics.cairo.CairoStatus"/>
		<meta>
			<m n=":value"><e>cast 26</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</USER_FONT_IMMUTABLE>
	<USER_FONT_ERROR public="1" get="inline" set="null" expr="cast 27" line="33" static="1">
		<x path="lime.graphics.cairo.CairoStatus"/>
		<meta>
			<m n=":value"><e>cast 27</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</USER_FONT_ERROR>
	<NEGATIVE_COUNT public="1" get="inline" set="null" expr="cast 28" line="34" static="1">
		<x path="lime.graphics.cairo.CairoStatus"/>
		<meta>
			<m n=":value"><e>cast 28</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NEGATIVE_COUNT>
	<INVALID_CLUSTERS public="1" get="inline" set="null" expr="cast 29" line="35" static="1">
		<x path="lime.graphics.cairo.CairoStatus"/>
		<meta>
			<m n=":value"><e>cast 29</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</INVALID_CLUSTERS>
	<INVALID_SLANT public="1" get="inline" set="null" expr="cast 30" line="36" static="1">
		<x path="lime.graphics.cairo.CairoStatus"/>
		<meta>
			<m n=":value"><e>cast 30</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</INVALID_SLANT>
	<INVALID_WEIGHT public="1" get="inline" set="null" expr="cast 31" line="37" static="1">
		<x path="lime.graphics.cairo.CairoStatus"/>
		<meta>
			<m n=":value"><e>cast 31</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</INVALID_WEIGHT>
	<INVALID_SIZE public="1" get="inline" set="null" expr="cast 32" line="38" static="1">
		<x path="lime.graphics.cairo.CairoStatus"/>
		<meta>
			<m n=":value"><e>cast 32</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</INVALID_SIZE>
	<USER_FONT_NOT_IMPLEMENTED public="1" get="inline" set="null" expr="cast 33" line="39" static="1">
		<x path="lime.graphics.cairo.CairoStatus"/>
		<meta>
			<m n=":value"><e>cast 33</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</USER_FONT_NOT_IMPLEMENTED>
	<DEVICE_TYPE_MISMATCH public="1" get="inline" set="null" expr="cast 34" line="40" static="1">
		<x path="lime.graphics.cairo.CairoStatus"/>
		<meta>
			<m n=":value"><e>cast 34</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</DEVICE_TYPE_MISMATCH>
	<DEVICE_ERROR public="1" get="inline" set="null" expr="cast 35" line="41" static="1">
		<x path="lime.graphics.cairo.CairoStatus"/>
		<meta>
			<m n=":value"><e>cast 35</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</DEVICE_ERROR>
	<INVALID_MESH_CONSTRUCTION public="1" get="inline" set="null" expr="cast 36" line="42" static="1">
		<x path="lime.graphics.cairo.CairoStatus"/>
		<meta>
			<m n=":value"><e>cast 36</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</INVALID_MESH_CONSTRUCTION>
	<DEVICE_FINISHED public="1" get="inline" set="null" expr="cast 37" line="43" static="1">
		<x path="lime.graphics.cairo.CairoStatus"/>
		<meta>
			<m n=":value"><e>cast 37</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</DEVICE_FINISHED>
	<JBIG2_GLOBAL_MISSING public="1" get="inline" set="null" expr="cast 38" line="44" static="1">
		<x path="lime.graphics.cairo.CairoStatus"/>
		<meta>
			<m n=":value"><e>cast 38</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</JBIG2_GLOBAL_MISSING>
	<meta>
		<m n=":final"/>
		<m n=":enum"/>
	</meta>
</class></impl>
	</abstract>
	<class path="lime.graphics.cairo._CairoStatus.CairoStatus_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/graphics/cairo/CairoStatus.hx" private="1" module="lime.graphics.cairo.CairoStatus" extern="1">
		<SUCCESS public="1" get="inline" set="null" expr="cast 0" line="6" static="1">
			<x path="lime.graphics.cairo.CairoStatus"/>
			<meta>
				<m n=":value"><e>cast 0</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</SUCCESS>
		<NO_MEMORY public="1" get="inline" set="null" expr="cast 1" line="7" static="1">
			<x path="lime.graphics.cairo.CairoStatus"/>
			<meta>
				<m n=":value"><e>cast 1</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NO_MEMORY>
		<INVALID_RESTORE public="1" get="inline" set="null" expr="cast 2" line="8" static="1">
			<x path="lime.graphics.cairo.CairoStatus"/>
			<meta>
				<m n=":value"><e>cast 2</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</INVALID_RESTORE>
		<INVALID_POP_GROUP public="1" get="inline" set="null" expr="cast 3" line="9" static="1">
			<x path="lime.graphics.cairo.CairoStatus"/>
			<meta>
				<m n=":value"><e>cast 3</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</INVALID_POP_GROUP>
		<NO_CURRENT_POINT public="1" get="inline" set="null" expr="cast 4" line="10" static="1">
			<x path="lime.graphics.cairo.CairoStatus"/>
			<meta>
				<m n=":value"><e>cast 4</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NO_CURRENT_POINT>
		<INVALID_MATRIX public="1" get="inline" set="null" expr="cast 5" line="11" static="1">
			<x path="lime.graphics.cairo.CairoStatus"/>
			<meta>
				<m n=":value"><e>cast 5</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</INVALID_MATRIX>
		<INVALID_STATUS public="1" get="inline" set="null" expr="cast 6" line="12" static="1">
			<x path="lime.graphics.cairo.CairoStatus"/>
			<meta>
				<m n=":value"><e>cast 6</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</INVALID_STATUS>
		<NULL_POINTER public="1" get="inline" set="null" expr="cast 7" line="13" static="1">
			<x path="lime.graphics.cairo.CairoStatus"/>
			<meta>
				<m n=":value"><e>cast 7</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NULL_POINTER>
		<INVALID_STRING public="1" get="inline" set="null" expr="cast 8" line="14" static="1">
			<x path="lime.graphics.cairo.CairoStatus"/>
			<meta>
				<m n=":value"><e>cast 8</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</INVALID_STRING>
		<INVALID_PATH_DATA public="1" get="inline" set="null" expr="cast 9" line="15" static="1">
			<x path="lime.graphics.cairo.CairoStatus"/>
			<meta>
				<m n=":value"><e>cast 9</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</INVALID_PATH_DATA>
		<READ_ERROR public="1" get="inline" set="null" expr="cast 10" line="16" static="1">
			<x path="lime.graphics.cairo.CairoStatus"/>
			<meta>
				<m n=":value"><e>cast 10</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</READ_ERROR>
		<WRITE_ERROR public="1" get="inline" set="null" expr="cast 11" line="17" static="1">
			<x path="lime.graphics.cairo.CairoStatus"/>
			<meta>
				<m n=":value"><e>cast 11</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</WRITE_ERROR>
		<SURFACE_FINISHED public="1" get="inline" set="null" expr="cast 12" line="18" static="1">
			<x path="lime.graphics.cairo.CairoStatus"/>
			<meta>
				<m n=":value"><e>cast 12</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</SURFACE_FINISHED>
		<SURFACE_TYPE_MISMATCH public="1" get="inline" set="null" expr="cast 13" line="19" static="1">
			<x path="lime.graphics.cairo.CairoStatus"/>
			<meta>
				<m n=":value"><e>cast 13</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</SURFACE_TYPE_MISMATCH>
		<PATTERN_TYPE_MISMATCH public="1" get="inline" set="null" expr="cast 14" line="20" static="1">
			<x path="lime.graphics.cairo.CairoStatus"/>
			<meta>
				<m n=":value"><e>cast 14</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</PATTERN_TYPE_MISMATCH>
		<INVALID_CONTENT public="1" get="inline" set="null" expr="cast 15" line="21" static="1">
			<x path="lime.graphics.cairo.CairoStatus"/>
			<meta>
				<m n=":value"><e>cast 15</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</INVALID_CONTENT>
		<INVALID_FORMAT public="1" get="inline" set="null" expr="cast 16" line="22" static="1">
			<x path="lime.graphics.cairo.CairoStatus"/>
			<meta>
				<m n=":value"><e>cast 16</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</INVALID_FORMAT>
		<INVALID_VISUAL public="1" get="inline" set="null" expr="cast 17" line="23" static="1">
			<x path="lime.graphics.cairo.CairoStatus"/>
			<meta>
				<m n=":value"><e>cast 17</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</INVALID_VISUAL>
		<FILE_NOT_FOUND public="1" get="inline" set="null" expr="cast 18" line="24" static="1">
			<x path="lime.graphics.cairo.CairoStatus"/>
			<meta>
				<m n=":value"><e>cast 18</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</FILE_NOT_FOUND>
		<INVALID_DASH public="1" get="inline" set="null" expr="cast 19" line="25" static="1">
			<x path="lime.graphics.cairo.CairoStatus"/>
			<meta>
				<m n=":value"><e>cast 19</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</INVALID_DASH>
		<INVALID_DSC_COMMENT public="1" get="inline" set="null" expr="cast 20" line="26" static="1">
			<x path="lime.graphics.cairo.CairoStatus"/>
			<meta>
				<m n=":value"><e>cast 20</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</INVALID_DSC_COMMENT>
		<INVALID_INDEX public="1" get="inline" set="null" expr="cast 21" line="27" static="1">
			<x path="lime.graphics.cairo.CairoStatus"/>
			<meta>
				<m n=":value"><e>cast 21</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</INVALID_INDEX>
		<CLIP_NOT_REPRESENTABLE public="1" get="inline" set="null" expr="cast 22" line="28" static="1">
			<x path="lime.graphics.cairo.CairoStatus"/>
			<meta>
				<m n=":value"><e>cast 22</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</CLIP_NOT_REPRESENTABLE>
		<TEMP_FILE_ERROR public="1" get="inline" set="null" expr="cast 23" line="29" static="1">
			<x path="lime.graphics.cairo.CairoStatus"/>
			<meta>
				<m n=":value"><e>cast 23</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</TEMP_FILE_ERROR>
		<INVALID_STRIDE public="1" get="inline" set="null" expr="cast 24" line="30" static="1">
			<x path="lime.graphics.cairo.CairoStatus"/>
			<meta>
				<m n=":value"><e>cast 24</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</INVALID_STRIDE>
		<FONT_TYPE_MISMATCH public="1" get="inline" set="null" expr="cast 25" line="31" static="1">
			<x path="lime.graphics.cairo.CairoStatus"/>
			<meta>
				<m n=":value"><e>cast 25</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</FONT_TYPE_MISMATCH>
		<USER_FONT_IMMUTABLE public="1" get="inline" set="null" expr="cast 26" line="32" static="1">
			<x path="lime.graphics.cairo.CairoStatus"/>
			<meta>
				<m n=":value"><e>cast 26</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</USER_FONT_IMMUTABLE>
		<USER_FONT_ERROR public="1" get="inline" set="null" expr="cast 27" line="33" static="1">
			<x path="lime.graphics.cairo.CairoStatus"/>
			<meta>
				<m n=":value"><e>cast 27</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</USER_FONT_ERROR>
		<NEGATIVE_COUNT public="1" get="inline" set="null" expr="cast 28" line="34" static="1">
			<x path="lime.graphics.cairo.CairoStatus"/>
			<meta>
				<m n=":value"><e>cast 28</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NEGATIVE_COUNT>
		<INVALID_CLUSTERS public="1" get="inline" set="null" expr="cast 29" line="35" static="1">
			<x path="lime.graphics.cairo.CairoStatus"/>
			<meta>
				<m n=":value"><e>cast 29</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</INVALID_CLUSTERS>
		<INVALID_SLANT public="1" get="inline" set="null" expr="cast 30" line="36" static="1">
			<x path="lime.graphics.cairo.CairoStatus"/>
			<meta>
				<m n=":value"><e>cast 30</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</INVALID_SLANT>
		<INVALID_WEIGHT public="1" get="inline" set="null" expr="cast 31" line="37" static="1">
			<x path="lime.graphics.cairo.CairoStatus"/>
			<meta>
				<m n=":value"><e>cast 31</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</INVALID_WEIGHT>
		<INVALID_SIZE public="1" get="inline" set="null" expr="cast 32" line="38" static="1">
			<x path="lime.graphics.cairo.CairoStatus"/>
			<meta>
				<m n=":value"><e>cast 32</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</INVALID_SIZE>
		<USER_FONT_NOT_IMPLEMENTED public="1" get="inline" set="null" expr="cast 33" line="39" static="1">
			<x path="lime.graphics.cairo.CairoStatus"/>
			<meta>
				<m n=":value"><e>cast 33</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</USER_FONT_NOT_IMPLEMENTED>
		<DEVICE_TYPE_MISMATCH public="1" get="inline" set="null" expr="cast 34" line="40" static="1">
			<x path="lime.graphics.cairo.CairoStatus"/>
			<meta>
				<m n=":value"><e>cast 34</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</DEVICE_TYPE_MISMATCH>
		<DEVICE_ERROR public="1" get="inline" set="null" expr="cast 35" line="41" static="1">
			<x path="lime.graphics.cairo.CairoStatus"/>
			<meta>
				<m n=":value"><e>cast 35</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</DEVICE_ERROR>
		<INVALID_MESH_CONSTRUCTION public="1" get="inline" set="null" expr="cast 36" line="42" static="1">
			<x path="lime.graphics.cairo.CairoStatus"/>
			<meta>
				<m n=":value"><e>cast 36</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</INVALID_MESH_CONSTRUCTION>
		<DEVICE_FINISHED public="1" get="inline" set="null" expr="cast 37" line="43" static="1">
			<x path="lime.graphics.cairo.CairoStatus"/>
			<meta>
				<m n=":value"><e>cast 37</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</DEVICE_FINISHED>
		<JBIG2_GLOBAL_MISSING public="1" get="inline" set="null" expr="cast 38" line="44" static="1">
			<x path="lime.graphics.cairo.CairoStatus"/>
			<meta>
				<m n=":value"><e>cast 38</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</JBIG2_GLOBAL_MISSING>
		<meta>
			<m n=":final"/>
			<m n=":enum"/>
		</meta>
	</class>
	<abstract path="lime.graphics.cairo.CairoSubpixelOrder" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/graphics/cairo/CairoSubpixelOrder.hx">
		<from>
			<icast><x path="UInt"/></icast>
			<icast><x path="Int"/></icast>
		</from>
		<this><x path="Int"/></this>
		<to>
			<icast><x path="UInt"/></icast>
			<icast><x path="Int"/></icast>
		</to>
		<meta><m n=":enum"/></meta>
		<impl><class path="lime.graphics.cairo._CairoSubpixelOrder.CairoSubpixelOrder_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/graphics/cairo/CairoSubpixelOrder.hx" private="1" module="lime.graphics.cairo.CairoSubpixelOrder" extern="1">
	<DEFAULT public="1" get="inline" set="null" expr="cast 0" line="6" static="1">
		<x path="lime.graphics.cairo.CairoSubpixelOrder"/>
		<meta>
			<m n=":value"><e>cast 0</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</DEFAULT>
	<RGB public="1" get="inline" set="null" expr="cast 1" line="7" static="1">
		<x path="lime.graphics.cairo.CairoSubpixelOrder"/>
		<meta>
			<m n=":value"><e>cast 1</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</RGB>
	<BGR public="1" get="inline" set="null" expr="cast 2" line="8" static="1">
		<x path="lime.graphics.cairo.CairoSubpixelOrder"/>
		<meta>
			<m n=":value"><e>cast 2</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</BGR>
	<VRGB public="1" get="inline" set="null" expr="cast 3" line="9" static="1">
		<x path="lime.graphics.cairo.CairoSubpixelOrder"/>
		<meta>
			<m n=":value"><e>cast 3</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</VRGB>
	<VBGR public="1" get="inline" set="null" expr="cast 4" line="10" static="1">
		<x path="lime.graphics.cairo.CairoSubpixelOrder"/>
		<meta>
			<m n=":value"><e>cast 4</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</VBGR>
	<meta>
		<m n=":final"/>
		<m n=":enum"/>
	</meta>
</class></impl>
	</abstract>
	<class path="lime.graphics.cairo._CairoSubpixelOrder.CairoSubpixelOrder_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/graphics/cairo/CairoSubpixelOrder.hx" private="1" module="lime.graphics.cairo.CairoSubpixelOrder" extern="1">
		<DEFAULT public="1" get="inline" set="null" expr="cast 0" line="6" static="1">
			<x path="lime.graphics.cairo.CairoSubpixelOrder"/>
			<meta>
				<m n=":value"><e>cast 0</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</DEFAULT>
		<RGB public="1" get="inline" set="null" expr="cast 1" line="7" static="1">
			<x path="lime.graphics.cairo.CairoSubpixelOrder"/>
			<meta>
				<m n=":value"><e>cast 1</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</RGB>
		<BGR public="1" get="inline" set="null" expr="cast 2" line="8" static="1">
			<x path="lime.graphics.cairo.CairoSubpixelOrder"/>
			<meta>
				<m n=":value"><e>cast 2</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</BGR>
		<VRGB public="1" get="inline" set="null" expr="cast 3" line="9" static="1">
			<x path="lime.graphics.cairo.CairoSubpixelOrder"/>
			<meta>
				<m n=":value"><e>cast 3</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</VRGB>
		<VBGR public="1" get="inline" set="null" expr="cast 4" line="10" static="1">
			<x path="lime.graphics.cairo.CairoSubpixelOrder"/>
			<meta>
				<m n=":value"><e>cast 4</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</VBGR>
		<meta>
			<m n=":final"/>
			<m n=":enum"/>
		</meta>
	</class>
	<abstract path="lime.graphics.cairo.CairoSurface" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/graphics/cairo/CairoSurface.hx">
		<from><icast><x path="lime.system.CFFIPointer"/></icast></from>
		<this><x path="lime.system.CFFIPointer"/></this>
		<to><icast><x path="lime.system.CFFIPointer"/></icast></to>
		<meta><m n=":build"><e>lime.system.CFFI.build()</e></m></meta>
		<impl><class path="lime.graphics.cairo._CairoSurface.CairoSurface_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/graphics/cairo/CairoSurface.hx" private="1" module="lime.graphics.cairo.CairoSurface">
	<flush public="1" set="method" line="14" static="1">
		<f a="this">
			<x path="lime.system.CFFIPointer"/>
			<x path="Void"/>
		</f>
		<meta><m n=":impl"/></meta>
	</flush>
	<meta>
		<m n=":directlyUsed"/>
		<m n=":final"/>
		<m n=":build"><e>lime.system.CFFI.build()</e></m>
	</meta>
</class></impl>
	</abstract>
	<class path="lime.graphics.cairo._CairoSurface.CairoSurface_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/graphics/cairo/CairoSurface.hx" private="1" module="lime.graphics.cairo.CairoSurface">
		<flush public="1" set="method" line="14" static="1">
			<f a="this">
				<x path="lime.system.CFFIPointer"/>
				<x path="Void"/>
			</f>
			<meta><m n=":impl"/></meta>
		</flush>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":final"/>
			<m n=":build"><e>lime.system.CFFI.build()</e></m>
		</meta>
	</class>
	<class path="lime.graphics.console.IndexBuffer" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/graphics/console/IndexBuffer.hx">
		<new public="1" set="method" line="24"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<enum path="lime.graphics.console.Primitive" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/graphics/console/Primitive.hx">
		<Point/>
		<Line/>
		<LineStrip/>
		<Triangle/>
		<TriangleStrip/>
		<meta><m n=":flatEnum"/></meta>
	</enum>
	<class path="lime.graphics.console.Shader" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/graphics/console/Shader.hx">
		<new public="1" set="method" line="20"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="lime.graphics.console.VertexBuffer" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/graphics/console/VertexBuffer.hx">
		<lock public="1" set="method" line="28"><f a=""><c path="lime.graphics.console.VertexOutput"/></f></lock>
		<unlock public="1" set="method" line="29"><f a=""><x path="Void"/></f></unlock>
		<new public="1" set="method" line="26"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="lime.graphics.console.VertexOutput" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/graphics/console/VertexOutput.hx">
		<vec2 public="1" set="method" line="27"><f a="x:y">
	<unknown/>
	<unknown/>
	<x path="Void"/>
</f></vec2>
		<vec3 public="1" set="method" line="28"><f a="x:y:z">
	<unknown/>
	<unknown/>
	<unknown/>
	<x path="Void"/>
</f></vec3>
		<color public="1" set="method" line="29"><f a="r:g:b:a">
	<unknown/>
	<unknown/>
	<unknown/>
	<unknown/>
	<x path="Void"/>
</f></color>
		<new public="1" set="method" line="25"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="lime.graphics.format.BMP" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/graphics/format/BMP.hx">
		<encode public="1" set="method" line="12" static="1">
			<f a="image:?type" v=":null">
				<c path="lime.graphics.Image"/>
				<e path="lime.graphics.format.BMPType"/>
				<c path="haxe.io.Bytes"/>
			</f>
			<meta><m n=":value"><e>{ type : null }</e></m></meta>
		</encode>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<enum path="lime.graphics.format.BMPType" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/graphics/format/BMP.hx" module="lime.graphics.format.BMP">
		<RGB/>
		<BITFIELD/>
		<ICO/>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<class path="lime.graphics.format.JPEG" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/graphics/format/JPEG.hx">
		<decodeBytes public="1" set="method" line="24" static="1">
			<f a="bytes:?decodeData" v=":true">
				<c path="haxe.io.Bytes"/>
				<x path="Bool"/>
				<c path="lime.graphics.Image"/>
			</f>
			<meta><m n=":value"><e>{ decodeData : true }</e></m></meta>
		</decodeBytes>
		<decodeFile public="1" set="method" line="45" static="1">
			<f a="path:?decodeData" v=":true">
				<c path="String"/>
				<x path="Bool"/>
				<c path="lime.graphics.Image"/>
			</f>
			<meta><m n=":value"><e>{ decodeData : true }</e></m></meta>
		</decodeFile>
		<encode public="1" set="method" line="66" static="1"><f a="image:quality">
	<c path="lime.graphics.Image"/>
	<x path="Int"/>
	<c path="haxe.io.Bytes"/>
</f></encode>
		<lime_jpeg_decode_bytes get="inline" set="null" line="124" static="1">
			<f a="data:decodeData">
				<d/>
				<x path="Bool"/>
				<d/>
			</f>
			<meta><m n=":cffi"/></meta>
		</lime_jpeg_decode_bytes>
		<lime_jpeg_decode_file get="inline" set="null" line="125" static="1">
			<f a="path:decodeData">
				<c path="String"/>
				<x path="Bool"/>
				<d/>
			</f>
			<meta><m n=":cffi"/></meta>
		</lime_jpeg_decode_file>
		<lime_image_encode get="inline" set="null" line="126" static="1">
			<f a="data:type:quality">
				<d/>
				<x path="Int"/>
				<x path="Int"/>
				<d/>
			</f>
			<meta><m n=":cffi"/></meta>
		</lime_image_encode>
		<cffi_lime_jpeg_decode_bytes expr="new cpp.Callable&lt;Dynamic -&gt; Bool&gt;(lime.system.CFFI.load(&quot;lime&quot;, &quot;lime_jpeg_decode_bytes&quot;, 2, false))" line="124" static="1">
			<x path="cpp.Callable"><f a=":">
	<d/>
	<x path="Bool"/>
	<d/>
</f></x>
			<meta><m n=":value"><e><![CDATA[new cpp.Callable<Dynamic -> Bool>(lime.system.CFFI.load("lime", "lime_jpeg_decode_bytes", 2, false))]]></e></m></meta>
		</cffi_lime_jpeg_decode_bytes>
		<cffi_lime_jpeg_decode_file expr="new cpp.Callable&lt;String -&gt; Bool&gt;(lime.system.CFFI.load(&quot;lime&quot;, &quot;lime_jpeg_decode_file&quot;, 2, false))" line="125" static="1">
			<x path="cpp.Callable"><f a=":">
	<c path="String"/>
	<x path="Bool"/>
	<d/>
</f></x>
			<meta><m n=":value"><e><![CDATA[new cpp.Callable<String -> Bool>(lime.system.CFFI.load("lime", "lime_jpeg_decode_file", 2, false))]]></e></m></meta>
		</cffi_lime_jpeg_decode_file>
		<cffi_lime_image_encode expr="new cpp.Callable&lt;Dynamic -&gt; Int -&gt; Int&gt;(lime.system.CFFI.load(&quot;lime&quot;, &quot;lime_image_encode&quot;, 3, false))" line="126" static="1">
			<x path="cpp.Callable"><f a="::">
	<d/>
	<x path="Int"/>
	<x path="Int"/>
	<d/>
</f></x>
			<meta><m n=":value"><e><![CDATA[new cpp.Callable<Dynamic -> Int -> Int>(lime.system.CFFI.load("lime", "lime_image_encode", 3, false))]]></e></m></meta>
		</cffi_lime_image_encode>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":access"><e>lime.graphics.ImageBuffer</e></m>
			<m n=":build"><e>lime.system.CFFI.build()</e></m>
		</meta>
	</class>
	<class path="lime.graphics.format.PNG" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/graphics/format/PNG.hx">
		<decodeBytes public="1" set="method" line="30" static="1">
			<f a="bytes:?decodeData" v=":true">
				<c path="haxe.io.Bytes"/>
				<x path="Bool"/>
				<c path="lime.graphics.Image"/>
			</f>
			<meta><m n=":value"><e>{ decodeData : true }</e></m></meta>
		</decodeBytes>
		<decodeFile public="1" set="method" line="51" static="1">
			<f a="path:?decodeData" v=":true">
				<c path="String"/>
				<x path="Bool"/>
				<c path="lime.graphics.Image"/>
			</f>
			<meta><m n=":value"><e>{ decodeData : true }</e></m></meta>
		</decodeFile>
		<encode public="1" set="method" line="72" static="1"><f a="image">
	<c path="lime.graphics.Image"/>
	<c path="haxe.io.Bytes"/>
</f></encode>
		<lime_png_decode_bytes get="inline" set="null" line="172" static="1">
			<f a="data:decodeData">
				<d/>
				<x path="Bool"/>
				<d/>
			</f>
			<meta><m n=":cffi"/></meta>
		</lime_png_decode_bytes>
		<lime_png_decode_file get="inline" set="null" line="173" static="1">
			<f a="path:decodeData">
				<c path="String"/>
				<x path="Bool"/>
				<d/>
			</f>
			<meta><m n=":cffi"/></meta>
		</lime_png_decode_file>
		<lime_image_encode get="inline" set="null" line="174" static="1">
			<f a="data:type:quality">
				<d/>
				<x path="Int"/>
				<x path="Int"/>
				<d/>
			</f>
			<meta><m n=":cffi"/></meta>
		</lime_image_encode>
		<cffi_lime_png_decode_bytes expr="new cpp.Callable&lt;Dynamic -&gt; Bool&gt;(lime.system.CFFI.load(&quot;lime&quot;, &quot;lime_png_decode_bytes&quot;, 2, false))" line="172" static="1">
			<x path="cpp.Callable"><f a=":">
	<d/>
	<x path="Bool"/>
	<d/>
</f></x>
			<meta><m n=":value"><e><![CDATA[new cpp.Callable<Dynamic -> Bool>(lime.system.CFFI.load("lime", "lime_png_decode_bytes", 2, false))]]></e></m></meta>
		</cffi_lime_png_decode_bytes>
		<cffi_lime_png_decode_file expr="new cpp.Callable&lt;String -&gt; Bool&gt;(lime.system.CFFI.load(&quot;lime&quot;, &quot;lime_png_decode_file&quot;, 2, false))" line="173" static="1">
			<x path="cpp.Callable"><f a=":">
	<c path="String"/>
	<x path="Bool"/>
	<d/>
</f></x>
			<meta><m n=":value"><e><![CDATA[new cpp.Callable<String -> Bool>(lime.system.CFFI.load("lime", "lime_png_decode_file", 2, false))]]></e></m></meta>
		</cffi_lime_png_decode_file>
		<cffi_lime_image_encode expr="new cpp.Callable&lt;Dynamic -&gt; Int -&gt; Int&gt;(lime.system.CFFI.load(&quot;lime&quot;, &quot;lime_image_encode&quot;, 3, false))" line="174" static="1">
			<x path="cpp.Callable"><f a="::">
	<d/>
	<x path="Int"/>
	<x path="Int"/>
	<d/>
</f></x>
			<meta><m n=":value"><e><![CDATA[new cpp.Callable<Dynamic -> Int -> Int>(lime.system.CFFI.load("lime", "lime_image_encode", 3, false))]]></e></m></meta>
		</cffi_lime_image_encode>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":access"><e>lime.graphics.ImageBuffer</e></m>
			<m n=":build"><e>lime.system.CFFI.build()</e></m>
		</meta>
	</class>
	<typedef path="lime.graphics.opengl.Float32" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/graphics/opengl/GL.hx" module="lime.graphics.opengl.GL"><x path="Float"/></typedef>
	<class path="lime.graphics.opengl.GL" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/graphics/opengl/GL.hx">
		<DEPTH_BUFFER_BIT public="1" get="inline" set="null" expr="0x00000100" line="38" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x00000100</e></m></meta>
		</DEPTH_BUFFER_BIT>
		<STENCIL_BUFFER_BIT public="1" get="inline" set="null" expr="0x00000400" line="39" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x00000400</e></m></meta>
		</STENCIL_BUFFER_BIT>
		<COLOR_BUFFER_BIT public="1" get="inline" set="null" expr="0x00004000" line="40" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x00004000</e></m></meta>
		</COLOR_BUFFER_BIT>
		<POINTS public="1" get="inline" set="null" expr="0x0000" line="42" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x0000</e></m></meta>
		</POINTS>
		<LINES public="1" get="inline" set="null" expr="0x0001" line="43" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x0001</e></m></meta>
		</LINES>
		<LINE_LOOP public="1" get="inline" set="null" expr="0x0002" line="44" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x0002</e></m></meta>
		</LINE_LOOP>
		<LINE_STRIP public="1" get="inline" set="null" expr="0x0003" line="45" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x0003</e></m></meta>
		</LINE_STRIP>
		<TRIANGLES public="1" get="inline" set="null" expr="0x0004" line="46" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x0004</e></m></meta>
		</TRIANGLES>
		<TRIANGLE_STRIP public="1" get="inline" set="null" expr="0x0005" line="47" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x0005</e></m></meta>
		</TRIANGLE_STRIP>
		<TRIANGLE_FAN public="1" get="inline" set="null" expr="0x0006" line="48" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x0006</e></m></meta>
		</TRIANGLE_FAN>
		<ZERO public="1" get="inline" set="null" expr="0" line="50" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</ZERO>
		<ONE public="1" get="inline" set="null" expr="1" line="51" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</ONE>
		<SRC_COLOR public="1" get="inline" set="null" expr="0x0300" line="52" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x0300</e></m></meta>
		</SRC_COLOR>
		<ONE_MINUS_SRC_COLOR public="1" get="inline" set="null" expr="0x0301" line="53" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x0301</e></m></meta>
		</ONE_MINUS_SRC_COLOR>
		<SRC_ALPHA public="1" get="inline" set="null" expr="0x0302" line="54" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x0302</e></m></meta>
		</SRC_ALPHA>
		<ONE_MINUS_SRC_ALPHA public="1" get="inline" set="null" expr="0x0303" line="55" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x0303</e></m></meta>
		</ONE_MINUS_SRC_ALPHA>
		<DST_ALPHA public="1" get="inline" set="null" expr="0x0304" line="56" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x0304</e></m></meta>
		</DST_ALPHA>
		<ONE_MINUS_DST_ALPHA public="1" get="inline" set="null" expr="0x0305" line="57" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x0305</e></m></meta>
		</ONE_MINUS_DST_ALPHA>
		<DST_COLOR public="1" get="inline" set="null" expr="0x0306" line="59" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x0306</e></m></meta>
		</DST_COLOR>
		<ONE_MINUS_DST_COLOR public="1" get="inline" set="null" expr="0x0307" line="60" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x0307</e></m></meta>
		</ONE_MINUS_DST_COLOR>
		<SRC_ALPHA_SATURATE public="1" get="inline" set="null" expr="0x0308" line="61" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x0308</e></m></meta>
		</SRC_ALPHA_SATURATE>
		<FUNC_ADD public="1" get="inline" set="null" expr="0x8006" line="63" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x8006</e></m></meta>
		</FUNC_ADD>
		<BLEND_EQUATION public="1" get="inline" set="null" expr="0x8009" line="64" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x8009</e></m></meta>
		</BLEND_EQUATION>
		<BLEND_EQUATION_RGB public="1" get="inline" set="null" expr="0x8009" line="65" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x8009</e></m></meta>
		</BLEND_EQUATION_RGB>
		<BLEND_EQUATION_ALPHA public="1" get="inline" set="null" expr="0x883D" line="66" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x883D</e></m></meta>
		</BLEND_EQUATION_ALPHA>
		<FUNC_SUBTRACT public="1" get="inline" set="null" expr="0x800A" line="68" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x800A</e></m></meta>
		</FUNC_SUBTRACT>
		<FUNC_REVERSE_SUBTRACT public="1" get="inline" set="null" expr="0x800B" line="69" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x800B</e></m></meta>
		</FUNC_REVERSE_SUBTRACT>
		<BLEND_DST_RGB public="1" get="inline" set="null" expr="0x80C8" line="71" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x80C8</e></m></meta>
		</BLEND_DST_RGB>
		<BLEND_SRC_RGB public="1" get="inline" set="null" expr="0x80C9" line="72" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x80C9</e></m></meta>
		</BLEND_SRC_RGB>
		<BLEND_DST_ALPHA public="1" get="inline" set="null" expr="0x80CA" line="73" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x80CA</e></m></meta>
		</BLEND_DST_ALPHA>
		<BLEND_SRC_ALPHA public="1" get="inline" set="null" expr="0x80CB" line="74" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x80CB</e></m></meta>
		</BLEND_SRC_ALPHA>
		<CONSTANT_COLOR public="1" get="inline" set="null" expr="0x8001" line="75" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x8001</e></m></meta>
		</CONSTANT_COLOR>
		<ONE_MINUS_CONSTANT_COLOR public="1" get="inline" set="null" expr="0x8002" line="76" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x8002</e></m></meta>
		</ONE_MINUS_CONSTANT_COLOR>
		<CONSTANT_ALPHA public="1" get="inline" set="null" expr="0x8003" line="77" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x8003</e></m></meta>
		</CONSTANT_ALPHA>
		<ONE_MINUS_CONSTANT_ALPHA public="1" get="inline" set="null" expr="0x8004" line="78" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x8004</e></m></meta>
		</ONE_MINUS_CONSTANT_ALPHA>
		<BLEND_COLOR public="1" get="inline" set="null" expr="0x8005" line="79" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x8005</e></m></meta>
		</BLEND_COLOR>
		<ARRAY_BUFFER public="1" get="inline" set="null" expr="0x8892" line="81" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x8892</e></m></meta>
		</ARRAY_BUFFER>
		<ELEMENT_ARRAY_BUFFER public="1" get="inline" set="null" expr="0x8893" line="82" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x8893</e></m></meta>
		</ELEMENT_ARRAY_BUFFER>
		<ARRAY_BUFFER_BINDING public="1" get="inline" set="null" expr="0x8894" line="83" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x8894</e></m></meta>
		</ARRAY_BUFFER_BINDING>
		<ELEMENT_ARRAY_BUFFER_BINDING public="1" get="inline" set="null" expr="0x8895" line="84" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x8895</e></m></meta>
		</ELEMENT_ARRAY_BUFFER_BINDING>
		<STREAM_DRAW public="1" get="inline" set="null" expr="0x88E0" line="86" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x88E0</e></m></meta>
		</STREAM_DRAW>
		<STATIC_DRAW public="1" get="inline" set="null" expr="0x88E4" line="87" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x88E4</e></m></meta>
		</STATIC_DRAW>
		<DYNAMIC_DRAW public="1" get="inline" set="null" expr="0x88E8" line="88" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x88E8</e></m></meta>
		</DYNAMIC_DRAW>
		<BUFFER_SIZE public="1" get="inline" set="null" expr="0x8764" line="90" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x8764</e></m></meta>
		</BUFFER_SIZE>
		<BUFFER_USAGE public="1" get="inline" set="null" expr="0x8765" line="91" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x8765</e></m></meta>
		</BUFFER_USAGE>
		<CURRENT_VERTEX_ATTRIB public="1" get="inline" set="null" expr="0x8626" line="93" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x8626</e></m></meta>
		</CURRENT_VERTEX_ATTRIB>
		<FRONT public="1" get="inline" set="null" expr="0x0404" line="95" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x0404</e></m></meta>
		</FRONT>
		<BACK public="1" get="inline" set="null" expr="0x0405" line="96" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x0405</e></m></meta>
		</BACK>
		<FRONT_AND_BACK public="1" get="inline" set="null" expr="0x0408" line="97" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x0408</e></m></meta>
		</FRONT_AND_BACK>
		<CULL_FACE public="1" get="inline" set="null" expr="0x0B44" line="99" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x0B44</e></m></meta>
		</CULL_FACE>
		<BLEND public="1" get="inline" set="null" expr="0x0BE2" line="100" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x0BE2</e></m></meta>
		</BLEND>
		<DITHER public="1" get="inline" set="null" expr="0x0BD0" line="101" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x0BD0</e></m></meta>
		</DITHER>
		<STENCIL_TEST public="1" get="inline" set="null" expr="0x0B90" line="102" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x0B90</e></m></meta>
		</STENCIL_TEST>
		<DEPTH_TEST public="1" get="inline" set="null" expr="0x0B71" line="103" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x0B71</e></m></meta>
		</DEPTH_TEST>
		<SCISSOR_TEST public="1" get="inline" set="null" expr="0x0C11" line="104" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x0C11</e></m></meta>
		</SCISSOR_TEST>
		<POLYGON_OFFSET_FILL public="1" get="inline" set="null" expr="0x8037" line="105" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x8037</e></m></meta>
		</POLYGON_OFFSET_FILL>
		<SAMPLE_ALPHA_TO_COVERAGE public="1" get="inline" set="null" expr="0x809E" line="106" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x809E</e></m></meta>
		</SAMPLE_ALPHA_TO_COVERAGE>
		<SAMPLE_COVERAGE public="1" get="inline" set="null" expr="0x80A0" line="107" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x80A0</e></m></meta>
		</SAMPLE_COVERAGE>
		<NO_ERROR public="1" get="inline" set="null" expr="0" line="109" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</NO_ERROR>
		<INVALID_ENUM public="1" get="inline" set="null" expr="0x0500" line="110" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x0500</e></m></meta>
		</INVALID_ENUM>
		<INVALID_VALUE public="1" get="inline" set="null" expr="0x0501" line="111" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x0501</e></m></meta>
		</INVALID_VALUE>
		<INVALID_OPERATION public="1" get="inline" set="null" expr="0x0502" line="112" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x0502</e></m></meta>
		</INVALID_OPERATION>
		<OUT_OF_MEMORY public="1" get="inline" set="null" expr="0x0505" line="113" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x0505</e></m></meta>
		</OUT_OF_MEMORY>
		<CW public="1" get="inline" set="null" expr="0x0900" line="115" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x0900</e></m></meta>
		</CW>
		<CCW public="1" get="inline" set="null" expr="0x0901" line="116" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x0901</e></m></meta>
		</CCW>
		<LINE_WIDTH public="1" get="inline" set="null" expr="0x0B21" line="118" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x0B21</e></m></meta>
		</LINE_WIDTH>
		<ALIASED_POINT_SIZE_RANGE public="1" get="inline" set="null" expr="0x846D" line="119" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x846D</e></m></meta>
		</ALIASED_POINT_SIZE_RANGE>
		<ALIASED_LINE_WIDTH_RANGE public="1" get="inline" set="null" expr="0x846E" line="120" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x846E</e></m></meta>
		</ALIASED_LINE_WIDTH_RANGE>
		<CULL_FACE_MODE public="1" get="inline" set="null" expr="0x0B45" line="121" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x0B45</e></m></meta>
		</CULL_FACE_MODE>
		<FRONT_FACE public="1" get="inline" set="null" expr="0x0B46" line="122" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x0B46</e></m></meta>
		</FRONT_FACE>
		<DEPTH_RANGE public="1" get="inline" set="null" expr="0x0B70" line="123" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x0B70</e></m></meta>
		</DEPTH_RANGE>
		<DEPTH_WRITEMASK public="1" get="inline" set="null" expr="0x0B72" line="124" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x0B72</e></m></meta>
		</DEPTH_WRITEMASK>
		<DEPTH_CLEAR_VALUE public="1" get="inline" set="null" expr="0x0B73" line="125" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x0B73</e></m></meta>
		</DEPTH_CLEAR_VALUE>
		<DEPTH_FUNC public="1" get="inline" set="null" expr="0x0B74" line="126" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x0B74</e></m></meta>
		</DEPTH_FUNC>
		<STENCIL_CLEAR_VALUE public="1" get="inline" set="null" expr="0x0B91" line="127" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x0B91</e></m></meta>
		</STENCIL_CLEAR_VALUE>
		<STENCIL_FUNC public="1" get="inline" set="null" expr="0x0B92" line="128" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x0B92</e></m></meta>
		</STENCIL_FUNC>
		<STENCIL_FAIL public="1" get="inline" set="null" expr="0x0B94" line="129" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x0B94</e></m></meta>
		</STENCIL_FAIL>
		<STENCIL_PASS_DEPTH_FAIL public="1" get="inline" set="null" expr="0x0B95" line="130" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x0B95</e></m></meta>
		</STENCIL_PASS_DEPTH_FAIL>
		<STENCIL_PASS_DEPTH_PASS public="1" get="inline" set="null" expr="0x0B96" line="131" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x0B96</e></m></meta>
		</STENCIL_PASS_DEPTH_PASS>
		<STENCIL_REF public="1" get="inline" set="null" expr="0x0B97" line="132" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x0B97</e></m></meta>
		</STENCIL_REF>
		<STENCIL_VALUE_MASK public="1" get="inline" set="null" expr="0x0B93" line="133" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x0B93</e></m></meta>
		</STENCIL_VALUE_MASK>
		<STENCIL_WRITEMASK public="1" get="inline" set="null" expr="0x0B98" line="134" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x0B98</e></m></meta>
		</STENCIL_WRITEMASK>
		<STENCIL_BACK_FUNC public="1" get="inline" set="null" expr="0x8800" line="135" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x8800</e></m></meta>
		</STENCIL_BACK_FUNC>
		<STENCIL_BACK_FAIL public="1" get="inline" set="null" expr="0x8801" line="136" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x8801</e></m></meta>
		</STENCIL_BACK_FAIL>
		<STENCIL_BACK_PASS_DEPTH_FAIL public="1" get="inline" set="null" expr="0x8802" line="137" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x8802</e></m></meta>
		</STENCIL_BACK_PASS_DEPTH_FAIL>
		<STENCIL_BACK_PASS_DEPTH_PASS public="1" get="inline" set="null" expr="0x8803" line="138" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x8803</e></m></meta>
		</STENCIL_BACK_PASS_DEPTH_PASS>
		<STENCIL_BACK_REF public="1" get="inline" set="null" expr="0x8CA3" line="139" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x8CA3</e></m></meta>
		</STENCIL_BACK_REF>
		<STENCIL_BACK_VALUE_MASK public="1" get="inline" set="null" expr="0x8CA4" line="140" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x8CA4</e></m></meta>
		</STENCIL_BACK_VALUE_MASK>
		<STENCIL_BACK_WRITEMASK public="1" get="inline" set="null" expr="0x8CA5" line="141" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x8CA5</e></m></meta>
		</STENCIL_BACK_WRITEMASK>
		<VIEWPORT public="1" get="inline" set="null" expr="0x0BA2" line="142" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x0BA2</e></m></meta>
		</VIEWPORT>
		<SCISSOR_BOX public="1" get="inline" set="null" expr="0x0C10" line="143" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x0C10</e></m></meta>
		</SCISSOR_BOX>
		<COLOR_CLEAR_VALUE public="1" get="inline" set="null" expr="0x0C22" line="145" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x0C22</e></m></meta>
		</COLOR_CLEAR_VALUE>
		<COLOR_WRITEMASK public="1" get="inline" set="null" expr="0x0C23" line="146" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x0C23</e></m></meta>
		</COLOR_WRITEMASK>
		<UNPACK_ALIGNMENT public="1" get="inline" set="null" expr="0x0CF5" line="147" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x0CF5</e></m></meta>
		</UNPACK_ALIGNMENT>
		<PACK_ALIGNMENT public="1" get="inline" set="null" expr="0x0D05" line="148" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x0D05</e></m></meta>
		</PACK_ALIGNMENT>
		<MAX_TEXTURE_SIZE public="1" get="inline" set="null" expr="0x0D33" line="149" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x0D33</e></m></meta>
		</MAX_TEXTURE_SIZE>
		<MAX_VIEWPORT_DIMS public="1" get="inline" set="null" expr="0x0D3A" line="150" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x0D3A</e></m></meta>
		</MAX_VIEWPORT_DIMS>
		<SUBPIXEL_BITS public="1" get="inline" set="null" expr="0x0D50" line="151" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x0D50</e></m></meta>
		</SUBPIXEL_BITS>
		<RED_BITS public="1" get="inline" set="null" expr="0x0D52" line="152" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x0D52</e></m></meta>
		</RED_BITS>
		<GREEN_BITS public="1" get="inline" set="null" expr="0x0D53" line="153" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x0D53</e></m></meta>
		</GREEN_BITS>
		<BLUE_BITS public="1" get="inline" set="null" expr="0x0D54" line="154" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x0D54</e></m></meta>
		</BLUE_BITS>
		<ALPHA_BITS public="1" get="inline" set="null" expr="0x0D55" line="155" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x0D55</e></m></meta>
		</ALPHA_BITS>
		<DEPTH_BITS public="1" get="inline" set="null" expr="0x0D56" line="156" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x0D56</e></m></meta>
		</DEPTH_BITS>
		<STENCIL_BITS public="1" get="inline" set="null" expr="0x0D57" line="157" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x0D57</e></m></meta>
		</STENCIL_BITS>
		<POLYGON_OFFSET_UNITS public="1" get="inline" set="null" expr="0x2A00" line="158" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x2A00</e></m></meta>
		</POLYGON_OFFSET_UNITS>
		<POLYGON_OFFSET_FACTOR public="1" get="inline" set="null" expr="0x8038" line="160" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x8038</e></m></meta>
		</POLYGON_OFFSET_FACTOR>
		<TEXTURE_BINDING_2D public="1" get="inline" set="null" expr="0x8069" line="161" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x8069</e></m></meta>
		</TEXTURE_BINDING_2D>
		<SAMPLE_BUFFERS public="1" get="inline" set="null" expr="0x80A8" line="162" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x80A8</e></m></meta>
		</SAMPLE_BUFFERS>
		<SAMPLES public="1" get="inline" set="null" expr="0x80A9" line="163" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x80A9</e></m></meta>
		</SAMPLES>
		<SAMPLE_COVERAGE_VALUE public="1" get="inline" set="null" expr="0x80AA" line="164" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x80AA</e></m></meta>
		</SAMPLE_COVERAGE_VALUE>
		<SAMPLE_COVERAGE_INVERT public="1" get="inline" set="null" expr="0x80AB" line="165" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x80AB</e></m></meta>
		</SAMPLE_COVERAGE_INVERT>
		<COMPRESSED_TEXTURE_FORMATS public="1" get="inline" set="null" expr="0x86A3" line="167" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x86A3</e></m></meta>
		</COMPRESSED_TEXTURE_FORMATS>
		<DONT_CARE public="1" get="inline" set="null" expr="0x1100" line="169" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x1100</e></m></meta>
		</DONT_CARE>
		<FASTEST public="1" get="inline" set="null" expr="0x1101" line="170" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x1101</e></m></meta>
		</FASTEST>
		<NICEST public="1" get="inline" set="null" expr="0x1102" line="171" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x1102</e></m></meta>
		</NICEST>
		<GENERATE_MIPMAP_HINT public="1" get="inline" set="null" expr="0x8192" line="173" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x8192</e></m></meta>
		</GENERATE_MIPMAP_HINT>
		<BYTE public="1" get="inline" set="null" expr="0x1400" line="175" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x1400</e></m></meta>
		</BYTE>
		<UNSIGNED_BYTE public="1" get="inline" set="null" expr="0x1401" line="176" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x1401</e></m></meta>
		</UNSIGNED_BYTE>
		<SHORT public="1" get="inline" set="null" expr="0x1402" line="177" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x1402</e></m></meta>
		</SHORT>
		<UNSIGNED_SHORT public="1" get="inline" set="null" expr="0x1403" line="178" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x1403</e></m></meta>
		</UNSIGNED_SHORT>
		<INT public="1" get="inline" set="null" expr="0x1404" line="179" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x1404</e></m></meta>
		</INT>
		<UNSIGNED_INT public="1" get="inline" set="null" expr="0x1405" line="180" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x1405</e></m></meta>
		</UNSIGNED_INT>
		<FLOAT public="1" get="inline" set="null" expr="0x1406" line="181" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x1406</e></m></meta>
		</FLOAT>
		<DEPTH_COMPONENT public="1" get="inline" set="null" expr="0x1902" line="183" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x1902</e></m></meta>
		</DEPTH_COMPONENT>
		<ALPHA public="1" get="inline" set="null" expr="0x1906" line="184" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x1906</e></m></meta>
		</ALPHA>
		<RGB public="1" get="inline" set="null" expr="0x1907" line="185" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x1907</e></m></meta>
		</RGB>
		<RGBA public="1" get="inline" set="null" expr="0x1908" line="186" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x1908</e></m></meta>
		</RGBA>
		<BGR_EXT public="1" get="inline" set="null" expr="0x80E0" line="187" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x80E0</e></m></meta>
		</BGR_EXT>
		<BGRA_EXT public="1" get="inline" set="null" expr="0x80E1" line="188" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x80E1</e></m></meta>
		</BGRA_EXT>
		<LUMINANCE public="1" get="inline" set="null" expr="0x1909" line="189" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x1909</e></m></meta>
		</LUMINANCE>
		<LUMINANCE_ALPHA public="1" get="inline" set="null" expr="0x190A" line="190" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x190A</e></m></meta>
		</LUMINANCE_ALPHA>
		<UNSIGNED_SHORT_4_4_4_4 public="1" get="inline" set="null" expr="0x8033" line="192" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x8033</e></m></meta>
		</UNSIGNED_SHORT_4_4_4_4>
		<UNSIGNED_SHORT_5_5_5_1 public="1" get="inline" set="null" expr="0x8034" line="193" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x8034</e></m></meta>
		</UNSIGNED_SHORT_5_5_5_1>
		<UNSIGNED_SHORT_5_6_5 public="1" get="inline" set="null" expr="0x8363" line="194" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x8363</e></m></meta>
		</UNSIGNED_SHORT_5_6_5>
		<FRAGMENT_SHADER public="1" get="inline" set="null" expr="0x8B30" line="196" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x8B30</e></m></meta>
		</FRAGMENT_SHADER>
		<VERTEX_SHADER public="1" get="inline" set="null" expr="0x8B31" line="197" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x8B31</e></m></meta>
		</VERTEX_SHADER>
		<MAX_VERTEX_ATTRIBS public="1" get="inline" set="null" expr="0x8869" line="198" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x8869</e></m></meta>
		</MAX_VERTEX_ATTRIBS>
		<MAX_VERTEX_UNIFORM_VECTORS public="1" get="inline" set="null" expr="0x8DFB" line="199" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x8DFB</e></m></meta>
		</MAX_VERTEX_UNIFORM_VECTORS>
		<MAX_VARYING_VECTORS public="1" get="inline" set="null" expr="0x8DFC" line="200" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x8DFC</e></m></meta>
		</MAX_VARYING_VECTORS>
		<MAX_COMBINED_TEXTURE_IMAGE_UNITS public="1" get="inline" set="null" expr="0x8B4D" line="201" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x8B4D</e></m></meta>
		</MAX_COMBINED_TEXTURE_IMAGE_UNITS>
		<MAX_VERTEX_TEXTURE_IMAGE_UNITS public="1" get="inline" set="null" expr="0x8B4C" line="202" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x8B4C</e></m></meta>
		</MAX_VERTEX_TEXTURE_IMAGE_UNITS>
		<MAX_TEXTURE_IMAGE_UNITS public="1" get="inline" set="null" expr="0x8872" line="203" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x8872</e></m></meta>
		</MAX_TEXTURE_IMAGE_UNITS>
		<MAX_FRAGMENT_UNIFORM_VECTORS public="1" get="inline" set="null" expr="0x8DFD" line="204" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x8DFD</e></m></meta>
		</MAX_FRAGMENT_UNIFORM_VECTORS>
		<SHADER_TYPE public="1" get="inline" set="null" expr="0x8B4F" line="205" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x8B4F</e></m></meta>
		</SHADER_TYPE>
		<DELETE_STATUS public="1" get="inline" set="null" expr="0x8B80" line="206" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x8B80</e></m></meta>
		</DELETE_STATUS>
		<LINK_STATUS public="1" get="inline" set="null" expr="0x8B82" line="207" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x8B82</e></m></meta>
		</LINK_STATUS>
		<VALIDATE_STATUS public="1" get="inline" set="null" expr="0x8B83" line="208" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x8B83</e></m></meta>
		</VALIDATE_STATUS>
		<ATTACHED_SHADERS public="1" get="inline" set="null" expr="0x8B85" line="209" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x8B85</e></m></meta>
		</ATTACHED_SHADERS>
		<ACTIVE_UNIFORMS public="1" get="inline" set="null" expr="0x8B86" line="210" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x8B86</e></m></meta>
		</ACTIVE_UNIFORMS>
		<ACTIVE_ATTRIBUTES public="1" get="inline" set="null" expr="0x8B89" line="211" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x8B89</e></m></meta>
		</ACTIVE_ATTRIBUTES>
		<SHADING_LANGUAGE_VERSION public="1" get="inline" set="null" expr="0x8B8C" line="212" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x8B8C</e></m></meta>
		</SHADING_LANGUAGE_VERSION>
		<CURRENT_PROGRAM public="1" get="inline" set="null" expr="0x8B8D" line="213" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x8B8D</e></m></meta>
		</CURRENT_PROGRAM>
		<NEVER public="1" get="inline" set="null" expr="0x0200" line="215" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x0200</e></m></meta>
		</NEVER>
		<LESS public="1" get="inline" set="null" expr="0x0201" line="216" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x0201</e></m></meta>
		</LESS>
		<EQUAL public="1" get="inline" set="null" expr="0x0202" line="217" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x0202</e></m></meta>
		</EQUAL>
		<LEQUAL public="1" get="inline" set="null" expr="0x0203" line="218" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x0203</e></m></meta>
		</LEQUAL>
		<GREATER public="1" get="inline" set="null" expr="0x0204" line="219" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x0204</e></m></meta>
		</GREATER>
		<NOTEQUAL public="1" get="inline" set="null" expr="0x0205" line="220" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x0205</e></m></meta>
		</NOTEQUAL>
		<GEQUAL public="1" get="inline" set="null" expr="0x0206" line="221" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x0206</e></m></meta>
		</GEQUAL>
		<ALWAYS public="1" get="inline" set="null" expr="0x0207" line="222" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x0207</e></m></meta>
		</ALWAYS>
		<KEEP public="1" get="inline" set="null" expr="0x1E00" line="224" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x1E00</e></m></meta>
		</KEEP>
		<REPLACE public="1" get="inline" set="null" expr="0x1E01" line="225" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x1E01</e></m></meta>
		</REPLACE>
		<INCR public="1" get="inline" set="null" expr="0x1E02" line="226" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x1E02</e></m></meta>
		</INCR>
		<DECR public="1" get="inline" set="null" expr="0x1E03" line="227" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x1E03</e></m></meta>
		</DECR>
		<INVERT public="1" get="inline" set="null" expr="0x150A" line="228" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x150A</e></m></meta>
		</INVERT>
		<INCR_WRAP public="1" get="inline" set="null" expr="0x8507" line="229" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x8507</e></m></meta>
		</INCR_WRAP>
		<DECR_WRAP public="1" get="inline" set="null" expr="0x8508" line="230" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x8508</e></m></meta>
		</DECR_WRAP>
		<VENDOR public="1" get="inline" set="null" expr="0x1F00" line="232" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x1F00</e></m></meta>
		</VENDOR>
		<RENDERER public="1" get="inline" set="null" expr="0x1F01" line="233" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x1F01</e></m></meta>
		</RENDERER>
		<VERSION public="1" get="inline" set="null" expr="0x1F02" line="234" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x1F02</e></m></meta>
		</VERSION>
		<NEAREST public="1" get="inline" set="null" expr="0x2600" line="236" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x2600</e></m></meta>
		</NEAREST>
		<LINEAR public="1" get="inline" set="null" expr="0x2601" line="237" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x2601</e></m></meta>
		</LINEAR>
		<NEAREST_MIPMAP_NEAREST public="1" get="inline" set="null" expr="0x2700" line="239" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x2700</e></m></meta>
		</NEAREST_MIPMAP_NEAREST>
		<LINEAR_MIPMAP_NEAREST public="1" get="inline" set="null" expr="0x2701" line="240" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x2701</e></m></meta>
		</LINEAR_MIPMAP_NEAREST>
		<NEAREST_MIPMAP_LINEAR public="1" get="inline" set="null" expr="0x2702" line="241" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x2702</e></m></meta>
		</NEAREST_MIPMAP_LINEAR>
		<LINEAR_MIPMAP_LINEAR public="1" get="inline" set="null" expr="0x2703" line="242" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x2703</e></m></meta>
		</LINEAR_MIPMAP_LINEAR>
		<TEXTURE_MAG_FILTER public="1" get="inline" set="null" expr="0x2800" line="244" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x2800</e></m></meta>
		</TEXTURE_MAG_FILTER>
		<TEXTURE_MIN_FILTER public="1" get="inline" set="null" expr="0x2801" line="245" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x2801</e></m></meta>
		</TEXTURE_MIN_FILTER>
		<TEXTURE_WRAP_S public="1" get="inline" set="null" expr="0x2802" line="246" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x2802</e></m></meta>
		</TEXTURE_WRAP_S>
		<TEXTURE_WRAP_T public="1" get="inline" set="null" expr="0x2803" line="247" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x2803</e></m></meta>
		</TEXTURE_WRAP_T>
		<TEXTURE_2D public="1" get="inline" set="null" expr="0x0DE1" line="249" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x0DE1</e></m></meta>
		</TEXTURE_2D>
		<TEXTURE public="1" get="inline" set="null" expr="0x1702" line="250" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x1702</e></m></meta>
		</TEXTURE>
		<TEXTURE_CUBE_MAP public="1" get="inline" set="null" expr="0x8513" line="252" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x8513</e></m></meta>
		</TEXTURE_CUBE_MAP>
		<TEXTURE_BINDING_CUBE_MAP public="1" get="inline" set="null" expr="0x8514" line="253" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x8514</e></m></meta>
		</TEXTURE_BINDING_CUBE_MAP>
		<TEXTURE_CUBE_MAP_POSITIVE_X public="1" get="inline" set="null" expr="0x8515" line="254" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x8515</e></m></meta>
		</TEXTURE_CUBE_MAP_POSITIVE_X>
		<TEXTURE_CUBE_MAP_NEGATIVE_X public="1" get="inline" set="null" expr="0x8516" line="255" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x8516</e></m></meta>
		</TEXTURE_CUBE_MAP_NEGATIVE_X>
		<TEXTURE_CUBE_MAP_POSITIVE_Y public="1" get="inline" set="null" expr="0x8517" line="256" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x8517</e></m></meta>
		</TEXTURE_CUBE_MAP_POSITIVE_Y>
		<TEXTURE_CUBE_MAP_NEGATIVE_Y public="1" get="inline" set="null" expr="0x8518" line="257" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x8518</e></m></meta>
		</TEXTURE_CUBE_MAP_NEGATIVE_Y>
		<TEXTURE_CUBE_MAP_POSITIVE_Z public="1" get="inline" set="null" expr="0x8519" line="258" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x8519</e></m></meta>
		</TEXTURE_CUBE_MAP_POSITIVE_Z>
		<TEXTURE_CUBE_MAP_NEGATIVE_Z public="1" get="inline" set="null" expr="0x851A" line="259" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x851A</e></m></meta>
		</TEXTURE_CUBE_MAP_NEGATIVE_Z>
		<MAX_CUBE_MAP_TEXTURE_SIZE public="1" get="inline" set="null" expr="0x851C" line="260" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x851C</e></m></meta>
		</MAX_CUBE_MAP_TEXTURE_SIZE>
		<TEXTURE0 public="1" get="inline" set="null" expr="0x84C0" line="262" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x84C0</e></m></meta>
		</TEXTURE0>
		<TEXTURE1 public="1" get="inline" set="null" expr="0x84C1" line="263" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x84C1</e></m></meta>
		</TEXTURE1>
		<TEXTURE2 public="1" get="inline" set="null" expr="0x84C2" line="264" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x84C2</e></m></meta>
		</TEXTURE2>
		<TEXTURE3 public="1" get="inline" set="null" expr="0x84C3" line="265" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x84C3</e></m></meta>
		</TEXTURE3>
		<TEXTURE4 public="1" get="inline" set="null" expr="0x84C4" line="266" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x84C4</e></m></meta>
		</TEXTURE4>
		<TEXTURE5 public="1" get="inline" set="null" expr="0x84C5" line="267" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x84C5</e></m></meta>
		</TEXTURE5>
		<TEXTURE6 public="1" get="inline" set="null" expr="0x84C6" line="268" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x84C6</e></m></meta>
		</TEXTURE6>
		<TEXTURE7 public="1" get="inline" set="null" expr="0x84C7" line="269" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x84C7</e></m></meta>
		</TEXTURE7>
		<TEXTURE8 public="1" get="inline" set="null" expr="0x84C8" line="270" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x84C8</e></m></meta>
		</TEXTURE8>
		<TEXTURE9 public="1" get="inline" set="null" expr="0x84C9" line="271" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x84C9</e></m></meta>
		</TEXTURE9>
		<TEXTURE10 public="1" get="inline" set="null" expr="0x84CA" line="272" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x84CA</e></m></meta>
		</TEXTURE10>
		<TEXTURE11 public="1" get="inline" set="null" expr="0x84CB" line="273" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x84CB</e></m></meta>
		</TEXTURE11>
		<TEXTURE12 public="1" get="inline" set="null" expr="0x84CC" line="274" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x84CC</e></m></meta>
		</TEXTURE12>
		<TEXTURE13 public="1" get="inline" set="null" expr="0x84CD" line="275" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x84CD</e></m></meta>
		</TEXTURE13>
		<TEXTURE14 public="1" get="inline" set="null" expr="0x84CE" line="276" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x84CE</e></m></meta>
		</TEXTURE14>
		<TEXTURE15 public="1" get="inline" set="null" expr="0x84CF" line="277" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x84CF</e></m></meta>
		</TEXTURE15>
		<TEXTURE16 public="1" get="inline" set="null" expr="0x84D0" line="278" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x84D0</e></m></meta>
		</TEXTURE16>
		<TEXTURE17 public="1" get="inline" set="null" expr="0x84D1" line="279" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x84D1</e></m></meta>
		</TEXTURE17>
		<TEXTURE18 public="1" get="inline" set="null" expr="0x84D2" line="280" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x84D2</e></m></meta>
		</TEXTURE18>
		<TEXTURE19 public="1" get="inline" set="null" expr="0x84D3" line="281" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x84D3</e></m></meta>
		</TEXTURE19>
		<TEXTURE20 public="1" get="inline" set="null" expr="0x84D4" line="282" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x84D4</e></m></meta>
		</TEXTURE20>
		<TEXTURE21 public="1" get="inline" set="null" expr="0x84D5" line="283" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x84D5</e></m></meta>
		</TEXTURE21>
		<TEXTURE22 public="1" get="inline" set="null" expr="0x84D6" line="284" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x84D6</e></m></meta>
		</TEXTURE22>
		<TEXTURE23 public="1" get="inline" set="null" expr="0x84D7" line="285" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x84D7</e></m></meta>
		</TEXTURE23>
		<TEXTURE24 public="1" get="inline" set="null" expr="0x84D8" line="286" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x84D8</e></m></meta>
		</TEXTURE24>
		<TEXTURE25 public="1" get="inline" set="null" expr="0x84D9" line="287" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x84D9</e></m></meta>
		</TEXTURE25>
		<TEXTURE26 public="1" get="inline" set="null" expr="0x84DA" line="288" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x84DA</e></m></meta>
		</TEXTURE26>
		<TEXTURE27 public="1" get="inline" set="null" expr="0x84DB" line="289" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x84DB</e></m></meta>
		</TEXTURE27>
		<TEXTURE28 public="1" get="inline" set="null" expr="0x84DC" line="290" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x84DC</e></m></meta>
		</TEXTURE28>
		<TEXTURE29 public="1" get="inline" set="null" expr="0x84DD" line="291" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x84DD</e></m></meta>
		</TEXTURE29>
		<TEXTURE30 public="1" get="inline" set="null" expr="0x84DE" line="292" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x84DE</e></m></meta>
		</TEXTURE30>
		<TEXTURE31 public="1" get="inline" set="null" expr="0x84DF" line="293" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x84DF</e></m></meta>
		</TEXTURE31>
		<ACTIVE_TEXTURE public="1" get="inline" set="null" expr="0x84E0" line="294" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x84E0</e></m></meta>
		</ACTIVE_TEXTURE>
		<REPEAT public="1" get="inline" set="null" expr="0x2901" line="296" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x2901</e></m></meta>
		</REPEAT>
		<CLAMP_TO_EDGE public="1" get="inline" set="null" expr="0x812F" line="297" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x812F</e></m></meta>
		</CLAMP_TO_EDGE>
		<MIRRORED_REPEAT public="1" get="inline" set="null" expr="0x8370" line="298" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x8370</e></m></meta>
		</MIRRORED_REPEAT>
		<FLOAT_VEC2 public="1" get="inline" set="null" expr="0x8B50" line="300" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x8B50</e></m></meta>
		</FLOAT_VEC2>
		<FLOAT_VEC3 public="1" get="inline" set="null" expr="0x8B51" line="301" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x8B51</e></m></meta>
		</FLOAT_VEC3>
		<FLOAT_VEC4 public="1" get="inline" set="null" expr="0x8B52" line="302" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x8B52</e></m></meta>
		</FLOAT_VEC4>
		<INT_VEC2 public="1" get="inline" set="null" expr="0x8B53" line="303" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x8B53</e></m></meta>
		</INT_VEC2>
		<INT_VEC3 public="1" get="inline" set="null" expr="0x8B54" line="304" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x8B54</e></m></meta>
		</INT_VEC3>
		<INT_VEC4 public="1" get="inline" set="null" expr="0x8B55" line="305" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x8B55</e></m></meta>
		</INT_VEC4>
		<BOOL public="1" get="inline" set="null" expr="0x8B56" line="306" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x8B56</e></m></meta>
		</BOOL>
		<BOOL_VEC2 public="1" get="inline" set="null" expr="0x8B57" line="307" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x8B57</e></m></meta>
		</BOOL_VEC2>
		<BOOL_VEC3 public="1" get="inline" set="null" expr="0x8B58" line="308" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x8B58</e></m></meta>
		</BOOL_VEC3>
		<BOOL_VEC4 public="1" get="inline" set="null" expr="0x8B59" line="309" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x8B59</e></m></meta>
		</BOOL_VEC4>
		<FLOAT_MAT2 public="1" get="inline" set="null" expr="0x8B5A" line="310" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x8B5A</e></m></meta>
		</FLOAT_MAT2>
		<FLOAT_MAT3 public="1" get="inline" set="null" expr="0x8B5B" line="311" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x8B5B</e></m></meta>
		</FLOAT_MAT3>
		<FLOAT_MAT4 public="1" get="inline" set="null" expr="0x8B5C" line="312" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x8B5C</e></m></meta>
		</FLOAT_MAT4>
		<SAMPLER_2D public="1" get="inline" set="null" expr="0x8B5E" line="313" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x8B5E</e></m></meta>
		</SAMPLER_2D>
		<SAMPLER_CUBE public="1" get="inline" set="null" expr="0x8B60" line="314" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x8B60</e></m></meta>
		</SAMPLER_CUBE>
		<VERTEX_ATTRIB_ARRAY_ENABLED public="1" get="inline" set="null" expr="0x8622" line="316" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x8622</e></m></meta>
		</VERTEX_ATTRIB_ARRAY_ENABLED>
		<VERTEX_ATTRIB_ARRAY_SIZE public="1" get="inline" set="null" expr="0x8623" line="317" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x8623</e></m></meta>
		</VERTEX_ATTRIB_ARRAY_SIZE>
		<VERTEX_ATTRIB_ARRAY_STRIDE public="1" get="inline" set="null" expr="0x8624" line="318" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x8624</e></m></meta>
		</VERTEX_ATTRIB_ARRAY_STRIDE>
		<VERTEX_ATTRIB_ARRAY_TYPE public="1" get="inline" set="null" expr="0x8625" line="319" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x8625</e></m></meta>
		</VERTEX_ATTRIB_ARRAY_TYPE>
		<VERTEX_ATTRIB_ARRAY_NORMALIZED public="1" get="inline" set="null" expr="0x886A" line="320" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x886A</e></m></meta>
		</VERTEX_ATTRIB_ARRAY_NORMALIZED>
		<VERTEX_ATTRIB_ARRAY_POINTER public="1" get="inline" set="null" expr="0x8645" line="321" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x8645</e></m></meta>
		</VERTEX_ATTRIB_ARRAY_POINTER>
		<VERTEX_ATTRIB_ARRAY_BUFFER_BINDING public="1" get="inline" set="null" expr="0x889F" line="322" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x889F</e></m></meta>
		</VERTEX_ATTRIB_ARRAY_BUFFER_BINDING>
		<VERTEX_PROGRAM_POINT_SIZE public="1" get="inline" set="null" expr="0x8642" line="324" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x8642</e></m></meta>
		</VERTEX_PROGRAM_POINT_SIZE>
		<POINT_SPRITE public="1" get="inline" set="null" expr="0x8861" line="325" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x8861</e></m></meta>
		</POINT_SPRITE>
		<COMPILE_STATUS public="1" get="inline" set="null" expr="0x8B81" line="327" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x8B81</e></m></meta>
		</COMPILE_STATUS>
		<LOW_FLOAT public="1" get="inline" set="null" expr="0x8DF0" line="329" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x8DF0</e></m></meta>
		</LOW_FLOAT>
		<MEDIUM_FLOAT public="1" get="inline" set="null" expr="0x8DF1" line="330" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x8DF1</e></m></meta>
		</MEDIUM_FLOAT>
		<HIGH_FLOAT public="1" get="inline" set="null" expr="0x8DF2" line="331" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x8DF2</e></m></meta>
		</HIGH_FLOAT>
		<LOW_INT public="1" get="inline" set="null" expr="0x8DF3" line="332" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x8DF3</e></m></meta>
		</LOW_INT>
		<MEDIUM_INT public="1" get="inline" set="null" expr="0x8DF4" line="333" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x8DF4</e></m></meta>
		</MEDIUM_INT>
		<HIGH_INT public="1" get="inline" set="null" expr="0x8DF5" line="334" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x8DF5</e></m></meta>
		</HIGH_INT>
		<FRAMEBUFFER public="1" get="inline" set="null" expr="0x8D40" line="336" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x8D40</e></m></meta>
		</FRAMEBUFFER>
		<RENDERBUFFER public="1" get="inline" set="null" expr="0x8D41" line="337" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x8D41</e></m></meta>
		</RENDERBUFFER>
		<RGBA4 public="1" get="inline" set="null" expr="0x8056" line="339" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x8056</e></m></meta>
		</RGBA4>
		<RGB5_A1 public="1" get="inline" set="null" expr="0x8057" line="340" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x8057</e></m></meta>
		</RGB5_A1>
		<RGB565 public="1" get="inline" set="null" expr="0x8D62" line="341" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x8D62</e></m></meta>
		</RGB565>
		<DEPTH_COMPONENT16 public="1" get="inline" set="null" expr="0x81A5" line="342" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x81A5</e></m></meta>
		</DEPTH_COMPONENT16>
		<STENCIL_INDEX public="1" get="inline" set="null" expr="0x1901" line="343" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x1901</e></m></meta>
		</STENCIL_INDEX>
		<STENCIL_INDEX8 public="1" get="inline" set="null" expr="0x8D48" line="344" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x8D48</e></m></meta>
		</STENCIL_INDEX8>
		<DEPTH_STENCIL public="1" get="inline" set="null" expr="0x84F9" line="345" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x84F9</e></m></meta>
		</DEPTH_STENCIL>
		<RENDERBUFFER_WIDTH public="1" get="inline" set="null" expr="0x8D42" line="347" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x8D42</e></m></meta>
		</RENDERBUFFER_WIDTH>
		<RENDERBUFFER_HEIGHT public="1" get="inline" set="null" expr="0x8D43" line="348" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x8D43</e></m></meta>
		</RENDERBUFFER_HEIGHT>
		<RENDERBUFFER_INTERNAL_FORMAT public="1" get="inline" set="null" expr="0x8D44" line="349" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x8D44</e></m></meta>
		</RENDERBUFFER_INTERNAL_FORMAT>
		<RENDERBUFFER_RED_SIZE public="1" get="inline" set="null" expr="0x8D50" line="350" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x8D50</e></m></meta>
		</RENDERBUFFER_RED_SIZE>
		<RENDERBUFFER_GREEN_SIZE public="1" get="inline" set="null" expr="0x8D51" line="351" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x8D51</e></m></meta>
		</RENDERBUFFER_GREEN_SIZE>
		<RENDERBUFFER_BLUE_SIZE public="1" get="inline" set="null" expr="0x8D52" line="352" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x8D52</e></m></meta>
		</RENDERBUFFER_BLUE_SIZE>
		<RENDERBUFFER_ALPHA_SIZE public="1" get="inline" set="null" expr="0x8D53" line="353" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x8D53</e></m></meta>
		</RENDERBUFFER_ALPHA_SIZE>
		<RENDERBUFFER_DEPTH_SIZE public="1" get="inline" set="null" expr="0x8D54" line="354" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x8D54</e></m></meta>
		</RENDERBUFFER_DEPTH_SIZE>
		<RENDERBUFFER_STENCIL_SIZE public="1" get="inline" set="null" expr="0x8D55" line="355" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x8D55</e></m></meta>
		</RENDERBUFFER_STENCIL_SIZE>
		<FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE public="1" get="inline" set="null" expr="0x8CD0" line="357" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x8CD0</e></m></meta>
		</FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE>
		<FRAMEBUFFER_ATTACHMENT_OBJECT_NAME public="1" get="inline" set="null" expr="0x8CD1" line="358" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x8CD1</e></m></meta>
		</FRAMEBUFFER_ATTACHMENT_OBJECT_NAME>
		<FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL public="1" get="inline" set="null" expr="0x8CD2" line="359" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x8CD2</e></m></meta>
		</FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL>
		<FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE public="1" get="inline" set="null" expr="0x8CD3" line="360" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x8CD3</e></m></meta>
		</FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE>
		<COLOR_ATTACHMENT0 public="1" get="inline" set="null" expr="0x8CE0" line="362" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x8CE0</e></m></meta>
		</COLOR_ATTACHMENT0>
		<DEPTH_ATTACHMENT public="1" get="inline" set="null" expr="0x8D00" line="363" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x8D00</e></m></meta>
		</DEPTH_ATTACHMENT>
		<STENCIL_ATTACHMENT public="1" get="inline" set="null" expr="0x8D20" line="364" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x8D20</e></m></meta>
		</STENCIL_ATTACHMENT>
		<DEPTH_STENCIL_ATTACHMENT public="1" get="inline" set="null" expr="0x821A" line="365" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x821A</e></m></meta>
		</DEPTH_STENCIL_ATTACHMENT>
		<NONE public="1" get="inline" set="null" expr="0" line="367" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</NONE>
		<FRAMEBUFFER_COMPLETE public="1" get="inline" set="null" expr="0x8CD5" line="369" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x8CD5</e></m></meta>
		</FRAMEBUFFER_COMPLETE>
		<FRAMEBUFFER_INCOMPLETE_ATTACHMENT public="1" get="inline" set="null" expr="0x8CD6" line="370" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x8CD6</e></m></meta>
		</FRAMEBUFFER_INCOMPLETE_ATTACHMENT>
		<FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT public="1" get="inline" set="null" expr="0x8CD7" line="371" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x8CD7</e></m></meta>
		</FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT>
		<FRAMEBUFFER_INCOMPLETE_DIMENSIONS public="1" get="inline" set="null" expr="0x8CD9" line="372" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x8CD9</e></m></meta>
		</FRAMEBUFFER_INCOMPLETE_DIMENSIONS>
		<FRAMEBUFFER_UNSUPPORTED public="1" get="inline" set="null" expr="0x8CDD" line="373" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x8CDD</e></m></meta>
		</FRAMEBUFFER_UNSUPPORTED>
		<FRAMEBUFFER_BINDING public="1" get="inline" set="null" expr="0x8CA6" line="375" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x8CA6</e></m></meta>
		</FRAMEBUFFER_BINDING>
		<RENDERBUFFER_BINDING public="1" get="inline" set="null" expr="0x8CA7" line="376" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x8CA7</e></m></meta>
		</RENDERBUFFER_BINDING>
		<MAX_RENDERBUFFER_SIZE public="1" get="inline" set="null" expr="0x84E8" line="377" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x84E8</e></m></meta>
		</MAX_RENDERBUFFER_SIZE>
		<INVALID_FRAMEBUFFER_OPERATION public="1" get="inline" set="null" expr="0x0506" line="379" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x0506</e></m></meta>
		</INVALID_FRAMEBUFFER_OPERATION>
		<UNPACK_FLIP_Y_WEBGL public="1" get="inline" set="null" expr="0x9240" line="381" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x9240</e></m></meta>
		</UNPACK_FLIP_Y_WEBGL>
		<UNPACK_PREMULTIPLY_ALPHA_WEBGL public="1" get="inline" set="null" expr="0x9241" line="382" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x9241</e></m></meta>
		</UNPACK_PREMULTIPLY_ALPHA_WEBGL>
		<CONTEXT_LOST_WEBGL public="1" get="inline" set="null" expr="0x9242" line="383" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x9242</e></m></meta>
		</CONTEXT_LOST_WEBGL>
		<UNPACK_COLORSPACE_CONVERSION_WEBGL public="1" get="inline" set="null" expr="0x9243" line="384" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x9243</e></m></meta>
		</UNPACK_COLORSPACE_CONVERSION_WEBGL>
		<BROWSER_DEFAULT_WEBGL public="1" get="inline" set="null" expr="0x9244" line="385" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x9244</e></m></meta>
		</BROWSER_DEFAULT_WEBGL>
		<version public="1" get="accessor" set="null" static="1"><x path="Int"/></version>
		<activeTexture public="1" get="inline" set="null" line="394" static="1"><f a="texture">
	<x path="Int"/>
	<x path="Void"/>
</f></activeTexture>
		<attachShader public="1" get="inline" set="null" line="407" static="1"><f a="program:shader">
	<c path="lime.graphics.opengl.GLProgram"/>
	<c path="lime.graphics.opengl.GLShader"/>
	<x path="Void"/>
</f></attachShader>
		<bindAttribLocation public="1" get="inline" set="null" line="422" static="1"><f a="program:index:name">
	<c path="lime.graphics.opengl.GLProgram"/>
	<x path="Int"/>
	<c path="String"/>
	<x path="Void"/>
</f></bindAttribLocation>
		<bindBuffer public="1" get="inline" set="null" line="435" static="1"><f a="target:buffer">
	<x path="Int"/>
	<c path="lime.graphics.opengl.GLBuffer"/>
	<x path="Void"/>
</f></bindBuffer>
		<bindFramebuffer public="1" get="inline" set="null" line="448" static="1"><f a="target:framebuffer">
	<x path="Int"/>
	<c path="lime.graphics.opengl.GLFramebuffer"/>
	<x path="Void"/>
</f></bindFramebuffer>
		<bindRenderbuffer public="1" get="inline" set="null" line="461" static="1"><f a="target:renderbuffer">
	<x path="Int"/>
	<c path="lime.graphics.opengl.GLRenderbuffer"/>
	<x path="Void"/>
</f></bindRenderbuffer>
		<bindTexture public="1" get="inline" set="null" line="474" static="1"><f a="target:texture">
	<x path="Int"/>
	<c path="lime.graphics.opengl.GLTexture"/>
	<x path="Void"/>
</f></bindTexture>
		<blendColor public="1" get="inline" set="null" line="487" static="1"><f a="red:green:blue:alpha">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></blendColor>
		<blendEquation public="1" get="inline" set="null" line="500" static="1"><f a="mode">
	<x path="Int"/>
	<x path="Void"/>
</f></blendEquation>
		<blendEquationSeparate public="1" get="inline" set="null" line="513" static="1"><f a="modeRGB:modeAlpha">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></blendEquationSeparate>
		<blendFunc public="1" get="inline" set="null" line="526" static="1"><f a="sfactor:dfactor">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></blendFunc>
		<blendFuncSeparate public="1" get="inline" set="null" line="539" static="1"><f a="srcRGB:dstRGB:srcAlpha:dstAlpha">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></blendFuncSeparate>
		<bufferData public="1" get="inline" set="null" line="552" static="1"><f a="target:data:usage">
	<x path="Int"/>
	<c path="lime.utils.ArrayBufferView"/>
	<x path="Int"/>
	<x path="Void"/>
</f></bufferData>
		<bufferSubData public="1" get="inline" set="null" line="567" static="1"><f a="target:offset:data">
	<x path="Int"/>
	<x path="Int"/>
	<c path="lime.utils.ArrayBufferView"/>
	<x path="Void"/>
</f></bufferSubData>
		<checkFramebufferStatus public="1" get="inline" set="null" line="582" static="1"><f a="target">
	<x path="Int"/>
	<x path="Int"/>
</f></checkFramebufferStatus>
		<clear public="1" get="inline" set="null" line="597" static="1"><f a="mask">
	<x path="Int"/>
	<x path="Void"/>
</f></clear>
		<clearColor public="1" get="inline" set="null" line="610" static="1"><f a="red:green:blue:alpha">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></clearColor>
		<clearDepth public="1" get="inline" set="null" line="623" static="1"><f a="depth">
	<x path="Float"/>
	<x path="Void"/>
</f></clearDepth>
		<clearStencil public="1" get="inline" set="null" line="636" static="1"><f a="s">
	<x path="Int"/>
	<x path="Void"/>
</f></clearStencil>
		<colorMask public="1" get="inline" set="null" line="649" static="1"><f a="red:green:blue:alpha">
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></colorMask>
		<compileShader public="1" get="inline" set="null" line="662" static="1"><f a="shader">
	<c path="lime.graphics.opengl.GLShader"/>
	<x path="Void"/>
</f></compileShader>
		<compressedTexImage2D public="1" get="inline" set="null" line="675" static="1"><f a="target:level:internalformat:width:height:border:data">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<c path="lime.utils.ArrayBufferView"/>
	<x path="Void"/>
</f></compressedTexImage2D>
		<compressedTexSubImage2D public="1" get="inline" set="null" line="691" static="1"><f a="target:level:xoffset:yoffset:width:height:format:data">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<c path="lime.utils.ArrayBufferView"/>
	<x path="Void"/>
</f></compressedTexSubImage2D>
		<copyTexImage2D public="1" get="inline" set="null" line="707" static="1"><f a="target:level:internalformat:x:y:width:height:border">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></copyTexImage2D>
		<copyTexSubImage2D public="1" get="inline" set="null" line="720" static="1"><f a="target:level:xoffset:yoffset:x:y:width:height">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></copyTexSubImage2D>
		<createBuffer public="1" get="inline" set="null" line="733" static="1"><f a=""><c path="lime.graphics.opengl.GLBuffer"/></f></createBuffer>
		<createFramebuffer public="1" get="inline" set="null" line="749" static="1"><f a=""><c path="lime.graphics.opengl.GLFramebuffer"/></f></createFramebuffer>
		<createProgram public="1" get="inline" set="null" line="765" static="1"><f a=""><c path="lime.graphics.opengl.GLProgram"/></f></createProgram>
		<createRenderbuffer public="1" get="inline" set="null" line="780" static="1"><f a=""><c path="lime.graphics.opengl.GLRenderbuffer"/></f></createRenderbuffer>
		<createShader public="1" get="inline" set="null" line="796" static="1"><f a="type">
	<x path="Int"/>
	<c path="lime.graphics.opengl.GLShader"/>
</f></createShader>
		<createTexture public="1" get="inline" set="null" line="811" static="1"><f a=""><c path="lime.graphics.opengl.GLTexture"/></f></createTexture>
		<cullFace public="1" get="inline" set="null" line="827" static="1"><f a="mode">
	<x path="Int"/>
	<x path="Void"/>
</f></cullFace>
		<deleteBuffer public="1" get="inline" set="null" line="840" static="1"><f a="buffer">
	<c path="lime.graphics.opengl.GLBuffer"/>
	<x path="Void"/>
</f></deleteBuffer>
		<deleteFramebuffer public="1" get="inline" set="null" line="855" static="1"><f a="framebuffer">
	<c path="lime.graphics.opengl.GLFramebuffer"/>
	<x path="Void"/>
</f></deleteFramebuffer>
		<deleteProgram public="1" get="inline" set="null" line="870" static="1"><f a="program">
	<c path="lime.graphics.opengl.GLProgram"/>
	<x path="Void"/>
</f></deleteProgram>
		<deleteRenderbuffer public="1" get="inline" set="null" line="885" static="1"><f a="renderbuffer">
	<c path="lime.graphics.opengl.GLRenderbuffer"/>
	<x path="Void"/>
</f></deleteRenderbuffer>
		<deleteShader public="1" get="inline" set="null" line="900" static="1"><f a="shader">
	<c path="lime.graphics.opengl.GLShader"/>
	<x path="Void"/>
</f></deleteShader>
		<deleteTexture public="1" get="inline" set="null" line="915" static="1"><f a="texture">
	<c path="lime.graphics.opengl.GLTexture"/>
	<x path="Void"/>
</f></deleteTexture>
		<depthFunc public="1" get="inline" set="null" line="930" static="1"><f a="func">
	<x path="Int"/>
	<x path="Void"/>
</f></depthFunc>
		<depthMask public="1" get="inline" set="null" line="943" static="1"><f a="flag">
	<x path="Bool"/>
	<x path="Void"/>
</f></depthMask>
		<depthRange public="1" get="inline" set="null" line="956" static="1"><f a="zNear:zFar">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></depthRange>
		<detachShader public="1" get="inline" set="null" line="969" static="1"><f a="program:shader">
	<c path="lime.graphics.opengl.GLProgram"/>
	<c path="lime.graphics.opengl.GLShader"/>
	<x path="Void"/>
</f></detachShader>
		<disable public="1" get="inline" set="null" line="982" static="1"><f a="cap">
	<x path="Int"/>
	<x path="Void"/>
</f></disable>
		<disableVertexAttribArray public="1" get="inline" set="null" line="995" static="1"><f a="index">
	<x path="Int"/>
	<x path="Void"/>
</f></disableVertexAttribArray>
		<drawArrays public="1" get="inline" set="null" line="1008" static="1"><f a="mode:first:count">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></drawArrays>
		<drawElements public="1" get="inline" set="null" line="1021" static="1"><f a="mode:count:type:offset">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></drawElements>
		<enable public="1" get="inline" set="null" line="1034" static="1"><f a="cap">
	<x path="Int"/>
	<x path="Void"/>
</f></enable>
		<enableVertexAttribArray public="1" get="inline" set="null" line="1047" static="1"><f a="index">
	<x path="Int"/>
	<x path="Void"/>
</f></enableVertexAttribArray>
		<finish public="1" get="inline" set="null" line="1060" static="1"><f a=""><x path="Void"/></f></finish>
		<flush public="1" get="inline" set="null" line="1073" static="1"><f a=""><x path="Void"/></f></flush>
		<framebufferRenderbuffer public="1" get="inline" set="null" line="1086" static="1"><f a="target:attachment:renderbuffertarget:renderbuffer">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<c path="lime.graphics.opengl.GLRenderbuffer"/>
	<x path="Void"/>
</f></framebufferRenderbuffer>
		<framebufferTexture2D public="1" get="inline" set="null" line="1099" static="1"><f a="target:attachment:textarget:texture:level">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<c path="lime.graphics.opengl.GLTexture"/>
	<x path="Int"/>
	<x path="Void"/>
</f></framebufferTexture2D>
		<frontFace public="1" get="inline" set="null" line="1112" static="1"><f a="mode">
	<x path="Int"/>
	<x path="Void"/>
</f></frontFace>
		<generateMipmap public="1" get="inline" set="null" line="1125" static="1"><f a="target">
	<x path="Int"/>
	<x path="Void"/>
</f></generateMipmap>
		<getActiveAttrib public="1" get="inline" set="null" line="1138" static="1"><f a="program:index">
	<c path="lime.graphics.opengl.GLProgram"/>
	<x path="Int"/>
	<t path="lime.graphics.opengl.GLActiveInfo"/>
</f></getActiveAttrib>
		<getActiveUniform public="1" get="inline" set="null" line="1155" static="1"><f a="program:index">
	<c path="lime.graphics.opengl.GLProgram"/>
	<x path="Int"/>
	<t path="lime.graphics.opengl.GLActiveInfo"/>
</f></getActiveUniform>
		<getAttachedShaders public="1" get="inline" set="null" line="1172" static="1"><f a="program">
	<c path="lime.graphics.opengl.GLProgram"/>
	<c path="Array"><c path="lime.graphics.opengl.GLShader"/></c>
</f></getAttachedShaders>
		<getAttribLocation public="1" get="inline" set="null" line="1187" static="1"><f a="program:name">
	<c path="lime.graphics.opengl.GLProgram"/>
	<c path="String"/>
	<x path="Int"/>
</f></getAttribLocation>
		<getBufferParameter public="1" get="inline" set="null" line="1202" static="1"><f a="target:pname">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></getBufferParameter>
		<getContextAttributes public="1" get="inline" set="null" line="1218" static="1"><f a=""><t path="lime.graphics.opengl.GLContextAttributes"/></f></getContextAttributes>
		<getError public="1" get="inline" set="null" line="1240" static="1"><f a=""><x path="Int"/></f></getError>
		<getExtension public="1" get="inline" set="null" line="1255" static="1"><f a="name">
	<c path="String"/>
	<d/>
</f></getExtension>
		<getFramebufferAttachmentParameter public="1" get="inline" set="null" line="1268" static="1"><f a="target:attachment:pname">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></getFramebufferAttachmentParameter>
		<getParameter public="1" get="inline" set="null" line="1284" static="1"><f a="pname">
	<x path="Int"/>
	<d/>
</f></getParameter>
		<getProgramInfoLog public="1" get="inline" set="null" line="1299" static="1"><f a="program">
	<c path="lime.graphics.opengl.GLProgram"/>
	<c path="String"/>
</f></getProgramInfoLog>
		<getProgramParameter public="1" get="inline" set="null" line="1314" static="1"><f a="program:pname">
	<c path="lime.graphics.opengl.GLProgram"/>
	<x path="Int"/>
	<x path="Int"/>
</f></getProgramParameter>
		<getRenderbufferParameter public="1" get="inline" set="null" line="1330" static="1"><f a="target:pname">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></getRenderbufferParameter>
		<getShaderInfoLog public="1" get="inline" set="null" line="1346" static="1"><f a="shader">
	<c path="lime.graphics.opengl.GLShader"/>
	<c path="String"/>
</f></getShaderInfoLog>
		<getShaderParameter public="1" get="inline" set="null" line="1361" static="1"><f a="shader:pname">
	<c path="lime.graphics.opengl.GLShader"/>
	<x path="Int"/>
	<x path="Int"/>
</f></getShaderParameter>
		<getShaderPrecisionFormat public="1" get="inline" set="null" line="1377" static="1"><f a="shadertype:precisiontype">
	<x path="Int"/>
	<x path="Int"/>
	<t path="lime.graphics.opengl.GLShaderPrecisionFormat"/>
</f></getShaderPrecisionFormat>
		<getShaderSource public="1" get="inline" set="null" line="1394" static="1"><f a="shader">
	<c path="lime.graphics.opengl.GLShader"/>
	<c path="String"/>
</f></getShaderSource>
		<getSupportedExtensions public="1" get="inline" set="null" line="1409" static="1"><f a=""><c path="Array"><c path="String"/></c></f></getSupportedExtensions>
		<getTexParameter public="1" get="inline" set="null" line="1426" static="1"><f a="target:pname">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></getTexParameter>
		<getUniform public="1" get="inline" set="null" line="1442" static="1"><f a="program:location">
	<c path="lime.graphics.opengl.GLProgram"/>
	<t path="lime.graphics.opengl.GLUniformLocation"/>
	<d/>
</f></getUniform>
		<getUniformLocation public="1" get="inline" set="null" line="1458" static="1"><f a="program:name">
	<c path="lime.graphics.opengl.GLProgram"/>
	<c path="String"/>
	<t path="lime.graphics.opengl.GLUniformLocation"/>
</f></getUniformLocation>
		<getVertexAttrib public="1" get="inline" set="null" line="1473" static="1"><f a="index:pname">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></getVertexAttrib>
		<getVertexAttribOffset public="1" get="inline" set="null" line="1488" static="1"><f a="index:pname">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></getVertexAttribOffset>
		<hint public="1" get="inline" set="null" line="1503" static="1"><f a="target:mode">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></hint>
		<isBuffer public="1" get="inline" set="null" line="1514" static="1"><f a="buffer">
	<c path="lime.graphics.opengl.GLBuffer"/>
	<x path="Bool"/>
</f></isBuffer>
		<isContextLost public="1" get="inline" set="null" line="1527" static="1"><f a=""><x path="Bool"/></f></isContextLost>
		<isEnabled public="1" get="inline" set="null" line="1538" static="1"><f a="cap">
	<x path="Int"/>
	<x path="Bool"/>
</f></isEnabled>
		<isFramebuffer public="1" get="inline" set="null" line="1551" static="1"><f a="framebuffer">
	<c path="lime.graphics.opengl.GLFramebuffer"/>
	<x path="Bool"/>
</f></isFramebuffer>
		<isProgram public="1" get="inline" set="null" line="1564" static="1"><f a="program">
	<c path="lime.graphics.opengl.GLProgram"/>
	<x path="Bool"/>
</f></isProgram>
		<isRenderbuffer public="1" get="inline" set="null" line="1577" static="1"><f a="renderbuffer">
	<c path="lime.graphics.opengl.GLRenderbuffer"/>
	<x path="Bool"/>
</f></isRenderbuffer>
		<isShader public="1" get="inline" set="null" line="1590" static="1"><f a="shader">
	<c path="lime.graphics.opengl.GLShader"/>
	<x path="Bool"/>
</f></isShader>
		<isTexture public="1" get="inline" set="null" line="1603" static="1"><f a="texture">
	<c path="lime.graphics.opengl.GLTexture"/>
	<x path="Bool"/>
</f></isTexture>
		<lineWidth public="1" get="inline" set="null" line="1616" static="1"><f a="width">
	<x path="Float"/>
	<x path="Void"/>
</f></lineWidth>
		<linkProgram public="1" get="inline" set="null" line="1627" static="1"><f a="program">
	<c path="lime.graphics.opengl.GLProgram"/>
	<x path="Void"/>
</f></linkProgram>
		<pixelStorei public="1" get="inline" set="null" line="1638" static="1"><f a="pname:param">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></pixelStorei>
		<polygonOffset public="1" get="inline" set="null" line="1649" static="1"><f a="factor:units">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></polygonOffset>
		<readPixels public="1" get="inline" set="null" line="1660" static="1"><f a="x:y:width:height:format:type:pixels">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<c path="lime.utils.ArrayBufferView"/>
	<x path="Void"/>
</f></readPixels>
		<renderbufferStorage public="1" get="inline" set="null" line="1674" static="1"><f a="target:internalformat:width:height">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></renderbufferStorage>
		<sampleCoverage public="1" get="inline" set="null" line="1685" static="1"><f a="value:invert">
	<x path="Float"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></sampleCoverage>
		<scissor public="1" get="inline" set="null" line="1696" static="1"><f a="x:y:width:height">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></scissor>
		<shaderSource public="1" get="inline" set="null" line="1707" static="1"><f a="shader:source">
	<c path="lime.graphics.opengl.GLShader"/>
	<c path="String"/>
	<x path="Void"/>
</f></shaderSource>
		<stencilFunc public="1" get="inline" set="null" line="1718" static="1"><f a="func:ref:mask">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></stencilFunc>
		<stencilFuncSeparate public="1" get="inline" set="null" line="1729" static="1"><f a="face:func:ref:mask">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></stencilFuncSeparate>
		<stencilMask public="1" get="inline" set="null" line="1740" static="1"><f a="mask">
	<x path="Int"/>
	<x path="Void"/>
</f></stencilMask>
		<stencilMaskSeparate public="1" get="inline" set="null" line="1751" static="1"><f a="face:mask">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></stencilMaskSeparate>
		<stencilOp public="1" get="inline" set="null" line="1762" static="1"><f a="fail:zfail:zpass">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></stencilOp>
		<stencilOpSeparate public="1" get="inline" set="null" line="1773" static="1"><f a="face:fail:zfail:zpass">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></stencilOpSeparate>
		<texImage2D public="1" get="inline" set="null" line="1784" static="1"><f a="target:level:internalformat:width:height:border:format:type:pixels">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<c path="lime.utils.ArrayBufferView"/>
	<x path="Void"/>
</f></texImage2D>
		<texParameterf public="1" get="inline" set="null" line="1798" static="1"><f a="target:pname:param">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Float"/>
	<x path="Void"/>
</f></texParameterf>
		<texParameteri public="1" get="inline" set="null" line="1809" static="1"><f a="target:pname:param">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></texParameteri>
		<texSubImage2D public="1" get="inline" set="null" line="1820" static="1"><f a="target:level:xoffset:yoffset:width:height:format:type:pixels">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<c path="lime.utils.ArrayBufferView"/>
	<x path="Void"/>
</f></texSubImage2D>
		<uniform1f public="1" get="inline" set="null" line="1834" static="1"><f a="location:x">
	<t path="lime.graphics.opengl.GLUniformLocation"/>
	<x path="Float"/>
	<x path="Void"/>
</f></uniform1f>
		<uniform1fv public="1" get="inline" set="null" line="1845" static="1"><f a="location:x">
	<t path="lime.graphics.opengl.GLUniformLocation"/>
	<x path="lime.utils.Float32Array"/>
	<x path="Void"/>
</f></uniform1fv>
		<uniform1i public="1" get="inline" set="null" line="1858" static="1"><f a="location:x">
	<t path="lime.graphics.opengl.GLUniformLocation"/>
	<x path="Int"/>
	<x path="Void"/>
</f></uniform1i>
		<uniform1iv public="1" get="inline" set="null" line="1869" static="1"><f a="location:v">
	<t path="lime.graphics.opengl.GLUniformLocation"/>
	<x path="lime.utils.Int32Array"/>
	<x path="Void"/>
</f></uniform1iv>
		<uniform2f public="1" get="inline" set="null" line="1882" static="1"><f a="location:x:y">
	<t path="lime.graphics.opengl.GLUniformLocation"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></uniform2f>
		<uniform2fv public="1" get="inline" set="null" line="1893" static="1"><f a="location:v">
	<t path="lime.graphics.opengl.GLUniformLocation"/>
	<x path="lime.utils.Float32Array"/>
	<x path="Void"/>
</f></uniform2fv>
		<uniform2i public="1" get="inline" set="null" line="1906" static="1"><f a="location:x:y">
	<t path="lime.graphics.opengl.GLUniformLocation"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></uniform2i>
		<uniform2iv public="1" get="inline" set="null" line="1917" static="1"><f a="location:v">
	<t path="lime.graphics.opengl.GLUniformLocation"/>
	<x path="lime.utils.Int32Array"/>
	<x path="Void"/>
</f></uniform2iv>
		<uniform3f public="1" get="inline" set="null" line="1930" static="1"><f a="location:x:y:z">
	<t path="lime.graphics.opengl.GLUniformLocation"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></uniform3f>
		<uniform3fv public="1" get="inline" set="null" line="1941" static="1"><f a="location:v">
	<t path="lime.graphics.opengl.GLUniformLocation"/>
	<x path="lime.utils.Float32Array"/>
	<x path="Void"/>
</f></uniform3fv>
		<uniform3i public="1" get="inline" set="null" line="1954" static="1"><f a="location:x:y:z">
	<t path="lime.graphics.opengl.GLUniformLocation"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></uniform3i>
		<uniform3iv public="1" get="inline" set="null" line="1965" static="1"><f a="location:v">
	<t path="lime.graphics.opengl.GLUniformLocation"/>
	<x path="lime.utils.Int32Array"/>
	<x path="Void"/>
</f></uniform3iv>
		<uniform4f public="1" get="inline" set="null" line="1978" static="1"><f a="location:x:y:z:w">
	<t path="lime.graphics.opengl.GLUniformLocation"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></uniform4f>
		<uniform4fv public="1" get="inline" set="null" line="1989" static="1"><f a="location:v">
	<t path="lime.graphics.opengl.GLUniformLocation"/>
	<x path="lime.utils.Float32Array"/>
	<x path="Void"/>
</f></uniform4fv>
		<uniform4i public="1" get="inline" set="null" line="2002" static="1"><f a="location:x:y:z:w">
	<t path="lime.graphics.opengl.GLUniformLocation"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></uniform4i>
		<uniform4iv public="1" get="inline" set="null" line="2013" static="1"><f a="location:v">
	<t path="lime.graphics.opengl.GLUniformLocation"/>
	<x path="lime.utils.Int32Array"/>
	<x path="Void"/>
</f></uniform4iv>
		<uniformMatrix2fv public="1" get="inline" set="null" line="2026" static="1"><f a="location:transpose:v">
	<t path="lime.graphics.opengl.GLUniformLocation"/>
	<x path="Bool"/>
	<x path="lime.utils.Float32Array"/>
	<x path="Void"/>
</f></uniformMatrix2fv>
		<uniformMatrix3fv public="1" get="inline" set="null" line="2039" static="1"><f a="location:transpose:v">
	<t path="lime.graphics.opengl.GLUniformLocation"/>
	<x path="Bool"/>
	<x path="lime.utils.Float32Array"/>
	<x path="Void"/>
</f></uniformMatrix3fv>
		<uniformMatrix4fv public="1" get="inline" set="null" line="2052" static="1"><f a="location:transpose:v">
	<t path="lime.graphics.opengl.GLUniformLocation"/>
	<x path="Bool"/>
	<x path="lime.utils.Float32Array"/>
	<x path="Void"/>
</f></uniformMatrix4fv>
		<useProgram public="1" get="inline" set="null" line="2072" static="1"><f a="program">
	<c path="lime.graphics.opengl.GLProgram"/>
	<x path="Void"/>
</f></useProgram>
		<validateProgram public="1" get="inline" set="null" line="2083" static="1"><f a="program">
	<c path="lime.graphics.opengl.GLProgram"/>
	<x path="Void"/>
</f></validateProgram>
		<vertexAttrib1f public="1" get="inline" set="null" line="2094" static="1"><f a="indx:x">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Void"/>
</f></vertexAttrib1f>
		<vertexAttrib1fv public="1" get="inline" set="null" line="2105" static="1"><f a="indx:values">
	<x path="Int"/>
	<x path="lime.utils.Float32Array"/>
	<x path="Void"/>
</f></vertexAttrib1fv>
		<vertexAttrib2f public="1" get="inline" set="null" line="2118" static="1"><f a="indx:x:y">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></vertexAttrib2f>
		<vertexAttrib2fv public="1" get="inline" set="null" line="2129" static="1"><f a="indx:values">
	<x path="Int"/>
	<x path="lime.utils.Float32Array"/>
	<x path="Void"/>
</f></vertexAttrib2fv>
		<vertexAttrib3f public="1" get="inline" set="null" line="2142" static="1"><f a="indx:x:y:z">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></vertexAttrib3f>
		<vertexAttrib3fv public="1" get="inline" set="null" line="2153" static="1"><f a="indx:values">
	<x path="Int"/>
	<x path="lime.utils.Float32Array"/>
	<x path="Void"/>
</f></vertexAttrib3fv>
		<vertexAttrib4f public="1" get="inline" set="null" line="2166" static="1"><f a="indx:x:y:z:w">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></vertexAttrib4f>
		<vertexAttrib4fv public="1" get="inline" set="null" line="2177" static="1"><f a="indx:values">
	<x path="Int"/>
	<x path="lime.utils.Float32Array"/>
	<x path="Void"/>
</f></vertexAttrib4fv>
		<vertexAttribPointer public="1" get="inline" set="null" line="2190" static="1"><f a="indx:size:type:normalized:stride:offset">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Bool"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></vertexAttribPointer>
		<viewport public="1" get="inline" set="null" line="2201" static="1"><f a="x:y:width:height">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></viewport>
		<get_version set="method" line="2212" static="1"><f a=""><x path="Int"/></f></get_version>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>lime.system.CFFI.build()</e></m>
			<m n=":allow"><e>lime.ui.Window</e></m>
		</meta>
	</class>
	<typedef path="lime.graphics.opengl.GLActiveInfo" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/graphics/opengl/GLActiveInfo.hx"><a>
	<type><x path="Int"/></type>
	<size><x path="Int"/></size>
	<name><c path="String"/></name>
</a></typedef>
	<class path="lime.graphics.opengl.GLObject" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/graphics/opengl/GLObject.hx">
		<id public="1" set="null">
			<d/>
			<haxe_doc>The native GL handle/id. read only</haxe_doc>
		</id>
		<invalidated public="1" get="accessor" set="null">
			<x path="Bool"/>
			<haxe_doc>The invalidated state. read only</haxe_doc>
		</invalidated>
		<valid public="1" get="accessor" set="null">
			<x path="Bool"/>
			<haxe_doc>The valid state. read only</haxe_doc>
		</valid>
		<version><x path="Int"/></version>
		<getType set="method" line="22"><f a=""><c path="String"/></f></getType>
		<invalidate public="1" set="method" line="26"><f a=""><x path="Void"/></f></invalidate>
		<isValid public="1" set="method" line="30"><f a=""><x path="Bool"/></f></isValid>
		<isInvalid public="1" set="method" line="34"><f a=""><x path="Bool"/></f></isInvalid>
		<toString public="1" set="method" line="38"><f a=""><c path="String"/></f></toString>
		<get_invalidated set="method" line="44"><f a=""><x path="Bool"/></f></get_invalidated>
		<get_valid set="method" line="48"><f a=""><x path="Bool"/></f></get_valid>
		<new public="1" set="method" line="15"><f a="version:id">
	<x path="Int"/>
	<d/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="lime.graphics.opengl.GLBuffer" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/graphics/opengl/GLBuffer.hx">
		<extends path="lime.graphics.opengl.GLObject"/>
		<getType set="method" line="7" override="1"><f a=""><c path="String"/></f></getType>
		<new public="1" set="method" line="4"><f a="version:id">
	<x path="Int"/>
	<d/>
	<x path="Void"/>
</f></new>
	</class>
	<typedef path="lime.graphics.opengl.GLContextAttributes" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/graphics/opengl/GLContextAttributes.hx"><a>
	<stencil><x path="Bool"/></stencil>
	<preserveDrawingBuffer><x path="Bool"/></preserveDrawingBuffer>
	<premultipliedAlpha><x path="Bool"/></premultipliedAlpha>
	<depth><x path="Bool"/></depth>
	<antialias><x path="Bool"/></antialias>
	<alpha><x path="Bool"/></alpha>
</a></typedef>
	<class path="lime.graphics.opengl.GLFramebuffer" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/graphics/opengl/GLFramebuffer.hx">
		<extends path="lime.graphics.opengl.GLObject"/>
		<getType set="method" line="7" override="1"><f a=""><c path="String"/></f></getType>
		<new public="1" set="method" line="4"><f a="version:id">
	<x path="Int"/>
	<d/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="lime.graphics.opengl.GLProgram" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/graphics/opengl/GLProgram.hx">
		<extends path="lime.graphics.opengl.GLObject"/>
		<shaders public="1"><c path="Array"><c path="lime.graphics.opengl.GLShader"/></c></shaders>
		<attach public="1" set="method" line="18"><f a="shader">
	<c path="lime.graphics.opengl.GLShader"/>
	<x path="Void"/>
</f></attach>
		<getShaders public="1" set="method" line="25"><f a=""><c path="Array"><c path="lime.graphics.opengl.GLShader"/></c></f></getShaders>
		<getType set="method" line="32" override="1"><f a=""><c path="String"/></f></getType>
		<new public="1" set="method" line="10"><f a="version:id">
	<x path="Int"/>
	<d/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="lime.graphics.opengl.GLRenderbuffer" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/graphics/opengl/GLRenderbuffer.hx">
		<extends path="lime.graphics.opengl.GLObject"/>
		<getType set="method" line="7" override="1"><f a=""><c path="String"/></f></getType>
		<new public="1" set="method" line="4"><f a="version:id">
	<x path="Int"/>
	<d/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="lime.graphics.opengl.GLShader" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/graphics/opengl/GLShader.hx">
		<extends path="lime.graphics.opengl.GLObject"/>
		<getType set="method" line="7" override="1"><f a=""><c path="String"/></f></getType>
		<isValid public="1" set="method" line="14" override="1"><f a=""><x path="Bool"/></f></isValid>
		<new public="1" set="method" line="4"><f a="version:id">
	<x path="Int"/>
	<d/>
	<x path="Void"/>
</f></new>
	</class>
	<typedef path="lime.graphics.opengl.GLShaderPrecisionFormat" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/graphics/opengl/GLShaderPrecisionFormat.hx"><a>
	<rangeMin><x path="Int"/></rangeMin>
	<rangeMax><x path="Int"/></rangeMax>
	<precision><x path="Int"/></precision>
</a></typedef>
	<class path="lime.graphics.opengl.GLTexture" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/graphics/opengl/GLTexture.hx">
		<extends path="lime.graphics.opengl.GLObject"/>
		<getType set="method" line="7" override="1"><f a=""><c path="String"/></f></getType>
		<new public="1" set="method" line="4"><f a="version:id">
	<x path="Int"/>
	<d/>
	<x path="Void"/>
</f></new>
	</class>
	<typedef path="lime.graphics.opengl.GLUniformLocation" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/graphics/opengl/GLUniformLocation.hx"><x path="Int"/></typedef>
	<class path="lime.graphics.utils.ImageCanvasUtil" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/graphics/utils/ImageCanvasUtil.hx">
		<colorTransform public="1" set="method" line="24" static="1"><f a="image:rect:colorMatrix">
	<c path="lime.graphics.Image"/>
	<c path="lime.math.Rectangle"/>
	<x path="lime.math.ColorMatrix"/>
	<x path="Void"/>
</f></colorTransform>
		<convertToCanvas public="1" set="method" line="34" static="1"><f a="image">
	<c path="lime.graphics.Image"/>
	<x path="Void"/>
</f></convertToCanvas>
		<convertToData public="1" set="method" line="63" static="1"><f a="image">
	<c path="lime.graphics.Image"/>
	<x path="Void"/>
</f></convertToData>
		<copyChannel public="1" set="method" line="81" static="1"><f a="image:sourceImage:sourceRect:destPoint:sourceChannel:destChannel">
	<c path="lime.graphics.Image"/>
	<c path="lime.graphics.Image"/>
	<c path="lime.math.Rectangle"/>
	<c path="lime.math.Vector2"/>
	<e path="lime.graphics.ImageChannel"/>
	<e path="lime.graphics.ImageChannel"/>
	<x path="Void"/>
</f></copyChannel>
		<copyPixels public="1" set="method" line="93" static="1">
			<f a="image:sourceImage:sourceRect:destPoint:?alphaImage:?alphaPoint:?mergeAlpha" v="::::null:null:false">
				<c path="lime.graphics.Image"/>
				<c path="lime.graphics.Image"/>
				<c path="lime.math.Rectangle"/>
				<c path="lime.math.Vector2"/>
				<c path="lime.graphics.Image"/>
				<c path="lime.math.Vector2"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ mergeAlpha : false, alphaPoint : null, alphaImage : null }</e></m></meta>
		</copyPixels>
		<createCanvas public="1" set="method" line="136" static="1"><f a="image:width:height">
	<c path="lime.graphics.Image"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></createCanvas>
		<createImageData public="1" set="method" line="169" static="1"><f a="image">
	<c path="lime.graphics.Image"/>
	<x path="Void"/>
</f></createImageData>
		<fillRect public="1" set="method" line="197" static="1"><f a="image:rect:color:format">
	<c path="lime.graphics.Image"/>
	<c path="lime.math.Rectangle"/>
	<x path="Int"/>
	<x path="lime.graphics.PixelFormat"/>
	<x path="Void"/>
</f></fillRect>
		<floodFill public="1" set="method" line="237" static="1"><f a="image:x:y:color:format">
	<c path="lime.graphics.Image"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="lime.graphics.PixelFormat"/>
	<x path="Void"/>
</f></floodFill>
		<getPixel public="1" set="method" line="247" static="1"><f a="image:x:y:format">
	<c path="lime.graphics.Image"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="lime.graphics.PixelFormat"/>
	<x path="Int"/>
</f></getPixel>
		<getPixel32 public="1" set="method" line="257" static="1"><f a="image:x:y:format">
	<c path="lime.graphics.Image"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="lime.graphics.PixelFormat"/>
	<x path="Int"/>
</f></getPixel32>
		<getPixels public="1" set="method" line="267" static="1"><f a="image:rect:format">
	<c path="lime.graphics.Image"/>
	<c path="lime.math.Rectangle"/>
	<x path="lime.graphics.PixelFormat"/>
	<c path="haxe.io.Bytes"/>
</f></getPixels>
		<merge public="1" set="method" line="277" static="1"><f a="image:sourceImage:sourceRect:destPoint:redMultiplier:greenMultiplier:blueMultiplier:alphaMultiplier">
	<c path="lime.graphics.Image"/>
	<c path="lime.graphics.Image"/>
	<c path="lime.math.Rectangle"/>
	<c path="lime.math.Vector2"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></merge>
		<resize public="1" set="method" line="289" static="1"><f a="image:newWidth:newHeight">
	<c path="lime.graphics.Image"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></resize>
		<scroll public="1" set="method" line="311" static="1"><f a="image:x:y">
	<c path="lime.graphics.Image"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></scroll>
		<setPixel public="1" set="method" line="324" static="1"><f a="image:x:y:color:format">
	<c path="lime.graphics.Image"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="lime.graphics.PixelFormat"/>
	<x path="Void"/>
</f></setPixel>
		<setPixel32 public="1" set="method" line="334" static="1"><f a="image:x:y:color:format">
	<c path="lime.graphics.Image"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="lime.graphics.PixelFormat"/>
	<x path="Void"/>
</f></setPixel32>
		<setPixels public="1" set="method" line="344" static="1"><f a="image:rect:bytes:format">
	<c path="lime.graphics.Image"/>
	<c path="lime.math.Rectangle"/>
	<c path="haxe.io.Bytes"/>
	<x path="lime.graphics.PixelFormat"/>
	<x path="Void"/>
</f></setPixels>
		<sync public="1" set="method" line="354" static="1"><f a="image:clear">
	<c path="lime.graphics.Image"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></sync>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":access"><e>lime.graphics.ImageBuffer</e></m>
		</meta>
	</class>
	<class path="lime.graphics.utils.ImageDataUtil" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/graphics/utils/ImageDataUtil.hx">
		<colorTransform public="1" set="method" line="29" static="1"><f a="image:rect:colorMatrix">
	<c path="lime.graphics.Image"/>
	<c path="lime.math.Rectangle"/>
	<x path="lime.math.ColorMatrix"/>
	<x path="Void"/>
</f></colorTransform>
		<copyChannel public="1" set="method" line="74" static="1"><f a="image:sourceImage:sourceRect:destPoint:sourceChannel:destChannel">
	<c path="lime.graphics.Image"/>
	<c path="lime.graphics.Image"/>
	<c path="lime.math.Rectangle"/>
	<c path="lime.math.Vector2"/>
	<e path="lime.graphics.ImageChannel"/>
	<e path="lime.graphics.ImageChannel"/>
	<x path="Void"/>
</f></copyChannel>
		<copyPixels public="1" set="method" line="158" static="1">
			<f a="image:sourceImage:sourceRect:destPoint:?alphaImage:?alphaPoint:?mergeAlpha" v="::::null:null:false">
				<c path="lime.graphics.Image"/>
				<c path="lime.graphics.Image"/>
				<c path="lime.math.Rectangle"/>
				<c path="lime.math.Vector2"/>
				<c path="lime.graphics.Image"/>
				<c path="lime.math.Vector2"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ mergeAlpha : false, alphaPoint : null, alphaImage : null }</e></m></meta>
		</copyPixels>
		<fillRect public="1" set="method" line="304" static="1"><f a="image:rect:color:format">
	<c path="lime.graphics.Image"/>
	<c path="lime.math.Rectangle"/>
	<x path="Int"/>
	<x path="lime.graphics.PixelFormat"/>
	<x path="Void"/>
</f></fillRect>
		<floodFill public="1" set="method" line="355" static="1"><f a="image:x:y:color:format">
	<c path="lime.graphics.Image"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="lime.graphics.PixelFormat"/>
	<x path="Void"/>
</f></floodFill>
		<getColorBoundsRect public="1" set="method" line="437" static="1">
			<f a="image:mask:color:?findColor:format" v=":::true:">
				<c path="lime.graphics.Image"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="lime.graphics.PixelFormat"/>
				<c path="lime.math.Rectangle"/>
			</f>
			<meta><m n=":value"><e>{ findColor : true }</e></m></meta>
		</getColorBoundsRect>
		<getPixel public="1" set="method" line="604" static="1"><f a="image:x:y:format">
	<c path="lime.graphics.Image"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="lime.graphics.PixelFormat"/>
	<x path="Int"/>
</f></getPixel>
		<getPixel32 public="1" set="method" line="622" static="1"><f a="image:x:y:format">
	<c path="lime.graphics.Image"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="lime.graphics.PixelFormat"/>
	<x path="Int"/>
</f></getPixel32>
		<getPixels public="1" set="method" line="639" static="1"><f a="image:rect:format">
	<c path="lime.graphics.Image"/>
	<c path="lime.math.Rectangle"/>
	<x path="lime.graphics.PixelFormat"/>
	<c path="haxe.io.Bytes"/>
</f></getPixels>
		<merge public="1" set="method" line="693" static="1"><f a="image:sourceImage:sourceRect:destPoint:redMultiplier:greenMultiplier:blueMultiplier:alphaMultiplier">
	<c path="lime.graphics.Image"/>
	<c path="lime.graphics.Image"/>
	<c path="lime.math.Rectangle"/>
	<c path="lime.math.Vector2"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></merge>
		<multiplyAlpha public="1" set="method" line="745" static="1"><f a="image">
	<c path="lime.graphics.Image"/>
	<x path="Void"/>
</f></multiplyAlpha>
		<resize public="1" set="method" line="774" static="1"><f a="image:newWidth:newHeight">
	<c path="lime.graphics.Image"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></resize>
		<resizeBuffer public="1" set="method" line="847" static="1"><f a="image:newWidth:newHeight">
	<c path="lime.graphics.Image"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></resizeBuffer>
		<setFormat public="1" set="method" line="877" static="1"><f a="image:format">
	<c path="lime.graphics.Image"/>
	<x path="lime.graphics.PixelFormat"/>
	<x path="Void"/>
</f></setFormat>
		<setPixel public="1" set="method" line="966" static="1"><f a="image:x:y:color:format">
	<c path="lime.graphics.Image"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="lime.graphics.PixelFormat"/>
	<x path="Void"/>
</f></setPixel>
		<setPixel32 public="1" set="method" line="991" static="1"><f a="image:x:y:color:format">
	<c path="lime.graphics.Image"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="lime.graphics.PixelFormat"/>
	<x path="Void"/>
</f></setPixel32>
		<setPixels public="1" set="method" line="1011" static="1"><f a="image:rect:bytes:format">
	<c path="lime.graphics.Image"/>
	<c path="lime.math.Rectangle"/>
	<c path="haxe.io.Bytes"/>
	<x path="lime.graphics.PixelFormat"/>
	<x path="Void"/>
</f></setPixels>
		<threshold public="1" set="method" line="1060" static="1"><f a="image:sourceImage:sourceRect:destPoint:operation:threshold:color:mask:copySource:format">
	<c path="lime.graphics.Image"/>
	<c path="lime.graphics.Image"/>
	<c path="lime.math.Rectangle"/>
	<c path="lime.math.Vector2"/>
	<c path="String"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Bool"/>
	<x path="lime.graphics.PixelFormat"/>
	<x path="Int"/>
</f></threshold>
		<unmultiplyAlpha public="1" set="method" line="1178" static="1"><f a="image">
	<c path="lime.graphics.Image"/>
	<x path="Void"/>
</f></unmultiplyAlpha>
		<__pixelCompare get="inline" set="null" line="1207" static="1"><f a="n1:n2">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></__pixelCompare>
		<lime_image_data_util_color_transform get="inline" set="null" line="1269" static="1">
			<f a="image:rect:colorMatrix">
				<d/>
				<d/>
				<d/>
				<x path="Void"/>
			</f>
			<meta><m n=":cffi"/></meta>
		</lime_image_data_util_color_transform>
		<lime_image_data_util_copy_channel get="inline" set="null" line="1270" static="1">
			<f a="image:sourceImage:sourceRect:destPoint:srcChannel:destChannel">
				<d/>
				<d/>
				<d/>
				<d/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":cffi"/></meta>
		</lime_image_data_util_copy_channel>
		<lime_image_data_util_copy_pixels get="inline" set="null" line="1271" static="1">
			<f a="image:sourceImage:sourceRect:destPoint:alphaImage:alphaPoint:mergeAlpha">
				<d/>
				<d/>
				<d/>
				<d/>
				<d/>
				<d/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":cffi"/></meta>
		</lime_image_data_util_copy_pixels>
		<lime_image_data_util_fill_rect get="inline" set="null" line="1272" static="1">
			<f a="image:rect:rg:ba">
				<d/>
				<d/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":cffi"/></meta>
		</lime_image_data_util_fill_rect>
		<lime_image_data_util_flood_fill get="inline" set="null" line="1273" static="1">
			<f a="image:x:y:rg:ba">
				<d/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":cffi"/></meta>
		</lime_image_data_util_flood_fill>
		<lime_image_data_util_get_pixels get="inline" set="null" line="1274" static="1">
			<f a="image:rect:format:bytes">
				<d/>
				<d/>
				<x path="Int"/>
				<d/>
				<x path="Void"/>
			</f>
			<meta><m n=":cffi"/></meta>
		</lime_image_data_util_get_pixels>
		<lime_image_data_util_merge get="inline" set="null" line="1275" static="1">
			<f a="image:sourceImage:sourceRect:destPoint:redMultiplier:greenMultiplier:blueMultiplier:alphaMultiplier">
				<d/>
				<d/>
				<d/>
				<d/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":cffi"/></meta>
		</lime_image_data_util_merge>
		<lime_image_data_util_multiply_alpha get="inline" set="null" line="1276" static="1">
			<f a="image">
				<d/>
				<x path="Void"/>
			</f>
			<meta><m n=":cffi"/></meta>
		</lime_image_data_util_multiply_alpha>
		<lime_image_data_util_resize get="inline" set="null" line="1277" static="1">
			<f a="image:buffer:width:height">
				<d/>
				<d/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":cffi"/></meta>
		</lime_image_data_util_resize>
		<lime_image_data_util_set_format get="inline" set="null" line="1278" static="1">
			<f a="image:format">
				<d/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":cffi"/></meta>
		</lime_image_data_util_set_format>
		<lime_image_data_util_set_pixels get="inline" set="null" line="1279" static="1">
			<f a="image:rect:bytes:format">
				<d/>
				<d/>
				<d/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":cffi"/></meta>
		</lime_image_data_util_set_pixels>
		<lime_image_data_util_threshold get="inline" set="null" line="1280" static="1">
			<f a="image:sourceImage:sourceRect:destPoint:operation:thresholdRG:thresholdBA:colorRG:colorBA:maskRG:maskBA:copySource">
				<d/>
				<c path="lime.graphics.Image"/>
				<d/>
				<d/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Int"/>
			</f>
			<meta><m n=":cffi"/></meta>
		</lime_image_data_util_threshold>
		<lime_image_data_util_unmultiply_alpha get="inline" set="null" line="1281" static="1">
			<f a="image">
				<d/>
				<x path="Void"/>
			</f>
			<meta><m n=":cffi"/></meta>
		</lime_image_data_util_unmultiply_alpha>
		<cffi_lime_image_data_util_color_transform expr="new cpp.Callable&lt;Dynamic -&gt; Dynamic -&gt; Dynamic&gt;(lime.system.CFFI.load(&quot;lime&quot;, &quot;lime_image_data_util_color_transform&quot;, 3, false))" line="1269" static="1">
			<x path="cpp.Callable"><f a="::">
	<d/>
	<d/>
	<d/>
	<x path="Void"/>
</f></x>
			<meta><m n=":value"><e><![CDATA[new cpp.Callable<Dynamic -> Dynamic -> Dynamic>(lime.system.CFFI.load("lime", "lime_image_data_util_color_transform", 3, false))]]></e></m></meta>
		</cffi_lime_image_data_util_color_transform>
		<cffi_lime_image_data_util_copy_channel expr="new cpp.Callable&lt;Dynamic -&gt; Dynamic -&gt; Dynamic -&gt; Dynamic -&gt; Int -&gt; Int&gt;(lime.system.CFFI.load(&quot;lime&quot;, &quot;lime_image_data_util_copy_channel&quot;, -1, false))" line="1270" static="1">
			<x path="cpp.Callable"><f a=":::::">
	<d/>
	<d/>
	<d/>
	<d/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></x>
			<meta><m n=":value"><e><![CDATA[new cpp.Callable<Dynamic -> Dynamic -> Dynamic -> Dynamic -> Int -> Int>(lime.system.CFFI.load("lime", "lime_image_data_util_copy_channel", -1, false))]]></e></m></meta>
		</cffi_lime_image_data_util_copy_channel>
		<cffi_lime_image_data_util_copy_pixels expr="new cpp.Callable&lt;Dynamic -&gt; Dynamic -&gt; Dynamic -&gt; Dynamic -&gt; Dynamic -&gt; Dynamic -&gt; Bool&gt;(lime.system.CFFI.load(&quot;lime&quot;, &quot;lime_image_data_util_copy_pixels&quot;, -1, false))" line="1271" static="1">
			<x path="cpp.Callable"><f a="::::::">
	<d/>
	<d/>
	<d/>
	<d/>
	<d/>
	<d/>
	<x path="Bool"/>
	<x path="Void"/>
</f></x>
			<meta><m n=":value"><e><![CDATA[new cpp.Callable<Dynamic -> Dynamic -> Dynamic -> Dynamic -> Dynamic -> Dynamic -> Bool>(lime.system.CFFI.load("lime", "lime_image_data_util_copy_pixels", -1, false))]]></e></m></meta>
		</cffi_lime_image_data_util_copy_pixels>
		<cffi_lime_image_data_util_fill_rect expr="new cpp.Callable&lt;Dynamic -&gt; Dynamic -&gt; Int -&gt; Int&gt;(lime.system.CFFI.load(&quot;lime&quot;, &quot;lime_image_data_util_fill_rect&quot;, 4, false))" line="1272" static="1">
			<x path="cpp.Callable"><f a=":::">
	<d/>
	<d/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></x>
			<meta><m n=":value"><e><![CDATA[new cpp.Callable<Dynamic -> Dynamic -> Int -> Int>(lime.system.CFFI.load("lime", "lime_image_data_util_fill_rect", 4, false))]]></e></m></meta>
		</cffi_lime_image_data_util_fill_rect>
		<cffi_lime_image_data_util_flood_fill expr="new cpp.Callable&lt;Dynamic -&gt; Int -&gt; Int -&gt; Int -&gt; Int&gt;(lime.system.CFFI.load(&quot;lime&quot;, &quot;lime_image_data_util_flood_fill&quot;, 5, false))" line="1273" static="1">
			<x path="cpp.Callable"><f a="::::">
	<d/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></x>
			<meta><m n=":value"><e><![CDATA[new cpp.Callable<Dynamic -> Int -> Int -> Int -> Int>(lime.system.CFFI.load("lime", "lime_image_data_util_flood_fill", 5, false))]]></e></m></meta>
		</cffi_lime_image_data_util_flood_fill>
		<cffi_lime_image_data_util_get_pixels expr="new cpp.Callable&lt;Dynamic -&gt; Dynamic -&gt; Int -&gt; Dynamic&gt;(lime.system.CFFI.load(&quot;lime&quot;, &quot;lime_image_data_util_get_pixels&quot;, 4, false))" line="1274" static="1">
			<x path="cpp.Callable"><f a=":::">
	<d/>
	<d/>
	<x path="Int"/>
	<d/>
	<x path="Void"/>
</f></x>
			<meta><m n=":value"><e><![CDATA[new cpp.Callable<Dynamic -> Dynamic -> Int -> Dynamic>(lime.system.CFFI.load("lime", "lime_image_data_util_get_pixels", 4, false))]]></e></m></meta>
		</cffi_lime_image_data_util_get_pixels>
		<cffi_lime_image_data_util_merge expr="new cpp.Callable&lt;Dynamic -&gt; Dynamic -&gt; Dynamic -&gt; Dynamic -&gt; Int -&gt; Int -&gt; Int -&gt; Int&gt;(lime.system.CFFI.load(&quot;lime&quot;, &quot;lime_image_data_util_merge&quot;, -1, false))" line="1275" static="1">
			<x path="cpp.Callable"><f a=":::::::">
	<d/>
	<d/>
	<d/>
	<d/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></x>
			<meta><m n=":value"><e><![CDATA[new cpp.Callable<Dynamic -> Dynamic -> Dynamic -> Dynamic -> Int -> Int -> Int -> Int>(lime.system.CFFI.load("lime", "lime_image_data_util_merge", -1, false))]]></e></m></meta>
		</cffi_lime_image_data_util_merge>
		<cffi_lime_image_data_util_multiply_alpha expr="new cpp.Callable&lt;Dynamic&gt;(lime.system.CFFI.load(&quot;lime&quot;, &quot;lime_image_data_util_multiply_alpha&quot;, 1, false))" line="1276" static="1">
			<x path="cpp.Callable"><f a="">
	<d/>
	<x path="Void"/>
</f></x>
			<meta><m n=":value"><e><![CDATA[new cpp.Callable<Dynamic>(lime.system.CFFI.load("lime", "lime_image_data_util_multiply_alpha", 1, false))]]></e></m></meta>
		</cffi_lime_image_data_util_multiply_alpha>
		<cffi_lime_image_data_util_resize expr="new cpp.Callable&lt;Dynamic -&gt; Dynamic -&gt; Int -&gt; Int&gt;(lime.system.CFFI.load(&quot;lime&quot;, &quot;lime_image_data_util_resize&quot;, 4, false))" line="1277" static="1">
			<x path="cpp.Callable"><f a=":::">
	<d/>
	<d/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></x>
			<meta><m n=":value"><e><![CDATA[new cpp.Callable<Dynamic -> Dynamic -> Int -> Int>(lime.system.CFFI.load("lime", "lime_image_data_util_resize", 4, false))]]></e></m></meta>
		</cffi_lime_image_data_util_resize>
		<cffi_lime_image_data_util_set_format expr="new cpp.Callable&lt;Dynamic -&gt; Int&gt;(lime.system.CFFI.load(&quot;lime&quot;, &quot;lime_image_data_util_set_format&quot;, 2, false))" line="1278" static="1">
			<x path="cpp.Callable"><f a=":">
	<d/>
	<x path="Int"/>
	<x path="Void"/>
</f></x>
			<meta><m n=":value"><e><![CDATA[new cpp.Callable<Dynamic -> Int>(lime.system.CFFI.load("lime", "lime_image_data_util_set_format", 2, false))]]></e></m></meta>
		</cffi_lime_image_data_util_set_format>
		<cffi_lime_image_data_util_set_pixels expr="new cpp.Callable&lt;Dynamic -&gt; Dynamic -&gt; Dynamic -&gt; Int&gt;(lime.system.CFFI.load(&quot;lime&quot;, &quot;lime_image_data_util_set_pixels&quot;, 4, false))" line="1279" static="1">
			<x path="cpp.Callable"><f a=":::">
	<d/>
	<d/>
	<d/>
	<x path="Int"/>
	<x path="Void"/>
</f></x>
			<meta><m n=":value"><e><![CDATA[new cpp.Callable<Dynamic -> Dynamic -> Dynamic -> Int>(lime.system.CFFI.load("lime", "lime_image_data_util_set_pixels", 4, false))]]></e></m></meta>
		</cffi_lime_image_data_util_set_pixels>
		<cffi_lime_image_data_util_threshold expr="new cpp.Callable&lt;Dynamic -&gt; Dynamic -&gt; Dynamic -&gt; Dynamic -&gt; Int -&gt; Int -&gt; Int -&gt; Int -&gt; Int -&gt; Int -&gt; Int -&gt; Bool&gt;(lime.system.CFFI.load(&quot;lime&quot;, &quot;lime_image_data_util_threshold&quot;, -1, false))" line="1280" static="1">
			<x path="cpp.Callable"><f a=":::::::::::">
	<d/>
	<d/>
	<d/>
	<d/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Bool"/>
	<x path="Int"/>
</f></x>
			<meta><m n=":value"><e><![CDATA[new cpp.Callable<Dynamic -> Dynamic -> Dynamic -> Dynamic -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Bool>(lime.system.CFFI.load("lime", "lime_image_data_util_threshold", -1, false))]]></e></m></meta>
		</cffi_lime_image_data_util_threshold>
		<cffi_lime_image_data_util_unmultiply_alpha expr="new cpp.Callable&lt;Dynamic&gt;(lime.system.CFFI.load(&quot;lime&quot;, &quot;lime_image_data_util_unmultiply_alpha&quot;, 1, false))" line="1281" static="1">
			<x path="cpp.Callable"><f a="">
	<d/>
	<x path="Void"/>
</f></x>
			<meta><m n=":value"><e><![CDATA[new cpp.Callable<Dynamic>(lime.system.CFFI.load("lime", "lime_image_data_util_unmultiply_alpha", 1, false))]]></e></m></meta>
		</cffi_lime_image_data_util_unmultiply_alpha>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>lime.system.CFFI.build()</e></m>
			<m n=":access"><e>lime.math.color.RGBA</e></m>
		</meta>
	</class>
	<class path="lime.graphics.utils._ImageDataUtil.ImageDataView" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/graphics/utils/ImageDataUtil.hx" private="1" module="lime.graphics.utils.ImageDataUtil">
		<x public="1" set="null"><x path="Int"/></x>
		<y public="1" set="null"><x path="Int"/></y>
		<height public="1" set="null"><x path="Int"/></height>
		<width public="1" set="null"><x path="Int"/></width>
		<image><c path="lime.graphics.Image"/></image>
		<offset><x path="Int"/></offset>
		<rect><c path="lime.math.Rectangle"/></rect>
		<stride><x path="Int"/></stride>
		<clip public="1" set="method" line="1333"><f a="x:y:width:height">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></clip>
		<row public="1" get="inline" set="null" line="1346"><f a="y">
	<x path="Int"/>
	<x path="Int"/>
</f></row>
		<new public="1" set="method" line="1302">
			<f a="image:?rect" v=":null">
				<c path="lime.graphics.Image"/>
				<c path="lime.math.Rectangle"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ rect : null }</e></m></meta>
		</new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<abstract path="lime.graphics.utils._ImageDataUtil.ThresholdOperation" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/graphics/utils/ImageDataUtil.hx" private="1" module="lime.graphics.utils.ImageDataUtil">
		<from><icast><x path="Int"/></icast></from>
		<this><x path="Int"/></this>
		<to><icast><x path="Int"/></icast></to>
		<meta>
			<m n=":noCompletion"/>
			<m n=":dox"><e>hide</e></m>
			<m n=":enum"/>
		</meta>
		<impl><class path="lime.graphics.utils._ImageDataUtil.ThresholdOperation_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/graphics/utils/ImageDataUtil.hx" private="1" module="lime.graphics.utils.ImageDataUtil" extern="1">
	<NOT_EQUALS public="1" get="inline" set="null" expr="cast 0" line="1358" static="1">
		<x path="lime.graphics.utils._ImageDataUtil.ThresholdOperation"/>
		<meta>
			<m n=":value"><e>cast 0</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NOT_EQUALS>
	<EQUALS public="1" get="inline" set="null" expr="cast 1" line="1359" static="1">
		<x path="lime.graphics.utils._ImageDataUtil.ThresholdOperation"/>
		<meta>
			<m n=":value"><e>cast 1</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</EQUALS>
	<LESS_THAN public="1" get="inline" set="null" expr="cast 2" line="1360" static="1">
		<x path="lime.graphics.utils._ImageDataUtil.ThresholdOperation"/>
		<meta>
			<m n=":value"><e>cast 2</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</LESS_THAN>
	<LESS_THAN_OR_EQUAL_TO public="1" get="inline" set="null" expr="cast 3" line="1361" static="1">
		<x path="lime.graphics.utils._ImageDataUtil.ThresholdOperation"/>
		<meta>
			<m n=":value"><e>cast 3</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</LESS_THAN_OR_EQUAL_TO>
	<GREATER_THAN public="1" get="inline" set="null" expr="cast 4" line="1362" static="1">
		<x path="lime.graphics.utils._ImageDataUtil.ThresholdOperation"/>
		<meta>
			<m n=":value"><e>cast 4</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</GREATER_THAN>
	<GREATER_THAN_OR_EQUAL_TO public="1" get="inline" set="null" expr="cast 5" line="1363" static="1">
		<x path="lime.graphics.utils._ImageDataUtil.ThresholdOperation"/>
		<meta>
			<m n=":value"><e>cast 5</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</GREATER_THAN_OR_EQUAL_TO>
	<meta>
		<m n=":final"/>
		<m n=":enum"/>
	</meta>
</class></impl>
	</abstract>
	<class path="lime.graphics.utils._ImageDataUtil.ThresholdOperation_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/graphics/utils/ImageDataUtil.hx" private="1" module="lime.graphics.utils.ImageDataUtil" extern="1">
		<NOT_EQUALS public="1" get="inline" set="null" expr="cast 0" line="1358" static="1">
			<x path="lime.graphics.utils._ImageDataUtil.ThresholdOperation"/>
			<meta>
				<m n=":value"><e>cast 0</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NOT_EQUALS>
		<EQUALS public="1" get="inline" set="null" expr="cast 1" line="1359" static="1">
			<x path="lime.graphics.utils._ImageDataUtil.ThresholdOperation"/>
			<meta>
				<m n=":value"><e>cast 1</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</EQUALS>
		<LESS_THAN public="1" get="inline" set="null" expr="cast 2" line="1360" static="1">
			<x path="lime.graphics.utils._ImageDataUtil.ThresholdOperation"/>
			<meta>
				<m n=":value"><e>cast 2</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</LESS_THAN>
		<LESS_THAN_OR_EQUAL_TO public="1" get="inline" set="null" expr="cast 3" line="1361" static="1">
			<x path="lime.graphics.utils._ImageDataUtil.ThresholdOperation"/>
			<meta>
				<m n=":value"><e>cast 3</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</LESS_THAN_OR_EQUAL_TO>
		<GREATER_THAN public="1" get="inline" set="null" expr="cast 4" line="1362" static="1">
			<x path="lime.graphics.utils._ImageDataUtil.ThresholdOperation"/>
			<meta>
				<m n=":value"><e>cast 4</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</GREATER_THAN>
		<GREATER_THAN_OR_EQUAL_TO public="1" get="inline" set="null" expr="cast 5" line="1363" static="1">
			<x path="lime.graphics.utils._ImageDataUtil.ThresholdOperation"/>
			<meta>
				<m n=":value"><e>cast 5</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</GREATER_THAN_OR_EQUAL_TO>
		<meta>
			<m n=":final"/>
			<m n=":enum"/>
		</meta>
	</class>
	<abstract path="lime.math.ColorMatrix" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/math/ColorMatrix.hx">
		<from><icast><x path="lime.utils.Float32Array"/></icast></from>
		<this><x path="lime.utils.Float32Array"/></this>
		<to><icast><x path="lime.utils.Float32Array"/></icast></to>
		<impl><class path="lime.math._ColorMatrix.ColorMatrix_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/math/ColorMatrix.hx" private="1" module="lime.math.ColorMatrix">
	<__identity expr="[1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0]" line="15" static="1">
		<c path="Array"><x path="Float"/></c>
		<meta><m n=":value"><e>[1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0]</e></m></meta>
	</__identity>
	<alphaMultiplier public="1" get="accessor" set="accessor" static="1">
		<x path="Float"/>
		<meta><m n=":impl"/></meta>
	</alphaMultiplier>
	<alphaOffset public="1" get="accessor" set="accessor" static="1">
		<x path="Float"/>
		<meta><m n=":impl"/></meta>
	</alphaOffset>
	<blueMultiplier public="1" get="accessor" set="accessor" static="1">
		<x path="Float"/>
		<meta><m n=":impl"/></meta>
	</blueMultiplier>
	<blueOffset public="1" get="accessor" set="accessor" static="1">
		<x path="Float"/>
		<meta><m n=":impl"/></meta>
	</blueOffset>
	<color public="1" get="accessor" set="accessor" static="1">
		<x path="Int"/>
		<meta><m n=":impl"/></meta>
	</color>
	<greenMultiplier public="1" get="accessor" set="accessor" static="1">
		<x path="Float"/>
		<meta><m n=":impl"/></meta>
	</greenMultiplier>
	<greenOffset public="1" get="accessor" set="accessor" static="1">
		<x path="Float"/>
		<meta><m n=":impl"/></meta>
	</greenOffset>
	<redMultiplier public="1" get="accessor" set="accessor" static="1">
		<x path="Float"/>
		<meta><m n=":impl"/></meta>
	</redMultiplier>
	<redOffset public="1" get="accessor" set="accessor" static="1">
		<x path="Float"/>
		<meta><m n=":impl"/></meta>
	</redOffset>
	<_new public="1" set="method" line="28" static="1">
		<f a="?data" v="null">
			<x path="lime.utils.Float32Array"/>
			<x path="lime.math.ColorMatrix"/>
		</f>
		<meta>
			<m n=":value"><e>{ data : null }</e></m>
			<m n=":impl"/>
		</meta>
	</_new>
	<clone public="1" set="method" line="43" static="1">
		<f a="this">
			<x path="lime.utils.Float32Array"/>
			<x path="lime.math.ColorMatrix"/>
		</f>
		<meta><m n=":impl"/></meta>
	</clone>
	<concat public="1" set="method" line="50" static="1">
		<f a="this:second">
			<x path="lime.utils.Float32Array"/>
			<x path="lime.math.ColorMatrix"/>
			<x path="Void"/>
		</f>
		<meta><m n=":impl"/></meta>
	</concat>
	<copyFrom public="1" set="method" line="60" static="1">
		<f a="this:other">
			<x path="lime.utils.Float32Array"/>
			<x path="lime.math.ColorMatrix"/>
			<x path="Void"/>
		</f>
		<meta><m n=":impl"/></meta>
	</copyFrom>
	<identity public="1" set="method" line="67" static="1">
		<f a="this">
			<x path="lime.utils.Float32Array"/>
			<x path="Void"/>
		</f>
		<meta><m n=":impl"/></meta>
	</identity>
	<getAlphaTable public="1" set="method" line="93" static="1">
		<f a="this">
			<x path="lime.utils.Float32Array"/>
			<x path="lime.utils.UInt8Array"/>
		</f>
		<meta><m n=":impl"/></meta>
	</getAlphaTable>
	<getBlueTable public="1" set="method" line="114" static="1">
		<f a="this">
			<x path="lime.utils.Float32Array"/>
			<x path="lime.utils.UInt8Array"/>
		</f>
		<meta><m n=":impl"/></meta>
	</getBlueTable>
	<getGreenTable public="1" set="method" line="135" static="1">
		<f a="this">
			<x path="lime.utils.Float32Array"/>
			<x path="lime.utils.UInt8Array"/>
		</f>
		<meta><m n=":impl"/></meta>
	</getGreenTable>
	<getRedTable public="1" set="method" line="156" static="1">
		<f a="this">
			<x path="lime.utils.Float32Array"/>
			<x path="lime.utils.UInt8Array"/>
		</f>
		<meta><m n=":impl"/></meta>
	</getRedTable>
	<__toFlashColorTransform set="method" line="177" static="1">
		<f a="this">
			<x path="lime.utils.Float32Array"/>
			<d/>
		</f>
		<meta><m n=":impl"/></meta>
	</__toFlashColorTransform>
	<get_alphaMultiplier get="inline" set="null" line="195" static="1">
		<f a="this">
			<x path="lime.utils.Float32Array"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_alphaMultiplier>
	<set_alphaMultiplier get="inline" set="null" line="202" static="1">
		<f a="this:value">
			<x path="lime.utils.Float32Array"/>
			<x path="Float"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</set_alphaMultiplier>
	<get_alphaOffset get="inline" set="null" line="209" static="1">
		<f a="this">
			<x path="lime.utils.Float32Array"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_alphaOffset>
	<set_alphaOffset get="inline" set="null" line="216" static="1">
		<f a="this:value">
			<x path="lime.utils.Float32Array"/>
			<x path="Float"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</set_alphaOffset>
	<get_blueMultiplier get="inline" set="null" line="223" static="1">
		<f a="this">
			<x path="lime.utils.Float32Array"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_blueMultiplier>
	<set_blueMultiplier get="inline" set="null" line="230" static="1">
		<f a="this:value">
			<x path="lime.utils.Float32Array"/>
			<x path="Float"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</set_blueMultiplier>
	<get_blueOffset get="inline" set="null" line="237" static="1">
		<f a="this">
			<x path="lime.utils.Float32Array"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_blueOffset>
	<set_blueOffset get="inline" set="null" line="244" static="1">
		<f a="this:value">
			<x path="lime.utils.Float32Array"/>
			<x path="Float"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</set_blueOffset>
	<get_color set="method" line="251" static="1">
		<f a="this">
			<x path="lime.utils.Float32Array"/>
			<x path="Int"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_color>
	<set_color set="method" line="258" static="1">
		<f a="this:value">
			<x path="lime.utils.Float32Array"/>
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<meta><m n=":impl"/></meta>
	</set_color>
	<get_greenMultiplier get="inline" set="null" line="273" static="1">
		<f a="this">
			<x path="lime.utils.Float32Array"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_greenMultiplier>
	<set_greenMultiplier get="inline" set="null" line="280" static="1">
		<f a="this:value">
			<x path="lime.utils.Float32Array"/>
			<x path="Float"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</set_greenMultiplier>
	<get_greenOffset get="inline" set="null" line="287" static="1">
		<f a="this">
			<x path="lime.utils.Float32Array"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_greenOffset>
	<set_greenOffset get="inline" set="null" line="294" static="1">
		<f a="this:value">
			<x path="lime.utils.Float32Array"/>
			<x path="Float"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</set_greenOffset>
	<get_redMultiplier get="inline" set="null" line="301" static="1">
		<f a="this">
			<x path="lime.utils.Float32Array"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_redMultiplier>
	<set_redMultiplier get="inline" set="null" line="308" static="1">
		<f a="this:value">
			<x path="lime.utils.Float32Array"/>
			<x path="Float"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</set_redMultiplier>
	<get_redOffset get="inline" set="null" line="315" static="1">
		<f a="this">
			<x path="lime.utils.Float32Array"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_redOffset>
	<set_redOffset get="inline" set="null" line="322" static="1">
		<f a="this:value">
			<x path="lime.utils.Float32Array"/>
			<x path="Float"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</set_redOffset>
	<get public="1" set="method" line="329" static="1">
		<f a="this:index">
			<x path="lime.utils.Float32Array"/>
			<x path="Int"/>
			<x path="Float"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":arrayAccess"/>
		</meta>
	</get>
	<set public="1" set="method" line="336" static="1">
		<f a="this:index:value">
			<x path="lime.utils.Float32Array"/>
			<x path="Int"/>
			<x path="Float"/>
			<x path="Float"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":arrayAccess"/>
		</meta>
	</set>
	<meta>
		<m n=":directlyUsed"/>
		<m n=":final"/>
	</meta>
</class></impl>
	</abstract>
	<class path="lime.math._ColorMatrix.ColorMatrix_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/math/ColorMatrix.hx" private="1" module="lime.math.ColorMatrix">
		<__identity expr="[1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0]" line="15" static="1">
			<c path="Array"><x path="Float"/></c>
			<meta><m n=":value"><e>[1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0]</e></m></meta>
		</__identity>
		<alphaMultiplier public="1" get="accessor" set="accessor" static="1">
			<x path="Float"/>
			<meta><m n=":impl"/></meta>
		</alphaMultiplier>
		<alphaOffset public="1" get="accessor" set="accessor" static="1">
			<x path="Float"/>
			<meta><m n=":impl"/></meta>
		</alphaOffset>
		<blueMultiplier public="1" get="accessor" set="accessor" static="1">
			<x path="Float"/>
			<meta><m n=":impl"/></meta>
		</blueMultiplier>
		<blueOffset public="1" get="accessor" set="accessor" static="1">
			<x path="Float"/>
			<meta><m n=":impl"/></meta>
		</blueOffset>
		<color public="1" get="accessor" set="accessor" static="1">
			<x path="Int"/>
			<meta><m n=":impl"/></meta>
		</color>
		<greenMultiplier public="1" get="accessor" set="accessor" static="1">
			<x path="Float"/>
			<meta><m n=":impl"/></meta>
		</greenMultiplier>
		<greenOffset public="1" get="accessor" set="accessor" static="1">
			<x path="Float"/>
			<meta><m n=":impl"/></meta>
		</greenOffset>
		<redMultiplier public="1" get="accessor" set="accessor" static="1">
			<x path="Float"/>
			<meta><m n=":impl"/></meta>
		</redMultiplier>
		<redOffset public="1" get="accessor" set="accessor" static="1">
			<x path="Float"/>
			<meta><m n=":impl"/></meta>
		</redOffset>
		<_new public="1" set="method" line="28" static="1">
			<f a="?data" v="null">
				<x path="lime.utils.Float32Array"/>
				<x path="lime.math.ColorMatrix"/>
			</f>
			<meta>
				<m n=":value"><e>{ data : null }</e></m>
				<m n=":impl"/>
			</meta>
		</_new>
		<clone public="1" set="method" line="43" static="1">
			<f a="this">
				<x path="lime.utils.Float32Array"/>
				<x path="lime.math.ColorMatrix"/>
			</f>
			<meta><m n=":impl"/></meta>
		</clone>
		<concat public="1" set="method" line="50" static="1">
			<f a="this:second">
				<x path="lime.utils.Float32Array"/>
				<x path="lime.math.ColorMatrix"/>
				<x path="Void"/>
			</f>
			<meta><m n=":impl"/></meta>
		</concat>
		<copyFrom public="1" set="method" line="60" static="1">
			<f a="this:other">
				<x path="lime.utils.Float32Array"/>
				<x path="lime.math.ColorMatrix"/>
				<x path="Void"/>
			</f>
			<meta><m n=":impl"/></meta>
		</copyFrom>
		<identity public="1" set="method" line="67" static="1">
			<f a="this">
				<x path="lime.utils.Float32Array"/>
				<x path="Void"/>
			</f>
			<meta><m n=":impl"/></meta>
		</identity>
		<getAlphaTable public="1" set="method" line="93" static="1">
			<f a="this">
				<x path="lime.utils.Float32Array"/>
				<x path="lime.utils.UInt8Array"/>
			</f>
			<meta><m n=":impl"/></meta>
		</getAlphaTable>
		<getBlueTable public="1" set="method" line="114" static="1">
			<f a="this">
				<x path="lime.utils.Float32Array"/>
				<x path="lime.utils.UInt8Array"/>
			</f>
			<meta><m n=":impl"/></meta>
		</getBlueTable>
		<getGreenTable public="1" set="method" line="135" static="1">
			<f a="this">
				<x path="lime.utils.Float32Array"/>
				<x path="lime.utils.UInt8Array"/>
			</f>
			<meta><m n=":impl"/></meta>
		</getGreenTable>
		<getRedTable public="1" set="method" line="156" static="1">
			<f a="this">
				<x path="lime.utils.Float32Array"/>
				<x path="lime.utils.UInt8Array"/>
			</f>
			<meta><m n=":impl"/></meta>
		</getRedTable>
		<__toFlashColorTransform set="method" line="177" static="1">
			<f a="this">
				<x path="lime.utils.Float32Array"/>
				<d/>
			</f>
			<meta><m n=":impl"/></meta>
		</__toFlashColorTransform>
		<get_alphaMultiplier get="inline" set="null" line="195" static="1">
			<f a="this">
				<x path="lime.utils.Float32Array"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_alphaMultiplier>
		<set_alphaMultiplier get="inline" set="null" line="202" static="1">
			<f a="this:value">
				<x path="lime.utils.Float32Array"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</set_alphaMultiplier>
		<get_alphaOffset get="inline" set="null" line="209" static="1">
			<f a="this">
				<x path="lime.utils.Float32Array"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_alphaOffset>
		<set_alphaOffset get="inline" set="null" line="216" static="1">
			<f a="this:value">
				<x path="lime.utils.Float32Array"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</set_alphaOffset>
		<get_blueMultiplier get="inline" set="null" line="223" static="1">
			<f a="this">
				<x path="lime.utils.Float32Array"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_blueMultiplier>
		<set_blueMultiplier get="inline" set="null" line="230" static="1">
			<f a="this:value">
				<x path="lime.utils.Float32Array"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</set_blueMultiplier>
		<get_blueOffset get="inline" set="null" line="237" static="1">
			<f a="this">
				<x path="lime.utils.Float32Array"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_blueOffset>
		<set_blueOffset get="inline" set="null" line="244" static="1">
			<f a="this:value">
				<x path="lime.utils.Float32Array"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</set_blueOffset>
		<get_color set="method" line="251" static="1">
			<f a="this">
				<x path="lime.utils.Float32Array"/>
				<x path="Int"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_color>
		<set_color set="method" line="258" static="1">
			<f a="this:value">
				<x path="lime.utils.Float32Array"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":impl"/></meta>
		</set_color>
		<get_greenMultiplier get="inline" set="null" line="273" static="1">
			<f a="this">
				<x path="lime.utils.Float32Array"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_greenMultiplier>
		<set_greenMultiplier get="inline" set="null" line="280" static="1">
			<f a="this:value">
				<x path="lime.utils.Float32Array"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</set_greenMultiplier>
		<get_greenOffset get="inline" set="null" line="287" static="1">
			<f a="this">
				<x path="lime.utils.Float32Array"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_greenOffset>
		<set_greenOffset get="inline" set="null" line="294" static="1">
			<f a="this:value">
				<x path="lime.utils.Float32Array"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</set_greenOffset>
		<get_redMultiplier get="inline" set="null" line="301" static="1">
			<f a="this">
				<x path="lime.utils.Float32Array"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_redMultiplier>
		<set_redMultiplier get="inline" set="null" line="308" static="1">
			<f a="this:value">
				<x path="lime.utils.Float32Array"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</set_redMultiplier>
		<get_redOffset get="inline" set="null" line="315" static="1">
			<f a="this">
				<x path="lime.utils.Float32Array"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_redOffset>
		<set_redOffset get="inline" set="null" line="322" static="1">
			<f a="this:value">
				<x path="lime.utils.Float32Array"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</set_redOffset>
		<get public="1" set="method" line="329" static="1">
			<f a="this:index">
				<x path="lime.utils.Float32Array"/>
				<x path="Int"/>
				<x path="Float"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":arrayAccess"/>
			</meta>
		</get>
		<set public="1" set="method" line="336" static="1">
			<f a="this:index:value">
				<x path="lime.utils.Float32Array"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":arrayAccess"/>
			</meta>
		</set>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":final"/>
		</meta>
	</class>
	<class path="lime.math.Matrix3" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/math/Matrix3.hx">
		<__identity expr="new Matrix3()" line="14" static="1">
			<c path="lime.math.Matrix3"/>
			<meta><m n=":value"><e>new Matrix3()</e></m></meta>
		</__identity>
		<a public="1"><x path="Float"/></a>
		<b public="1"><x path="Float"/></b>
		<c public="1"><x path="Float"/></c>
		<d public="1"><x path="Float"/></d>
		<tx public="1"><x path="Float"/></tx>
		<ty public="1"><x path="Float"/></ty>
		<clone public="1" get="inline" set="null" line="29"><f a=""><c path="lime.math.Matrix3"/></f></clone>
		<concat public="1" set="method" line="36"><f a="m">
	<c path="lime.math.Matrix3"/>
	<x path="Void"/>
</f></concat>
		<copyColumnFrom public="1" set="method" line="55"><f a="column:vector4">
	<x path="Int"/>
	<c path="lime.math.Vector4"/>
	<x path="Void"/>
</f></copyColumnFrom>
		<copyColumnTo public="1" set="method" line="81"><f a="column:vector4">
	<x path="Int"/>
	<c path="lime.math.Vector4"/>
	<x path="Void"/>
</f></copyColumnTo>
		<copyFrom public="1" set="method" line="110"><f a="sourceMatrix3">
	<c path="lime.math.Matrix3"/>
	<x path="Void"/>
</f></copyFrom>
		<copyRowFrom public="1" set="method" line="122"><f a="row:vector4">
	<x path="Int"/>
	<c path="lime.math.Vector4"/>
	<x path="Void"/>
</f></copyRowFrom>
		<copyRowTo public="1" set="method" line="148"><f a="row:vector4">
	<x path="Int"/>
	<c path="lime.math.Vector4"/>
	<x path="Void"/>
</f></copyRowTo>
		<createBox public="1" set="method" line="175">
			<f a="scaleX:scaleY:?rotation:?tx:?ty" v="::0:0:0">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ ty : 0, tx : 0, rotation : 0 }</e></m></meta>
		</createBox>
		<createGradientBox public="1" set="method" line="186">
			<f a="width:height:?rotation:?tx:?ty" v="::0:0:0">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ ty : 0, tx : 0, rotation : 0 }</e></m></meta>
		</createGradientBox>
		<equals public="1" set="method" line="215"><f a="Matrix3">
	<a>
		<ty set="null"><x path="Float"/></ty>
		<tx set="null"><x path="Float"/></tx>
		<d set="null"><x path="Float"/></d>
		<c set="null"><x path="Float"/></c>
		<b set="null"><x path="Float"/></b>
		<a set="null"><x path="Float"/></a>
	</a>
	<x path="Bool"/>
</f></equals>
		<deltaTransformVector2 public="1" set="method" line="222"><f a="Vector2">
	<c path="lime.math.Vector2"/>
	<c path="lime.math.Vector2"/>
</f></deltaTransformVector2>
		<identity public="1" set="method" line="229"><f a=""><x path="Void"/></f></identity>
		<invert public="1" set="method" line="241"><f a=""><c path="lime.math.Matrix3"/></f></invert>
		<mult public="1" get="inline" set="null" line="273"><f a="m">
	<c path="lime.math.Matrix3"/>
	<c path="lime.math.Matrix3"/>
</f></mult>
		<rotate public="1" set="method" line="282"><f a="theta">
	<x path="Float"/>
	<x path="Void"/>
</f></rotate>
		<scale public="1" set="method" line="318"><f a="sx:sy">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></scale>
		<setRotation get="inline" set="null" line="341">
			<f a="theta:?scale" v=":1">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ scale : 1 }</e></m></meta>
		</setRotation>
		<setTo public="1" set="method" line="353"><f a="a:b:c:d:tx:ty">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></setTo>
		<to3DString public="1" get="inline" set="null" line="365">
			<f a="?roundPixels" v="false">
				<x path="Bool"/>
				<c path="String"/>
			</f>
			<meta><m n=":value"><e>{ roundPixels : false }</e></m></meta>
		</to3DString>
		<toMozString public="1" get="inline" set="null" line="388"><f a=""><c path="String"/></f></toMozString>
		<toString public="1" get="inline" set="null" line="395"><f a=""><c path="String"/></f></toString>
		<transformVector2 public="1" set="method" line="402"><f a="pos">
	<c path="lime.math.Vector2"/>
	<c path="lime.math.Vector2"/>
</f></transformVector2>
		<translate public="1" get="inline" set="null" line="409"><f a="dx:dy">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></translate>
		<__cleanValues get="inline" set="null" line="417"><f a=""><x path="Void"/></f></__cleanValues>
		<__transformX public="1" get="inline" set="null" line="429"><f a="pos">
	<c path="lime.math.Vector2"/>
	<x path="Float"/>
</f></__transformX>
		<__transformY public="1" get="inline" set="null" line="436"><f a="pos">
	<c path="lime.math.Vector2"/>
	<x path="Float"/>
</f></__transformY>
		<__translateTransformed public="1" get="inline" set="null" line="443"><f a="pos">
	<c path="lime.math.Vector2"/>
	<x path="Void"/>
</f></__translateTransformed>
		<new public="1" set="method" line="17">
			<f a="?a:?b:?c:?d:?tx:?ty" v="1:0:0:1:0:0">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ ty : 0, tx : 0, d : 1, c : 0, b : 0, a : 1 }</e></m></meta>
		</new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<abstract path="lime.math.Matrix4" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/math/Matrix4.hx">
		<from><icast><x path="lime.utils.Float32Array"/></icast></from>
		<this><x path="lime.utils.Float32Array"/></this>
		<to><icast><x path="lime.utils.Float32Array"/></icast></to>
		<impl><class path="lime.math._Matrix4.Matrix4_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/math/Matrix4.hx" private="1" module="lime.math.Matrix4">
	<__identity expr="[1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0]" line="10" static="1">
		<c path="Array"><x path="Float"/></c>
		<meta><m n=":value"><e>[1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0]</e></m></meta>
	</__identity>
	<determinant public="1" get="accessor" set="null" static="1">
		<x path="Float"/>
		<meta><m n=":impl"/></meta>
	</determinant>
	<position public="1" get="accessor" set="accessor" static="1">
		<c path="lime.math.Vector4"/>
		<meta><m n=":impl"/></meta>
	</position>
	<_new public="1" set="method" line="16" static="1">
		<f a="?data" v="null">
			<x path="lime.utils.Float32Array"/>
			<x path="lime.math.Matrix4"/>
		</f>
		<meta>
			<m n=":value"><e>{ data : null }</e></m>
			<m n=":impl"/>
		</meta>
	</_new>
	<append public="1" set="method" line="31" static="1">
		<f a="this:lhs">
			<x path="lime.utils.Float32Array"/>
			<x path="lime.math.Matrix4"/>
			<x path="Void"/>
		</f>
		<meta><m n=":impl"/></meta>
	</append>
	<appendRotation public="1" set="method" line="65" static="1">
		<f a="this:degrees:axis:?pivotPoint" v=":::null">
			<x path="lime.utils.Float32Array"/>
			<x path="Float"/>
			<c path="lime.math.Vector4"/>
			<c path="lime.math.Vector4"/>
			<x path="Void"/>
		</f>
		<meta>
			<m n=":value"><e>{ pivotPoint : null }</e></m>
			<m n=":impl"/>
		</meta>
	</appendRotation>
	<appendScale public="1" set="method" line="81" static="1">
		<f a="this:xScale:yScale:zScale">
			<x path="lime.utils.Float32Array"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Void"/>
		</f>
		<meta><m n=":impl"/></meta>
	</appendScale>
	<appendTranslation public="1" set="method" line="88" static="1">
		<f a="this:x:y:z">
			<x path="lime.utils.Float32Array"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Void"/>
		</f>
		<meta><m n=":impl"/></meta>
	</appendTranslation>
	<clone public="1" set="method" line="97" static="1">
		<f a="this">
			<x path="lime.utils.Float32Array"/>
			<x path="lime.math.Matrix4"/>
		</f>
		<meta><m n=":impl"/></meta>
	</clone>
	<copyColumnFrom public="1" set="method" line="104" static="1">
		<f a="this:column:vector">
			<x path="lime.utils.Float32Array"/>
			<x path="Int"/>
			<c path="lime.math.Vector4"/>
			<x path="Void"/>
		</f>
		<meta><m n=":impl"/></meta>
	</copyColumnFrom>
	<copyColumnTo public="1" set="method" line="136" static="1">
		<f a="this:column:vector">
			<x path="lime.utils.Float32Array"/>
			<x path="Int"/>
			<c path="lime.math.Vector4"/>
			<x path="Void"/>
		</f>
		<meta><m n=":impl"/></meta>
	</copyColumnTo>
	<copyFrom public="1" set="method" line="168" static="1">
		<f a="this:other">
			<x path="lime.utils.Float32Array"/>
			<x path="lime.math.Matrix4"/>
			<x path="Void"/>
		</f>
		<meta><m n=":impl"/></meta>
	</copyFrom>
	<copythisFrom public="1" set="method" line="174" static="1">
		<f a="this:array:?index:?transposeValues" v="::0:false">
			<x path="lime.utils.Float32Array"/>
			<x path="lime.utils.Float32Array"/>
			<x path="UInt"/>
			<x path="Bool"/>
			<x path="Void"/>
		</f>
		<meta>
			<m n=":value"><e>{ transposeValues : false, index : 0 }</e></m>
			<m n=":impl"/>
		</meta>
	</copythisFrom>
	<copythisTo public="1" set="method" line="189" static="1">
		<f a="this:array:?index:?transposeValues" v="::0:false">
			<x path="lime.utils.Float32Array"/>
			<x path="lime.utils.Float32Array"/>
			<x path="UInt"/>
			<x path="Bool"/>
			<x path="Void"/>
		</f>
		<meta>
			<m n=":value"><e>{ transposeValues : false, index : 0 }</e></m>
			<m n=":impl"/>
		</meta>
	</copythisTo>
	<copyRowFrom public="1" set="method" line="204" static="1">
		<f a="this:row:vector">
			<x path="lime.utils.Float32Array"/>
			<x path="UInt"/>
			<c path="lime.math.Vector4"/>
			<x path="Void"/>
		</f>
		<meta><m n=":impl"/></meta>
	</copyRowFrom>
	<create2D public="1" set="method" line="240" static="1">
		<f a="x:y:?scale:?rotation" v="::1:0">
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="lime.math.Matrix4"/>
		</f>
		<meta><m n=":value"><e>{ rotation : 0, scale : 1 }</e></m></meta>
	</create2D>
	<createABCD public="1" set="method" line="256" static="1"><f a="a:b:c:d:tx:ty">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="lime.math.Matrix4"/>
</f></createABCD>
	<createOrtho public="1" set="method" line="268" static="1"><f a="x0:x1:y0:y1:zNear:zFar">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="lime.math.Matrix4"/>
</f></createOrtho>
	<copyRowTo public="1" set="method" line="284" static="1">
		<f a="this:row:vector">
			<x path="lime.utils.Float32Array"/>
			<x path="Int"/>
			<c path="lime.math.Vector4"/>
			<x path="Void"/>
		</f>
		<meta><m n=":impl"/></meta>
	</copyRowTo>
	<copyToMatrix4 public="1" set="method" line="320" static="1">
		<f a="this:other">
			<x path="lime.utils.Float32Array"/>
			<x path="lime.math.Matrix4"/>
			<x path="Void"/>
		</f>
		<meta><m n=":impl"/></meta>
	</copyToMatrix4>
	<deltaTransformVector public="1" set="method" line="426" static="1">
		<f a="this:v">
			<x path="lime.utils.Float32Array"/>
			<c path="lime.math.Vector4"/>
			<c path="lime.math.Vector4"/>
		</f>
		<meta><m n=":impl"/></meta>
		<haxe_doc>* Returns the transformation matrix's translation, rotation, and scale settings as a Vector of three Vector4 objects.</haxe_doc>
	</deltaTransformVector>
	<identity public="1" set="method" line="439" static="1">
		<f a="this">
			<x path="lime.utils.Float32Array"/>
			<x path="Void"/>
		</f>
		<meta><m n=":impl"/></meta>
	</identity>
	<interpolate public="1" set="method" line="461" static="1"><f a="thisMat:toMat:percent">
	<x path="lime.math.Matrix4"/>
	<x path="lime.math.Matrix4"/>
	<x path="Float"/>
	<x path="lime.math.Matrix4"/>
</f></interpolate>
	<interpolateTo public="1" set="method" line="476" static="1">
		<f a="this:toMat:percent">
			<x path="lime.utils.Float32Array"/>
			<x path="lime.math.Matrix4"/>
			<x path="Float"/>
			<x path="Void"/>
		</f>
		<meta><m n=":impl"/></meta>
	</interpolateTo>
	<invert public="1" set="method" line="487" static="1">
		<f a="this">
			<x path="lime.utils.Float32Array"/>
			<x path="Bool"/>
		</f>
		<meta><m n=":impl"/></meta>
	</invert>
	<pointAt public="1" set="method" line="525" static="1">
		<f a="this:pos:?at:?up" v="::null:null">
			<x path="lime.utils.Float32Array"/>
			<c path="lime.math.Vector4"/>
			<c path="lime.math.Vector4"/>
			<c path="lime.math.Vector4"/>
			<x path="Void"/>
		</f>
		<meta>
			<m n=":value"><e>{ up : null, at : null }</e></m>
			<m n=":impl"/>
		</meta>
	</pointAt>
	<prepend public="1" set="method" line="592" static="1">
		<f a="this:rhs">
			<x path="lime.utils.Float32Array"/>
			<x path="lime.math.Matrix4"/>
			<x path="Void"/>
		</f>
		<meta><m n=":impl"/></meta>
	</prepend>
	<prependRotation public="1" set="method" line="626" static="1">
		<f a="this:degrees:axis:?pivotPoint" v=":::null">
			<x path="lime.utils.Float32Array"/>
			<x path="Float"/>
			<c path="lime.math.Vector4"/>
			<c path="lime.math.Vector4"/>
			<x path="Void"/>
		</f>
		<meta>
			<m n=":value"><e>{ pivotPoint : null }</e></m>
			<m n=":impl"/>
		</meta>
	</prependRotation>
	<prependScale public="1" set="method" line="642" static="1">
		<f a="this:xScale:yScale:zScale">
			<x path="lime.utils.Float32Array"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Void"/>
		</f>
		<meta><m n=":impl"/></meta>
	</prependScale>
	<prependTranslation public="1" set="method" line="649" static="1">
		<f a="this:x:y:z">
			<x path="lime.utils.Float32Array"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Float"/>
			<x path="Void"/>
		</f>
		<meta><m n=":impl"/></meta>
	</prependTranslation>
	<transformVector public="1" set="method" line="742" static="1">
		<f a="this:v">
			<x path="lime.utils.Float32Array"/>
			<c path="lime.math.Vector4"/>
			<c path="lime.math.Vector4"/>
		</f>
		<meta><m n=":impl"/></meta>
	</transformVector>
	<transformVectors public="1" set="method" line="755" static="1">
		<f a="this:ain:aout">
			<x path="lime.utils.Float32Array"/>
			<x path="lime.utils.Float32Array"/>
			<x path="lime.utils.Float32Array"/>
			<x path="Void"/>
		</f>
		<meta><m n=":impl"/></meta>
	</transformVectors>
	<transpose public="1" set="method" line="774" static="1">
		<f a="this">
			<x path="lime.utils.Float32Array"/>
			<x path="Void"/>
		</f>
		<meta><m n=":impl"/></meta>
	</transpose>
	<getAxisRotation set="method" line="792" static="1"><f a="x:y:z:degrees">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="lime.math.Matrix4"/>
</f></getAxisRotation>
	<get_determinant set="method" line="831" static="1">
		<f a="this">
			<x path="lime.utils.Float32Array"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_determinant>
	<get_position set="method" line="843" static="1">
		<f a="this">
			<x path="lime.utils.Float32Array"/>
			<c path="lime.math.Vector4"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_position>
	<set_position set="method" line="850" static="1">
		<f a="this:val">
			<x path="lime.utils.Float32Array"/>
			<c path="lime.math.Vector4"/>
			<c path="lime.math.Vector4"/>
		</f>
		<meta><m n=":impl"/></meta>
	</set_position>
	<get public="1" set="method" line="860" static="1">
		<f a="this:index">
			<x path="lime.utils.Float32Array"/>
			<x path="Int"/>
			<x path="Float"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":arrayAccess"/>
		</meta>
	</get>
	<set public="1" set="method" line="867" static="1">
		<f a="this:index:value">
			<x path="lime.utils.Float32Array"/>
			<x path="Int"/>
			<x path="Float"/>
			<x path="Float"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":arrayAccess"/>
		</meta>
	</set>
	<meta>
		<m n=":directlyUsed"/>
		<m n=":final"/>
	</meta>
</class></impl>
	</abstract>
	<class path="lime.math._Matrix4.Matrix4_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/math/Matrix4.hx" private="1" module="lime.math.Matrix4">
		<__identity expr="[1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0]" line="10" static="1">
			<c path="Array"><x path="Float"/></c>
			<meta><m n=":value"><e>[1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0]</e></m></meta>
		</__identity>
		<determinant public="1" get="accessor" set="null" static="1">
			<x path="Float"/>
			<meta><m n=":impl"/></meta>
		</determinant>
		<position public="1" get="accessor" set="accessor" static="1">
			<c path="lime.math.Vector4"/>
			<meta><m n=":impl"/></meta>
		</position>
		<_new public="1" set="method" line="16" static="1">
			<f a="?data" v="null">
				<x path="lime.utils.Float32Array"/>
				<x path="lime.math.Matrix4"/>
			</f>
			<meta>
				<m n=":value"><e>{ data : null }</e></m>
				<m n=":impl"/>
			</meta>
		</_new>
		<append public="1" set="method" line="31" static="1">
			<f a="this:lhs">
				<x path="lime.utils.Float32Array"/>
				<x path="lime.math.Matrix4"/>
				<x path="Void"/>
			</f>
			<meta><m n=":impl"/></meta>
		</append>
		<appendRotation public="1" set="method" line="65" static="1">
			<f a="this:degrees:axis:?pivotPoint" v=":::null">
				<x path="lime.utils.Float32Array"/>
				<x path="Float"/>
				<c path="lime.math.Vector4"/>
				<c path="lime.math.Vector4"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":value"><e>{ pivotPoint : null }</e></m>
				<m n=":impl"/>
			</meta>
		</appendRotation>
		<appendScale public="1" set="method" line="81" static="1">
			<f a="this:xScale:yScale:zScale">
				<x path="lime.utils.Float32Array"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":impl"/></meta>
		</appendScale>
		<appendTranslation public="1" set="method" line="88" static="1">
			<f a="this:x:y:z">
				<x path="lime.utils.Float32Array"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":impl"/></meta>
		</appendTranslation>
		<clone public="1" set="method" line="97" static="1">
			<f a="this">
				<x path="lime.utils.Float32Array"/>
				<x path="lime.math.Matrix4"/>
			</f>
			<meta><m n=":impl"/></meta>
		</clone>
		<copyColumnFrom public="1" set="method" line="104" static="1">
			<f a="this:column:vector">
				<x path="lime.utils.Float32Array"/>
				<x path="Int"/>
				<c path="lime.math.Vector4"/>
				<x path="Void"/>
			</f>
			<meta><m n=":impl"/></meta>
		</copyColumnFrom>
		<copyColumnTo public="1" set="method" line="136" static="1">
			<f a="this:column:vector">
				<x path="lime.utils.Float32Array"/>
				<x path="Int"/>
				<c path="lime.math.Vector4"/>
				<x path="Void"/>
			</f>
			<meta><m n=":impl"/></meta>
		</copyColumnTo>
		<copyFrom public="1" set="method" line="168" static="1">
			<f a="this:other">
				<x path="lime.utils.Float32Array"/>
				<x path="lime.math.Matrix4"/>
				<x path="Void"/>
			</f>
			<meta><m n=":impl"/></meta>
		</copyFrom>
		<copythisFrom public="1" set="method" line="174" static="1">
			<f a="this:array:?index:?transposeValues" v="::0:false">
				<x path="lime.utils.Float32Array"/>
				<x path="lime.utils.Float32Array"/>
				<x path="UInt"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":value"><e>{ transposeValues : false, index : 0 }</e></m>
				<m n=":impl"/>
			</meta>
		</copythisFrom>
		<copythisTo public="1" set="method" line="189" static="1">
			<f a="this:array:?index:?transposeValues" v="::0:false">
				<x path="lime.utils.Float32Array"/>
				<x path="lime.utils.Float32Array"/>
				<x path="UInt"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":value"><e>{ transposeValues : false, index : 0 }</e></m>
				<m n=":impl"/>
			</meta>
		</copythisTo>
		<copyRowFrom public="1" set="method" line="204" static="1">
			<f a="this:row:vector">
				<x path="lime.utils.Float32Array"/>
				<x path="UInt"/>
				<c path="lime.math.Vector4"/>
				<x path="Void"/>
			</f>
			<meta><m n=":impl"/></meta>
		</copyRowFrom>
		<create2D public="1" set="method" line="240" static="1">
			<f a="x:y:?scale:?rotation" v="::1:0">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="lime.math.Matrix4"/>
			</f>
			<meta><m n=":value"><e>{ rotation : 0, scale : 1 }</e></m></meta>
		</create2D>
		<createABCD public="1" set="method" line="256" static="1"><f a="a:b:c:d:tx:ty">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="lime.math.Matrix4"/>
</f></createABCD>
		<createOrtho public="1" set="method" line="268" static="1"><f a="x0:x1:y0:y1:zNear:zFar">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="lime.math.Matrix4"/>
</f></createOrtho>
		<copyRowTo public="1" set="method" line="284" static="1">
			<f a="this:row:vector">
				<x path="lime.utils.Float32Array"/>
				<x path="Int"/>
				<c path="lime.math.Vector4"/>
				<x path="Void"/>
			</f>
			<meta><m n=":impl"/></meta>
		</copyRowTo>
		<copyToMatrix4 public="1" set="method" line="320" static="1">
			<f a="this:other">
				<x path="lime.utils.Float32Array"/>
				<x path="lime.math.Matrix4"/>
				<x path="Void"/>
			</f>
			<meta><m n=":impl"/></meta>
		</copyToMatrix4>
		<deltaTransformVector public="1" set="method" line="426" static="1">
			<f a="this:v">
				<x path="lime.utils.Float32Array"/>
				<c path="lime.math.Vector4"/>
				<c path="lime.math.Vector4"/>
			</f>
			<meta><m n=":impl"/></meta>
			<haxe_doc>* Returns the transformation matrix's translation, rotation, and scale settings as a Vector of three Vector4 objects.</haxe_doc>
		</deltaTransformVector>
		<identity public="1" set="method" line="439" static="1">
			<f a="this">
				<x path="lime.utils.Float32Array"/>
				<x path="Void"/>
			</f>
			<meta><m n=":impl"/></meta>
		</identity>
		<interpolate public="1" set="method" line="461" static="1"><f a="thisMat:toMat:percent">
	<x path="lime.math.Matrix4"/>
	<x path="lime.math.Matrix4"/>
	<x path="Float"/>
	<x path="lime.math.Matrix4"/>
</f></interpolate>
		<interpolateTo public="1" set="method" line="476" static="1">
			<f a="this:toMat:percent">
				<x path="lime.utils.Float32Array"/>
				<x path="lime.math.Matrix4"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":impl"/></meta>
		</interpolateTo>
		<invert public="1" set="method" line="487" static="1">
			<f a="this">
				<x path="lime.utils.Float32Array"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":impl"/></meta>
		</invert>
		<pointAt public="1" set="method" line="525" static="1">
			<f a="this:pos:?at:?up" v="::null:null">
				<x path="lime.utils.Float32Array"/>
				<c path="lime.math.Vector4"/>
				<c path="lime.math.Vector4"/>
				<c path="lime.math.Vector4"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":value"><e>{ up : null, at : null }</e></m>
				<m n=":impl"/>
			</meta>
		</pointAt>
		<prepend public="1" set="method" line="592" static="1">
			<f a="this:rhs">
				<x path="lime.utils.Float32Array"/>
				<x path="lime.math.Matrix4"/>
				<x path="Void"/>
			</f>
			<meta><m n=":impl"/></meta>
		</prepend>
		<prependRotation public="1" set="method" line="626" static="1">
			<f a="this:degrees:axis:?pivotPoint" v=":::null">
				<x path="lime.utils.Float32Array"/>
				<x path="Float"/>
				<c path="lime.math.Vector4"/>
				<c path="lime.math.Vector4"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":value"><e>{ pivotPoint : null }</e></m>
				<m n=":impl"/>
			</meta>
		</prependRotation>
		<prependScale public="1" set="method" line="642" static="1">
			<f a="this:xScale:yScale:zScale">
				<x path="lime.utils.Float32Array"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":impl"/></meta>
		</prependScale>
		<prependTranslation public="1" set="method" line="649" static="1">
			<f a="this:x:y:z">
				<x path="lime.utils.Float32Array"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":impl"/></meta>
		</prependTranslation>
		<transformVector public="1" set="method" line="742" static="1">
			<f a="this:v">
				<x path="lime.utils.Float32Array"/>
				<c path="lime.math.Vector4"/>
				<c path="lime.math.Vector4"/>
			</f>
			<meta><m n=":impl"/></meta>
		</transformVector>
		<transformVectors public="1" set="method" line="755" static="1">
			<f a="this:ain:aout">
				<x path="lime.utils.Float32Array"/>
				<x path="lime.utils.Float32Array"/>
				<x path="lime.utils.Float32Array"/>
				<x path="Void"/>
			</f>
			<meta><m n=":impl"/></meta>
		</transformVectors>
		<transpose public="1" set="method" line="774" static="1">
			<f a="this">
				<x path="lime.utils.Float32Array"/>
				<x path="Void"/>
			</f>
			<meta><m n=":impl"/></meta>
		</transpose>
		<getAxisRotation set="method" line="792" static="1"><f a="x:y:z:degrees">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="lime.math.Matrix4"/>
</f></getAxisRotation>
		<get_determinant set="method" line="831" static="1">
			<f a="this">
				<x path="lime.utils.Float32Array"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_determinant>
		<get_position set="method" line="843" static="1">
			<f a="this">
				<x path="lime.utils.Float32Array"/>
				<c path="lime.math.Vector4"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_position>
		<set_position set="method" line="850" static="1">
			<f a="this:val">
				<x path="lime.utils.Float32Array"/>
				<c path="lime.math.Vector4"/>
				<c path="lime.math.Vector4"/>
			</f>
			<meta><m n=":impl"/></meta>
		</set_position>
		<get public="1" set="method" line="860" static="1">
			<f a="this:index">
				<x path="lime.utils.Float32Array"/>
				<x path="Int"/>
				<x path="Float"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":arrayAccess"/>
			</meta>
		</get>
		<set public="1" set="method" line="867" static="1">
			<f a="this:index:value">
				<x path="lime.utils.Float32Array"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":arrayAccess"/>
			</meta>
		</set>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":final"/>
		</meta>
	</class>
	<class path="lime.math.Rectangle" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/math/Rectangle.hx">
		<bottom public="1" get="accessor" set="accessor"><x path="Float"/></bottom>
		<bottomRight public="1" get="accessor" set="accessor"><c path="lime.math.Vector2"/></bottomRight>
		<height public="1"><x path="Float"/></height>
		<left public="1" get="accessor" set="accessor"><x path="Float"/></left>
		<right public="1" get="accessor" set="accessor"><x path="Float"/></right>
		<size public="1" get="accessor" set="accessor"><c path="lime.math.Vector2"/></size>
		<top public="1" get="accessor" set="accessor"><x path="Float"/></top>
		<topLeft public="1" get="accessor" set="accessor"><c path="lime.math.Vector2"/></topLeft>
		<width public="1"><x path="Float"/></width>
		<x public="1"><x path="Float"/></x>
		<y public="1"><x path="Float"/></y>
		<clone public="1" set="method" line="35"><f a=""><c path="lime.math.Rectangle"/></f></clone>
		<contains public="1" set="method" line="42"><f a="x:y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Bool"/>
</f></contains>
		<containsPoint public="1" set="method" line="49"><f a="point">
	<c path="lime.math.Vector2"/>
	<x path="Bool"/>
</f></containsPoint>
		<containsRect public="1" set="method" line="56"><f a="rect">
	<c path="lime.math.Rectangle"/>
	<x path="Bool"/>
</f></containsRect>
		<copyFrom public="1" set="method" line="71"><f a="sourceRect">
	<c path="lime.math.Rectangle"/>
	<x path="Void"/>
</f></copyFrom>
		<equals public="1" set="method" line="81"><f a="toCompare">
	<c path="lime.math.Rectangle"/>
	<x path="Bool"/>
</f></equals>
		<inflate public="1" set="method" line="88"><f a="dx:dy">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></inflate>
		<inflatePoint public="1" set="method" line="96"><f a="point">
	<c path="lime.math.Vector2"/>
	<x path="Void"/>
</f></inflatePoint>
		<intersection public="1" set="method" line="103"><f a="toIntersect">
	<c path="lime.math.Rectangle"/>
	<c path="lime.math.Rectangle"/>
</f></intersection>
		<intersects public="1" set="method" line="128"><f a="toIntersect">
	<c path="lime.math.Rectangle"/>
	<x path="Bool"/>
</f></intersects>
		<isEmpty public="1" set="method" line="147"><f a=""><x path="Bool"/></f></isEmpty>
		<offset public="1" set="method" line="154"><f a="dx:dy">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></offset>
		<offsetPoint public="1" set="method" line="162"><f a="point">
	<c path="lime.math.Vector2"/>
	<x path="Void"/>
</f></offsetPoint>
		<setEmpty public="1" set="method" line="170"><f a=""><x path="Void"/></f></setEmpty>
		<setTo public="1" set="method" line="177"><f a="xa:ya:widtha:heighta">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></setTo>
		<transform public="1" set="method" line="187"><f a="m">
	<c path="lime.math.Matrix3"/>
	<c path="lime.math.Rectangle"/>
</f></transform>
		<union public="1" set="method" line="223"><f a="toUnion">
	<c path="lime.math.Rectangle"/>
	<c path="lime.math.Rectangle"/>
</f></union>
		<__contract public="1" set="method" line="245"><f a="x:y:width:height">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></__contract>
		<__expand public="1" set="method" line="264"><f a="x:y:width:height">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></__expand>
		<__toFlashRectangle set="method" line="287"><f a=""><d/></f></__toFlashRectangle>
		<get_bottom set="method" line="305"><f a=""><x path="Float"/></f></get_bottom>
		<set_bottom set="method" line="306"><f a="b">
	<x path="Float"/>
	<x path="Float"/>
</f></set_bottom>
		<get_bottomRight set="method" line="307"><f a=""><c path="lime.math.Vector2"/></f></get_bottomRight>
		<set_bottomRight set="method" line="308"><f a="p">
	<c path="lime.math.Vector2"/>
	<c path="lime.math.Vector2"/>
</f></set_bottomRight>
		<get_left set="method" line="309"><f a=""><x path="Float"/></f></get_left>
		<set_left set="method" line="310"><f a="l">
	<x path="Float"/>
	<x path="Float"/>
</f></set_left>
		<get_right set="method" line="311"><f a=""><x path="Float"/></f></get_right>
		<set_right set="method" line="312"><f a="r">
	<x path="Float"/>
	<x path="Float"/>
</f></set_right>
		<get_size set="method" line="313"><f a=""><c path="lime.math.Vector2"/></f></get_size>
		<set_size set="method" line="314"><f a="p">
	<c path="lime.math.Vector2"/>
	<c path="lime.math.Vector2"/>
</f></set_size>
		<get_top set="method" line="315"><f a=""><x path="Float"/></f></get_top>
		<set_top set="method" line="316"><f a="t">
	<x path="Float"/>
	<x path="Float"/>
</f></set_top>
		<get_topLeft set="method" line="317"><f a=""><c path="lime.math.Vector2"/></f></get_topLeft>
		<set_topLeft set="method" line="318"><f a="p">
	<c path="lime.math.Vector2"/>
	<c path="lime.math.Vector2"/>
</f></set_topLeft>
		<new public="1" set="method" line="25">
			<f a="?x:?y:?width:?height" v="0:0:0:0">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ height : 0, width : 0, y : 0, x : 0 }</e></m></meta>
		</new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="lime.math.Vector2" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/math/Vector2.hx">
		<distance public="1" set="method" line="39" static="1"><f a="pt1:pt2">
	<c path="lime.math.Vector2"/>
	<c path="lime.math.Vector2"/>
	<x path="Float"/>
</f></distance>
		<interpolate public="1" set="method" line="55" static="1"><f a="pt1:pt2:f">
	<c path="lime.math.Vector2"/>
	<c path="lime.math.Vector2"/>
	<x path="Float"/>
	<c path="lime.math.Vector2"/>
</f></interpolate>
		<polar public="1" set="method" line="87" static="1"><f a="len:angle">
	<x path="Float"/>
	<x path="Float"/>
	<c path="lime.math.Vector2"/>
</f></polar>
		<length public="1" get="accessor" set="null"><x path="Float"/></length>
		<x public="1"><x path="Float"/></x>
		<y public="1"><x path="Float"/></y>
		<add public="1" set="method" line="25"><f a="v">
	<c path="lime.math.Vector2"/>
	<c path="lime.math.Vector2"/>
</f></add>
		<clone public="1" set="method" line="32"><f a=""><c path="lime.math.Vector2"/></f></clone>
		<equals public="1" set="method" line="48"><f a="toCompare">
	<c path="lime.math.Vector2"/>
	<x path="Bool"/>
</f></equals>
		<normalize public="1" set="method" line="62"><f a="thickness">
	<x path="Float"/>
	<x path="Void"/>
</f></normalize>
		<offset public="1" set="method" line="79"><f a="dx:dy">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></offset>
		<setTo public="1" get="inline" set="null" line="94"><f a="xa:ya">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></setTo>
		<subtract public="1" set="method" line="101"><f a="v">
	<c path="lime.math.Vector2"/>
	<c path="lime.math.Vector2"/>
</f></subtract>
		<__toFlashPoint set="method" line="108"><f a=""><d/></f></__toFlashPoint>
		<get_length set="method" line="126"><f a=""><x path="Float"/></f></get_length>
		<new public="1" set="method" line="17">
			<f a="?x:?y" v="0:0">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ y : 0, x : 0 }</e></m></meta>
		</new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="lime.math.Vector4" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/math/Vector4.hx">
		<X_AXIS public="1" get="accessor" set="null" static="1"><c path="lime.math.Vector4"/></X_AXIS>
		<Y_AXIS public="1" get="accessor" set="null" static="1"><c path="lime.math.Vector4"/></Y_AXIS>
		<Z_AXIS public="1" get="accessor" set="null" static="1"><c path="lime.math.Vector4"/></Z_AXIS>
		<angleBetween public="1" get="inline" set="null" line="36" static="1"><f a="a:b">
	<c path="lime.math.Vector4"/>
	<c path="lime.math.Vector4"/>
	<x path="Float"/>
</f></angleBetween>
		<distance public="1" get="inline" set="null" line="80" static="1"><f a="pt1:pt2">
	<c path="lime.math.Vector4"/>
	<c path="lime.math.Vector4"/>
	<x path="Float"/>
</f></distance>
		<get_X_AXIS get="inline" set="null" line="209" static="1"><f a=""><c path="lime.math.Vector4"/></f></get_X_AXIS>
		<get_Y_AXIS get="inline" set="null" line="216" static="1"><f a=""><c path="lime.math.Vector4"/></f></get_Y_AXIS>
		<get_Z_AXIS get="inline" set="null" line="223" static="1"><f a=""><c path="lime.math.Vector4"/></f></get_Z_AXIS>
		<length public="1" get="accessor" set="null"><x path="Float"/></length>
		<lengthSquared public="1" get="accessor" set="null"><x path="Float"/></lengthSquared>
		<w public="1"><x path="Float"/></w>
		<x public="1"><x path="Float"/></x>
		<y public="1"><x path="Float"/></y>
		<z public="1"><x path="Float"/></z>
		<add public="1" get="inline" set="null" line="29"><f a="a">
	<c path="lime.math.Vector4"/>
	<c path="lime.math.Vector4"/>
</f></add>
		<clone public="1" get="inline" set="null" line="48"><f a=""><c path="lime.math.Vector4"/></f></clone>
		<copyFrom public="1" get="inline" set="null" line="55"><f a="sourceVector4">
	<c path="lime.math.Vector4"/>
	<x path="Void"/>
</f></copyFrom>
		<crossProduct public="1" get="inline" set="null" line="64"><f a="a">
	<c path="lime.math.Vector4"/>
	<c path="lime.math.Vector4"/>
</f></crossProduct>
		<decrementBy public="1" get="inline" set="null" line="71"><f a="a">
	<c path="lime.math.Vector4"/>
	<x path="Void"/>
</f></decrementBy>
		<dotProduct public="1" get="inline" set="null" line="91"><f a="a">
	<c path="lime.math.Vector4"/>
	<x path="Float"/>
</f></dotProduct>
		<equals public="1" get="inline" set="null" line="98">
			<f a="toCompare:?allFour" v=":false">
				<c path="lime.math.Vector4"/>
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":value"><e>{ allFour : false }</e></m></meta>
		</equals>
		<incrementBy public="1" get="inline" set="null" line="105"><f a="a">
	<c path="lime.math.Vector4"/>
	<x path="Void"/>
</f></incrementBy>
		<nearEquals public="1" get="inline" set="null" line="114">
			<f a="toCompare:tolerance:?allFour" v="::false">
				<c path="lime.math.Vector4"/>
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":value"><e>{ allFour : false }</e></m></meta>
		</nearEquals>
		<negate public="1" get="inline" set="null" line="121"><f a=""><x path="Void"/></f></negate>
		<normalize public="1" get="inline" set="null" line="130"><f a=""><x path="Float"/></f></normalize>
		<project public="1" get="inline" set="null" line="147"><f a=""><x path="Void"/></f></project>
		<scaleBy public="1" get="inline" set="null" line="156"><f a="s">
	<x path="Float"/>
	<x path="Void"/>
</f></scaleBy>
		<setTo public="1" get="inline" set="null" line="165"><f a="xa:ya:za">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></setTo>
		<subtract public="1" get="inline" set="null" line="174"><f a="a">
	<c path="lime.math.Vector4"/>
	<c path="lime.math.Vector4"/>
</f></subtract>
		<toString public="1" get="inline" set="null" line="181"><f a=""><c path="String"/></f></toString>
		<get_length get="inline" set="null" line="195"><f a=""><x path="Float"/></f></get_length>
		<get_lengthSquared get="inline" set="null" line="202"><f a=""><x path="Float"/></f></get_lengthSquared>
		<new public="1" set="method" line="19">
			<f a="?x:?y:?z:?w" v="0.:0.:0.:0.">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ w : 0., z : 0., y : 0., x : 0. }</e></m></meta>
		</new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<abstract path="lime.math.color.ARGB" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/math/color/ARGB.hx">
		<from>
			<icast><x path="UInt"/></icast>
			<icast><x path="Int"/></icast>
			<icast field="__fromBGRA"><x path="lime.math.color.BGRA"/></icast>
			<icast field="__fromRGBA"><x path="lime.math.color.RGBA"/></icast>
		</from>
		<this><x path="Int"/></this>
		<to>
			<icast><x path="UInt"/></icast>
			<icast><x path="Int"/></icast>
		</to>
		<impl><class path="lime.math.color._ARGB.ARGB_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/math/color/ARGB.hx" private="1" module="lime.math.color.ARGB">
	<a16 static="1"><x path="Int"/></a16>
	<unmult static="1"><x path="Float"/></unmult>
	<a public="1" get="accessor" set="accessor" static="1">
		<x path="Int"/>
		<meta><m n=":impl"/></meta>
	</a>
	<b public="1" get="accessor" set="accessor" static="1">
		<x path="Int"/>
		<meta><m n=":impl"/></meta>
	</b>
	<g public="1" get="accessor" set="accessor" static="1">
		<x path="Int"/>
		<meta><m n=":impl"/></meta>
	</g>
	<r public="1" get="accessor" set="accessor" static="1">
		<x path="Int"/>
		<meta><m n=":impl"/></meta>
	</r>
	<_new public="1" get="inline" set="null" line="21" static="1">
		<f a="?argb" v="0">
			<x path="Int"/>
			<x path="lime.math.color.ARGB"/>
		</f>
		<meta>
			<m n=":value"><e>{ argb : 0 }</e></m>
			<m n=":impl"/>
		</meta>
	</_new>
	<create public="1" get="inline" set="null" line="28" static="1"><f a="a:r:g:b">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="lime.math.color.ARGB"/>
</f></create>
	<multiplyAlpha public="1" get="inline" set="null" line="37" static="1">
		<f a="this">
			<x path="Int"/>
			<x path="Void"/>
		</f>
		<meta><m n=":impl"/></meta>
	</multiplyAlpha>
	<readUInt8 public="1" get="inline" set="null" line="53" static="1">
		<f a="this:data:offset:?format:?premultiplied" v=":::RGBA32:false">
			<x path="Int"/>
			<x path="lime.utils.UInt8Array"/>
			<x path="Int"/>
			<x path="lime.graphics.PixelFormat"/>
			<x path="Bool"/>
			<x path="Void"/>
		</f>
		<meta>
			<m n=":value"><e>{ premultiplied : false, format : RGBA32 }</e></m>
			<m n=":impl"/>
		</meta>
	</readUInt8>
	<set public="1" get="inline" set="null" line="80" static="1">
		<f a="this:a:r:g:b">
			<x path="Int"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="Void"/>
		</f>
		<meta><m n=":impl"/></meta>
	</set>
	<unmultiplyAlpha public="1" get="inline" set="null" line="87" static="1">
		<f a="this">
			<x path="Int"/>
			<x path="Void"/>
		</f>
		<meta><m n=":impl"/></meta>
	</unmultiplyAlpha>
	<writeUInt8 public="1" get="inline" set="null" line="99" static="1">
		<f a="this:data:offset:?format:?premultiplied" v=":::RGBA32:false">
			<x path="Int"/>
			<x path="lime.utils.UInt8Array"/>
			<x path="Int"/>
			<x path="lime.graphics.PixelFormat"/>
			<x path="Bool"/>
			<x path="Void"/>
		</f>
		<meta>
			<m n=":value"><e>{ premultiplied : false, format : RGBA32 }</e></m>
			<m n=":impl"/>
		</meta>
	</writeUInt8>
	<__fromBGRA get="inline" set="null" line="135" static="1">
		<f a="bgra">
			<x path="lime.math.color.BGRA"/>
			<x path="lime.math.color.ARGB"/>
		</f>
		<meta><m n=":from"/></meta>
	</__fromBGRA>
	<__fromRGBA get="inline" set="null" line="142" static="1">
		<f a="rgba">
			<x path="lime.math.color.RGBA"/>
			<x path="lime.math.color.ARGB"/>
		</f>
		<meta><m n=":from"/></meta>
	</__fromRGBA>
	<get_a get="inline" set="null" line="156" static="1">
		<f a="this">
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_a>
	<set_a get="inline" set="null" line="164" static="1">
		<f a="this:value">
			<x path="Int"/>
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<meta><m n=":impl"/></meta>
	</set_a>
	<get_b get="inline" set="null" line="172" static="1">
		<f a="this">
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_b>
	<set_b get="inline" set="null" line="179" static="1">
		<f a="this:value">
			<x path="Int"/>
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<meta><m n=":impl"/></meta>
	</set_b>
	<get_g get="inline" set="null" line="187" static="1">
		<f a="this">
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_g>
	<set_g get="inline" set="null" line="194" static="1">
		<f a="this:value">
			<x path="Int"/>
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<meta><m n=":impl"/></meta>
	</set_g>
	<get_r get="inline" set="null" line="202" static="1">
		<f a="this">
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_r>
	<set_r get="inline" set="null" line="209" static="1">
		<f a="this:value">
			<x path="Int"/>
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<meta><m n=":impl"/></meta>
	</set_r>
	<meta>
		<m n=":directlyUsed"/>
		<m n=":final"/>
	</meta>
</class></impl>
	</abstract>
	<class path="lime.math.color._ARGB.ARGB_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/math/color/ARGB.hx" private="1" module="lime.math.color.ARGB">
		<a16 static="1"><x path="Int"/></a16>
		<unmult static="1"><x path="Float"/></unmult>
		<a public="1" get="accessor" set="accessor" static="1">
			<x path="Int"/>
			<meta><m n=":impl"/></meta>
		</a>
		<b public="1" get="accessor" set="accessor" static="1">
			<x path="Int"/>
			<meta><m n=":impl"/></meta>
		</b>
		<g public="1" get="accessor" set="accessor" static="1">
			<x path="Int"/>
			<meta><m n=":impl"/></meta>
		</g>
		<r public="1" get="accessor" set="accessor" static="1">
			<x path="Int"/>
			<meta><m n=":impl"/></meta>
		</r>
		<_new public="1" get="inline" set="null" line="21" static="1">
			<f a="?argb" v="0">
				<x path="Int"/>
				<x path="lime.math.color.ARGB"/>
			</f>
			<meta>
				<m n=":value"><e>{ argb : 0 }</e></m>
				<m n=":impl"/>
			</meta>
		</_new>
		<create public="1" get="inline" set="null" line="28" static="1"><f a="a:r:g:b">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="lime.math.color.ARGB"/>
</f></create>
		<multiplyAlpha public="1" get="inline" set="null" line="37" static="1">
			<f a="this">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":impl"/></meta>
		</multiplyAlpha>
		<readUInt8 public="1" get="inline" set="null" line="53" static="1">
			<f a="this:data:offset:?format:?premultiplied" v=":::RGBA32:false">
				<x path="Int"/>
				<x path="lime.utils.UInt8Array"/>
				<x path="Int"/>
				<x path="lime.graphics.PixelFormat"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":value"><e>{ premultiplied : false, format : RGBA32 }</e></m>
				<m n=":impl"/>
			</meta>
		</readUInt8>
		<set public="1" get="inline" set="null" line="80" static="1">
			<f a="this:a:r:g:b">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":impl"/></meta>
		</set>
		<unmultiplyAlpha public="1" get="inline" set="null" line="87" static="1">
			<f a="this">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":impl"/></meta>
		</unmultiplyAlpha>
		<writeUInt8 public="1" get="inline" set="null" line="99" static="1">
			<f a="this:data:offset:?format:?premultiplied" v=":::RGBA32:false">
				<x path="Int"/>
				<x path="lime.utils.UInt8Array"/>
				<x path="Int"/>
				<x path="lime.graphics.PixelFormat"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":value"><e>{ premultiplied : false, format : RGBA32 }</e></m>
				<m n=":impl"/>
			</meta>
		</writeUInt8>
		<__fromBGRA get="inline" set="null" line="135" static="1">
			<f a="bgra">
				<x path="lime.math.color.BGRA"/>
				<x path="lime.math.color.ARGB"/>
			</f>
			<meta><m n=":from"/></meta>
		</__fromBGRA>
		<__fromRGBA get="inline" set="null" line="142" static="1">
			<f a="rgba">
				<x path="lime.math.color.RGBA"/>
				<x path="lime.math.color.ARGB"/>
			</f>
			<meta><m n=":from"/></meta>
		</__fromRGBA>
		<get_a get="inline" set="null" line="156" static="1">
			<f a="this">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_a>
		<set_a get="inline" set="null" line="164" static="1">
			<f a="this:value">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":impl"/></meta>
		</set_a>
		<get_b get="inline" set="null" line="172" static="1">
			<f a="this">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_b>
		<set_b get="inline" set="null" line="179" static="1">
			<f a="this:value">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":impl"/></meta>
		</set_b>
		<get_g get="inline" set="null" line="187" static="1">
			<f a="this">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_g>
		<set_g get="inline" set="null" line="194" static="1">
			<f a="this:value">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":impl"/></meta>
		</set_g>
		<get_r get="inline" set="null" line="202" static="1">
			<f a="this">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_r>
		<set_r get="inline" set="null" line="209" static="1">
			<f a="this:value">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":impl"/></meta>
		</set_r>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":final"/>
		</meta>
	</class>
	<abstract path="lime.math.color.BGRA" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/math/color/BGRA.hx">
		<from>
			<icast><x path="UInt"/></icast>
			<icast><x path="Int"/></icast>
			<icast field="__fromARGB"><x path="lime.math.color.ARGB"/></icast>
			<icast field="__fromRGBA"><x path="lime.math.color.RGBA"/></icast>
		</from>
		<this><x path="Int"/></this>
		<to>
			<icast><x path="UInt"/></icast>
			<icast><x path="Int"/></icast>
		</to>
		<impl><class path="lime.math.color._BGRA.BGRA_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/math/color/BGRA.hx" private="1" module="lime.math.color.BGRA">
	<a16 static="1"><x path="Int"/></a16>
	<unmult static="1"><x path="Float"/></unmult>
	<a public="1" get="accessor" set="accessor" static="1">
		<x path="Int"/>
		<meta><m n=":impl"/></meta>
	</a>
	<b public="1" get="accessor" set="accessor" static="1">
		<x path="Int"/>
		<meta><m n=":impl"/></meta>
	</b>
	<g public="1" get="accessor" set="accessor" static="1">
		<x path="Int"/>
		<meta><m n=":impl"/></meta>
	</g>
	<r public="1" get="accessor" set="accessor" static="1">
		<x path="Int"/>
		<meta><m n=":impl"/></meta>
	</r>
	<_new public="1" get="inline" set="null" line="21" static="1">
		<f a="?bgra" v="0">
			<x path="Int"/>
			<x path="lime.math.color.BGRA"/>
		</f>
		<meta>
			<m n=":value"><e>{ bgra : 0 }</e></m>
			<m n=":impl"/>
		</meta>
	</_new>
	<create public="1" get="inline" set="null" line="28" static="1"><f a="b:g:r:a">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="lime.math.color.BGRA"/>
</f></create>
	<multiplyAlpha public="1" get="inline" set="null" line="37" static="1">
		<f a="this">
			<x path="Int"/>
			<x path="Void"/>
		</f>
		<meta><m n=":impl"/></meta>
	</multiplyAlpha>
	<readUInt8 public="1" get="inline" set="null" line="53" static="1">
		<f a="this:data:offset:?format:?premultiplied" v=":::RGBA32:false">
			<x path="Int"/>
			<x path="lime.utils.UInt8Array"/>
			<x path="Int"/>
			<x path="lime.graphics.PixelFormat"/>
			<x path="Bool"/>
			<x path="Void"/>
		</f>
		<meta>
			<m n=":value"><e>{ premultiplied : false, format : RGBA32 }</e></m>
			<m n=":impl"/>
		</meta>
	</readUInt8>
	<set public="1" get="inline" set="null" line="80" static="1">
		<f a="this:b:g:r:a">
			<x path="Int"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="Void"/>
		</f>
		<meta><m n=":impl"/></meta>
	</set>
	<unmultiplyAlpha public="1" get="inline" set="null" line="87" static="1">
		<f a="this">
			<x path="Int"/>
			<x path="Void"/>
		</f>
		<meta><m n=":impl"/></meta>
	</unmultiplyAlpha>
	<writeUInt8 public="1" get="inline" set="null" line="99" static="1">
		<f a="this:data:offset:?format:?premultiplied" v=":::RGBA32:false">
			<x path="Int"/>
			<x path="lime.utils.UInt8Array"/>
			<x path="Int"/>
			<x path="lime.graphics.PixelFormat"/>
			<x path="Bool"/>
			<x path="Void"/>
		</f>
		<meta>
			<m n=":value"><e>{ premultiplied : false, format : RGBA32 }</e></m>
			<m n=":impl"/>
		</meta>
	</writeUInt8>
	<__fromARGB get="inline" set="null" line="135" static="1">
		<f a="argb">
			<x path="lime.math.color.ARGB"/>
			<x path="lime.math.color.BGRA"/>
		</f>
		<meta><m n=":from"/></meta>
	</__fromARGB>
	<__fromRGBA get="inline" set="null" line="142" static="1">
		<f a="rgba">
			<x path="lime.math.color.RGBA"/>
			<x path="lime.math.color.BGRA"/>
		</f>
		<meta><m n=":from"/></meta>
	</__fromRGBA>
	<get_a get="inline" set="null" line="156" static="1">
		<f a="this">
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_a>
	<set_a get="inline" set="null" line="163" static="1">
		<f a="this:value">
			<x path="Int"/>
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<meta><m n=":impl"/></meta>
	</set_a>
	<get_b get="inline" set="null" line="171" static="1">
		<f a="this">
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_b>
	<set_b get="inline" set="null" line="178" static="1">
		<f a="this:value">
			<x path="Int"/>
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<meta><m n=":impl"/></meta>
	</set_b>
	<get_g get="inline" set="null" line="186" static="1">
		<f a="this">
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_g>
	<set_g get="inline" set="null" line="193" static="1">
		<f a="this:value">
			<x path="Int"/>
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<meta><m n=":impl"/></meta>
	</set_g>
	<get_r get="inline" set="null" line="201" static="1">
		<f a="this">
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_r>
	<set_r get="inline" set="null" line="208" static="1">
		<f a="this:value">
			<x path="Int"/>
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<meta><m n=":impl"/></meta>
	</set_r>
	<meta>
		<m n=":directlyUsed"/>
		<m n=":final"/>
	</meta>
</class></impl>
	</abstract>
	<class path="lime.math.color._BGRA.BGRA_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/math/color/BGRA.hx" private="1" module="lime.math.color.BGRA">
		<a16 static="1"><x path="Int"/></a16>
		<unmult static="1"><x path="Float"/></unmult>
		<a public="1" get="accessor" set="accessor" static="1">
			<x path="Int"/>
			<meta><m n=":impl"/></meta>
		</a>
		<b public="1" get="accessor" set="accessor" static="1">
			<x path="Int"/>
			<meta><m n=":impl"/></meta>
		</b>
		<g public="1" get="accessor" set="accessor" static="1">
			<x path="Int"/>
			<meta><m n=":impl"/></meta>
		</g>
		<r public="1" get="accessor" set="accessor" static="1">
			<x path="Int"/>
			<meta><m n=":impl"/></meta>
		</r>
		<_new public="1" get="inline" set="null" line="21" static="1">
			<f a="?bgra" v="0">
				<x path="Int"/>
				<x path="lime.math.color.BGRA"/>
			</f>
			<meta>
				<m n=":value"><e>{ bgra : 0 }</e></m>
				<m n=":impl"/>
			</meta>
		</_new>
		<create public="1" get="inline" set="null" line="28" static="1"><f a="b:g:r:a">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="lime.math.color.BGRA"/>
</f></create>
		<multiplyAlpha public="1" get="inline" set="null" line="37" static="1">
			<f a="this">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":impl"/></meta>
		</multiplyAlpha>
		<readUInt8 public="1" get="inline" set="null" line="53" static="1">
			<f a="this:data:offset:?format:?premultiplied" v=":::RGBA32:false">
				<x path="Int"/>
				<x path="lime.utils.UInt8Array"/>
				<x path="Int"/>
				<x path="lime.graphics.PixelFormat"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":value"><e>{ premultiplied : false, format : RGBA32 }</e></m>
				<m n=":impl"/>
			</meta>
		</readUInt8>
		<set public="1" get="inline" set="null" line="80" static="1">
			<f a="this:b:g:r:a">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":impl"/></meta>
		</set>
		<unmultiplyAlpha public="1" get="inline" set="null" line="87" static="1">
			<f a="this">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":impl"/></meta>
		</unmultiplyAlpha>
		<writeUInt8 public="1" get="inline" set="null" line="99" static="1">
			<f a="this:data:offset:?format:?premultiplied" v=":::RGBA32:false">
				<x path="Int"/>
				<x path="lime.utils.UInt8Array"/>
				<x path="Int"/>
				<x path="lime.graphics.PixelFormat"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":value"><e>{ premultiplied : false, format : RGBA32 }</e></m>
				<m n=":impl"/>
			</meta>
		</writeUInt8>
		<__fromARGB get="inline" set="null" line="135" static="1">
			<f a="argb">
				<x path="lime.math.color.ARGB"/>
				<x path="lime.math.color.BGRA"/>
			</f>
			<meta><m n=":from"/></meta>
		</__fromARGB>
		<__fromRGBA get="inline" set="null" line="142" static="1">
			<f a="rgba">
				<x path="lime.math.color.RGBA"/>
				<x path="lime.math.color.BGRA"/>
			</f>
			<meta><m n=":from"/></meta>
		</__fromRGBA>
		<get_a get="inline" set="null" line="156" static="1">
			<f a="this">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_a>
		<set_a get="inline" set="null" line="163" static="1">
			<f a="this:value">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":impl"/></meta>
		</set_a>
		<get_b get="inline" set="null" line="171" static="1">
			<f a="this">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_b>
		<set_b get="inline" set="null" line="178" static="1">
			<f a="this:value">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":impl"/></meta>
		</set_b>
		<get_g get="inline" set="null" line="186" static="1">
			<f a="this">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_g>
		<set_g get="inline" set="null" line="193" static="1">
			<f a="this:value">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":impl"/></meta>
		</set_g>
		<get_r get="inline" set="null" line="201" static="1">
			<f a="this">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_r>
		<set_r get="inline" set="null" line="208" static="1">
			<f a="this:value">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":impl"/></meta>
		</set_r>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":final"/>
		</meta>
	</class>
	<abstract path="lime.math.color.RGBA" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/math/color/RGBA.hx">
		<from>
			<icast><x path="UInt"/></icast>
			<icast><x path="Int"/></icast>
			<icast field="__fromARGB"><x path="lime.math.color.ARGB"/></icast>
			<icast field="__fromBGRA"><x path="lime.math.color.BGRA"/></icast>
		</from>
		<this><x path="Int"/></this>
		<to>
			<icast><x path="UInt"/></icast>
			<icast><x path="Int"/></icast>
		</to>
		<meta><m n=":allow"><e>lime.math.color</e></m></meta>
		<impl><class path="lime.math.color._RGBA.RGBA_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/math/color/RGBA.hx" private="1" module="lime.math.color.RGBA">
	<__alpha16 static="1"><x path="lime.utils.UInt32Array"/></__alpha16>
	<__clamp static="1"><x path="lime.utils.UInt8Array"/></__clamp>
	<a16 static="1"><x path="Int"/></a16>
	<unmult static="1"><x path="Float"/></unmult>
	<a public="1" get="accessor" set="accessor" static="1">
		<x path="Int"/>
		<meta><m n=":impl"/></meta>
	</a>
	<b public="1" get="accessor" set="accessor" static="1">
		<x path="Int"/>
		<meta><m n=":impl"/></meta>
	</b>
	<g public="1" get="accessor" set="accessor" static="1">
		<x path="Int"/>
		<meta><m n=":impl"/></meta>
	</g>
	<r public="1" get="accessor" set="accessor" static="1">
		<x path="Int"/>
		<meta><m n=":impl"/></meta>
	</r>
	<_new public="1" get="inline" set="null" line="52" static="1">
		<f a="?rgba" v="0">
			<x path="Int"/>
			<x path="lime.math.color.RGBA"/>
		</f>
		<meta>
			<m n=":value"><e>{ rgba : 0 }</e></m>
			<m n=":impl"/>
		</meta>
	</_new>
	<create public="1" get="inline" set="null" line="59" static="1"><f a="r:g:b:a">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="lime.math.color.RGBA"/>
</f></create>
	<multiplyAlpha public="1" get="inline" set="null" line="68" static="1">
		<f a="this">
			<x path="Int"/>
			<x path="Void"/>
		</f>
		<meta><m n=":impl"/></meta>
	</multiplyAlpha>
	<readUInt8 public="1" get="inline" set="null" line="88" static="1">
		<f a="this:data:offset:?format:?premultiplied" v=":::RGBA32:false">
			<x path="Int"/>
			<x path="lime.utils.UInt8Array"/>
			<x path="Int"/>
			<x path="lime.graphics.PixelFormat"/>
			<x path="Bool"/>
			<x path="Void"/>
		</f>
		<meta>
			<m n=":value"><e>{ premultiplied : false, format : RGBA32 }</e></m>
			<m n=":impl"/>
		</meta>
	</readUInt8>
	<set public="1" get="inline" set="null" line="115" static="1">
		<f a="this:r:g:b:a">
			<x path="Int"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="Void"/>
		</f>
		<meta><m n=":impl"/></meta>
	</set>
	<unmultiplyAlpha public="1" get="inline" set="null" line="122" static="1">
		<f a="this">
			<x path="Int"/>
			<x path="Void"/>
		</f>
		<meta><m n=":impl"/></meta>
	</unmultiplyAlpha>
	<writeUInt8 public="1" get="inline" set="null" line="134" static="1">
		<f a="this:data:offset:?format:?premultiplied" v=":::RGBA32:false">
			<x path="Int"/>
			<x path="lime.utils.UInt8Array"/>
			<x path="Int"/>
			<x path="lime.graphics.PixelFormat"/>
			<x path="Bool"/>
			<x path="Void"/>
		</f>
		<meta>
			<m n=":value"><e>{ premultiplied : false, format : RGBA32 }</e></m>
			<m n=":impl"/>
		</meta>
	</writeUInt8>
	<__fromARGB get="inline" set="null" line="170" static="1">
		<f a="argb">
			<x path="lime.math.color.ARGB"/>
			<x path="lime.math.color.RGBA"/>
		</f>
		<meta><m n=":from"/></meta>
	</__fromARGB>
	<__fromBGRA get="inline" set="null" line="177" static="1">
		<f a="bgra">
			<x path="lime.math.color.BGRA"/>
			<x path="lime.math.color.RGBA"/>
		</f>
		<meta><m n=":from"/></meta>
	</__fromBGRA>
	<get_a get="inline" set="null" line="191" static="1">
		<f a="this">
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_a>
	<set_a get="inline" set="null" line="198" static="1">
		<f a="this:value">
			<x path="Int"/>
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<meta><m n=":impl"/></meta>
	</set_a>
	<get_b get="inline" set="null" line="206" static="1">
		<f a="this">
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_b>
	<set_b get="inline" set="null" line="213" static="1">
		<f a="this:value">
			<x path="Int"/>
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<meta><m n=":impl"/></meta>
	</set_b>
	<get_g get="inline" set="null" line="221" static="1">
		<f a="this">
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_g>
	<set_g get="inline" set="null" line="228" static="1">
		<f a="this:value">
			<x path="Int"/>
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<meta><m n=":impl"/></meta>
	</set_g>
	<get_r get="inline" set="null" line="236" static="1">
		<f a="this">
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_r>
	<set_r get="inline" set="null" line="243" static="1">
		<f a="this:value">
			<x path="Int"/>
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<meta><m n=":impl"/></meta>
	</set_r>
	<meta>
		<m n=":directlyUsed"/>
		<m n=":final"/>
		<m n=":allow"><e>lime.math.color</e></m>
	</meta>
</class></impl>
	</abstract>
	<class path="lime.utils.ArrayBufferView" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/utils/ArrayBufferView.hx">
		<type public="1" expr="TypedArrayType.None">
			<x path="lime.utils._ArrayBufferView.TypedArrayType"/>
			<meta><m n=":value"><e>TypedArrayType.None</e></m></meta>
		</type>
		<buffer public="1"><x path="lime.utils.ArrayBuffer"/></buffer>
		<byteOffset public="1"><x path="Int"/></byteOffset>
		<byteLength public="1"><x path="Int"/></byteLength>
		<length public="1"><x path="Int"/></length>
		<bytesPerElement set="null" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</bytesPerElement>
		<initTypedArray get="inline" set="null" line="48">
			<f a="view">
				<c path="lime.utils.ArrayBufferView"/>
				<c path="lime.utils.ArrayBufferView"/>
			</f>
			<meta><m n=":allow"><e>lime.utils</e></m></meta>
		</initTypedArray>
		<initBuffer get="inline" set="null" line="75">
			<f a="in_buffer:?in_byteOffset:?len" v=":0:null">
				<x path="lime.utils.ArrayBuffer"/>
				<x path="Int"/>
				<x path="Int"/>
				<c path="lime.utils.ArrayBufferView"/>
			</f>
			<meta>
				<m n=":value"><e>{ len : null, in_byteOffset : 0 }</e></m>
				<m n=":allow"><e>lime.utils</e></m>
			</meta>
		</initBuffer>
		<initArray params="T" get="inline" set="null" line="112">
			<f a="array">
				<c path="Array"><c path="initArray.T"/></c>
				<c path="lime.utils.ArrayBufferView"/>
			</f>
			<meta><m n=":allow"><e>lime.utils</e></m></meta>
		</initArray>
		<set public="1" params="T" get="inline" set="null" line="130">
			<f a="?view:?array:?offset" v="::0">
				<c path="lime.utils.ArrayBufferView"/>
				<c path="Array"><c path="set.T"/></c>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ offset : 0 }</e></m></meta>
		</set>
		<cloneBuffer get="inline" set="null" line="146">
			<f a="src:?srcByteOffset" v=":0">
				<x path="lime.utils.ArrayBuffer"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ srcByteOffset : 0 }</e></m></meta>
		</cloneBuffer>
		<subarray params="T_subarray" get="inline" set="null" line="160">
			<f a="begin:?end" v=":null">
				<x path="Int"/>
				<x path="Int"/>
				<c path="subarray.T_subarray"/>
			</f>
			<meta>
				<m n=":value"><e>{ end : null }</e></m>
				<m n=":generic"/>
				<m n=":allow"><e>lime.utils</e></m>
			</meta>
		</subarray>
		<bytesForType get="inline" set="null" line="205"><f a="type">
	<x path="lime.utils._ArrayBufferView.TypedArrayType"/>
	<x path="Int"/>
</f></bytesForType>
		<toString get="inline" set="null" line="243"><f a=""><c path="String"/></f></toString>
		<toByteLength get="inline" set="null" line="266"><f a="elemCount">
	<x path="Int"/>
	<x path="Int"/>
</f></toByteLength>
		<copyFromArray set="method" line="275">
			<f a="array:?offset" v=":0">
				<c path="Array"><x path="Float"/></c>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ offset : 0 }</e></m></meta>
		</copyFromArray>
		<new get="inline" set="null" line="22">
			<f a="?elements:in_type" v="null:">
				<x path="Int"/>
				<x path="lime.utils._ArrayBufferView.TypedArrayType"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":value"><e>{ elements : null }</e></m>
				<m n=":allow"><e>lime.utils</e></m>
			</meta>
		</new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<enum path="lime.utils.TAError" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/utils/ArrayBufferView.hx" module="lime.utils.ArrayBufferView">
		<RangeError/>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
			<m n=":noCompletion"/>
			<m n=":dox"><e>hide</e></m>
		</meta>
	</enum>
	<class path="lime.math.color._RGBA.RGBA_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/math/color/RGBA.hx" private="1" module="lime.math.color.RGBA">
		<__alpha16 static="1"><x path="lime.utils.UInt32Array"/></__alpha16>
		<__clamp static="1"><x path="lime.utils.UInt8Array"/></__clamp>
		<a16 static="1"><x path="Int"/></a16>
		<unmult static="1"><x path="Float"/></unmult>
		<a public="1" get="accessor" set="accessor" static="1">
			<x path="Int"/>
			<meta><m n=":impl"/></meta>
		</a>
		<b public="1" get="accessor" set="accessor" static="1">
			<x path="Int"/>
			<meta><m n=":impl"/></meta>
		</b>
		<g public="1" get="accessor" set="accessor" static="1">
			<x path="Int"/>
			<meta><m n=":impl"/></meta>
		</g>
		<r public="1" get="accessor" set="accessor" static="1">
			<x path="Int"/>
			<meta><m n=":impl"/></meta>
		</r>
		<_new public="1" get="inline" set="null" line="52" static="1">
			<f a="?rgba" v="0">
				<x path="Int"/>
				<x path="lime.math.color.RGBA"/>
			</f>
			<meta>
				<m n=":value"><e>{ rgba : 0 }</e></m>
				<m n=":impl"/>
			</meta>
		</_new>
		<create public="1" get="inline" set="null" line="59" static="1"><f a="r:g:b:a">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="lime.math.color.RGBA"/>
</f></create>
		<multiplyAlpha public="1" get="inline" set="null" line="68" static="1">
			<f a="this">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":impl"/></meta>
		</multiplyAlpha>
		<readUInt8 public="1" get="inline" set="null" line="88" static="1">
			<f a="this:data:offset:?format:?premultiplied" v=":::RGBA32:false">
				<x path="Int"/>
				<x path="lime.utils.UInt8Array"/>
				<x path="Int"/>
				<x path="lime.graphics.PixelFormat"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":value"><e>{ premultiplied : false, format : RGBA32 }</e></m>
				<m n=":impl"/>
			</meta>
		</readUInt8>
		<set public="1" get="inline" set="null" line="115" static="1">
			<f a="this:r:g:b:a">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":impl"/></meta>
		</set>
		<unmultiplyAlpha public="1" get="inline" set="null" line="122" static="1">
			<f a="this">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":impl"/></meta>
		</unmultiplyAlpha>
		<writeUInt8 public="1" get="inline" set="null" line="134" static="1">
			<f a="this:data:offset:?format:?premultiplied" v=":::RGBA32:false">
				<x path="Int"/>
				<x path="lime.utils.UInt8Array"/>
				<x path="Int"/>
				<x path="lime.graphics.PixelFormat"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":value"><e>{ premultiplied : false, format : RGBA32 }</e></m>
				<m n=":impl"/>
			</meta>
		</writeUInt8>
		<__fromARGB get="inline" set="null" line="170" static="1">
			<f a="argb">
				<x path="lime.math.color.ARGB"/>
				<x path="lime.math.color.RGBA"/>
			</f>
			<meta><m n=":from"/></meta>
		</__fromARGB>
		<__fromBGRA get="inline" set="null" line="177" static="1">
			<f a="bgra">
				<x path="lime.math.color.BGRA"/>
				<x path="lime.math.color.RGBA"/>
			</f>
			<meta><m n=":from"/></meta>
		</__fromBGRA>
		<get_a get="inline" set="null" line="191" static="1">
			<f a="this">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_a>
		<set_a get="inline" set="null" line="198" static="1">
			<f a="this:value">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":impl"/></meta>
		</set_a>
		<get_b get="inline" set="null" line="206" static="1">
			<f a="this">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_b>
		<set_b get="inline" set="null" line="213" static="1">
			<f a="this:value">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":impl"/></meta>
		</set_b>
		<get_g get="inline" set="null" line="221" static="1">
			<f a="this">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_g>
		<set_g get="inline" set="null" line="228" static="1">
			<f a="this:value">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":impl"/></meta>
		</set_g>
		<get_r get="inline" set="null" line="236" static="1">
			<f a="this">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_r>
		<set_r get="inline" set="null" line="243" static="1">
			<f a="this:value">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":impl"/></meta>
		</set_r>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":final"/>
			<m n=":allow"><e>lime.math.color</e></m>
		</meta>
	</class>
	<class path="lime.system.BackgroundWorker" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/system/BackgroundWorker.hx">
		<MESSAGE_COMPLETE expr="&quot;__COMPLETE__&quot;" line="19" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"__COMPLETE__"</e></m></meta>
		</MESSAGE_COMPLETE>
		<MESSAGE_ERROR expr="&quot;__ERROR__&quot;" line="20" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"__ERROR__"</e></m></meta>
		</MESSAGE_ERROR>
		<canceled public="1" set="null"><x path="Bool"/></canceled>
		<doWork public="1" expr="new Event&lt;Dynamic&gt;()">
			<c path="lime.app.Event_Dynamic_Void"><f a="">
	<d/>
	<x path="Void"/>
</f></c>
			<meta><m n=":value"><e><![CDATA[new Event<Dynamic>()]]></e></m></meta>
		</doWork>
		<onComplete public="1" expr="new Event&lt;Dynamic&gt;()">
			<c path="lime.app.Event_Dynamic_Void"><f a="">
	<d/>
	<x path="Void"/>
</f></c>
			<meta><m n=":value"><e><![CDATA[new Event<Dynamic>()]]></e></m></meta>
		</onComplete>
		<onError public="1" expr="new Event&lt;Dynamic&gt;()">
			<c path="lime.app.Event_Dynamic_Void"><f a="">
	<d/>
	<x path="Void"/>
</f></c>
			<meta><m n=":value"><e><![CDATA[new Event<Dynamic>()]]></e></m></meta>
		</onError>
		<onProgress public="1" expr="new Event&lt;Dynamic&gt;()">
			<c path="lime.app.Event_Dynamic_Void"><f a="">
	<d/>
	<x path="Void"/>
</f></c>
			<meta><m n=":value"><e><![CDATA[new Event<Dynamic>()]]></e></m></meta>
		</onProgress>
		<__runMessage><d/></__runMessage>
		<__messageQueue><c path="neko.vm.Deque"><d/></c></__messageQueue>
		<__workerThread><c path="neko.vm.Thread"/></__workerThread>
		<cancel public="1" set="method" line="43"><f a=""><x path="Void"/></f></cancel>
		<run public="1" set="method" line="56">
			<f a="?message" v="null">
				<d/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ message : null }</e></m></meta>
		</run>
		<sendComplete public="1" set="method" line="77">
			<f a="?message" v="null">
				<d/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ message : null }</e></m></meta>
		</sendComplete>
		<sendError public="1" set="method" line="98">
			<f a="?message" v="null">
				<d/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ message : null }</e></m></meta>
		</sendError>
		<sendProgress public="1" set="method" line="119">
			<f a="?message" v="null">
				<d/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ message : null }</e></m></meta>
		</sendProgress>
		<__doWork set="method" line="138"><f a=""><x path="Void"/></f></__doWork>
		<__update set="method" line="160"><f a="deltaTime">
	<x path="Int"/>
	<x path="Void"/>
</f></__update>
		<new public="1" set="method" line="36"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<abstract path="lime.system.CFFIPointer" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/system/CFFIPointer.hx">
		<from><icast><d/></icast></from>
		<this><d/></this>
		<to><icast><d/></icast></to>
		<meta><m n=":build"><e>lime.system.CFFI.build()</e></m></meta>
		<impl><class path="lime.system._CFFIPointer.CFFIPointer_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/system/CFFIPointer.hx" private="1" module="lime.system.CFFIPointer">
	<_new public="1" get="inline" set="null" line="11" static="1">
		<f a="handle">
			<d/>
			<x path="lime.system.CFFIPointer"/>
		</f>
		<meta><m n=":impl"/></meta>
	</_new>
	<get public="1" set="method" line="18" static="1">
		<f a="this">
			<d/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get>
	<equals get="inline" set="null" line="33" static="1">
		<f a="a:b">
			<x path="lime.system.CFFIPointer"/>
			<x path="Int"/>
			<x path="Bool"/>
		</f>
		<meta>
			<m n=":noCompletion"/>
			<m n=":op"><e>A == B</e></m>
		</meta>
	</equals>
	<equalsPointer get="inline" set="null" line="34" static="1">
		<f a="a:b">
			<x path="lime.system.CFFIPointer"/>
			<x path="lime.system.CFFIPointer"/>
			<x path="Bool"/>
		</f>
		<meta>
			<m n=":noCompletion"/>
			<m n=":op"><e>A == B</e></m>
		</meta>
	</equalsPointer>
	<greaterThan get="inline" set="null" line="35" static="1">
		<f a="a:b">
			<x path="lime.system.CFFIPointer"/>
			<x path="Int"/>
			<x path="Bool"/>
		</f>
		<meta>
			<m n=":noCompletion"/>
			<m n=":op"><e><![CDATA[A > B]]></e></m>
		</meta>
	</greaterThan>
	<greaterThanPointer get="inline" set="null" line="36" static="1">
		<f a="a:b">
			<x path="lime.system.CFFIPointer"/>
			<x path="lime.system.CFFIPointer"/>
			<x path="Bool"/>
		</f>
		<meta>
			<m n=":noCompletion"/>
			<m n=":op"><e><![CDATA[A > B]]></e></m>
		</meta>
	</greaterThanPointer>
	<greaterThanOrEqual get="inline" set="null" line="37" static="1">
		<f a="a:b">
			<x path="lime.system.CFFIPointer"/>
			<x path="Int"/>
			<x path="Bool"/>
		</f>
		<meta>
			<m n=":noCompletion"/>
			<m n=":op"><e><![CDATA[A >= B]]></e></m>
		</meta>
	</greaterThanOrEqual>
	<greaterThanOrEqualPointer get="inline" set="null" line="38" static="1">
		<f a="a:b">
			<x path="lime.system.CFFIPointer"/>
			<x path="lime.system.CFFIPointer"/>
			<x path="Bool"/>
		</f>
		<meta>
			<m n=":noCompletion"/>
			<m n=":op"><e><![CDATA[A >= B]]></e></m>
		</meta>
	</greaterThanOrEqualPointer>
	<lessThan get="inline" set="null" line="39" static="1">
		<f a="a:b">
			<x path="lime.system.CFFIPointer"/>
			<x path="Int"/>
			<x path="Bool"/>
		</f>
		<meta>
			<m n=":noCompletion"/>
			<m n=":op"><e><![CDATA[A < B]]></e></m>
		</meta>
	</lessThan>
	<lessThanPointer get="inline" set="null" line="40" static="1">
		<f a="a:b">
			<x path="lime.system.CFFIPointer"/>
			<x path="lime.system.CFFIPointer"/>
			<x path="Bool"/>
		</f>
		<meta>
			<m n=":noCompletion"/>
			<m n=":op"><e><![CDATA[A < B]]></e></m>
		</meta>
	</lessThanPointer>
	<lessThanOrEqual get="inline" set="null" line="41" static="1">
		<f a="a:b">
			<x path="lime.system.CFFIPointer"/>
			<x path="Int"/>
			<x path="Bool"/>
		</f>
		<meta>
			<m n=":noCompletion"/>
			<m n=":op"><e><![CDATA[A <= B]]></e></m>
		</meta>
	</lessThanOrEqual>
	<lessThanOrEqualPointer get="inline" set="null" line="42" static="1">
		<f a="a:b">
			<x path="lime.system.CFFIPointer"/>
			<x path="lime.system.CFFIPointer"/>
			<x path="Bool"/>
		</f>
		<meta>
			<m n=":noCompletion"/>
			<m n=":op"><e><![CDATA[A <= B]]></e></m>
		</meta>
	</lessThanOrEqualPointer>
	<notEquals get="inline" set="null" line="43" static="1">
		<f a="a:b">
			<x path="lime.system.CFFIPointer"/>
			<x path="Int"/>
			<x path="Bool"/>
		</f>
		<meta>
			<m n=":noCompletion"/>
			<m n=":op"><e>A != B</e></m>
		</meta>
	</notEquals>
	<notEqualsPointer get="inline" set="null" line="44" static="1">
		<f a="a:b">
			<x path="lime.system.CFFIPointer"/>
			<x path="lime.system.CFFIPointer"/>
			<x path="Bool"/>
		</f>
		<meta>
			<m n=":noCompletion"/>
			<m n=":op"><e>A != B</e></m>
		</meta>
	</notEqualsPointer>
	<lime_cffi_get_native_pointer get="inline" set="null" line="55" static="1">
		<f a="ptr">
			<d/>
			<x path="Float"/>
		</f>
		<meta><m n=":cffi"/></meta>
	</lime_cffi_get_native_pointer>
	<cffi_lime_cffi_get_native_pointer expr="new cpp.Callable&lt;Dynamic&gt;(lime.system.CFFI.load(&quot;lime&quot;, &quot;lime_cffi_get_native_pointer&quot;, 1, false))" line="55" static="1">
		<x path="cpp.Callable"><f a="">
	<d/>
	<x path="Float"/>
</f></x>
		<meta><m n=":value"><e><![CDATA[new cpp.Callable<Dynamic>(lime.system.CFFI.load("lime", "lime_cffi_get_native_pointer", 1, false))]]></e></m></meta>
	</cffi_lime_cffi_get_native_pointer>
	<meta>
		<m n=":directlyUsed"/>
		<m n=":final"/>
		<m n=":build"><e>lime.system.CFFI.build()</e></m>
	</meta>
</class></impl>
	</abstract>
	<class path="lime.system._CFFIPointer.CFFIPointer_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/system/CFFIPointer.hx" private="1" module="lime.system.CFFIPointer">
		<_new public="1" get="inline" set="null" line="11" static="1">
			<f a="handle">
				<d/>
				<x path="lime.system.CFFIPointer"/>
			</f>
			<meta><m n=":impl"/></meta>
		</_new>
		<get public="1" set="method" line="18" static="1">
			<f a="this">
				<d/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get>
		<equals get="inline" set="null" line="33" static="1">
			<f a="a:b">
				<x path="lime.system.CFFIPointer"/>
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<meta>
				<m n=":noCompletion"/>
				<m n=":op"><e>A == B</e></m>
			</meta>
		</equals>
		<equalsPointer get="inline" set="null" line="34" static="1">
			<f a="a:b">
				<x path="lime.system.CFFIPointer"/>
				<x path="lime.system.CFFIPointer"/>
				<x path="Bool"/>
			</f>
			<meta>
				<m n=":noCompletion"/>
				<m n=":op"><e>A == B</e></m>
			</meta>
		</equalsPointer>
		<greaterThan get="inline" set="null" line="35" static="1">
			<f a="a:b">
				<x path="lime.system.CFFIPointer"/>
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<meta>
				<m n=":noCompletion"/>
				<m n=":op"><e><![CDATA[A > B]]></e></m>
			</meta>
		</greaterThan>
		<greaterThanPointer get="inline" set="null" line="36" static="1">
			<f a="a:b">
				<x path="lime.system.CFFIPointer"/>
				<x path="lime.system.CFFIPointer"/>
				<x path="Bool"/>
			</f>
			<meta>
				<m n=":noCompletion"/>
				<m n=":op"><e><![CDATA[A > B]]></e></m>
			</meta>
		</greaterThanPointer>
		<greaterThanOrEqual get="inline" set="null" line="37" static="1">
			<f a="a:b">
				<x path="lime.system.CFFIPointer"/>
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<meta>
				<m n=":noCompletion"/>
				<m n=":op"><e><![CDATA[A >= B]]></e></m>
			</meta>
		</greaterThanOrEqual>
		<greaterThanOrEqualPointer get="inline" set="null" line="38" static="1">
			<f a="a:b">
				<x path="lime.system.CFFIPointer"/>
				<x path="lime.system.CFFIPointer"/>
				<x path="Bool"/>
			</f>
			<meta>
				<m n=":noCompletion"/>
				<m n=":op"><e><![CDATA[A >= B]]></e></m>
			</meta>
		</greaterThanOrEqualPointer>
		<lessThan get="inline" set="null" line="39" static="1">
			<f a="a:b">
				<x path="lime.system.CFFIPointer"/>
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<meta>
				<m n=":noCompletion"/>
				<m n=":op"><e><![CDATA[A < B]]></e></m>
			</meta>
		</lessThan>
		<lessThanPointer get="inline" set="null" line="40" static="1">
			<f a="a:b">
				<x path="lime.system.CFFIPointer"/>
				<x path="lime.system.CFFIPointer"/>
				<x path="Bool"/>
			</f>
			<meta>
				<m n=":noCompletion"/>
				<m n=":op"><e><![CDATA[A < B]]></e></m>
			</meta>
		</lessThanPointer>
		<lessThanOrEqual get="inline" set="null" line="41" static="1">
			<f a="a:b">
				<x path="lime.system.CFFIPointer"/>
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<meta>
				<m n=":noCompletion"/>
				<m n=":op"><e><![CDATA[A <= B]]></e></m>
			</meta>
		</lessThanOrEqual>
		<lessThanOrEqualPointer get="inline" set="null" line="42" static="1">
			<f a="a:b">
				<x path="lime.system.CFFIPointer"/>
				<x path="lime.system.CFFIPointer"/>
				<x path="Bool"/>
			</f>
			<meta>
				<m n=":noCompletion"/>
				<m n=":op"><e><![CDATA[A <= B]]></e></m>
			</meta>
		</lessThanOrEqualPointer>
		<notEquals get="inline" set="null" line="43" static="1">
			<f a="a:b">
				<x path="lime.system.CFFIPointer"/>
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<meta>
				<m n=":noCompletion"/>
				<m n=":op"><e>A != B</e></m>
			</meta>
		</notEquals>
		<notEqualsPointer get="inline" set="null" line="44" static="1">
			<f a="a:b">
				<x path="lime.system.CFFIPointer"/>
				<x path="lime.system.CFFIPointer"/>
				<x path="Bool"/>
			</f>
			<meta>
				<m n=":noCompletion"/>
				<m n=":op"><e>A != B</e></m>
			</meta>
		</notEqualsPointer>
		<lime_cffi_get_native_pointer get="inline" set="null" line="55" static="1">
			<f a="ptr">
				<d/>
				<x path="Float"/>
			</f>
			<meta><m n=":cffi"/></meta>
		</lime_cffi_get_native_pointer>
		<cffi_lime_cffi_get_native_pointer expr="new cpp.Callable&lt;Dynamic&gt;(lime.system.CFFI.load(&quot;lime&quot;, &quot;lime_cffi_get_native_pointer&quot;, 1, false))" line="55" static="1">
			<x path="cpp.Callable"><f a="">
	<d/>
	<x path="Float"/>
</f></x>
			<meta><m n=":value"><e><![CDATA[new cpp.Callable<Dynamic>(lime.system.CFFI.load("lime", "lime_cffi_get_native_pointer", 1, false))]]></e></m></meta>
		</cffi_lime_cffi_get_native_pointer>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":final"/>
			<m n=":build"><e>lime.system.CFFI.build()</e></m>
		</meta>
	</class>
	<class path="lime.system.Clipboard" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/system/Clipboard.hx">
		<text public="1" get="accessor" set="accessor" static="1"><c path="String"/></text>
		<get_text set="method" line="26" static="1"><f a=""><c path="String"/></f></get_text>
		<set_text set="method" line="43" static="1"><f a="value">
	<c path="String"/>
	<c path="String"/>
</f></set_text>
		<lime_clipboard_get_text get="inline" set="null" line="66" static="1">
			<f a=""><d/></f>
			<meta><m n=":cffi"/></meta>
		</lime_clipboard_get_text>
		<lime_clipboard_set_text get="inline" set="null" line="67" static="1">
			<f a="text">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":cffi"/></meta>
		</lime_clipboard_set_text>
		<cffi_lime_clipboard_get_text expr="new cpp.Callable&lt;Void&gt;(lime.system.CFFI.load(&quot;lime&quot;, &quot;lime_clipboard_get_text&quot;, 0, false))" line="66" static="1">
			<x path="cpp.Callable"><f a=""><d/></f></x>
			<meta><m n=":value"><e><![CDATA[new cpp.Callable<Void>(lime.system.CFFI.load("lime", "lime_clipboard_get_text", 0, false))]]></e></m></meta>
		</cffi_lime_clipboard_get_text>
		<cffi_lime_clipboard_set_text expr="new cpp.Callable&lt;String&gt;(lime.system.CFFI.load(&quot;lime&quot;, &quot;lime_clipboard_set_text&quot;, 1, false))" line="67" static="1">
			<x path="cpp.Callable"><f a="">
	<c path="String"/>
	<x path="Void"/>
</f></x>
			<meta><m n=":value"><e><![CDATA[new cpp.Callable<String>(lime.system.CFFI.load("lime", "lime_clipboard_set_text", 1, false))]]></e></m></meta>
		</cffi_lime_clipboard_set_text>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>lime.system.CFFI.build()</e></m>
		</meta>
	</class>
	<class path="lime.system.Display" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/system/Display.hx">
		<bounds public="1" set="null">
			<c path="lime.math.Rectangle"/>
			<haxe_doc>* The desktop area represented by this display, with the upper-leftmost display at 0,0</haxe_doc>
		</bounds>
		<currentMode public="1" set="null">
			<c path="lime.system.DisplayMode"/>
			<haxe_doc>* The current display mode</haxe_doc>
		</currentMode>
		<id public="1" set="null"><x path="Int"/></id>
		<dpi public="1" set="null">
			<x path="Float"/>
			<haxe_doc>* Pixel density of the display</haxe_doc>
		</dpi>
		<name public="1" set="null">
			<c path="String"/>
			<haxe_doc>* The name of the device, such as "Samsung SyncMaster P2350", "iPhone 6", "Occulus Rift DK2", etc.</haxe_doc>
		</name>
		<supportedModes public="1" set="null">
			<c path="Array"><c path="lime.system.DisplayMode"/></c>
			<haxe_doc>* All of the display modes supported by this device</haxe_doc>
		</supportedModes>
		<new set="method" line="38"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="lime.system.DisplayMode" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/system/DisplayMode.hx">
		<height public="1" set="null">
			<x path="Int"/>
			<haxe_doc>* vertical resolution</haxe_doc>
		</height>
		<pixelFormat public="1" set="null">
			<x path="lime.graphics.PixelFormat"/>
			<haxe_doc>* pixel format</haxe_doc>
		</pixelFormat>
		<refreshRate public="1" set="null">
			<x path="Int"/>
			<haxe_doc>* refresh rate in Hz</haxe_doc>
		</refreshRate>
		<width public="1" set="null">
			<x path="Int"/>
			<haxe_doc>* horizontal resolution</haxe_doc>
		</width>
		<new set="method" line="31"><f a="width:height:refreshRate:pixelFormat">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="lime.graphics.PixelFormat"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<enum path="lime.system.Endian" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/system/Endian.hx">
		<LITTLE_ENDIAN/>
		<BIG_ENDIAN/>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<class path="lime.system.Sensor" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/system/Sensor.hx">
		<sensorByID expr="new Map&lt;Int,Sensor&gt;()" line="10" static="1">
			<x path="Map">
				<x path="Int"/>
				<c path="lime.system.Sensor"/>
			</x>
			<meta><m n=":value"><e><![CDATA[new Map<Int,Sensor>()]]></e></m></meta>
		</sensorByID>
		<sensors expr="new Array&lt;Sensor&gt;()" line="11" static="1">
			<c path="Array"><c path="lime.system.Sensor"/></c>
			<meta><m n=":value"><e><![CDATA[new Array<Sensor>()]]></e></m></meta>
		</sensors>
		<getSensors public="1" set="method" line="26" static="1">
			<f a="?type" v="null">
				<e path="lime.system.SensorType"/>
				<c path="Array"><c path="lime.system.Sensor"/></c>
			</f>
			<meta><m n=":value"><e>{ type : null }</e></m></meta>
		</getSensors>
		<registerSensor set="method" line="53" static="1"><f a="type:id">
	<e path="lime.system.SensorType"/>
	<x path="Int"/>
	<x path="Void"/>
</f></registerSensor>
		<id public="1"><x path="Int"/></id>
		<onUpdate public="1" expr="new Event&lt;Float -&gt; Float -&gt; Float&gt;()">
			<c path="lime.app.Event_Float_Float_Float_Void"><f a="::">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></c>
			<meta><m n=":value"><e><![CDATA[new Event<Float -> Float -> Float>()]]></e></m></meta>
		</onUpdate>
		<type public="1"><e path="lime.system.SensorType"/></type>
		<new set="method" line="18"><f a="type:id">
	<e path="lime.system.SensorType"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<enum path="lime.system.SensorType" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/system/SensorType.hx">
		<ACCELEROMETER/>
		<meta><m n=":flatEnum"/></meta>
	</enum>
	<class path="lime.system.System" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/system/System.hx">
		<allowScreenTimeout public="1" get="accessor" set="accessor" static="1"><x path="Bool"/></allowScreenTimeout>
		<applicationDirectory public="1" get="accessor" set="null" static="1"><c path="String"/></applicationDirectory>
		<applicationStorageDirectory public="1" get="accessor" set="null" static="1"><c path="String"/></applicationStorageDirectory>
		<desktopDirectory public="1" get="accessor" set="null" static="1"><c path="String"/></desktopDirectory>
		<disableCFFI public="1" static="1"><x path="Bool"/></disableCFFI>
		<documentsDirectory public="1" get="accessor" set="null" static="1"><c path="String"/></documentsDirectory>
		<endianness public="1" get="accessor" set="null" static="1"><e path="lime.system.Endian"/></endianness>
		<fontsDirectory public="1" get="accessor" set="null" static="1"><c path="String"/></fontsDirectory>
		<numDisplays public="1" get="accessor" set="null" static="1"><x path="Int"/></numDisplays>
		<userDirectory public="1" get="accessor" set="null" static="1"><c path="String"/></userDirectory>
		<exit public="1" set="method" line="111" static="1"><f a="code">
	<x path="Int"/>
	<x path="Void"/>
</f></exit>
		<getDisplay public="1" set="method" line="149" static="1"><f a="id">
	<x path="Int"/>
	<c path="lime.system.Display"/>
</f></getDisplay>
		<getTimer public="1" set="method" line="205" static="1"><f a=""><x path="Int"/></f></getTimer>
		<load public="1" get="inline" set="null" line="224" static="1">
			<f a="library:method:?args:?lazy" v="::0:false">
				<c path="String"/>
				<c path="String"/>
				<x path="Int"/>
				<x path="Bool"/>
				<d/>
			</f>
			<meta><m n=":value"><e>{ lazy : false, args : 0 }</e></m></meta>
		</load>
		<get_allowScreenTimeout set="method" line="242" static="1"><f a=""><x path="Bool"/></f></get_allowScreenTimeout>
		<set_allowScreenTimeout set="method" line="253" static="1"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_allowScreenTimeout>
		<get_applicationDirectory set="method" line="264" static="1"><f a=""><c path="String"/></f></get_applicationDirectory>
		<get_applicationStorageDirectory set="method" line="285" static="1"><f a=""><c path="String"/></f></get_applicationStorageDirectory>
		<get_desktopDirectory set="method" line="325" static="1"><f a=""><c path="String"/></f></get_desktopDirectory>
		<get_documentsDirectory set="method" line="346" static="1"><f a=""><c path="String"/></f></get_documentsDirectory>
		<get_fontsDirectory set="method" line="367" static="1"><f a=""><c path="String"/></f></get_fontsDirectory>
		<get_numDisplays set="method" line="378" static="1"><f a=""><x path="Int"/></f></get_numDisplays>
		<get_userDirectory set="method" line="389" static="1"><f a=""><c path="String"/></f></get_userDirectory>
		<get_endianness set="method" line="410" static="1"><f a=""><e path="lime.system.Endian"/></f></get_endianness>
		<lime_system_get_allow_screen_timeout get="inline" set="null" line="431" static="1">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":cffi"/></meta>
		</lime_system_get_allow_screen_timeout>
		<lime_system_set_allow_screen_timeout get="inline" set="null" line="432" static="1">
			<f a="value">
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":cffi"/></meta>
		</lime_system_set_allow_screen_timeout>
		<lime_system_get_directory get="inline" set="null" line="433" static="1">
			<f a="type:company:title">
				<x path="Int"/>
				<c path="String"/>
				<c path="String"/>
				<d/>
			</f>
			<meta><m n=":cffi"/></meta>
		</lime_system_get_directory>
		<lime_system_get_display get="inline" set="null" line="434" static="1">
			<f a="index">
				<x path="Int"/>
				<d/>
			</f>
			<meta><m n=":cffi"/></meta>
		</lime_system_get_display>
		<lime_system_get_num_displays get="inline" set="null" line="435" static="1">
			<f a=""><x path="Int"/></f>
			<meta><m n=":cffi"/></meta>
		</lime_system_get_num_displays>
		<lime_system_get_timer get="inline" set="null" line="436" static="1">
			<f a=""><x path="Float"/></f>
			<meta><m n=":cffi"/></meta>
		</lime_system_get_timer>
		<cffi_lime_system_get_allow_screen_timeout expr="new cpp.Callable&lt;Void&gt;(lime.system.CFFI.load(&quot;lime&quot;, &quot;lime_system_get_allow_screen_timeout&quot;, 0, false))" line="431" static="1">
			<x path="cpp.Callable"><f a=""><x path="Bool"/></f></x>
			<meta><m n=":value"><e><![CDATA[new cpp.Callable<Void>(lime.system.CFFI.load("lime", "lime_system_get_allow_screen_timeout", 0, false))]]></e></m></meta>
		</cffi_lime_system_get_allow_screen_timeout>
		<cffi_lime_system_set_allow_screen_timeout expr="new cpp.Callable&lt;Bool&gt;(lime.system.CFFI.load(&quot;lime&quot;, &quot;lime_system_set_allow_screen_timeout&quot;, 1, false))" line="432" static="1">
			<x path="cpp.Callable"><f a="">
	<x path="Bool"/>
	<x path="Bool"/>
</f></x>
			<meta><m n=":value"><e><![CDATA[new cpp.Callable<Bool>(lime.system.CFFI.load("lime", "lime_system_set_allow_screen_timeout", 1, false))]]></e></m></meta>
		</cffi_lime_system_set_allow_screen_timeout>
		<cffi_lime_system_get_directory expr="new cpp.Callable&lt;Int -&gt; String -&gt; String&gt;(lime.system.CFFI.load(&quot;lime&quot;, &quot;lime_system_get_directory&quot;, 3, false))" line="433" static="1">
			<x path="cpp.Callable"><f a="::">
	<x path="Int"/>
	<c path="String"/>
	<c path="String"/>
	<d/>
</f></x>
			<meta><m n=":value"><e><![CDATA[new cpp.Callable<Int -> String -> String>(lime.system.CFFI.load("lime", "lime_system_get_directory", 3, false))]]></e></m></meta>
		</cffi_lime_system_get_directory>
		<cffi_lime_system_get_display expr="new cpp.Callable&lt;Int&gt;(lime.system.CFFI.load(&quot;lime&quot;, &quot;lime_system_get_display&quot;, 1, false))" line="434" static="1">
			<x path="cpp.Callable"><f a="">
	<x path="Int"/>
	<d/>
</f></x>
			<meta><m n=":value"><e><![CDATA[new cpp.Callable<Int>(lime.system.CFFI.load("lime", "lime_system_get_display", 1, false))]]></e></m></meta>
		</cffi_lime_system_get_display>
		<cffi_lime_system_get_num_displays expr="new cpp.Callable&lt;Void&gt;(lime.system.CFFI.load(&quot;lime&quot;, &quot;lime_system_get_num_displays&quot;, 0, false))" line="435" static="1">
			<x path="cpp.Callable"><f a=""><x path="Int"/></f></x>
			<meta><m n=":value"><e><![CDATA[new cpp.Callable<Void>(lime.system.CFFI.load("lime", "lime_system_get_num_displays", 0, false))]]></e></m></meta>
		</cffi_lime_system_get_num_displays>
		<cffi_lime_system_get_timer expr="new cpp.Callable&lt;Void&gt;(lime.system.CFFI.load(&quot;lime&quot;, &quot;lime_system_get_timer&quot;, 0, false))" line="436" static="1">
			<x path="cpp.Callable"><f a=""><x path="Float"/></f></x>
			<meta><m n=":value"><e><![CDATA[new cpp.Callable<Void>(lime.system.CFFI.load("lime", "lime_system_get_timer", 0, false))]]></e></m></meta>
		</cffi_lime_system_get_timer>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>lime.system.CFFI.build()</e></m>
			<m n=":access"><e>lime.system.Display</e></m>
			<m n=":access"><e>lime.system.DisplayMode</e></m>
		</meta>
	</class>
	<abstract path="lime.system._System.SystemDirectory" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/system/System.hx" private="1" module="lime.system.System">
		<from>
			<icast><x path="UInt"/></icast>
			<icast><x path="Int"/></icast>
		</from>
		<this><x path="Int"/></this>
		<to>
			<icast><x path="UInt"/></icast>
			<icast><x path="Int"/></icast>
		</to>
		<meta><m n=":enum"/></meta>
		<impl><class path="lime.system._System.SystemDirectory_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/system/System.hx" private="1" module="lime.system.System" extern="1">
	<APPLICATION public="1" get="inline" set="null" expr="cast 0" line="445" static="1">
		<x path="lime.system._System.SystemDirectory"/>
		<meta>
			<m n=":value"><e>cast 0</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</APPLICATION>
	<APPLICATION_STORAGE public="1" get="inline" set="null" expr="cast 1" line="446" static="1">
		<x path="lime.system._System.SystemDirectory"/>
		<meta>
			<m n=":value"><e>cast 1</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</APPLICATION_STORAGE>
	<DESKTOP public="1" get="inline" set="null" expr="cast 2" line="447" static="1">
		<x path="lime.system._System.SystemDirectory"/>
		<meta>
			<m n=":value"><e>cast 2</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</DESKTOP>
	<DOCUMENTS public="1" get="inline" set="null" expr="cast 3" line="448" static="1">
		<x path="lime.system._System.SystemDirectory"/>
		<meta>
			<m n=":value"><e>cast 3</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</DOCUMENTS>
	<FONTS public="1" get="inline" set="null" expr="cast 4" line="449" static="1">
		<x path="lime.system._System.SystemDirectory"/>
		<meta>
			<m n=":value"><e>cast 4</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</FONTS>
	<USER public="1" get="inline" set="null" expr="cast 5" line="450" static="1">
		<x path="lime.system._System.SystemDirectory"/>
		<meta>
			<m n=":value"><e>cast 5</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</USER>
	<meta>
		<m n=":final"/>
		<m n=":enum"/>
	</meta>
</class></impl>
	</abstract>
	<class path="lime.system._System.SystemDirectory_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/system/System.hx" private="1" module="lime.system.System" extern="1">
		<APPLICATION public="1" get="inline" set="null" expr="cast 0" line="445" static="1">
			<x path="lime.system._System.SystemDirectory"/>
			<meta>
				<m n=":value"><e>cast 0</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</APPLICATION>
		<APPLICATION_STORAGE public="1" get="inline" set="null" expr="cast 1" line="446" static="1">
			<x path="lime.system._System.SystemDirectory"/>
			<meta>
				<m n=":value"><e>cast 1</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</APPLICATION_STORAGE>
		<DESKTOP public="1" get="inline" set="null" expr="cast 2" line="447" static="1">
			<x path="lime.system._System.SystemDirectory"/>
			<meta>
				<m n=":value"><e>cast 2</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</DESKTOP>
		<DOCUMENTS public="1" get="inline" set="null" expr="cast 3" line="448" static="1">
			<x path="lime.system._System.SystemDirectory"/>
			<meta>
				<m n=":value"><e>cast 3</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</DOCUMENTS>
		<FONTS public="1" get="inline" set="null" expr="cast 4" line="449" static="1">
			<x path="lime.system._System.SystemDirectory"/>
			<meta>
				<m n=":value"><e>cast 4</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</FONTS>
		<USER public="1" get="inline" set="null" expr="cast 5" line="450" static="1">
			<x path="lime.system._System.SystemDirectory"/>
			<meta>
				<m n=":value"><e>cast 5</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</USER>
		<meta>
			<m n=":final"/>
			<m n=":enum"/>
		</meta>
	</class>
	<class path="lime.system.ThreadPool" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/system/ThreadPool.hx">
		<currentThreads public="1" set="null"><x path="Int"/></currentThreads>
		<doWork public="1" expr="new Event&lt;Dynamic&gt;()">
			<c path="lime.app.Event_Dynamic_Void"><f a="">
	<d/>
	<x path="Void"/>
</f></c>
			<meta><m n=":value"><e><![CDATA[new Event<Dynamic>()]]></e></m></meta>
		</doWork>
		<maxThreads public="1"><x path="Int"/></maxThreads>
		<minThreads public="1"><x path="Int"/></minThreads>
		<onComplete public="1" expr="new Event&lt;Dynamic&gt;()">
			<c path="lime.app.Event_Dynamic_Void"><f a="">
	<d/>
	<x path="Void"/>
</f></c>
			<meta><m n=":value"><e><![CDATA[new Event<Dynamic>()]]></e></m></meta>
		</onComplete>
		<onError public="1" expr="new Event&lt;Dynamic&gt;()">
			<c path="lime.app.Event_Dynamic_Void"><f a="">
	<d/>
	<x path="Void"/>
</f></c>
			<meta><m n=":value"><e><![CDATA[new Event<Dynamic>()]]></e></m></meta>
		</onError>
		<onProgress public="1" expr="new Event&lt;Dynamic&gt;()">
			<c path="lime.app.Event_Dynamic_Void"><f a="">
	<d/>
	<x path="Void"/>
</f></c>
			<meta><m n=":value"><e><![CDATA[new Event<Dynamic>()]]></e></m></meta>
		</onProgress>
		<__workCompleted><x path="Int"/></__workCompleted>
		<__workIncoming expr="new Deque&lt;ThreadPoolMessage&gt;()">
			<c path="neko.vm.Deque"><c path="lime.system._ThreadPool.ThreadPoolMessage"/></c>
			<meta><m n=":value"><e><![CDATA[new Deque<ThreadPoolMessage>()]]></e></m></meta>
		</__workIncoming>
		<__workQueued><x path="Int"/></__workQueued>
		<__workResult expr="new Deque&lt;ThreadPoolMessage&gt;()">
			<c path="neko.vm.Deque"><c path="lime.system._ThreadPool.ThreadPoolMessage"/></c>
			<meta><m n=":value"><e><![CDATA[new Deque<ThreadPoolMessage>()]]></e></m></meta>
		</__workResult>
		<queue public="1" set="method" line="64">
			<f a="?state" v="null">
				<d/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ state : null }</e></m></meta>
		</queue>
		<sendComplete public="1" set="method" line="93">
			<f a="?state" v="null">
				<d/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ state : null }</e></m></meta>
		</sendComplete>
		<sendError public="1" set="method" line="104">
			<f a="?state" v="null">
				<d/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ state : null }</e></m></meta>
		</sendError>
		<sendProgress public="1" set="method" line="115">
			<f a="?state" v="null">
				<d/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ state : null }</e></m></meta>
		</sendProgress>
		<__doWork set="method" line="128"><f a=""><x path="Void"/></f></__doWork>
		<__update set="method" line="149"><f a="deltaTime">
	<x path="Int"/>
	<x path="Void"/>
</f></__update>
		<new public="1" set="method" line="35">
			<f a="?minThreads:?maxThreads" v="0:1">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ maxThreads : 1, minThreads : 0 }</e></m></meta>
		</new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<enum path="lime.system._ThreadPool.ThreadPoolMessageType" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/system/ThreadPool.hx" private="1" module="lime.system.ThreadPool">
		<COMPLETE/>
		<ERROR/>
		<EXIT/>
		<PROGRESS/>
		<WORK/>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<class path="lime.system._ThreadPool.ThreadPoolMessage" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/system/ThreadPool.hx" private="1" module="lime.system.ThreadPool">
		<state public="1"><d/></state>
		<type public="1"><e path="lime.system._ThreadPool.ThreadPoolMessageType"/></type>
		<new public="1" set="method" line="230"><f a="type:state">
	<e path="lime.system._ThreadPool.ThreadPoolMessageType"/>
	<d/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="lime.text.Font" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/text/Font.hx">
		<fromBytes public="1" set="method" line="84" static="1"><f a="bytes">
	<c path="haxe.io.Bytes"/>
	<c path="lime.text.Font"/>
</f></fromBytes>
		<fromFile public="1" set="method" line="98" static="1"><f a="path">
	<c path="String"/>
	<c path="lime.text.Font"/>
</f></fromFile>
		<lime_font_get_ascender get="inline" set="null" line="499" static="1">
			<f a="handle">
				<d/>
				<x path="Int"/>
			</f>
			<meta><m n=":cffi"/></meta>
		</lime_font_get_ascender>
		<lime_font_get_descender get="inline" set="null" line="500" static="1">
			<f a="handle">
				<d/>
				<x path="Int"/>
			</f>
			<meta><m n=":cffi"/></meta>
		</lime_font_get_descender>
		<lime_font_get_family_name get="inline" set="null" line="501" static="1">
			<f a="handle">
				<d/>
				<d/>
			</f>
			<meta><m n=":cffi"/></meta>
		</lime_font_get_family_name>
		<lime_font_get_glyph_index get="inline" set="null" line="502" static="1">
			<f a="handle:character">
				<d/>
				<c path="String"/>
				<x path="Int"/>
			</f>
			<meta><m n=":cffi"/></meta>
		</lime_font_get_glyph_index>
		<lime_font_get_glyph_indices get="inline" set="null" line="503" static="1">
			<f a="handle:characters">
				<d/>
				<c path="String"/>
				<d/>
			</f>
			<meta><m n=":cffi"/></meta>
		</lime_font_get_glyph_indices>
		<lime_font_get_glyph_metrics get="inline" set="null" line="504" static="1">
			<f a="handle:index">
				<d/>
				<x path="Int"/>
				<d/>
			</f>
			<meta><m n=":cffi"/></meta>
		</lime_font_get_glyph_metrics>
		<lime_font_get_height get="inline" set="null" line="505" static="1">
			<f a="handle">
				<d/>
				<x path="Int"/>
			</f>
			<meta><m n=":cffi"/></meta>
		</lime_font_get_height>
		<lime_font_get_num_glyphs get="inline" set="null" line="506" static="1">
			<f a="handle">
				<d/>
				<x path="Int"/>
			</f>
			<meta><m n=":cffi"/></meta>
		</lime_font_get_num_glyphs>
		<lime_font_get_underline_position get="inline" set="null" line="507" static="1">
			<f a="handle">
				<d/>
				<x path="Int"/>
			</f>
			<meta><m n=":cffi"/></meta>
		</lime_font_get_underline_position>
		<lime_font_get_underline_thickness get="inline" set="null" line="508" static="1">
			<f a="handle">
				<d/>
				<x path="Int"/>
			</f>
			<meta><m n=":cffi"/></meta>
		</lime_font_get_underline_thickness>
		<lime_font_get_units_per_em get="inline" set="null" line="509" static="1">
			<f a="handle">
				<d/>
				<x path="Int"/>
			</f>
			<meta><m n=":cffi"/></meta>
		</lime_font_get_units_per_em>
		<lime_font_load get="inline" set="null" line="510" static="1">
			<f a="data">
				<d/>
				<d/>
			</f>
			<meta><m n=":cffi"/></meta>
		</lime_font_load>
		<lime_font_outline_decompose get="inline" set="null" line="511" static="1">
			<f a="handle:size">
				<d/>
				<x path="Int"/>
				<d/>
			</f>
			<meta><m n=":cffi"/></meta>
		</lime_font_outline_decompose>
		<lime_font_render_glyph get="inline" set="null" line="512" static="1">
			<f a="handle:index:data">
				<d/>
				<x path="Int"/>
				<d/>
				<x path="Bool"/>
			</f>
			<meta><m n=":cffi"/></meta>
		</lime_font_render_glyph>
		<lime_font_render_glyphs get="inline" set="null" line="513" static="1">
			<f a="handle:indices:data">
				<d/>
				<d/>
				<d/>
				<x path="Bool"/>
			</f>
			<meta><m n=":cffi"/></meta>
		</lime_font_render_glyphs>
		<lime_font_set_size get="inline" set="null" line="514" static="1">
			<f a="handle:size">
				<d/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":cffi"/></meta>
		</lime_font_set_size>
		<cffi_lime_font_get_ascender expr="new cpp.Callable&lt;Dynamic&gt;(lime.system.CFFI.load(&quot;lime&quot;, &quot;lime_font_get_ascender&quot;, 1, false))" line="499" static="1">
			<x path="cpp.Callable"><f a="">
	<d/>
	<x path="Int"/>
</f></x>
			<meta><m n=":value"><e><![CDATA[new cpp.Callable<Dynamic>(lime.system.CFFI.load("lime", "lime_font_get_ascender", 1, false))]]></e></m></meta>
		</cffi_lime_font_get_ascender>
		<cffi_lime_font_get_descender expr="new cpp.Callable&lt;Dynamic&gt;(lime.system.CFFI.load(&quot;lime&quot;, &quot;lime_font_get_descender&quot;, 1, false))" line="500" static="1">
			<x path="cpp.Callable"><f a="">
	<d/>
	<x path="Int"/>
</f></x>
			<meta><m n=":value"><e><![CDATA[new cpp.Callable<Dynamic>(lime.system.CFFI.load("lime", "lime_font_get_descender", 1, false))]]></e></m></meta>
		</cffi_lime_font_get_descender>
		<cffi_lime_font_get_family_name expr="new cpp.Callable&lt;Dynamic&gt;(lime.system.CFFI.load(&quot;lime&quot;, &quot;lime_font_get_family_name&quot;, 1, false))" line="501" static="1">
			<x path="cpp.Callable"><f a="">
	<d/>
	<d/>
</f></x>
			<meta><m n=":value"><e><![CDATA[new cpp.Callable<Dynamic>(lime.system.CFFI.load("lime", "lime_font_get_family_name", 1, false))]]></e></m></meta>
		</cffi_lime_font_get_family_name>
		<cffi_lime_font_get_glyph_index expr="new cpp.Callable&lt;Dynamic -&gt; String&gt;(lime.system.CFFI.load(&quot;lime&quot;, &quot;lime_font_get_glyph_index&quot;, 2, false))" line="502" static="1">
			<x path="cpp.Callable"><f a=":">
	<d/>
	<c path="String"/>
	<x path="Int"/>
</f></x>
			<meta><m n=":value"><e><![CDATA[new cpp.Callable<Dynamic -> String>(lime.system.CFFI.load("lime", "lime_font_get_glyph_index", 2, false))]]></e></m></meta>
		</cffi_lime_font_get_glyph_index>
		<cffi_lime_font_get_glyph_indices expr="new cpp.Callable&lt;Dynamic -&gt; String&gt;(lime.system.CFFI.load(&quot;lime&quot;, &quot;lime_font_get_glyph_indices&quot;, 2, false))" line="503" static="1">
			<x path="cpp.Callable"><f a=":">
	<d/>
	<c path="String"/>
	<d/>
</f></x>
			<meta><m n=":value"><e><![CDATA[new cpp.Callable<Dynamic -> String>(lime.system.CFFI.load("lime", "lime_font_get_glyph_indices", 2, false))]]></e></m></meta>
		</cffi_lime_font_get_glyph_indices>
		<cffi_lime_font_get_glyph_metrics expr="new cpp.Callable&lt;Dynamic -&gt; Int&gt;(lime.system.CFFI.load(&quot;lime&quot;, &quot;lime_font_get_glyph_metrics&quot;, 2, false))" line="504" static="1">
			<x path="cpp.Callable"><f a=":">
	<d/>
	<x path="Int"/>
	<d/>
</f></x>
			<meta><m n=":value"><e><![CDATA[new cpp.Callable<Dynamic -> Int>(lime.system.CFFI.load("lime", "lime_font_get_glyph_metrics", 2, false))]]></e></m></meta>
		</cffi_lime_font_get_glyph_metrics>
		<cffi_lime_font_get_height expr="new cpp.Callable&lt;Dynamic&gt;(lime.system.CFFI.load(&quot;lime&quot;, &quot;lime_font_get_height&quot;, 1, false))" line="505" static="1">
			<x path="cpp.Callable"><f a="">
	<d/>
	<x path="Int"/>
</f></x>
			<meta><m n=":value"><e><![CDATA[new cpp.Callable<Dynamic>(lime.system.CFFI.load("lime", "lime_font_get_height", 1, false))]]></e></m></meta>
		</cffi_lime_font_get_height>
		<cffi_lime_font_get_num_glyphs expr="new cpp.Callable&lt;Dynamic&gt;(lime.system.CFFI.load(&quot;lime&quot;, &quot;lime_font_get_num_glyphs&quot;, 1, false))" line="506" static="1">
			<x path="cpp.Callable"><f a="">
	<d/>
	<x path="Int"/>
</f></x>
			<meta><m n=":value"><e><![CDATA[new cpp.Callable<Dynamic>(lime.system.CFFI.load("lime", "lime_font_get_num_glyphs", 1, false))]]></e></m></meta>
		</cffi_lime_font_get_num_glyphs>
		<cffi_lime_font_get_underline_position expr="new cpp.Callable&lt;Dynamic&gt;(lime.system.CFFI.load(&quot;lime&quot;, &quot;lime_font_get_underline_position&quot;, 1, false))" line="507" static="1">
			<x path="cpp.Callable"><f a="">
	<d/>
	<x path="Int"/>
</f></x>
			<meta><m n=":value"><e><![CDATA[new cpp.Callable<Dynamic>(lime.system.CFFI.load("lime", "lime_font_get_underline_position", 1, false))]]></e></m></meta>
		</cffi_lime_font_get_underline_position>
		<cffi_lime_font_get_underline_thickness expr="new cpp.Callable&lt;Dynamic&gt;(lime.system.CFFI.load(&quot;lime&quot;, &quot;lime_font_get_underline_thickness&quot;, 1, false))" line="508" static="1">
			<x path="cpp.Callable"><f a="">
	<d/>
	<x path="Int"/>
</f></x>
			<meta><m n=":value"><e><![CDATA[new cpp.Callable<Dynamic>(lime.system.CFFI.load("lime", "lime_font_get_underline_thickness", 1, false))]]></e></m></meta>
		</cffi_lime_font_get_underline_thickness>
		<cffi_lime_font_get_units_per_em expr="new cpp.Callable&lt;Dynamic&gt;(lime.system.CFFI.load(&quot;lime&quot;, &quot;lime_font_get_units_per_em&quot;, 1, false))" line="509" static="1">
			<x path="cpp.Callable"><f a="">
	<d/>
	<x path="Int"/>
</f></x>
			<meta><m n=":value"><e><![CDATA[new cpp.Callable<Dynamic>(lime.system.CFFI.load("lime", "lime_font_get_units_per_em", 1, false))]]></e></m></meta>
		</cffi_lime_font_get_units_per_em>
		<cffi_lime_font_load expr="new cpp.Callable&lt;Dynamic&gt;(lime.system.CFFI.load(&quot;lime&quot;, &quot;lime_font_load&quot;, 1, false))" line="510" static="1">
			<x path="cpp.Callable"><f a="">
	<d/>
	<d/>
</f></x>
			<meta><m n=":value"><e><![CDATA[new cpp.Callable<Dynamic>(lime.system.CFFI.load("lime", "lime_font_load", 1, false))]]></e></m></meta>
		</cffi_lime_font_load>
		<cffi_lime_font_outline_decompose expr="new cpp.Callable&lt;Dynamic -&gt; Int&gt;(lime.system.CFFI.load(&quot;lime&quot;, &quot;lime_font_outline_decompose&quot;, 2, false))" line="511" static="1">
			<x path="cpp.Callable"><f a=":">
	<d/>
	<x path="Int"/>
	<d/>
</f></x>
			<meta><m n=":value"><e><![CDATA[new cpp.Callable<Dynamic -> Int>(lime.system.CFFI.load("lime", "lime_font_outline_decompose", 2, false))]]></e></m></meta>
		</cffi_lime_font_outline_decompose>
		<cffi_lime_font_render_glyph expr="new cpp.Callable&lt;Dynamic -&gt; Int -&gt; Dynamic&gt;(lime.system.CFFI.load(&quot;lime&quot;, &quot;lime_font_render_glyph&quot;, 3, false))" line="512" static="1">
			<x path="cpp.Callable"><f a="::">
	<d/>
	<x path="Int"/>
	<d/>
	<x path="Bool"/>
</f></x>
			<meta><m n=":value"><e><![CDATA[new cpp.Callable<Dynamic -> Int -> Dynamic>(lime.system.CFFI.load("lime", "lime_font_render_glyph", 3, false))]]></e></m></meta>
		</cffi_lime_font_render_glyph>
		<cffi_lime_font_render_glyphs expr="new cpp.Callable&lt;Dynamic -&gt; Dynamic -&gt; Dynamic&gt;(lime.system.CFFI.load(&quot;lime&quot;, &quot;lime_font_render_glyphs&quot;, 3, false))" line="513" static="1">
			<x path="cpp.Callable"><f a="::">
	<d/>
	<d/>
	<d/>
	<x path="Bool"/>
</f></x>
			<meta><m n=":value"><e><![CDATA[new cpp.Callable<Dynamic -> Dynamic -> Dynamic>(lime.system.CFFI.load("lime", "lime_font_render_glyphs", 3, false))]]></e></m></meta>
		</cffi_lime_font_render_glyphs>
		<cffi_lime_font_set_size expr="new cpp.Callable&lt;Dynamic -&gt; Int&gt;(lime.system.CFFI.load(&quot;lime&quot;, &quot;lime_font_set_size&quot;, 2, false))" line="514" static="1">
			<x path="cpp.Callable"><f a=":">
	<d/>
	<x path="Int"/>
	<x path="Void"/>
</f></x>
			<meta><m n=":value"><e><![CDATA[new cpp.Callable<Dynamic -> Int>(lime.system.CFFI.load("lime", "lime_font_set_size", 2, false))]]></e></m></meta>
		</cffi_lime_font_set_size>
		<ascender public="1" get="accessor" set="null"><x path="Int"/></ascender>
		<descender public="1" get="accessor" set="null"><x path="Int"/></descender>
		<height public="1" get="accessor" set="null"><x path="Int"/></height>
		<name public="1" set="null"><c path="String"/></name>
		<numGlyphs public="1" get="accessor" set="null"><x path="Int"/></numGlyphs>
		<src public="1"><d/></src>
		<underlinePosition public="1" get="accessor" set="null"><x path="Int"/></underlinePosition>
		<underlineThickness public="1" get="accessor" set="null"><x path="Int"/></underlineThickness>
		<unitsPerEM public="1" get="accessor" set="null"><x path="Int"/></unitsPerEM>
		<__fontPath>
			<c path="String"/>
			<meta><m n=":noCompletion"/></meta>
		</__fontPath>
		<__fontPathWithoutDirectory>
			<c path="String"/>
			<meta><m n=":noCompletion"/></meta>
		</__fontPathWithoutDirectory>
		<decompose public="1" set="method" line="67"><f a=""><t path="lime.text.NativeFontData"/></f></decompose>
		<getGlyph public="1" set="method" line="112"><f a="character">
	<c path="String"/>
	<x path="lime.text.Glyph"/>
</f></getGlyph>
		<getGlyphs public="1" set="method" line="123">
			<f a="?characters" v="&quot;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789!@#$%^`&apos;\&quot;/\\&amp;*()[]{}&lt;&gt;|:;_-+=?,. &quot;">
				<c path="String"/>
				<c path="Array"><x path="lime.text.Glyph"/></c>
			</f>
			<meta><m n=":value"><e><![CDATA[{ characters : "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789!@#$%^`'\"/\\&*()[]{}<>|:;_-+=?,. " }]]></e></m></meta>
		</getGlyphs>
		<getGlyphMetrics public="1" set="method" line="135"><f a="glyph">
	<x path="lime.text.Glyph"/>
	<c path="lime.text.GlyphMetrics"/>
</f></getGlyphMetrics>
		<renderGlyph public="1" set="method" line="154"><f a="glyph:fontSize">
	<x path="lime.text.Glyph"/>
	<x path="Int"/>
	<c path="lime.graphics.Image"/>
</f></renderGlyph>
		<renderGlyphs public="1" set="method" line="192"><f a="glyphs:fontSize">
	<c path="Array"><x path="lime.text.Glyph"/></c>
	<x path="Int"/>
	<x path="Map">
		<x path="lime.text.Glyph"/>
		<c path="lime.graphics.Image"/>
	</x>
</f></renderGlyphs>
		<__fromBytes set="method" line="356">
			<f a="bytes">
				<c path="haxe.io.Bytes"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</__fromBytes>
		<__fromFile set="method" line="377">
			<f a="path">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</__fromFile>
		<__setSize set="method" line="398">
			<f a="size">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</__setSize>
		<get_ascender set="method" line="414"><f a=""><x path="Int"/></f></get_ascender>
		<get_descender set="method" line="425"><f a=""><x path="Int"/></f></get_descender>
		<get_height set="method" line="436"><f a=""><x path="Int"/></f></get_height>
		<get_numGlyphs set="method" line="447"><f a=""><x path="Int"/></f></get_numGlyphs>
		<get_underlinePosition set="method" line="458"><f a=""><x path="Int"/></f></get_underlinePosition>
		<get_underlineThickness set="method" line="469"><f a=""><x path="Int"/></f></get_underlineThickness>
		<get_unitsPerEM set="method" line="480"><f a=""><x path="Int"/></f></get_unitsPerEM>
		<new public="1" set="method" line="50">
			<f a="?name" v="null">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ name : null }</e></m></meta>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>lime.system.CFFI.build()</e></m>
			<m n=":autoBuild"><e>lime.Assets.embedFont()</e></m>
			<m n=":access"><e>lime.text.Glyph</e></m>
		</meta>
	</class>
	<typedef path="lime.text.NativeFontData" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/text/Font.hx" module="lime.text.Font"><a>
	<style_name><c path="String"/></style_name>
	<num_glyphs><x path="Int"/></num_glyphs>
	<kerning><c path="Array"><t path="lime.text.NativeKerningData"/></c></kerning>
	<is_italic><x path="Bool"/></is_italic>
	<is_fixed_width><x path="Bool"/></is_fixed_width>
	<is_bold><x path="Bool"/></is_bold>
	<height><x path="Int"/></height>
	<has_kerning><x path="Bool"/></has_kerning>
	<has_glyph_names><x path="Bool"/></has_glyph_names>
	<glyphs><c path="Array"><t path="lime.text.NativeGlyphData"/></c></glyphs>
	<family_name><c path="String"/></family_name>
	<em_size><x path="Int"/></em_size>
	<descend><x path="Int"/></descend>
	<ascend><x path="Int"/></ascend>
</a></typedef>
	<typedef path="lime.text.NativeGlyphData" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/text/Font.hx" module="lime.text.Font"><a>
	<points><c path="Array"><x path="Int"/></c></points>
	<min_y><x path="Int"/></min_y>
	<min_x><x path="Int"/></min_x>
	<max_y><x path="Int"/></max_y>
	<max_x><x path="Int"/></max_x>
	<char_code><x path="Int"/></char_code>
	<advance><x path="Int"/></advance>
</a></typedef>
	<typedef path="lime.text.NativeKerningData" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/text/Font.hx" module="lime.text.Font"><a>
	<y><x path="Int"/></y>
	<x><x path="Int"/></x>
	<right_glyph><x path="Int"/></right_glyph>
	<left_glyph><x path="Int"/></left_glyph>
</a></typedef>
	<abstract path="lime.text.Glyph" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/text/Glyph.hx">
		<from>
			<icast><x path="UInt"/></icast>
			<icast><x path="Int"/></icast>
		</from>
		<this><x path="Int"/></this>
		<to>
			<icast><x path="UInt"/></icast>
			<icast><x path="Int"/></icast>
		</to>
		<impl><class path="lime.text._Glyph.Glyph_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/text/Glyph.hx" private="1" module="lime.text.Glyph">
	<_new public="1" set="method" line="7" static="1">
		<f a="i">
			<x path="Int"/>
			<x path="lime.text.Glyph"/>
		</f>
		<meta><m n=":impl"/></meta>
	</_new>
	<meta><m n=":final"/></meta>
</class></impl>
	</abstract>
	<class path="lime.text._Glyph.Glyph_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/text/Glyph.hx" private="1" module="lime.text.Glyph">
		<_new public="1" set="method" line="7" static="1">
			<f a="i">
				<x path="Int"/>
				<x path="lime.text.Glyph"/>
			</f>
			<meta><m n=":impl"/></meta>
		</_new>
		<meta><m n=":final"/></meta>
	</class>
	<class path="lime.text.GlyphMetrics" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/text/GlyphMetrics.hx">
		<advance public="1"><c path="lime.math.Vector2"/></advance>
		<height public="1"><x path="Int"/></height>
		<horizontalBearing public="1"><c path="lime.math.Vector2"/></horizontalBearing>
		<verticalBearing public="1"><c path="lime.math.Vector2"/></verticalBearing>
		<new public="1" set="method" line="16"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="lime.text.GlyphPosition" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/text/GlyphPosition.hx">
		<advance public="1"><c path="lime.math.Vector2"/></advance>
		<glyph public="1"><x path="lime.text.Glyph"/></glyph>
		<offset public="1"><c path="lime.math.Vector2"/></offset>
		<new public="1" set="method" line="15">
			<f a="glyph:advance:?offset" v="::null">
				<x path="lime.text.Glyph"/>
				<c path="lime.math.Vector2"/>
				<c path="lime.math.Vector2"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ offset : null }</e></m></meta>
		</new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<abstract path="lime.text.TextDirection" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/text/TextDirection.hx">
		<this><x path="Int"/></this>
		<to><icast><x path="Int"/></icast></to>
		<meta><m n=":enum"/></meta>
		<impl><class path="lime.text._TextDirection.TextDirection_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/text/TextDirection.hx" private="1" module="lime.text.TextDirection">
	<INVALID public="1" get="inline" set="null" expr="cast 0" line="7" static="1">
		<x path="lime.text.TextDirection"/>
		<meta>
			<m n=":value"><e>cast 0</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</INVALID>
	<LEFT_TO_RIGHT public="1" get="inline" set="null" expr="cast 4" line="8" static="1">
		<x path="lime.text.TextDirection"/>
		<meta>
			<m n=":value"><e>cast 4</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</LEFT_TO_RIGHT>
	<RIGHT_TO_LEFT public="1" get="inline" set="null" expr="cast 5" line="9" static="1">
		<x path="lime.text.TextDirection"/>
		<meta>
			<m n=":value"><e>cast 5</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</RIGHT_TO_LEFT>
	<TOP_TO_BOTTOM public="1" get="inline" set="null" expr="cast 6" line="10" static="1">
		<x path="lime.text.TextDirection"/>
		<meta>
			<m n=":value"><e>cast 6</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</TOP_TO_BOTTOM>
	<BOTTOM_TO_TOP public="1" get="inline" set="null" expr="cast 7" line="11" static="1">
		<x path="lime.text.TextDirection"/>
		<meta>
			<m n=":value"><e>cast 7</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</BOTTOM_TO_TOP>
	<backward public="1" get="accessor" set="null" static="1">
		<x path="Bool"/>
		<meta><m n=":impl"/></meta>
	</backward>
	<forward public="1" get="accessor" set="null" static="1">
		<x path="Bool"/>
		<meta><m n=":impl"/></meta>
	</forward>
	<horizontal public="1" get="accessor" set="null" static="1">
		<x path="Bool"/>
		<meta><m n=":impl"/></meta>
	</horizontal>
	<vertical public="1" get="accessor" set="null" static="1">
		<x path="Bool"/>
		<meta><m n=":impl"/></meta>
	</vertical>
	<reverse public="1" get="inline" set="null" line="20" static="1">
		<f a="this">
			<x path="Int"/>
			<x path="Void"/>
		</f>
		<meta><m n=":impl"/></meta>
	</reverse>
	<toString public="1" get="inline" set="null" line="27" static="1">
		<f a="this">
			<x path="Int"/>
			<c path="String"/>
		</f>
		<meta><m n=":impl"/></meta>
	</toString>
	<get_backward get="inline" set="null" line="42" static="1">
		<f a="this">
			<x path="Int"/>
			<x path="Bool"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_backward>
	<get_forward get="inline" set="null" line="49" static="1">
		<f a="this">
			<x path="Int"/>
			<x path="Bool"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_forward>
	<get_horizontal get="inline" set="null" line="56" static="1">
		<f a="this">
			<x path="Int"/>
			<x path="Bool"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_horizontal>
	<get_vertical get="inline" set="null" line="63" static="1">
		<f a="this">
			<x path="Int"/>
			<x path="Bool"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_vertical>
	<meta>
		<m n=":final"/>
		<m n=":enum"/>
	</meta>
</class></impl>
	</abstract>
	<class path="lime.text._TextDirection.TextDirection_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/text/TextDirection.hx" private="1" module="lime.text.TextDirection">
		<INVALID public="1" get="inline" set="null" expr="cast 0" line="7" static="1">
			<x path="lime.text.TextDirection"/>
			<meta>
				<m n=":value"><e>cast 0</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</INVALID>
		<LEFT_TO_RIGHT public="1" get="inline" set="null" expr="cast 4" line="8" static="1">
			<x path="lime.text.TextDirection"/>
			<meta>
				<m n=":value"><e>cast 4</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</LEFT_TO_RIGHT>
		<RIGHT_TO_LEFT public="1" get="inline" set="null" expr="cast 5" line="9" static="1">
			<x path="lime.text.TextDirection"/>
			<meta>
				<m n=":value"><e>cast 5</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</RIGHT_TO_LEFT>
		<TOP_TO_BOTTOM public="1" get="inline" set="null" expr="cast 6" line="10" static="1">
			<x path="lime.text.TextDirection"/>
			<meta>
				<m n=":value"><e>cast 6</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</TOP_TO_BOTTOM>
		<BOTTOM_TO_TOP public="1" get="inline" set="null" expr="cast 7" line="11" static="1">
			<x path="lime.text.TextDirection"/>
			<meta>
				<m n=":value"><e>cast 7</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</BOTTOM_TO_TOP>
		<backward public="1" get="accessor" set="null" static="1">
			<x path="Bool"/>
			<meta><m n=":impl"/></meta>
		</backward>
		<forward public="1" get="accessor" set="null" static="1">
			<x path="Bool"/>
			<meta><m n=":impl"/></meta>
		</forward>
		<horizontal public="1" get="accessor" set="null" static="1">
			<x path="Bool"/>
			<meta><m n=":impl"/></meta>
		</horizontal>
		<vertical public="1" get="accessor" set="null" static="1">
			<x path="Bool"/>
			<meta><m n=":impl"/></meta>
		</vertical>
		<reverse public="1" get="inline" set="null" line="20" static="1">
			<f a="this">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":impl"/></meta>
		</reverse>
		<toString public="1" get="inline" set="null" line="27" static="1">
			<f a="this">
				<x path="Int"/>
				<c path="String"/>
			</f>
			<meta><m n=":impl"/></meta>
		</toString>
		<get_backward get="inline" set="null" line="42" static="1">
			<f a="this">
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_backward>
		<get_forward get="inline" set="null" line="49" static="1">
			<f a="this">
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_forward>
		<get_horizontal get="inline" set="null" line="56" static="1">
			<f a="this">
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_horizontal>
		<get_vertical get="inline" set="null" line="63" static="1">
			<f a="this">
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_vertical>
		<meta>
			<m n=":final"/>
			<m n=":enum"/>
		</meta>
	</class>
	<class path="lime.text.TextLayout" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/text/TextLayout.hx">
		<lime_text_layout_create get="inline" set="null" line="246" static="1">
			<f a="direction:script:language">
				<x path="Int"/>
				<c path="String"/>
				<c path="String"/>
				<d/>
			</f>
			<meta><m n=":cffi"/></meta>
		</lime_text_layout_create>
		<lime_text_layout_position get="inline" set="null" line="247" static="1">
			<f a="textHandle:fontHandle:size:textString:data">
				<d/>
				<d/>
				<x path="Int"/>
				<c path="String"/>
				<d/>
				<d/>
			</f>
			<meta><m n=":cffi"/></meta>
		</lime_text_layout_position>
		<lime_text_layout_set_direction get="inline" set="null" line="248" static="1">
			<f a="textHandle:direction">
				<d/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":cffi"/></meta>
		</lime_text_layout_set_direction>
		<lime_text_layout_set_language get="inline" set="null" line="249" static="1">
			<f a="textHandle:language">
				<d/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":cffi"/></meta>
		</lime_text_layout_set_language>
		<lime_text_layout_set_script get="inline" set="null" line="250" static="1">
			<f a="textHandle:script">
				<d/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":cffi"/></meta>
		</lime_text_layout_set_script>
		<cffi_lime_text_layout_create expr="new cpp.Callable&lt;Int -&gt; String -&gt; String&gt;(lime.system.CFFI.load(&quot;lime&quot;, &quot;lime_text_layout_create&quot;, 3, false))" line="246" static="1">
			<x path="cpp.Callable"><f a="::">
	<x path="Int"/>
	<c path="String"/>
	<c path="String"/>
	<d/>
</f></x>
			<meta><m n=":value"><e><![CDATA[new cpp.Callable<Int -> String -> String>(lime.system.CFFI.load("lime", "lime_text_layout_create", 3, false))]]></e></m></meta>
		</cffi_lime_text_layout_create>
		<cffi_lime_text_layout_position expr="new cpp.Callable&lt;Dynamic -&gt; Dynamic -&gt; Int -&gt; String -&gt; Dynamic&gt;(lime.system.CFFI.load(&quot;lime&quot;, &quot;lime_text_layout_position&quot;, 5, false))" line="247" static="1">
			<x path="cpp.Callable"><f a="::::">
	<d/>
	<d/>
	<x path="Int"/>
	<c path="String"/>
	<d/>
	<d/>
</f></x>
			<meta><m n=":value"><e><![CDATA[new cpp.Callable<Dynamic -> Dynamic -> Int -> String -> Dynamic>(lime.system.CFFI.load("lime", "lime_text_layout_position", 5, false))]]></e></m></meta>
		</cffi_lime_text_layout_position>
		<cffi_lime_text_layout_set_direction expr="new cpp.Callable&lt;Dynamic -&gt; Int&gt;(lime.system.CFFI.load(&quot;lime&quot;, &quot;lime_text_layout_set_direction&quot;, 2, false))" line="248" static="1">
			<x path="cpp.Callable"><f a=":">
	<d/>
	<x path="Int"/>
	<x path="Void"/>
</f></x>
			<meta><m n=":value"><e><![CDATA[new cpp.Callable<Dynamic -> Int>(lime.system.CFFI.load("lime", "lime_text_layout_set_direction", 2, false))]]></e></m></meta>
		</cffi_lime_text_layout_set_direction>
		<cffi_lime_text_layout_set_language expr="new cpp.Callable&lt;Dynamic -&gt; String&gt;(lime.system.CFFI.load(&quot;lime&quot;, &quot;lime_text_layout_set_language&quot;, 2, false))" line="249" static="1">
			<x path="cpp.Callable"><f a=":">
	<d/>
	<c path="String"/>
	<x path="Void"/>
</f></x>
			<meta><m n=":value"><e><![CDATA[new cpp.Callable<Dynamic -> String>(lime.system.CFFI.load("lime", "lime_text_layout_set_language", 2, false))]]></e></m></meta>
		</cffi_lime_text_layout_set_language>
		<cffi_lime_text_layout_set_script expr="new cpp.Callable&lt;Dynamic -&gt; String&gt;(lime.system.CFFI.load(&quot;lime&quot;, &quot;lime_text_layout_set_script&quot;, 2, false))" line="250" static="1">
			<x path="cpp.Callable"><f a=":">
	<d/>
	<c path="String"/>
	<x path="Void"/>
</f></x>
			<meta><m n=":value"><e><![CDATA[new cpp.Callable<Dynamic -> String>(lime.system.CFFI.load("lime", "lime_text_layout_set_script", 2, false))]]></e></m></meta>
		</cffi_lime_text_layout_set_script>
		<direction public="1" get="accessor" set="accessor"><x path="lime.text.TextDirection"/></direction>
		<font public="1" set="accessor"><c path="lime.text.Font"/></font>
		<glyphs public="1" get="accessor" set="null"><c path="Array"><x path="lime.text.Glyph"/></c></glyphs>
		<language public="1" get="accessor" set="accessor"><c path="String"/></language>
		<positions public="1" get="accessor" set="null">
			<c path="Array"><c path="lime.text.GlyphPosition"/></c>
			<meta><m n=":isVar"/></meta>
		</positions>
		<script public="1" get="accessor" set="accessor"><x path="lime.text.TextScript"/></script>
		<size public="1" set="accessor"><x path="Int"/></size>
		<text public="1" set="accessor"><c path="String"/></text>
		<__dirty><x path="Bool"/></__dirty>
		<__buffer>
			<c path="haxe.io.Bytes"/>
			<meta><m n=":noCompletion"/></meta>
		</__buffer>
		<__direction>
			<x path="lime.text.TextDirection"/>
			<meta><m n=":noCompletion"/></meta>
		</__direction>
		<__handle>
			<d/>
			<meta><m n=":noCompletion"/></meta>
		</__handle>
		<__language>
			<c path="String"/>
			<meta><m n=":noCompletion"/></meta>
		</__language>
		<__script>
			<x path="lime.text.TextScript"/>
			<meta><m n=":noCompletion"/></meta>
		</__script>
		<__position set="method" line="54">
			<f a=""><x path="Void"/></f>
			<meta><m n=":noCompletion"/></meta>
		</__position>
		<get_positions set="method" line="104">
			<f a=""><c path="Array"><c path="lime.text.GlyphPosition"/></c></f>
			<meta><m n=":noCompletion"/></meta>
		</get_positions>
		<get_direction set="method" line="118">
			<f a=""><x path="lime.text.TextDirection"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_direction>
		<set_direction set="method" line="125">
			<f a="value">
				<x path="lime.text.TextDirection"/>
				<x path="lime.text.TextDirection"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_direction>
		<set_font set="method" line="142">
			<f a="value">
				<c path="lime.text.Font"/>
				<c path="lime.text.Font"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_font>
		<get_glyphs set="method" line="153">
			<f a=""><c path="Array"><x path="lime.text.Glyph"/></c></f>
			<meta><m n=":noCompletion"/></meta>
		</get_glyphs>
		<get_language set="method" line="168">
			<f a=""><c path="String"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_language>
		<set_language set="method" line="175">
			<f a="value">
				<c path="String"/>
				<c path="String"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_language>
		<get_script set="method" line="192">
			<f a=""><x path="lime.text.TextScript"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_script>
		<set_script set="method" line="199">
			<f a="value">
				<x path="lime.text.TextScript"/>
				<x path="lime.text.TextScript"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_script>
		<set_size set="method" line="216">
			<f a="value">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_size>
		<set_text set="method" line="227">
			<f a="value">
				<c path="String"/>
				<c path="String"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_text>
		<new public="1" set="method" line="36">
			<f a="?text:?font:?size:?direction:?script:?language" v="&quot;&quot;:null:12:LEFT_TO_RIGHT:COMMON:&quot;en&quot;">
				<c path="String"/>
				<c path="lime.text.Font"/>
				<x path="Int"/>
				<x path="lime.text.TextDirection"/>
				<x path="lime.text.TextScript"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ language : "en", script : COMMON, direction : LEFT_TO_RIGHT, size : 12, font : null, text : "" }</e></m></meta>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>lime.system.CFFI.build()</e></m>
			<m n=":access"><e>lime.text.Font</e></m>
		</meta>
	</class>
	<abstract path="lime.text.TextScript" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/text/TextScript.hx">
		<this><c path="String"/></this>
		<to><icast><c path="String"/></icast></to>
		<meta><m n=":enum"/></meta>
		<impl><class path="lime.text._TextScript.TextScript_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/text/TextScript.hx" private="1" module="lime.text.TextScript">
	<COMMON public="1" get="inline" set="null" expr="cast &quot;Zyyy&quot;" line="6" static="1">
		<x path="lime.text.TextScript"/>
		<meta>
			<m n=":value"><e>cast "Zyyy"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</COMMON>
	<INHERITED public="1" get="inline" set="null" expr="cast &quot;Zinh&quot;" line="7" static="1">
		<x path="lime.text.TextScript"/>
		<meta>
			<m n=":value"><e>cast "Zinh"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</INHERITED>
	<UNKNOWN public="1" get="inline" set="null" expr="cast &quot;Zzzz&quot;" line="8" static="1">
		<x path="lime.text.TextScript"/>
		<meta>
			<m n=":value"><e>cast "Zzzz"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</UNKNOWN>
	<ARABIC public="1" get="inline" set="null" expr="cast &quot;Arab&quot;" line="10" static="1">
		<x path="lime.text.TextScript"/>
		<meta>
			<m n=":value"><e>cast "Arab"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</ARABIC>
	<ARMENIAN public="1" get="inline" set="null" expr="cast &quot;Armn&quot;" line="11" static="1">
		<x path="lime.text.TextScript"/>
		<meta>
			<m n=":value"><e>cast "Armn"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</ARMENIAN>
	<BENGALI public="1" get="inline" set="null" expr="cast &quot;Beng&quot;" line="12" static="1">
		<x path="lime.text.TextScript"/>
		<meta>
			<m n=":value"><e>cast "Beng"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</BENGALI>
	<CYRILLIC public="1" get="inline" set="null" expr="cast &quot;Cyrl&quot;" line="13" static="1">
		<x path="lime.text.TextScript"/>
		<meta>
			<m n=":value"><e>cast "Cyrl"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</CYRILLIC>
	<DEVANAGARI public="1" get="inline" set="null" expr="cast &quot;Deva&quot;" line="14" static="1">
		<x path="lime.text.TextScript"/>
		<meta>
			<m n=":value"><e>cast "Deva"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</DEVANAGARI>
	<GEORGIAN public="1" get="inline" set="null" expr="cast &quot;Geor&quot;" line="15" static="1">
		<x path="lime.text.TextScript"/>
		<meta>
			<m n=":value"><e>cast "Geor"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</GEORGIAN>
	<GREEK public="1" get="inline" set="null" expr="cast &quot;Grek&quot;" line="16" static="1">
		<x path="lime.text.TextScript"/>
		<meta>
			<m n=":value"><e>cast "Grek"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</GREEK>
	<GUJARATI public="1" get="inline" set="null" expr="cast &quot;Gujr&quot;" line="17" static="1">
		<x path="lime.text.TextScript"/>
		<meta>
			<m n=":value"><e>cast "Gujr"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</GUJARATI>
	<GURMUKHI public="1" get="inline" set="null" expr="cast &quot;Guru&quot;" line="18" static="1">
		<x path="lime.text.TextScript"/>
		<meta>
			<m n=":value"><e>cast "Guru"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</GURMUKHI>
	<HANGUL public="1" get="inline" set="null" expr="cast &quot;Hang&quot;" line="19" static="1">
		<x path="lime.text.TextScript"/>
		<meta>
			<m n=":value"><e>cast "Hang"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</HANGUL>
	<HAN public="1" get="inline" set="null" expr="cast &quot;Hani&quot;" line="20" static="1">
		<x path="lime.text.TextScript"/>
		<meta>
			<m n=":value"><e>cast "Hani"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</HAN>
	<HEBREW public="1" get="inline" set="null" expr="cast &quot;Hebr&quot;" line="21" static="1">
		<x path="lime.text.TextScript"/>
		<meta>
			<m n=":value"><e>cast "Hebr"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</HEBREW>
	<HIRAGANA public="1" get="inline" set="null" expr="cast &quot;Hira&quot;" line="22" static="1">
		<x path="lime.text.TextScript"/>
		<meta>
			<m n=":value"><e>cast "Hira"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</HIRAGANA>
	<KANNADA public="1" get="inline" set="null" expr="cast &quot;Knda&quot;" line="23" static="1">
		<x path="lime.text.TextScript"/>
		<meta>
			<m n=":value"><e>cast "Knda"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</KANNADA>
	<KATAKANA public="1" get="inline" set="null" expr="cast &quot;Kana&quot;" line="24" static="1">
		<x path="lime.text.TextScript"/>
		<meta>
			<m n=":value"><e>cast "Kana"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</KATAKANA>
	<LAO public="1" get="inline" set="null" expr="cast &quot;Laoo&quot;" line="25" static="1">
		<x path="lime.text.TextScript"/>
		<meta>
			<m n=":value"><e>cast "Laoo"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</LAO>
	<LATIN public="1" get="inline" set="null" expr="cast &quot;Latn&quot;" line="26" static="1">
		<x path="lime.text.TextScript"/>
		<meta>
			<m n=":value"><e>cast "Latn"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</LATIN>
	<MALAYALAM public="1" get="inline" set="null" expr="cast &quot;Mlym&quot;" line="27" static="1">
		<x path="lime.text.TextScript"/>
		<meta>
			<m n=":value"><e>cast "Mlym"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</MALAYALAM>
	<ORIYA public="1" get="inline" set="null" expr="cast &quot;Orya&quot;" line="28" static="1">
		<x path="lime.text.TextScript"/>
		<meta>
			<m n=":value"><e>cast "Orya"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</ORIYA>
	<TAMIL public="1" get="inline" set="null" expr="cast &quot;Taml&quot;" line="29" static="1">
		<x path="lime.text.TextScript"/>
		<meta>
			<m n=":value"><e>cast "Taml"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</TAMIL>
	<TELUGA public="1" get="inline" set="null" expr="cast &quot;Telu&quot;" line="30" static="1">
		<x path="lime.text.TextScript"/>
		<meta>
			<m n=":value"><e>cast "Telu"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</TELUGA>
	<THAI public="1" get="inline" set="null" expr="cast &quot;Thai&quot;" line="31" static="1">
		<x path="lime.text.TextScript"/>
		<meta>
			<m n=":value"><e>cast "Thai"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</THAI>
	<TIBETAN public="1" get="inline" set="null" expr="cast &quot;Tibt&quot;" line="33" static="1">
		<x path="lime.text.TextScript"/>
		<meta>
			<m n=":value"><e>cast "Tibt"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</TIBETAN>
	<BOPOMOFO public="1" get="inline" set="null" expr="cast &quot;Bopo&quot;" line="35" static="1">
		<x path="lime.text.TextScript"/>
		<meta>
			<m n=":value"><e>cast "Bopo"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</BOPOMOFO>
	<BRAILLE public="1" get="inline" set="null" expr="cast &quot;Brai&quot;" line="36" static="1">
		<x path="lime.text.TextScript"/>
		<meta>
			<m n=":value"><e>cast "Brai"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</BRAILLE>
	<CANADIAN_SYLLABICS public="1" get="inline" set="null" expr="cast &quot;Cans&quot;" line="37" static="1">
		<x path="lime.text.TextScript"/>
		<meta>
			<m n=":value"><e>cast "Cans"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</CANADIAN_SYLLABICS>
	<CHEROKEE public="1" get="inline" set="null" expr="cast &quot;Cher&quot;" line="38" static="1">
		<x path="lime.text.TextScript"/>
		<meta>
			<m n=":value"><e>cast "Cher"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</CHEROKEE>
	<ETHIOPIC public="1" get="inline" set="null" expr="cast &quot;Ethi&quot;" line="39" static="1">
		<x path="lime.text.TextScript"/>
		<meta>
			<m n=":value"><e>cast "Ethi"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</ETHIOPIC>
	<KHMER public="1" get="inline" set="null" expr="cast &quot;Khmr&quot;" line="40" static="1">
		<x path="lime.text.TextScript"/>
		<meta>
			<m n=":value"><e>cast "Khmr"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</KHMER>
	<MONGOLIAN public="1" get="inline" set="null" expr="cast &quot;Mong&quot;" line="41" static="1">
		<x path="lime.text.TextScript"/>
		<meta>
			<m n=":value"><e>cast "Mong"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</MONGOLIAN>
	<MYANMAR public="1" get="inline" set="null" expr="cast &quot;Mymr&quot;" line="42" static="1">
		<x path="lime.text.TextScript"/>
		<meta>
			<m n=":value"><e>cast "Mymr"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</MYANMAR>
	<OGHAM public="1" get="inline" set="null" expr="cast &quot;Ogam&quot;" line="43" static="1">
		<x path="lime.text.TextScript"/>
		<meta>
			<m n=":value"><e>cast "Ogam"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</OGHAM>
	<RUNIC public="1" get="inline" set="null" expr="cast &quot;Runr&quot;" line="44" static="1">
		<x path="lime.text.TextScript"/>
		<meta>
			<m n=":value"><e>cast "Runr"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</RUNIC>
	<SINHALA public="1" get="inline" set="null" expr="cast &quot;Sinh&quot;" line="45" static="1">
		<x path="lime.text.TextScript"/>
		<meta>
			<m n=":value"><e>cast "Sinh"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</SINHALA>
	<SYRIAC public="1" get="inline" set="null" expr="cast &quot;Syrc&quot;" line="46" static="1">
		<x path="lime.text.TextScript"/>
		<meta>
			<m n=":value"><e>cast "Syrc"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</SYRIAC>
	<THAANA public="1" get="inline" set="null" expr="cast &quot;Thaa&quot;" line="47" static="1">
		<x path="lime.text.TextScript"/>
		<meta>
			<m n=":value"><e>cast "Thaa"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</THAANA>
	<YI public="1" get="inline" set="null" expr="cast &quot;Yiii&quot;" line="48" static="1">
		<x path="lime.text.TextScript"/>
		<meta>
			<m n=":value"><e>cast "Yiii"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</YI>
	<DESERET public="1" get="inline" set="null" expr="cast &quot;Dsrt&quot;" line="50" static="1">
		<x path="lime.text.TextScript"/>
		<meta>
			<m n=":value"><e>cast "Dsrt"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</DESERET>
	<GOTHIC public="1" get="inline" set="null" expr="cast &quot;Goth&quot;" line="51" static="1">
		<x path="lime.text.TextScript"/>
		<meta>
			<m n=":value"><e>cast "Goth"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</GOTHIC>
	<OLD_ITALIC public="1" get="inline" set="null" expr="cast &quot;Ital&quot;" line="52" static="1">
		<x path="lime.text.TextScript"/>
		<meta>
			<m n=":value"><e>cast "Ital"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</OLD_ITALIC>
	<BUHID public="1" get="inline" set="null" expr="cast &quot;Buhd&quot;" line="54" static="1">
		<x path="lime.text.TextScript"/>
		<meta>
			<m n=":value"><e>cast "Buhd"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</BUHID>
	<HANUNOO public="1" get="inline" set="null" expr="cast &quot;Hano&quot;" line="55" static="1">
		<x path="lime.text.TextScript"/>
		<meta>
			<m n=":value"><e>cast "Hano"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</HANUNOO>
	<TAGALOG public="1" get="inline" set="null" expr="cast &quot;Tglg&quot;" line="56" static="1">
		<x path="lime.text.TextScript"/>
		<meta>
			<m n=":value"><e>cast "Tglg"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</TAGALOG>
	<TAGBANWA public="1" get="inline" set="null" expr="cast &quot;Tagb&quot;" line="57" static="1">
		<x path="lime.text.TextScript"/>
		<meta>
			<m n=":value"><e>cast "Tagb"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</TAGBANWA>
	<CYPRIOT public="1" get="inline" set="null" expr="cast &quot;Cprt&quot;" line="59" static="1">
		<x path="lime.text.TextScript"/>
		<meta>
			<m n=":value"><e>cast "Cprt"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</CYPRIOT>
	<LIMBU public="1" get="inline" set="null" expr="cast &quot;Limb&quot;" line="60" static="1">
		<x path="lime.text.TextScript"/>
		<meta>
			<m n=":value"><e>cast "Limb"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</LIMBU>
	<LINEAR_B public="1" get="inline" set="null" expr="cast &quot;Linb&quot;" line="61" static="1">
		<x path="lime.text.TextScript"/>
		<meta>
			<m n=":value"><e>cast "Linb"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</LINEAR_B>
	<OSMANYA public="1" get="inline" set="null" expr="cast &quot;Osma&quot;" line="62" static="1">
		<x path="lime.text.TextScript"/>
		<meta>
			<m n=":value"><e>cast "Osma"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</OSMANYA>
	<SHAVIAN public="1" get="inline" set="null" expr="cast &quot;Shaw&quot;" line="63" static="1">
		<x path="lime.text.TextScript"/>
		<meta>
			<m n=":value"><e>cast "Shaw"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</SHAVIAN>
	<TAI_LE public="1" get="inline" set="null" expr="cast &quot;Tale&quot;" line="64" static="1">
		<x path="lime.text.TextScript"/>
		<meta>
			<m n=":value"><e>cast "Tale"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</TAI_LE>
	<UGARITIC public="1" get="inline" set="null" expr="cast &quot;Ugar&quot;" line="65" static="1">
		<x path="lime.text.TextScript"/>
		<meta>
			<m n=":value"><e>cast "Ugar"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</UGARITIC>
	<BUGINESE public="1" get="inline" set="null" expr="cast &quot;Bugi&quot;" line="67" static="1">
		<x path="lime.text.TextScript"/>
		<meta>
			<m n=":value"><e>cast "Bugi"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</BUGINESE>
	<COPTIC public="1" get="inline" set="null" expr="cast &quot;Copt&quot;" line="68" static="1">
		<x path="lime.text.TextScript"/>
		<meta>
			<m n=":value"><e>cast "Copt"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</COPTIC>
	<GLAGOLITIC public="1" get="inline" set="null" expr="cast &quot;Glag&quot;" line="69" static="1">
		<x path="lime.text.TextScript"/>
		<meta>
			<m n=":value"><e>cast "Glag"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</GLAGOLITIC>
	<KHAROSHTHI public="1" get="inline" set="null" expr="cast &quot;Khar&quot;" line="70" static="1">
		<x path="lime.text.TextScript"/>
		<meta>
			<m n=":value"><e>cast "Khar"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</KHAROSHTHI>
	<NEW_TAI_LUE public="1" get="inline" set="null" expr="cast &quot;Talu&quot;" line="71" static="1">
		<x path="lime.text.TextScript"/>
		<meta>
			<m n=":value"><e>cast "Talu"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NEW_TAI_LUE>
	<OLD_PERSIAN public="1" get="inline" set="null" expr="cast &quot;Xpeo&quot;" line="72" static="1">
		<x path="lime.text.TextScript"/>
		<meta>
			<m n=":value"><e>cast "Xpeo"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</OLD_PERSIAN>
	<SYLOTI_NAGRI public="1" get="inline" set="null" expr="cast &quot;Sylo&quot;" line="73" static="1">
		<x path="lime.text.TextScript"/>
		<meta>
			<m n=":value"><e>cast "Sylo"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</SYLOTI_NAGRI>
	<TIFINAGH public="1" get="inline" set="null" expr="cast &quot;Tfng&quot;" line="74" static="1">
		<x path="lime.text.TextScript"/>
		<meta>
			<m n=":value"><e>cast "Tfng"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</TIFINAGH>
	<BALINESE public="1" get="inline" set="null" expr="cast &quot;Bali&quot;" line="76" static="1">
		<x path="lime.text.TextScript"/>
		<meta>
			<m n=":value"><e>cast "Bali"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</BALINESE>
	<CUNEIFORM public="1" get="inline" set="null" expr="cast &quot;Xsux&quot;" line="77" static="1">
		<x path="lime.text.TextScript"/>
		<meta>
			<m n=":value"><e>cast "Xsux"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</CUNEIFORM>
	<NKO public="1" get="inline" set="null" expr="cast &quot;Nkoo&quot;" line="78" static="1">
		<x path="lime.text.TextScript"/>
		<meta>
			<m n=":value"><e>cast "Nkoo"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NKO>
	<PHAGS_PA public="1" get="inline" set="null" expr="cast &quot;Phag&quot;" line="79" static="1">
		<x path="lime.text.TextScript"/>
		<meta>
			<m n=":value"><e>cast "Phag"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</PHAGS_PA>
	<PHOENICIAN public="1" get="inline" set="null" expr="cast &quot;Phnx&quot;" line="80" static="1">
		<x path="lime.text.TextScript"/>
		<meta>
			<m n=":value"><e>cast "Phnx"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</PHOENICIAN>
	<CARIAN public="1" get="inline" set="null" expr="cast &quot;Cari&quot;" line="82" static="1">
		<x path="lime.text.TextScript"/>
		<meta>
			<m n=":value"><e>cast "Cari"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</CARIAN>
	<CHAM public="1" get="inline" set="null" expr="cast &quot;Cham&quot;" line="83" static="1">
		<x path="lime.text.TextScript"/>
		<meta>
			<m n=":value"><e>cast "Cham"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</CHAM>
	<KAYAH_LI public="1" get="inline" set="null" expr="cast &quot;Kali&quot;" line="84" static="1">
		<x path="lime.text.TextScript"/>
		<meta>
			<m n=":value"><e>cast "Kali"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</KAYAH_LI>
	<LEPCHA public="1" get="inline" set="null" expr="cast &quot;Lepc&quot;" line="85" static="1">
		<x path="lime.text.TextScript"/>
		<meta>
			<m n=":value"><e>cast "Lepc"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</LEPCHA>
	<LYCIAN public="1" get="inline" set="null" expr="cast &quot;Lyci&quot;" line="86" static="1">
		<x path="lime.text.TextScript"/>
		<meta>
			<m n=":value"><e>cast "Lyci"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</LYCIAN>
	<LYDIAN public="1" get="inline" set="null" expr="cast &quot;Lydi&quot;" line="87" static="1">
		<x path="lime.text.TextScript"/>
		<meta>
			<m n=":value"><e>cast "Lydi"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</LYDIAN>
	<OL_CHIKI public="1" get="inline" set="null" expr="cast &quot;Olck&quot;" line="88" static="1">
		<x path="lime.text.TextScript"/>
		<meta>
			<m n=":value"><e>cast "Olck"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</OL_CHIKI>
	<REJANG public="1" get="inline" set="null" expr="cast &quot;Rjng&quot;" line="89" static="1">
		<x path="lime.text.TextScript"/>
		<meta>
			<m n=":value"><e>cast "Rjng"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</REJANG>
	<SAURASHTRA public="1" get="inline" set="null" expr="cast &quot;Saur&quot;" line="90" static="1">
		<x path="lime.text.TextScript"/>
		<meta>
			<m n=":value"><e>cast "Saur"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</SAURASHTRA>
	<SUNDANESE public="1" get="inline" set="null" expr="cast &quot;Sund&quot;" line="91" static="1">
		<x path="lime.text.TextScript"/>
		<meta>
			<m n=":value"><e>cast "Sund"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</SUNDANESE>
	<VAI public="1" get="inline" set="null" expr="cast &quot;Vaii&quot;" line="92" static="1">
		<x path="lime.text.TextScript"/>
		<meta>
			<m n=":value"><e>cast "Vaii"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</VAI>
	<AVESTAN public="1" get="inline" set="null" expr="cast &quot;Avst&quot;" line="94" static="1">
		<x path="lime.text.TextScript"/>
		<meta>
			<m n=":value"><e>cast "Avst"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</AVESTAN>
	<BAMUM public="1" get="inline" set="null" expr="cast &quot;Bamu&quot;" line="95" static="1">
		<x path="lime.text.TextScript"/>
		<meta>
			<m n=":value"><e>cast "Bamu"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</BAMUM>
	<EGYPTIAN_HIEROGLYPHS public="1" get="inline" set="null" expr="cast &quot;Egyp&quot;" line="96" static="1">
		<x path="lime.text.TextScript"/>
		<meta>
			<m n=":value"><e>cast "Egyp"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</EGYPTIAN_HIEROGLYPHS>
	<IMPERIAL_ARAMAIC public="1" get="inline" set="null" expr="cast &quot;Armi&quot;" line="97" static="1">
		<x path="lime.text.TextScript"/>
		<meta>
			<m n=":value"><e>cast "Armi"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</IMPERIAL_ARAMAIC>
	<INSCRIPTIONAL_PAHLAVI public="1" get="inline" set="null" expr="cast &quot;Phli&quot;" line="98" static="1">
		<x path="lime.text.TextScript"/>
		<meta>
			<m n=":value"><e>cast "Phli"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</INSCRIPTIONAL_PAHLAVI>
	<INSCRIPTIONAL_PARTHIAN public="1" get="inline" set="null" expr="cast &quot;Prti&quot;" line="99" static="1">
		<x path="lime.text.TextScript"/>
		<meta>
			<m n=":value"><e>cast "Prti"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</INSCRIPTIONAL_PARTHIAN>
	<JAVANESE public="1" get="inline" set="null" expr="cast &quot;Java&quot;" line="100" static="1">
		<x path="lime.text.TextScript"/>
		<meta>
			<m n=":value"><e>cast "Java"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</JAVANESE>
	<KAITHI public="1" get="inline" set="null" expr="cast &quot;Kthi&quot;" line="101" static="1">
		<x path="lime.text.TextScript"/>
		<meta>
			<m n=":value"><e>cast "Kthi"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</KAITHI>
	<LISU public="1" get="inline" set="null" expr="cast &quot;Lisu&quot;" line="102" static="1">
		<x path="lime.text.TextScript"/>
		<meta>
			<m n=":value"><e>cast "Lisu"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</LISU>
	<MEETEI_MAYEK public="1" get="inline" set="null" expr="cast &quot;Mtei&quot;" line="103" static="1">
		<x path="lime.text.TextScript"/>
		<meta>
			<m n=":value"><e>cast "Mtei"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</MEETEI_MAYEK>
	<OLD_SOUTH_ARABIAN public="1" get="inline" set="null" expr="cast &quot;Sarb&quot;" line="104" static="1">
		<x path="lime.text.TextScript"/>
		<meta>
			<m n=":value"><e>cast "Sarb"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</OLD_SOUTH_ARABIAN>
	<OLD_TURKIC public="1" get="inline" set="null" expr="cast &quot;Orkh&quot;" line="105" static="1">
		<x path="lime.text.TextScript"/>
		<meta>
			<m n=":value"><e>cast "Orkh"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</OLD_TURKIC>
	<SAMARITAN public="1" get="inline" set="null" expr="cast &quot;Samr&quot;" line="106" static="1">
		<x path="lime.text.TextScript"/>
		<meta>
			<m n=":value"><e>cast "Samr"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</SAMARITAN>
	<TAI_THAM public="1" get="inline" set="null" expr="cast &quot;Lana&quot;" line="107" static="1">
		<x path="lime.text.TextScript"/>
		<meta>
			<m n=":value"><e>cast "Lana"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</TAI_THAM>
	<TAI_VIET public="1" get="inline" set="null" expr="cast &quot;Tavt&quot;" line="108" static="1">
		<x path="lime.text.TextScript"/>
		<meta>
			<m n=":value"><e>cast "Tavt"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</TAI_VIET>
	<BATAK public="1" get="inline" set="null" expr="cast &quot;Batk&quot;" line="110" static="1">
		<x path="lime.text.TextScript"/>
		<meta>
			<m n=":value"><e>cast "Batk"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</BATAK>
	<BRAHMI public="1" get="inline" set="null" expr="cast &quot;Brah&quot;" line="111" static="1">
		<x path="lime.text.TextScript"/>
		<meta>
			<m n=":value"><e>cast "Brah"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</BRAHMI>
	<MANDAIC public="1" get="inline" set="null" expr="cast &quot;Mand&quot;" line="112" static="1">
		<x path="lime.text.TextScript"/>
		<meta>
			<m n=":value"><e>cast "Mand"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</MANDAIC>
	<CHAKMA public="1" get="inline" set="null" expr="cast &quot;Cakm&quot;" line="114" static="1">
		<x path="lime.text.TextScript"/>
		<meta>
			<m n=":value"><e>cast "Cakm"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</CHAKMA>
	<MEROITIC_CURSIVE public="1" get="inline" set="null" expr="cast &quot;Merc&quot;" line="115" static="1">
		<x path="lime.text.TextScript"/>
		<meta>
			<m n=":value"><e>cast "Merc"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</MEROITIC_CURSIVE>
	<MEROITIC_HIEROGLYPHS public="1" get="inline" set="null" expr="cast &quot;Mero&quot;" line="116" static="1">
		<x path="lime.text.TextScript"/>
		<meta>
			<m n=":value"><e>cast "Mero"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</MEROITIC_HIEROGLYPHS>
	<MIAO public="1" get="inline" set="null" expr="cast &quot;Plrd&quot;" line="117" static="1">
		<x path="lime.text.TextScript"/>
		<meta>
			<m n=":value"><e>cast "Plrd"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</MIAO>
	<SHARADA public="1" get="inline" set="null" expr="cast &quot;Shrd&quot;" line="118" static="1">
		<x path="lime.text.TextScript"/>
		<meta>
			<m n=":value"><e>cast "Shrd"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</SHARADA>
	<SORA_SOMPENG public="1" get="inline" set="null" expr="cast &quot;Sora&quot;" line="119" static="1">
		<x path="lime.text.TextScript"/>
		<meta>
			<m n=":value"><e>cast "Sora"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</SORA_SOMPENG>
	<TAKRI public="1" get="inline" set="null" expr="cast &quot;Takr&quot;" line="120" static="1">
		<x path="lime.text.TextScript"/>
		<meta>
			<m n=":value"><e>cast "Takr"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</TAKRI>
	<BASSA_VAH public="1" get="inline" set="null" expr="cast &quot;Bass&quot;" line="122" static="1">
		<x path="lime.text.TextScript"/>
		<meta>
			<m n=":value"><e>cast "Bass"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</BASSA_VAH>
	<CAUCASIAN_ALBANIAN public="1" get="inline" set="null" expr="cast &quot;Aghb&quot;" line="123" static="1">
		<x path="lime.text.TextScript"/>
		<meta>
			<m n=":value"><e>cast "Aghb"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</CAUCASIAN_ALBANIAN>
	<DUPLOYAN public="1" get="inline" set="null" expr="cast &quot;Dupl&quot;" line="124" static="1">
		<x path="lime.text.TextScript"/>
		<meta>
			<m n=":value"><e>cast "Dupl"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</DUPLOYAN>
	<ELBASAN public="1" get="inline" set="null" expr="cast &quot;Elba&quot;" line="125" static="1">
		<x path="lime.text.TextScript"/>
		<meta>
			<m n=":value"><e>cast "Elba"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</ELBASAN>
	<GRANTHA public="1" get="inline" set="null" expr="cast &quot;Gran&quot;" line="126" static="1">
		<x path="lime.text.TextScript"/>
		<meta>
			<m n=":value"><e>cast "Gran"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</GRANTHA>
	<KHOJKI public="1" get="inline" set="null" expr="cast &quot;Khoj&quot;" line="127" static="1">
		<x path="lime.text.TextScript"/>
		<meta>
			<m n=":value"><e>cast "Khoj"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</KHOJKI>
	<KHUDAWADI public="1" get="inline" set="null" expr="cast &quot;Sind&quot;" line="128" static="1">
		<x path="lime.text.TextScript"/>
		<meta>
			<m n=":value"><e>cast "Sind"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</KHUDAWADI>
	<LINEAR_A public="1" get="inline" set="null" expr="cast &quot;Lina&quot;" line="129" static="1">
		<x path="lime.text.TextScript"/>
		<meta>
			<m n=":value"><e>cast "Lina"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</LINEAR_A>
	<MAHAJANI public="1" get="inline" set="null" expr="cast &quot;Mahj&quot;" line="130" static="1">
		<x path="lime.text.TextScript"/>
		<meta>
			<m n=":value"><e>cast "Mahj"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</MAHAJANI>
	<MANICHAEAN public="1" get="inline" set="null" expr="cast &quot;Mani&quot;" line="131" static="1">
		<x path="lime.text.TextScript"/>
		<meta>
			<m n=":value"><e>cast "Mani"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</MANICHAEAN>
	<MENDE_KIKAKUI public="1" get="inline" set="null" expr="cast &quot;Mend&quot;" line="132" static="1">
		<x path="lime.text.TextScript"/>
		<meta>
			<m n=":value"><e>cast "Mend"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</MENDE_KIKAKUI>
	<MODI public="1" get="inline" set="null" expr="cast &quot;Modi&quot;" line="133" static="1">
		<x path="lime.text.TextScript"/>
		<meta>
			<m n=":value"><e>cast "Modi"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</MODI>
	<MRO public="1" get="inline" set="null" expr="cast &quot;Mroo&quot;" line="134" static="1">
		<x path="lime.text.TextScript"/>
		<meta>
			<m n=":value"><e>cast "Mroo"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</MRO>
	<NABATAEAN public="1" get="inline" set="null" expr="cast &quot;Nbat&quot;" line="135" static="1">
		<x path="lime.text.TextScript"/>
		<meta>
			<m n=":value"><e>cast "Nbat"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NABATAEAN>
	<OLD_NORTH_ARABIAN public="1" get="inline" set="null" expr="cast &quot;Narb&quot;" line="136" static="1">
		<x path="lime.text.TextScript"/>
		<meta>
			<m n=":value"><e>cast "Narb"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</OLD_NORTH_ARABIAN>
	<OLD_PERMIC public="1" get="inline" set="null" expr="cast &quot;Perm&quot;" line="137" static="1">
		<x path="lime.text.TextScript"/>
		<meta>
			<m n=":value"><e>cast "Perm"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</OLD_PERMIC>
	<PAHAWH_HMONG public="1" get="inline" set="null" expr="cast &quot;Hmng&quot;" line="138" static="1">
		<x path="lime.text.TextScript"/>
		<meta>
			<m n=":value"><e>cast "Hmng"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</PAHAWH_HMONG>
	<PALMYRENE public="1" get="inline" set="null" expr="cast &quot;Palm&quot;" line="139" static="1">
		<x path="lime.text.TextScript"/>
		<meta>
			<m n=":value"><e>cast "Palm"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</PALMYRENE>
	<PAU_CIN_HAU public="1" get="inline" set="null" expr="cast &quot;Pauc&quot;" line="140" static="1">
		<x path="lime.text.TextScript"/>
		<meta>
			<m n=":value"><e>cast "Pauc"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</PAU_CIN_HAU>
	<PSALTER_PAHLAVI public="1" get="inline" set="null" expr="cast &quot;Phlp&quot;" line="141" static="1">
		<x path="lime.text.TextScript"/>
		<meta>
			<m n=":value"><e>cast "Phlp"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</PSALTER_PAHLAVI>
	<SIDDHAM public="1" get="inline" set="null" expr="cast &quot;Sidd&quot;" line="142" static="1">
		<x path="lime.text.TextScript"/>
		<meta>
			<m n=":value"><e>cast "Sidd"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</SIDDHAM>
	<TIRHUTA public="1" get="inline" set="null" expr="cast &quot;Tirh&quot;" line="143" static="1">
		<x path="lime.text.TextScript"/>
		<meta>
			<m n=":value"><e>cast "Tirh"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</TIRHUTA>
	<WARANG_CITI public="1" get="inline" set="null" expr="cast &quot;Wara&quot;" line="144" static="1">
		<x path="lime.text.TextScript"/>
		<meta>
			<m n=":value"><e>cast "Wara"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</WARANG_CITI>
	<rightToLeft public="1" get="accessor" set="null" static="1">
		<x path="Bool"/>
		<meta><m n=":impl"/></meta>
	</rightToLeft>
	<get_rightToLeft get="inline" set="null" line="150" static="1">
		<f a="this">
			<c path="String"/>
			<x path="Bool"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_rightToLeft>
	<meta>
		<m n=":final"/>
		<m n=":enum"/>
	</meta>
</class></impl>
	</abstract>
	<class path="lime.text._TextScript.TextScript_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/text/TextScript.hx" private="1" module="lime.text.TextScript">
		<COMMON public="1" get="inline" set="null" expr="cast &quot;Zyyy&quot;" line="6" static="1">
			<x path="lime.text.TextScript"/>
			<meta>
				<m n=":value"><e>cast "Zyyy"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</COMMON>
		<INHERITED public="1" get="inline" set="null" expr="cast &quot;Zinh&quot;" line="7" static="1">
			<x path="lime.text.TextScript"/>
			<meta>
				<m n=":value"><e>cast "Zinh"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</INHERITED>
		<UNKNOWN public="1" get="inline" set="null" expr="cast &quot;Zzzz&quot;" line="8" static="1">
			<x path="lime.text.TextScript"/>
			<meta>
				<m n=":value"><e>cast "Zzzz"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</UNKNOWN>
		<ARABIC public="1" get="inline" set="null" expr="cast &quot;Arab&quot;" line="10" static="1">
			<x path="lime.text.TextScript"/>
			<meta>
				<m n=":value"><e>cast "Arab"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</ARABIC>
		<ARMENIAN public="1" get="inline" set="null" expr="cast &quot;Armn&quot;" line="11" static="1">
			<x path="lime.text.TextScript"/>
			<meta>
				<m n=":value"><e>cast "Armn"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</ARMENIAN>
		<BENGALI public="1" get="inline" set="null" expr="cast &quot;Beng&quot;" line="12" static="1">
			<x path="lime.text.TextScript"/>
			<meta>
				<m n=":value"><e>cast "Beng"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</BENGALI>
		<CYRILLIC public="1" get="inline" set="null" expr="cast &quot;Cyrl&quot;" line="13" static="1">
			<x path="lime.text.TextScript"/>
			<meta>
				<m n=":value"><e>cast "Cyrl"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</CYRILLIC>
		<DEVANAGARI public="1" get="inline" set="null" expr="cast &quot;Deva&quot;" line="14" static="1">
			<x path="lime.text.TextScript"/>
			<meta>
				<m n=":value"><e>cast "Deva"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</DEVANAGARI>
		<GEORGIAN public="1" get="inline" set="null" expr="cast &quot;Geor&quot;" line="15" static="1">
			<x path="lime.text.TextScript"/>
			<meta>
				<m n=":value"><e>cast "Geor"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</GEORGIAN>
		<GREEK public="1" get="inline" set="null" expr="cast &quot;Grek&quot;" line="16" static="1">
			<x path="lime.text.TextScript"/>
			<meta>
				<m n=":value"><e>cast "Grek"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</GREEK>
		<GUJARATI public="1" get="inline" set="null" expr="cast &quot;Gujr&quot;" line="17" static="1">
			<x path="lime.text.TextScript"/>
			<meta>
				<m n=":value"><e>cast "Gujr"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</GUJARATI>
		<GURMUKHI public="1" get="inline" set="null" expr="cast &quot;Guru&quot;" line="18" static="1">
			<x path="lime.text.TextScript"/>
			<meta>
				<m n=":value"><e>cast "Guru"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</GURMUKHI>
		<HANGUL public="1" get="inline" set="null" expr="cast &quot;Hang&quot;" line="19" static="1">
			<x path="lime.text.TextScript"/>
			<meta>
				<m n=":value"><e>cast "Hang"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</HANGUL>
		<HAN public="1" get="inline" set="null" expr="cast &quot;Hani&quot;" line="20" static="1">
			<x path="lime.text.TextScript"/>
			<meta>
				<m n=":value"><e>cast "Hani"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</HAN>
		<HEBREW public="1" get="inline" set="null" expr="cast &quot;Hebr&quot;" line="21" static="1">
			<x path="lime.text.TextScript"/>
			<meta>
				<m n=":value"><e>cast "Hebr"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</HEBREW>
		<HIRAGANA public="1" get="inline" set="null" expr="cast &quot;Hira&quot;" line="22" static="1">
			<x path="lime.text.TextScript"/>
			<meta>
				<m n=":value"><e>cast "Hira"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</HIRAGANA>
		<KANNADA public="1" get="inline" set="null" expr="cast &quot;Knda&quot;" line="23" static="1">
			<x path="lime.text.TextScript"/>
			<meta>
				<m n=":value"><e>cast "Knda"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</KANNADA>
		<KATAKANA public="1" get="inline" set="null" expr="cast &quot;Kana&quot;" line="24" static="1">
			<x path="lime.text.TextScript"/>
			<meta>
				<m n=":value"><e>cast "Kana"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</KATAKANA>
		<LAO public="1" get="inline" set="null" expr="cast &quot;Laoo&quot;" line="25" static="1">
			<x path="lime.text.TextScript"/>
			<meta>
				<m n=":value"><e>cast "Laoo"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</LAO>
		<LATIN public="1" get="inline" set="null" expr="cast &quot;Latn&quot;" line="26" static="1">
			<x path="lime.text.TextScript"/>
			<meta>
				<m n=":value"><e>cast "Latn"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</LATIN>
		<MALAYALAM public="1" get="inline" set="null" expr="cast &quot;Mlym&quot;" line="27" static="1">
			<x path="lime.text.TextScript"/>
			<meta>
				<m n=":value"><e>cast "Mlym"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</MALAYALAM>
		<ORIYA public="1" get="inline" set="null" expr="cast &quot;Orya&quot;" line="28" static="1">
			<x path="lime.text.TextScript"/>
			<meta>
				<m n=":value"><e>cast "Orya"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</ORIYA>
		<TAMIL public="1" get="inline" set="null" expr="cast &quot;Taml&quot;" line="29" static="1">
			<x path="lime.text.TextScript"/>
			<meta>
				<m n=":value"><e>cast "Taml"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</TAMIL>
		<TELUGA public="1" get="inline" set="null" expr="cast &quot;Telu&quot;" line="30" static="1">
			<x path="lime.text.TextScript"/>
			<meta>
				<m n=":value"><e>cast "Telu"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</TELUGA>
		<THAI public="1" get="inline" set="null" expr="cast &quot;Thai&quot;" line="31" static="1">
			<x path="lime.text.TextScript"/>
			<meta>
				<m n=":value"><e>cast "Thai"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</THAI>
		<TIBETAN public="1" get="inline" set="null" expr="cast &quot;Tibt&quot;" line="33" static="1">
			<x path="lime.text.TextScript"/>
			<meta>
				<m n=":value"><e>cast "Tibt"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</TIBETAN>
		<BOPOMOFO public="1" get="inline" set="null" expr="cast &quot;Bopo&quot;" line="35" static="1">
			<x path="lime.text.TextScript"/>
			<meta>
				<m n=":value"><e>cast "Bopo"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</BOPOMOFO>
		<BRAILLE public="1" get="inline" set="null" expr="cast &quot;Brai&quot;" line="36" static="1">
			<x path="lime.text.TextScript"/>
			<meta>
				<m n=":value"><e>cast "Brai"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</BRAILLE>
		<CANADIAN_SYLLABICS public="1" get="inline" set="null" expr="cast &quot;Cans&quot;" line="37" static="1">
			<x path="lime.text.TextScript"/>
			<meta>
				<m n=":value"><e>cast "Cans"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</CANADIAN_SYLLABICS>
		<CHEROKEE public="1" get="inline" set="null" expr="cast &quot;Cher&quot;" line="38" static="1">
			<x path="lime.text.TextScript"/>
			<meta>
				<m n=":value"><e>cast "Cher"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</CHEROKEE>
		<ETHIOPIC public="1" get="inline" set="null" expr="cast &quot;Ethi&quot;" line="39" static="1">
			<x path="lime.text.TextScript"/>
			<meta>
				<m n=":value"><e>cast "Ethi"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</ETHIOPIC>
		<KHMER public="1" get="inline" set="null" expr="cast &quot;Khmr&quot;" line="40" static="1">
			<x path="lime.text.TextScript"/>
			<meta>
				<m n=":value"><e>cast "Khmr"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</KHMER>
		<MONGOLIAN public="1" get="inline" set="null" expr="cast &quot;Mong&quot;" line="41" static="1">
			<x path="lime.text.TextScript"/>
			<meta>
				<m n=":value"><e>cast "Mong"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</MONGOLIAN>
		<MYANMAR public="1" get="inline" set="null" expr="cast &quot;Mymr&quot;" line="42" static="1">
			<x path="lime.text.TextScript"/>
			<meta>
				<m n=":value"><e>cast "Mymr"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</MYANMAR>
		<OGHAM public="1" get="inline" set="null" expr="cast &quot;Ogam&quot;" line="43" static="1">
			<x path="lime.text.TextScript"/>
			<meta>
				<m n=":value"><e>cast "Ogam"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</OGHAM>
		<RUNIC public="1" get="inline" set="null" expr="cast &quot;Runr&quot;" line="44" static="1">
			<x path="lime.text.TextScript"/>
			<meta>
				<m n=":value"><e>cast "Runr"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</RUNIC>
		<SINHALA public="1" get="inline" set="null" expr="cast &quot;Sinh&quot;" line="45" static="1">
			<x path="lime.text.TextScript"/>
			<meta>
				<m n=":value"><e>cast "Sinh"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</SINHALA>
		<SYRIAC public="1" get="inline" set="null" expr="cast &quot;Syrc&quot;" line="46" static="1">
			<x path="lime.text.TextScript"/>
			<meta>
				<m n=":value"><e>cast "Syrc"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</SYRIAC>
		<THAANA public="1" get="inline" set="null" expr="cast &quot;Thaa&quot;" line="47" static="1">
			<x path="lime.text.TextScript"/>
			<meta>
				<m n=":value"><e>cast "Thaa"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</THAANA>
		<YI public="1" get="inline" set="null" expr="cast &quot;Yiii&quot;" line="48" static="1">
			<x path="lime.text.TextScript"/>
			<meta>
				<m n=":value"><e>cast "Yiii"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</YI>
		<DESERET public="1" get="inline" set="null" expr="cast &quot;Dsrt&quot;" line="50" static="1">
			<x path="lime.text.TextScript"/>
			<meta>
				<m n=":value"><e>cast "Dsrt"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</DESERET>
		<GOTHIC public="1" get="inline" set="null" expr="cast &quot;Goth&quot;" line="51" static="1">
			<x path="lime.text.TextScript"/>
			<meta>
				<m n=":value"><e>cast "Goth"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</GOTHIC>
		<OLD_ITALIC public="1" get="inline" set="null" expr="cast &quot;Ital&quot;" line="52" static="1">
			<x path="lime.text.TextScript"/>
			<meta>
				<m n=":value"><e>cast "Ital"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</OLD_ITALIC>
		<BUHID public="1" get="inline" set="null" expr="cast &quot;Buhd&quot;" line="54" static="1">
			<x path="lime.text.TextScript"/>
			<meta>
				<m n=":value"><e>cast "Buhd"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</BUHID>
		<HANUNOO public="1" get="inline" set="null" expr="cast &quot;Hano&quot;" line="55" static="1">
			<x path="lime.text.TextScript"/>
			<meta>
				<m n=":value"><e>cast "Hano"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</HANUNOO>
		<TAGALOG public="1" get="inline" set="null" expr="cast &quot;Tglg&quot;" line="56" static="1">
			<x path="lime.text.TextScript"/>
			<meta>
				<m n=":value"><e>cast "Tglg"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</TAGALOG>
		<TAGBANWA public="1" get="inline" set="null" expr="cast &quot;Tagb&quot;" line="57" static="1">
			<x path="lime.text.TextScript"/>
			<meta>
				<m n=":value"><e>cast "Tagb"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</TAGBANWA>
		<CYPRIOT public="1" get="inline" set="null" expr="cast &quot;Cprt&quot;" line="59" static="1">
			<x path="lime.text.TextScript"/>
			<meta>
				<m n=":value"><e>cast "Cprt"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</CYPRIOT>
		<LIMBU public="1" get="inline" set="null" expr="cast &quot;Limb&quot;" line="60" static="1">
			<x path="lime.text.TextScript"/>
			<meta>
				<m n=":value"><e>cast "Limb"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</LIMBU>
		<LINEAR_B public="1" get="inline" set="null" expr="cast &quot;Linb&quot;" line="61" static="1">
			<x path="lime.text.TextScript"/>
			<meta>
				<m n=":value"><e>cast "Linb"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</LINEAR_B>
		<OSMANYA public="1" get="inline" set="null" expr="cast &quot;Osma&quot;" line="62" static="1">
			<x path="lime.text.TextScript"/>
			<meta>
				<m n=":value"><e>cast "Osma"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</OSMANYA>
		<SHAVIAN public="1" get="inline" set="null" expr="cast &quot;Shaw&quot;" line="63" static="1">
			<x path="lime.text.TextScript"/>
			<meta>
				<m n=":value"><e>cast "Shaw"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</SHAVIAN>
		<TAI_LE public="1" get="inline" set="null" expr="cast &quot;Tale&quot;" line="64" static="1">
			<x path="lime.text.TextScript"/>
			<meta>
				<m n=":value"><e>cast "Tale"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</TAI_LE>
		<UGARITIC public="1" get="inline" set="null" expr="cast &quot;Ugar&quot;" line="65" static="1">
			<x path="lime.text.TextScript"/>
			<meta>
				<m n=":value"><e>cast "Ugar"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</UGARITIC>
		<BUGINESE public="1" get="inline" set="null" expr="cast &quot;Bugi&quot;" line="67" static="1">
			<x path="lime.text.TextScript"/>
			<meta>
				<m n=":value"><e>cast "Bugi"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</BUGINESE>
		<COPTIC public="1" get="inline" set="null" expr="cast &quot;Copt&quot;" line="68" static="1">
			<x path="lime.text.TextScript"/>
			<meta>
				<m n=":value"><e>cast "Copt"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</COPTIC>
		<GLAGOLITIC public="1" get="inline" set="null" expr="cast &quot;Glag&quot;" line="69" static="1">
			<x path="lime.text.TextScript"/>
			<meta>
				<m n=":value"><e>cast "Glag"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</GLAGOLITIC>
		<KHAROSHTHI public="1" get="inline" set="null" expr="cast &quot;Khar&quot;" line="70" static="1">
			<x path="lime.text.TextScript"/>
			<meta>
				<m n=":value"><e>cast "Khar"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</KHAROSHTHI>
		<NEW_TAI_LUE public="1" get="inline" set="null" expr="cast &quot;Talu&quot;" line="71" static="1">
			<x path="lime.text.TextScript"/>
			<meta>
				<m n=":value"><e>cast "Talu"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NEW_TAI_LUE>
		<OLD_PERSIAN public="1" get="inline" set="null" expr="cast &quot;Xpeo&quot;" line="72" static="1">
			<x path="lime.text.TextScript"/>
			<meta>
				<m n=":value"><e>cast "Xpeo"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</OLD_PERSIAN>
		<SYLOTI_NAGRI public="1" get="inline" set="null" expr="cast &quot;Sylo&quot;" line="73" static="1">
			<x path="lime.text.TextScript"/>
			<meta>
				<m n=":value"><e>cast "Sylo"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</SYLOTI_NAGRI>
		<TIFINAGH public="1" get="inline" set="null" expr="cast &quot;Tfng&quot;" line="74" static="1">
			<x path="lime.text.TextScript"/>
			<meta>
				<m n=":value"><e>cast "Tfng"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</TIFINAGH>
		<BALINESE public="1" get="inline" set="null" expr="cast &quot;Bali&quot;" line="76" static="1">
			<x path="lime.text.TextScript"/>
			<meta>
				<m n=":value"><e>cast "Bali"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</BALINESE>
		<CUNEIFORM public="1" get="inline" set="null" expr="cast &quot;Xsux&quot;" line="77" static="1">
			<x path="lime.text.TextScript"/>
			<meta>
				<m n=":value"><e>cast "Xsux"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</CUNEIFORM>
		<NKO public="1" get="inline" set="null" expr="cast &quot;Nkoo&quot;" line="78" static="1">
			<x path="lime.text.TextScript"/>
			<meta>
				<m n=":value"><e>cast "Nkoo"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NKO>
		<PHAGS_PA public="1" get="inline" set="null" expr="cast &quot;Phag&quot;" line="79" static="1">
			<x path="lime.text.TextScript"/>
			<meta>
				<m n=":value"><e>cast "Phag"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</PHAGS_PA>
		<PHOENICIAN public="1" get="inline" set="null" expr="cast &quot;Phnx&quot;" line="80" static="1">
			<x path="lime.text.TextScript"/>
			<meta>
				<m n=":value"><e>cast "Phnx"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</PHOENICIAN>
		<CARIAN public="1" get="inline" set="null" expr="cast &quot;Cari&quot;" line="82" static="1">
			<x path="lime.text.TextScript"/>
			<meta>
				<m n=":value"><e>cast "Cari"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</CARIAN>
		<CHAM public="1" get="inline" set="null" expr="cast &quot;Cham&quot;" line="83" static="1">
			<x path="lime.text.TextScript"/>
			<meta>
				<m n=":value"><e>cast "Cham"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</CHAM>
		<KAYAH_LI public="1" get="inline" set="null" expr="cast &quot;Kali&quot;" line="84" static="1">
			<x path="lime.text.TextScript"/>
			<meta>
				<m n=":value"><e>cast "Kali"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</KAYAH_LI>
		<LEPCHA public="1" get="inline" set="null" expr="cast &quot;Lepc&quot;" line="85" static="1">
			<x path="lime.text.TextScript"/>
			<meta>
				<m n=":value"><e>cast "Lepc"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</LEPCHA>
		<LYCIAN public="1" get="inline" set="null" expr="cast &quot;Lyci&quot;" line="86" static="1">
			<x path="lime.text.TextScript"/>
			<meta>
				<m n=":value"><e>cast "Lyci"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</LYCIAN>
		<LYDIAN public="1" get="inline" set="null" expr="cast &quot;Lydi&quot;" line="87" static="1">
			<x path="lime.text.TextScript"/>
			<meta>
				<m n=":value"><e>cast "Lydi"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</LYDIAN>
		<OL_CHIKI public="1" get="inline" set="null" expr="cast &quot;Olck&quot;" line="88" static="1">
			<x path="lime.text.TextScript"/>
			<meta>
				<m n=":value"><e>cast "Olck"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</OL_CHIKI>
		<REJANG public="1" get="inline" set="null" expr="cast &quot;Rjng&quot;" line="89" static="1">
			<x path="lime.text.TextScript"/>
			<meta>
				<m n=":value"><e>cast "Rjng"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</REJANG>
		<SAURASHTRA public="1" get="inline" set="null" expr="cast &quot;Saur&quot;" line="90" static="1">
			<x path="lime.text.TextScript"/>
			<meta>
				<m n=":value"><e>cast "Saur"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</SAURASHTRA>
		<SUNDANESE public="1" get="inline" set="null" expr="cast &quot;Sund&quot;" line="91" static="1">
			<x path="lime.text.TextScript"/>
			<meta>
				<m n=":value"><e>cast "Sund"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</SUNDANESE>
		<VAI public="1" get="inline" set="null" expr="cast &quot;Vaii&quot;" line="92" static="1">
			<x path="lime.text.TextScript"/>
			<meta>
				<m n=":value"><e>cast "Vaii"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</VAI>
		<AVESTAN public="1" get="inline" set="null" expr="cast &quot;Avst&quot;" line="94" static="1">
			<x path="lime.text.TextScript"/>
			<meta>
				<m n=":value"><e>cast "Avst"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</AVESTAN>
		<BAMUM public="1" get="inline" set="null" expr="cast &quot;Bamu&quot;" line="95" static="1">
			<x path="lime.text.TextScript"/>
			<meta>
				<m n=":value"><e>cast "Bamu"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</BAMUM>
		<EGYPTIAN_HIEROGLYPHS public="1" get="inline" set="null" expr="cast &quot;Egyp&quot;" line="96" static="1">
			<x path="lime.text.TextScript"/>
			<meta>
				<m n=":value"><e>cast "Egyp"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</EGYPTIAN_HIEROGLYPHS>
		<IMPERIAL_ARAMAIC public="1" get="inline" set="null" expr="cast &quot;Armi&quot;" line="97" static="1">
			<x path="lime.text.TextScript"/>
			<meta>
				<m n=":value"><e>cast "Armi"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</IMPERIAL_ARAMAIC>
		<INSCRIPTIONAL_PAHLAVI public="1" get="inline" set="null" expr="cast &quot;Phli&quot;" line="98" static="1">
			<x path="lime.text.TextScript"/>
			<meta>
				<m n=":value"><e>cast "Phli"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</INSCRIPTIONAL_PAHLAVI>
		<INSCRIPTIONAL_PARTHIAN public="1" get="inline" set="null" expr="cast &quot;Prti&quot;" line="99" static="1">
			<x path="lime.text.TextScript"/>
			<meta>
				<m n=":value"><e>cast "Prti"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</INSCRIPTIONAL_PARTHIAN>
		<JAVANESE public="1" get="inline" set="null" expr="cast &quot;Java&quot;" line="100" static="1">
			<x path="lime.text.TextScript"/>
			<meta>
				<m n=":value"><e>cast "Java"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</JAVANESE>
		<KAITHI public="1" get="inline" set="null" expr="cast &quot;Kthi&quot;" line="101" static="1">
			<x path="lime.text.TextScript"/>
			<meta>
				<m n=":value"><e>cast "Kthi"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</KAITHI>
		<LISU public="1" get="inline" set="null" expr="cast &quot;Lisu&quot;" line="102" static="1">
			<x path="lime.text.TextScript"/>
			<meta>
				<m n=":value"><e>cast "Lisu"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</LISU>
		<MEETEI_MAYEK public="1" get="inline" set="null" expr="cast &quot;Mtei&quot;" line="103" static="1">
			<x path="lime.text.TextScript"/>
			<meta>
				<m n=":value"><e>cast "Mtei"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</MEETEI_MAYEK>
		<OLD_SOUTH_ARABIAN public="1" get="inline" set="null" expr="cast &quot;Sarb&quot;" line="104" static="1">
			<x path="lime.text.TextScript"/>
			<meta>
				<m n=":value"><e>cast "Sarb"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</OLD_SOUTH_ARABIAN>
		<OLD_TURKIC public="1" get="inline" set="null" expr="cast &quot;Orkh&quot;" line="105" static="1">
			<x path="lime.text.TextScript"/>
			<meta>
				<m n=":value"><e>cast "Orkh"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</OLD_TURKIC>
		<SAMARITAN public="1" get="inline" set="null" expr="cast &quot;Samr&quot;" line="106" static="1">
			<x path="lime.text.TextScript"/>
			<meta>
				<m n=":value"><e>cast "Samr"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</SAMARITAN>
		<TAI_THAM public="1" get="inline" set="null" expr="cast &quot;Lana&quot;" line="107" static="1">
			<x path="lime.text.TextScript"/>
			<meta>
				<m n=":value"><e>cast "Lana"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</TAI_THAM>
		<TAI_VIET public="1" get="inline" set="null" expr="cast &quot;Tavt&quot;" line="108" static="1">
			<x path="lime.text.TextScript"/>
			<meta>
				<m n=":value"><e>cast "Tavt"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</TAI_VIET>
		<BATAK public="1" get="inline" set="null" expr="cast &quot;Batk&quot;" line="110" static="1">
			<x path="lime.text.TextScript"/>
			<meta>
				<m n=":value"><e>cast "Batk"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</BATAK>
		<BRAHMI public="1" get="inline" set="null" expr="cast &quot;Brah&quot;" line="111" static="1">
			<x path="lime.text.TextScript"/>
			<meta>
				<m n=":value"><e>cast "Brah"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</BRAHMI>
		<MANDAIC public="1" get="inline" set="null" expr="cast &quot;Mand&quot;" line="112" static="1">
			<x path="lime.text.TextScript"/>
			<meta>
				<m n=":value"><e>cast "Mand"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</MANDAIC>
		<CHAKMA public="1" get="inline" set="null" expr="cast &quot;Cakm&quot;" line="114" static="1">
			<x path="lime.text.TextScript"/>
			<meta>
				<m n=":value"><e>cast "Cakm"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</CHAKMA>
		<MEROITIC_CURSIVE public="1" get="inline" set="null" expr="cast &quot;Merc&quot;" line="115" static="1">
			<x path="lime.text.TextScript"/>
			<meta>
				<m n=":value"><e>cast "Merc"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</MEROITIC_CURSIVE>
		<MEROITIC_HIEROGLYPHS public="1" get="inline" set="null" expr="cast &quot;Mero&quot;" line="116" static="1">
			<x path="lime.text.TextScript"/>
			<meta>
				<m n=":value"><e>cast "Mero"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</MEROITIC_HIEROGLYPHS>
		<MIAO public="1" get="inline" set="null" expr="cast &quot;Plrd&quot;" line="117" static="1">
			<x path="lime.text.TextScript"/>
			<meta>
				<m n=":value"><e>cast "Plrd"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</MIAO>
		<SHARADA public="1" get="inline" set="null" expr="cast &quot;Shrd&quot;" line="118" static="1">
			<x path="lime.text.TextScript"/>
			<meta>
				<m n=":value"><e>cast "Shrd"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</SHARADA>
		<SORA_SOMPENG public="1" get="inline" set="null" expr="cast &quot;Sora&quot;" line="119" static="1">
			<x path="lime.text.TextScript"/>
			<meta>
				<m n=":value"><e>cast "Sora"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</SORA_SOMPENG>
		<TAKRI public="1" get="inline" set="null" expr="cast &quot;Takr&quot;" line="120" static="1">
			<x path="lime.text.TextScript"/>
			<meta>
				<m n=":value"><e>cast "Takr"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</TAKRI>
		<BASSA_VAH public="1" get="inline" set="null" expr="cast &quot;Bass&quot;" line="122" static="1">
			<x path="lime.text.TextScript"/>
			<meta>
				<m n=":value"><e>cast "Bass"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</BASSA_VAH>
		<CAUCASIAN_ALBANIAN public="1" get="inline" set="null" expr="cast &quot;Aghb&quot;" line="123" static="1">
			<x path="lime.text.TextScript"/>
			<meta>
				<m n=":value"><e>cast "Aghb"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</CAUCASIAN_ALBANIAN>
		<DUPLOYAN public="1" get="inline" set="null" expr="cast &quot;Dupl&quot;" line="124" static="1">
			<x path="lime.text.TextScript"/>
			<meta>
				<m n=":value"><e>cast "Dupl"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</DUPLOYAN>
		<ELBASAN public="1" get="inline" set="null" expr="cast &quot;Elba&quot;" line="125" static="1">
			<x path="lime.text.TextScript"/>
			<meta>
				<m n=":value"><e>cast "Elba"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</ELBASAN>
		<GRANTHA public="1" get="inline" set="null" expr="cast &quot;Gran&quot;" line="126" static="1">
			<x path="lime.text.TextScript"/>
			<meta>
				<m n=":value"><e>cast "Gran"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</GRANTHA>
		<KHOJKI public="1" get="inline" set="null" expr="cast &quot;Khoj&quot;" line="127" static="1">
			<x path="lime.text.TextScript"/>
			<meta>
				<m n=":value"><e>cast "Khoj"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</KHOJKI>
		<KHUDAWADI public="1" get="inline" set="null" expr="cast &quot;Sind&quot;" line="128" static="1">
			<x path="lime.text.TextScript"/>
			<meta>
				<m n=":value"><e>cast "Sind"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</KHUDAWADI>
		<LINEAR_A public="1" get="inline" set="null" expr="cast &quot;Lina&quot;" line="129" static="1">
			<x path="lime.text.TextScript"/>
			<meta>
				<m n=":value"><e>cast "Lina"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</LINEAR_A>
		<MAHAJANI public="1" get="inline" set="null" expr="cast &quot;Mahj&quot;" line="130" static="1">
			<x path="lime.text.TextScript"/>
			<meta>
				<m n=":value"><e>cast "Mahj"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</MAHAJANI>
		<MANICHAEAN public="1" get="inline" set="null" expr="cast &quot;Mani&quot;" line="131" static="1">
			<x path="lime.text.TextScript"/>
			<meta>
				<m n=":value"><e>cast "Mani"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</MANICHAEAN>
		<MENDE_KIKAKUI public="1" get="inline" set="null" expr="cast &quot;Mend&quot;" line="132" static="1">
			<x path="lime.text.TextScript"/>
			<meta>
				<m n=":value"><e>cast "Mend"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</MENDE_KIKAKUI>
		<MODI public="1" get="inline" set="null" expr="cast &quot;Modi&quot;" line="133" static="1">
			<x path="lime.text.TextScript"/>
			<meta>
				<m n=":value"><e>cast "Modi"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</MODI>
		<MRO public="1" get="inline" set="null" expr="cast &quot;Mroo&quot;" line="134" static="1">
			<x path="lime.text.TextScript"/>
			<meta>
				<m n=":value"><e>cast "Mroo"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</MRO>
		<NABATAEAN public="1" get="inline" set="null" expr="cast &quot;Nbat&quot;" line="135" static="1">
			<x path="lime.text.TextScript"/>
			<meta>
				<m n=":value"><e>cast "Nbat"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NABATAEAN>
		<OLD_NORTH_ARABIAN public="1" get="inline" set="null" expr="cast &quot;Narb&quot;" line="136" static="1">
			<x path="lime.text.TextScript"/>
			<meta>
				<m n=":value"><e>cast "Narb"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</OLD_NORTH_ARABIAN>
		<OLD_PERMIC public="1" get="inline" set="null" expr="cast &quot;Perm&quot;" line="137" static="1">
			<x path="lime.text.TextScript"/>
			<meta>
				<m n=":value"><e>cast "Perm"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</OLD_PERMIC>
		<PAHAWH_HMONG public="1" get="inline" set="null" expr="cast &quot;Hmng&quot;" line="138" static="1">
			<x path="lime.text.TextScript"/>
			<meta>
				<m n=":value"><e>cast "Hmng"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</PAHAWH_HMONG>
		<PALMYRENE public="1" get="inline" set="null" expr="cast &quot;Palm&quot;" line="139" static="1">
			<x path="lime.text.TextScript"/>
			<meta>
				<m n=":value"><e>cast "Palm"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</PALMYRENE>
		<PAU_CIN_HAU public="1" get="inline" set="null" expr="cast &quot;Pauc&quot;" line="140" static="1">
			<x path="lime.text.TextScript"/>
			<meta>
				<m n=":value"><e>cast "Pauc"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</PAU_CIN_HAU>
		<PSALTER_PAHLAVI public="1" get="inline" set="null" expr="cast &quot;Phlp&quot;" line="141" static="1">
			<x path="lime.text.TextScript"/>
			<meta>
				<m n=":value"><e>cast "Phlp"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</PSALTER_PAHLAVI>
		<SIDDHAM public="1" get="inline" set="null" expr="cast &quot;Sidd&quot;" line="142" static="1">
			<x path="lime.text.TextScript"/>
			<meta>
				<m n=":value"><e>cast "Sidd"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</SIDDHAM>
		<TIRHUTA public="1" get="inline" set="null" expr="cast &quot;Tirh&quot;" line="143" static="1">
			<x path="lime.text.TextScript"/>
			<meta>
				<m n=":value"><e>cast "Tirh"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</TIRHUTA>
		<WARANG_CITI public="1" get="inline" set="null" expr="cast &quot;Wara&quot;" line="144" static="1">
			<x path="lime.text.TextScript"/>
			<meta>
				<m n=":value"><e>cast "Wara"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</WARANG_CITI>
		<rightToLeft public="1" get="accessor" set="null" static="1">
			<x path="Bool"/>
			<meta><m n=":impl"/></meta>
		</rightToLeft>
		<get_rightToLeft get="inline" set="null" line="150" static="1">
			<f a="this">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_rightToLeft>
		<meta>
			<m n=":final"/>
			<m n=":enum"/>
		</meta>
	</class>
	<class path="lime.ui.Gamepad" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/ui/Gamepad.hx">
		<devices public="1" expr="new Map&lt;Int,Gamepad&gt;()" line="16" static="1">
			<x path="Map">
				<x path="Int"/>
				<c path="lime.ui.Gamepad"/>
			</x>
			<meta><m n=":value"><e><![CDATA[new Map<Int,Gamepad>()]]></e></m></meta>
		</devices>
		<onConnect public="1" expr="new Event&lt;Gamepad&gt;()" line="17" static="1">
			<c path="lime.app.Event_lime_ui_Gamepad_Void"><f a="">
	<c path="lime.ui.Gamepad"/>
	<x path="Void"/>
</f></c>
			<meta><m n=":value"><e><![CDATA[new Event<Gamepad>()]]></e></m></meta>
		</onConnect>
		<addMappings public="1" set="method" line="37" static="1"><f a="mappings">
	<c path="Array"><c path="String"/></c>
	<x path="Void"/>
</f></addMappings>
		<__connect set="method" line="46" static="1">
			<f a="id">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</__connect>
		<__disconnect set="method" line="59" static="1">
			<f a="id">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</__disconnect>
		<lime_gamepad_add_mappings get="inline" set="null" line="112" static="1">
			<f a="mappings">
				<d/>
				<x path="Void"/>
			</f>
			<meta><m n=":cffi"/></meta>
		</lime_gamepad_add_mappings>
		<lime_gamepad_get_device_guid get="inline" set="null" line="113" static="1">
			<f a="id">
				<x path="Int"/>
				<d/>
			</f>
			<meta><m n=":cffi"/></meta>
		</lime_gamepad_get_device_guid>
		<lime_gamepad_get_device_name get="inline" set="null" line="114" static="1">
			<f a="id">
				<x path="Int"/>
				<d/>
			</f>
			<meta><m n=":cffi"/></meta>
		</lime_gamepad_get_device_name>
		<cffi_lime_gamepad_add_mappings expr="new cpp.Callable&lt;Dynamic&gt;(lime.system.CFFI.load(&quot;lime&quot;, &quot;lime_gamepad_add_mappings&quot;, 1, false))" line="112" static="1">
			<x path="cpp.Callable"><f a="">
	<d/>
	<x path="Void"/>
</f></x>
			<meta><m n=":value"><e><![CDATA[new cpp.Callable<Dynamic>(lime.system.CFFI.load("lime", "lime_gamepad_add_mappings", 1, false))]]></e></m></meta>
		</cffi_lime_gamepad_add_mappings>
		<cffi_lime_gamepad_get_device_guid expr="new cpp.Callable&lt;Int&gt;(lime.system.CFFI.load(&quot;lime&quot;, &quot;lime_gamepad_get_device_guid&quot;, 1, false))" line="113" static="1">
			<x path="cpp.Callable"><f a="">
	<x path="Int"/>
	<d/>
</f></x>
			<meta><m n=":value"><e><![CDATA[new cpp.Callable<Int>(lime.system.CFFI.load("lime", "lime_gamepad_get_device_guid", 1, false))]]></e></m></meta>
		</cffi_lime_gamepad_get_device_guid>
		<cffi_lime_gamepad_get_device_name expr="new cpp.Callable&lt;Int&gt;(lime.system.CFFI.load(&quot;lime&quot;, &quot;lime_gamepad_get_device_name&quot;, 1, false))" line="114" static="1">
			<x path="cpp.Callable"><f a="">
	<x path="Int"/>
	<d/>
</f></x>
			<meta><m n=":value"><e><![CDATA[new cpp.Callable<Int>(lime.system.CFFI.load("lime", "lime_gamepad_get_device_name", 1, false))]]></e></m></meta>
		</cffi_lime_gamepad_get_device_name>
		<connected public="1" set="null"><x path="Bool"/></connected>
		<guid public="1" get="accessor" set="null"><c path="String"/></guid>
		<id public="1" set="null"><x path="Int"/></id>
		<name public="1" get="accessor" set="null"><c path="String"/></name>
		<onAxisMove public="1" expr="new Event&lt;GamepadAxis -&gt; Float&gt;()">
			<c path="lime.app.Event_lime_ui_GamepadAxis_Float_Void"><f a=":">
	<x path="lime.ui.GamepadAxis"/>
	<x path="Float"/>
	<x path="Void"/>
</f></c>
			<meta><m n=":value"><e><![CDATA[new Event<GamepadAxis -> Float>()]]></e></m></meta>
		</onAxisMove>
		<onButtonDown public="1" expr="new Event&lt;GamepadButton&gt;()">
			<c path="lime.app.Event_lime_ui_GamepadButton_Void"><f a="">
	<x path="lime.ui.GamepadButton"/>
	<x path="Void"/>
</f></c>
			<meta><m n=":value"><e><![CDATA[new Event<GamepadButton>()]]></e></m></meta>
		</onButtonDown>
		<onButtonUp public="1" expr="new Event&lt;GamepadButton&gt;()">
			<c path="lime.app.Event_lime_ui_GamepadButton_Void"><f a="">
	<x path="lime.ui.GamepadButton"/>
	<x path="Void"/>
</f></c>
			<meta><m n=":value"><e><![CDATA[new Event<GamepadButton>()]]></e></m></meta>
		</onButtonUp>
		<onDisconnect public="1" expr="new Event&lt;Void&gt;()">
			<c path="lime.app.Event_Void_Void"><f a=""><x path="Void"/></f></c>
			<meta><m n=":value"><e><![CDATA[new Event<Void>()]]></e></m></meta>
		</onDisconnect>
		<get_guid get="inline" set="null" line="76">
			<f a=""><c path="String"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_guid>
		<get_name get="inline" set="null" line="90">
			<f a=""><c path="String"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_name>
		<new public="1" set="method" line="29"><f a="id">
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>lime.system.CFFI.build()</e></m>
			<m n=":access"><e>lime.ui.Joystick</e></m>
		</meta>
	</class>
	<abstract path="lime.ui.GamepadAxis" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/ui/GamepadAxis.hx">
		<from>
			<icast><x path="UInt"/></icast>
			<icast><x path="Int"/></icast>
		</from>
		<this><x path="Int"/></this>
		<to>
			<icast><x path="UInt"/></icast>
			<icast><x path="Int"/></icast>
		</to>
		<meta><m n=":enum"/></meta>
		<impl><class path="lime.ui._GamepadAxis.GamepadAxis_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/ui/GamepadAxis.hx" private="1" module="lime.ui.GamepadAxis">
	<LEFT_X public="1" get="inline" set="null" expr="cast 0" line="7" static="1">
		<x path="lime.ui.GamepadAxis"/>
		<meta>
			<m n=":value"><e>cast 0</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</LEFT_X>
	<LEFT_Y public="1" get="inline" set="null" expr="cast 1" line="8" static="1">
		<x path="lime.ui.GamepadAxis"/>
		<meta>
			<m n=":value"><e>cast 1</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</LEFT_Y>
	<RIGHT_X public="1" get="inline" set="null" expr="cast 2" line="9" static="1">
		<x path="lime.ui.GamepadAxis"/>
		<meta>
			<m n=":value"><e>cast 2</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</RIGHT_X>
	<RIGHT_Y public="1" get="inline" set="null" expr="cast 3" line="10" static="1">
		<x path="lime.ui.GamepadAxis"/>
		<meta>
			<m n=":value"><e>cast 3</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</RIGHT_Y>
	<TRIGGER_LEFT public="1" get="inline" set="null" expr="cast 4" line="11" static="1">
		<x path="lime.ui.GamepadAxis"/>
		<meta>
			<m n=":value"><e>cast 4</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</TRIGGER_LEFT>
	<TRIGGER_RIGHT public="1" get="inline" set="null" expr="cast 5" line="12" static="1">
		<x path="lime.ui.GamepadAxis"/>
		<meta>
			<m n=":value"><e>cast 5</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</TRIGGER_RIGHT>
	<toString public="1" get="inline" set="null" line="15" static="1">
		<f a="this">
			<x path="Int"/>
			<c path="String"/>
		</f>
		<meta><m n=":impl"/></meta>
	</toString>
	<meta>
		<m n=":final"/>
		<m n=":enum"/>
	</meta>
</class></impl>
	</abstract>
	<class path="lime.ui._GamepadAxis.GamepadAxis_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/ui/GamepadAxis.hx" private="1" module="lime.ui.GamepadAxis">
		<LEFT_X public="1" get="inline" set="null" expr="cast 0" line="7" static="1">
			<x path="lime.ui.GamepadAxis"/>
			<meta>
				<m n=":value"><e>cast 0</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</LEFT_X>
		<LEFT_Y public="1" get="inline" set="null" expr="cast 1" line="8" static="1">
			<x path="lime.ui.GamepadAxis"/>
			<meta>
				<m n=":value"><e>cast 1</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</LEFT_Y>
		<RIGHT_X public="1" get="inline" set="null" expr="cast 2" line="9" static="1">
			<x path="lime.ui.GamepadAxis"/>
			<meta>
				<m n=":value"><e>cast 2</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</RIGHT_X>
		<RIGHT_Y public="1" get="inline" set="null" expr="cast 3" line="10" static="1">
			<x path="lime.ui.GamepadAxis"/>
			<meta>
				<m n=":value"><e>cast 3</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</RIGHT_Y>
		<TRIGGER_LEFT public="1" get="inline" set="null" expr="cast 4" line="11" static="1">
			<x path="lime.ui.GamepadAxis"/>
			<meta>
				<m n=":value"><e>cast 4</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</TRIGGER_LEFT>
		<TRIGGER_RIGHT public="1" get="inline" set="null" expr="cast 5" line="12" static="1">
			<x path="lime.ui.GamepadAxis"/>
			<meta>
				<m n=":value"><e>cast 5</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</TRIGGER_RIGHT>
		<toString public="1" get="inline" set="null" line="15" static="1">
			<f a="this">
				<x path="Int"/>
				<c path="String"/>
			</f>
			<meta><m n=":impl"/></meta>
		</toString>
		<meta>
			<m n=":final"/>
			<m n=":enum"/>
		</meta>
	</class>
	<abstract path="lime.ui.GamepadButton" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/ui/GamepadButton.hx">
		<from>
			<icast><x path="UInt"/></icast>
			<icast><x path="Int"/></icast>
		</from>
		<this><x path="Int"/></this>
		<to>
			<icast><x path="UInt"/></icast>
			<icast><x path="Int"/></icast>
		</to>
		<meta><m n=":enum"/></meta>
		<impl><class path="lime.ui._GamepadButton.GamepadButton_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/ui/GamepadButton.hx" private="1" module="lime.ui.GamepadButton">
	<A public="1" get="inline" set="null" expr="cast 0" line="7" static="1">
		<x path="lime.ui.GamepadButton"/>
		<meta>
			<m n=":value"><e>cast 0</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</A>
	<B public="1" get="inline" set="null" expr="cast 1" line="8" static="1">
		<x path="lime.ui.GamepadButton"/>
		<meta>
			<m n=":value"><e>cast 1</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</B>
	<X public="1" get="inline" set="null" expr="cast 2" line="9" static="1">
		<x path="lime.ui.GamepadButton"/>
		<meta>
			<m n=":value"><e>cast 2</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</X>
	<Y public="1" get="inline" set="null" expr="cast 3" line="10" static="1">
		<x path="lime.ui.GamepadButton"/>
		<meta>
			<m n=":value"><e>cast 3</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Y>
	<BACK public="1" get="inline" set="null" expr="cast 4" line="11" static="1">
		<x path="lime.ui.GamepadButton"/>
		<meta>
			<m n=":value"><e>cast 4</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</BACK>
	<GUIDE public="1" get="inline" set="null" expr="cast 5" line="12" static="1">
		<x path="lime.ui.GamepadButton"/>
		<meta>
			<m n=":value"><e>cast 5</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</GUIDE>
	<START public="1" get="inline" set="null" expr="cast 6" line="13" static="1">
		<x path="lime.ui.GamepadButton"/>
		<meta>
			<m n=":value"><e>cast 6</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</START>
	<LEFT_STICK public="1" get="inline" set="null" expr="cast 7" line="14" static="1">
		<x path="lime.ui.GamepadButton"/>
		<meta>
			<m n=":value"><e>cast 7</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</LEFT_STICK>
	<RIGHT_STICK public="1" get="inline" set="null" expr="cast 8" line="15" static="1">
		<x path="lime.ui.GamepadButton"/>
		<meta>
			<m n=":value"><e>cast 8</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</RIGHT_STICK>
	<LEFT_SHOULDER public="1" get="inline" set="null" expr="cast 9" line="16" static="1">
		<x path="lime.ui.GamepadButton"/>
		<meta>
			<m n=":value"><e>cast 9</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</LEFT_SHOULDER>
	<RIGHT_SHOULDER public="1" get="inline" set="null" expr="cast 10" line="17" static="1">
		<x path="lime.ui.GamepadButton"/>
		<meta>
			<m n=":value"><e>cast 10</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</RIGHT_SHOULDER>
	<DPAD_UP public="1" get="inline" set="null" expr="cast 11" line="18" static="1">
		<x path="lime.ui.GamepadButton"/>
		<meta>
			<m n=":value"><e>cast 11</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</DPAD_UP>
	<DPAD_DOWN public="1" get="inline" set="null" expr="cast 12" line="19" static="1">
		<x path="lime.ui.GamepadButton"/>
		<meta>
			<m n=":value"><e>cast 12</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</DPAD_DOWN>
	<DPAD_LEFT public="1" get="inline" set="null" expr="cast 13" line="20" static="1">
		<x path="lime.ui.GamepadButton"/>
		<meta>
			<m n=":value"><e>cast 13</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</DPAD_LEFT>
	<DPAD_RIGHT public="1" get="inline" set="null" expr="cast 14" line="21" static="1">
		<x path="lime.ui.GamepadButton"/>
		<meta>
			<m n=":value"><e>cast 14</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</DPAD_RIGHT>
	<toString public="1" get="inline" set="null" line="24" static="1">
		<f a="this">
			<x path="Int"/>
			<c path="String"/>
		</f>
		<meta><m n=":impl"/></meta>
	</toString>
	<meta>
		<m n=":final"/>
		<m n=":enum"/>
	</meta>
</class></impl>
	</abstract>
	<class path="lime.ui._GamepadButton.GamepadButton_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/ui/GamepadButton.hx" private="1" module="lime.ui.GamepadButton">
		<A public="1" get="inline" set="null" expr="cast 0" line="7" static="1">
			<x path="lime.ui.GamepadButton"/>
			<meta>
				<m n=":value"><e>cast 0</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</A>
		<B public="1" get="inline" set="null" expr="cast 1" line="8" static="1">
			<x path="lime.ui.GamepadButton"/>
			<meta>
				<m n=":value"><e>cast 1</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</B>
		<X public="1" get="inline" set="null" expr="cast 2" line="9" static="1">
			<x path="lime.ui.GamepadButton"/>
			<meta>
				<m n=":value"><e>cast 2</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</X>
		<Y public="1" get="inline" set="null" expr="cast 3" line="10" static="1">
			<x path="lime.ui.GamepadButton"/>
			<meta>
				<m n=":value"><e>cast 3</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Y>
		<BACK public="1" get="inline" set="null" expr="cast 4" line="11" static="1">
			<x path="lime.ui.GamepadButton"/>
			<meta>
				<m n=":value"><e>cast 4</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</BACK>
		<GUIDE public="1" get="inline" set="null" expr="cast 5" line="12" static="1">
			<x path="lime.ui.GamepadButton"/>
			<meta>
				<m n=":value"><e>cast 5</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</GUIDE>
		<START public="1" get="inline" set="null" expr="cast 6" line="13" static="1">
			<x path="lime.ui.GamepadButton"/>
			<meta>
				<m n=":value"><e>cast 6</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</START>
		<LEFT_STICK public="1" get="inline" set="null" expr="cast 7" line="14" static="1">
			<x path="lime.ui.GamepadButton"/>
			<meta>
				<m n=":value"><e>cast 7</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</LEFT_STICK>
		<RIGHT_STICK public="1" get="inline" set="null" expr="cast 8" line="15" static="1">
			<x path="lime.ui.GamepadButton"/>
			<meta>
				<m n=":value"><e>cast 8</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</RIGHT_STICK>
		<LEFT_SHOULDER public="1" get="inline" set="null" expr="cast 9" line="16" static="1">
			<x path="lime.ui.GamepadButton"/>
			<meta>
				<m n=":value"><e>cast 9</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</LEFT_SHOULDER>
		<RIGHT_SHOULDER public="1" get="inline" set="null" expr="cast 10" line="17" static="1">
			<x path="lime.ui.GamepadButton"/>
			<meta>
				<m n=":value"><e>cast 10</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</RIGHT_SHOULDER>
		<DPAD_UP public="1" get="inline" set="null" expr="cast 11" line="18" static="1">
			<x path="lime.ui.GamepadButton"/>
			<meta>
				<m n=":value"><e>cast 11</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</DPAD_UP>
		<DPAD_DOWN public="1" get="inline" set="null" expr="cast 12" line="19" static="1">
			<x path="lime.ui.GamepadButton"/>
			<meta>
				<m n=":value"><e>cast 12</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</DPAD_DOWN>
		<DPAD_LEFT public="1" get="inline" set="null" expr="cast 13" line="20" static="1">
			<x path="lime.ui.GamepadButton"/>
			<meta>
				<m n=":value"><e>cast 13</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</DPAD_LEFT>
		<DPAD_RIGHT public="1" get="inline" set="null" expr="cast 14" line="21" static="1">
			<x path="lime.ui.GamepadButton"/>
			<meta>
				<m n=":value"><e>cast 14</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</DPAD_RIGHT>
		<toString public="1" get="inline" set="null" line="24" static="1">
			<f a="this">
				<x path="Int"/>
				<c path="String"/>
			</f>
			<meta><m n=":impl"/></meta>
		</toString>
		<meta>
			<m n=":final"/>
			<m n=":enum"/>
		</meta>
	</class>
	<class path="lime.ui.Joystick" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/ui/Joystick.hx">
		<devices public="1" expr="new Map&lt;Int,Joystick&gt;()" line="14" static="1">
			<x path="Map">
				<x path="Int"/>
				<c path="lime.ui.Joystick"/>
			</x>
			<meta><m n=":value"><e><![CDATA[new Map<Int,Joystick>()]]></e></m></meta>
		</devices>
		<onConnect public="1" expr="new Event&lt;Joystick&gt;()" line="15" static="1">
			<c path="lime.app.Event_lime_ui_Joystick_Void"><f a="">
	<c path="lime.ui.Joystick"/>
	<x path="Void"/>
</f></c>
			<meta><m n=":value"><e><![CDATA[new Event<Joystick>()]]></e></m></meta>
		</onConnect>
		<__connect set="method" line="41" static="1">
			<f a="id">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</__connect>
		<__disconnect set="method" line="54" static="1">
			<f a="id">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</__disconnect>
		<lime_joystick_get_device_guid get="inline" set="null" line="166" static="1">
			<f a="id">
				<x path="Int"/>
				<d/>
			</f>
			<meta><m n=":cffi"/></meta>
		</lime_joystick_get_device_guid>
		<lime_joystick_get_device_name get="inline" set="null" line="167" static="1">
			<f a="id">
				<x path="Int"/>
				<d/>
			</f>
			<meta><m n=":cffi"/></meta>
		</lime_joystick_get_device_name>
		<lime_joystick_get_num_axes get="inline" set="null" line="168" static="1">
			<f a="id">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":cffi"/></meta>
		</lime_joystick_get_num_axes>
		<lime_joystick_get_num_buttons get="inline" set="null" line="169" static="1">
			<f a="id">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":cffi"/></meta>
		</lime_joystick_get_num_buttons>
		<lime_joystick_get_num_hats get="inline" set="null" line="170" static="1">
			<f a="id">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":cffi"/></meta>
		</lime_joystick_get_num_hats>
		<lime_joystick_get_num_trackballs get="inline" set="null" line="171" static="1">
			<f a="id">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":cffi"/></meta>
		</lime_joystick_get_num_trackballs>
		<cffi_lime_joystick_get_device_guid expr="new cpp.Callable&lt;Int&gt;(lime.system.CFFI.load(&quot;lime&quot;, &quot;lime_joystick_get_device_guid&quot;, 1, false))" line="166" static="1">
			<x path="cpp.Callable"><f a="">
	<x path="Int"/>
	<d/>
</f></x>
			<meta><m n=":value"><e><![CDATA[new cpp.Callable<Int>(lime.system.CFFI.load("lime", "lime_joystick_get_device_guid", 1, false))]]></e></m></meta>
		</cffi_lime_joystick_get_device_guid>
		<cffi_lime_joystick_get_device_name expr="new cpp.Callable&lt;Int&gt;(lime.system.CFFI.load(&quot;lime&quot;, &quot;lime_joystick_get_device_name&quot;, 1, false))" line="167" static="1">
			<x path="cpp.Callable"><f a="">
	<x path="Int"/>
	<d/>
</f></x>
			<meta><m n=":value"><e><![CDATA[new cpp.Callable<Int>(lime.system.CFFI.load("lime", "lime_joystick_get_device_name", 1, false))]]></e></m></meta>
		</cffi_lime_joystick_get_device_name>
		<cffi_lime_joystick_get_num_axes expr="new cpp.Callable&lt;Int&gt;(lime.system.CFFI.load(&quot;lime&quot;, &quot;lime_joystick_get_num_axes&quot;, 1, false))" line="168" static="1">
			<x path="cpp.Callable"><f a="">
	<x path="Int"/>
	<x path="Int"/>
</f></x>
			<meta><m n=":value"><e><![CDATA[new cpp.Callable<Int>(lime.system.CFFI.load("lime", "lime_joystick_get_num_axes", 1, false))]]></e></m></meta>
		</cffi_lime_joystick_get_num_axes>
		<cffi_lime_joystick_get_num_buttons expr="new cpp.Callable&lt;Int&gt;(lime.system.CFFI.load(&quot;lime&quot;, &quot;lime_joystick_get_num_buttons&quot;, 1, false))" line="169" static="1">
			<x path="cpp.Callable"><f a="">
	<x path="Int"/>
	<x path="Int"/>
</f></x>
			<meta><m n=":value"><e><![CDATA[new cpp.Callable<Int>(lime.system.CFFI.load("lime", "lime_joystick_get_num_buttons", 1, false))]]></e></m></meta>
		</cffi_lime_joystick_get_num_buttons>
		<cffi_lime_joystick_get_num_hats expr="new cpp.Callable&lt;Int&gt;(lime.system.CFFI.load(&quot;lime&quot;, &quot;lime_joystick_get_num_hats&quot;, 1, false))" line="170" static="1">
			<x path="cpp.Callable"><f a="">
	<x path="Int"/>
	<x path="Int"/>
</f></x>
			<meta><m n=":value"><e><![CDATA[new cpp.Callable<Int>(lime.system.CFFI.load("lime", "lime_joystick_get_num_hats", 1, false))]]></e></m></meta>
		</cffi_lime_joystick_get_num_hats>
		<cffi_lime_joystick_get_num_trackballs expr="new cpp.Callable&lt;Int&gt;(lime.system.CFFI.load(&quot;lime&quot;, &quot;lime_joystick_get_num_trackballs&quot;, 1, false))" line="171" static="1">
			<x path="cpp.Callable"><f a="">
	<x path="Int"/>
	<x path="Int"/>
</f></x>
			<meta><m n=":value"><e><![CDATA[new cpp.Callable<Int>(lime.system.CFFI.load("lime", "lime_joystick_get_num_trackballs", 1, false))]]></e></m></meta>
		</cffi_lime_joystick_get_num_trackballs>
		<connected public="1" set="null"><x path="Bool"/></connected>
		<guid public="1" get="accessor" set="null"><c path="String"/></guid>
		<id public="1" set="null"><x path="Int"/></id>
		<name public="1" get="accessor" set="null"><c path="String"/></name>
		<numAxes public="1" get="accessor" set="null"><x path="Int"/></numAxes>
		<numButtons public="1" get="accessor" set="null"><x path="Int"/></numButtons>
		<numHats public="1" get="accessor" set="null"><x path="Int"/></numHats>
		<numTrackballs public="1" get="accessor" set="null"><x path="Int"/></numTrackballs>
		<onAxisMove public="1" expr="new Event&lt;Int -&gt; Float&gt;()">
			<c path="lime.app.Event_Int_Float_Void"><f a=":">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Void"/>
</f></c>
			<meta><m n=":value"><e><![CDATA[new Event<Int -> Float>()]]></e></m></meta>
		</onAxisMove>
		<onButtonDown public="1" expr="new Event&lt;Int&gt;()">
			<c path="lime.app.Event_Int_Void"><f a="">
	<x path="Int"/>
	<x path="Void"/>
</f></c>
			<meta><m n=":value"><e><![CDATA[new Event<Int>()]]></e></m></meta>
		</onButtonDown>
		<onButtonUp public="1" expr="new Event&lt;Int&gt;()">
			<c path="lime.app.Event_Int_Void"><f a="">
	<x path="Int"/>
	<x path="Void"/>
</f></c>
			<meta><m n=":value"><e><![CDATA[new Event<Int>()]]></e></m></meta>
		</onButtonUp>
		<onDisconnect public="1" expr="new Event&lt;Void&gt;()">
			<c path="lime.app.Event_Void_Void"><f a=""><x path="Void"/></f></c>
			<meta><m n=":value"><e><![CDATA[new Event<Void>()]]></e></m></meta>
		</onDisconnect>
		<onHatMove public="1" expr="new Event&lt;Int -&gt; JoystickHatPosition&gt;()">
			<c path="lime.app.Event_Int_lime_ui_JoystickHatPosition_Void"><f a=":">
	<x path="Int"/>
	<x path="lime.ui.JoystickHatPosition"/>
	<x path="Void"/>
</f></c>
			<meta><m n=":value"><e><![CDATA[new Event<Int -> JoystickHatPosition>()]]></e></m></meta>
		</onHatMove>
		<onTrackballMove public="1" expr="new Event&lt;Int -&gt; Float&gt;()">
			<c path="lime.app.Event_Int_Float_Void"><f a=":">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Void"/>
</f></c>
			<meta><m n=":value"><e><![CDATA[new Event<Int -> Float>()]]></e></m></meta>
		</onTrackballMove>
		<get_guid get="inline" set="null" line="80">
			<f a=""><c path="String"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_guid>
		<get_name get="inline" set="null" line="94">
			<f a=""><c path="String"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_name>
		<get_numAxes get="inline" set="null" line="108">
			<f a=""><x path="Int"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_numAxes>
		<get_numButtons get="inline" set="null" line="122">
			<f a=""><x path="Int"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_numButtons>
		<get_numHats get="inline" set="null" line="136">
			<f a=""><x path="Int"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_numHats>
		<get_numTrackballs get="inline" set="null" line="147">
			<f a=""><x path="Int"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_numTrackballs>
		<new public="1" set="method" line="33"><f a="id">
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>lime.system.CFFI.build()</e></m>
		</meta>
	</class>
	<abstract path="lime.ui.JoystickHatPosition" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/ui/JoystickHatPosition.hx">
		<from>
			<icast><x path="UInt"/></icast>
			<icast><x path="Int"/></icast>
		</from>
		<this><x path="Int"/></this>
		<to>
			<icast><x path="UInt"/></icast>
			<icast><x path="Int"/></icast>
		</to>
		<impl><class path="lime.ui._JoystickHatPosition.JoystickHatPosition_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/ui/JoystickHatPosition.hx" private="1" module="lime.ui.JoystickHatPosition">
	<CENTER public="1" get="inline" set="null" expr="0x00" line="7" static="1">
		<x path="lime.ui.JoystickHatPosition"/>
		<meta><m n=":value"><e>0x00</e></m></meta>
	</CENTER>
	<DOWN public="1" get="inline" set="null" expr="0x04" line="8" static="1">
		<x path="lime.ui.JoystickHatPosition"/>
		<meta><m n=":value"><e>0x04</e></m></meta>
	</DOWN>
	<LEFT public="1" get="inline" set="null" expr="0x08" line="9" static="1">
		<x path="lime.ui.JoystickHatPosition"/>
		<meta><m n=":value"><e>0x08</e></m></meta>
	</LEFT>
	<RIGHT public="1" get="inline" set="null" expr="0x02" line="10" static="1">
		<x path="lime.ui.JoystickHatPosition"/>
		<meta><m n=":value"><e>0x02</e></m></meta>
	</RIGHT>
	<UP public="1" get="inline" set="null" expr="0x01" line="11" static="1">
		<x path="lime.ui.JoystickHatPosition"/>
		<meta><m n=":value"><e>0x01</e></m></meta>
	</UP>
	<DOWN_LEFT public="1" get="inline" set="null" expr="(0x04 | 0x08)" line="13" static="1">
		<x path="lime.ui.JoystickHatPosition"/>
		<meta><m n=":value"><e>(0x04 | 0x08)</e></m></meta>
	</DOWN_LEFT>
	<DOWN_RIGHT public="1" get="inline" set="null" expr="(0x04 | 0x02)" line="14" static="1">
		<x path="lime.ui.JoystickHatPosition"/>
		<meta><m n=":value"><e>(0x04 | 0x02)</e></m></meta>
	</DOWN_RIGHT>
	<UP_LEFT public="1" get="inline" set="null" expr="(0x01 | 0x08)" line="15" static="1">
		<x path="lime.ui.JoystickHatPosition"/>
		<meta><m n=":value"><e>(0x01 | 0x08)</e></m></meta>
	</UP_LEFT>
	<UP_RIGHT public="1" get="inline" set="null" expr="(0x01 | 0x02)" line="16" static="1">
		<x path="lime.ui.JoystickHatPosition"/>
		<meta><m n=":value"><e>(0x01 | 0x02)</e></m></meta>
	</UP_RIGHT>
	<center public="1" get="accessor" set="accessor" static="1">
		<x path="Bool"/>
		<meta><m n=":impl"/></meta>
	</center>
	<down public="1" get="accessor" set="accessor" static="1">
		<x path="Bool"/>
		<meta><m n=":impl"/></meta>
	</down>
	<left public="1" get="accessor" set="accessor" static="1">
		<x path="Bool"/>
		<meta><m n=":impl"/></meta>
	</left>
	<right public="1" get="accessor" set="accessor" static="1">
		<x path="Bool"/>
		<meta><m n=":impl"/></meta>
	</right>
	<up public="1" get="accessor" set="accessor" static="1">
		<x path="Bool"/>
		<meta><m n=":impl"/></meta>
	</up>
	<_new public="1" set="method" line="25" static="1">
		<f a="value">
			<x path="Int"/>
			<x path="lime.ui.JoystickHatPosition"/>
		</f>
		<meta><m n=":impl"/></meta>
	</_new>
	<get_center set="method" line="32" static="1">
		<f a="this">
			<x path="Int"/>
			<x path="Bool"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_center>
	<set_center get="inline" set="null" line="39" static="1">
		<f a="this:value">
			<x path="Int"/>
			<x path="Bool"/>
			<x path="Bool"/>
		</f>
		<meta><m n=":impl"/></meta>
	</set_center>
	<get_down set="method" line="52" static="1">
		<f a="this">
			<x path="Int"/>
			<x path="Bool"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_down>
	<set_down get="inline" set="null" line="59" static="1">
		<f a="this:value">
			<x path="Int"/>
			<x path="Bool"/>
			<x path="Bool"/>
		</f>
		<meta><m n=":impl"/></meta>
	</set_down>
	<get_left set="method" line="76" static="1">
		<f a="this">
			<x path="Int"/>
			<x path="Bool"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_left>
	<set_left get="inline" set="null" line="83" static="1">
		<f a="this:value">
			<x path="Int"/>
			<x path="Bool"/>
			<x path="Bool"/>
		</f>
		<meta><m n=":impl"/></meta>
	</set_left>
	<get_right set="method" line="100" static="1">
		<f a="this">
			<x path="Int"/>
			<x path="Bool"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_right>
	<set_right get="inline" set="null" line="107" static="1">
		<f a="this:value">
			<x path="Int"/>
			<x path="Bool"/>
			<x path="Bool"/>
		</f>
		<meta><m n=":impl"/></meta>
	</set_right>
	<get_up set="method" line="124" static="1">
		<f a="this">
			<x path="Int"/>
			<x path="Bool"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_up>
	<set_up get="inline" set="null" line="131" static="1">
		<f a="this:value">
			<x path="Int"/>
			<x path="Bool"/>
			<x path="Bool"/>
		</f>
		<meta><m n=":impl"/></meta>
	</set_up>
	<meta><m n=":final"/></meta>
</class></impl>
	</abstract>
	<class path="lime.ui._JoystickHatPosition.JoystickHatPosition_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/ui/JoystickHatPosition.hx" private="1" module="lime.ui.JoystickHatPosition">
		<CENTER public="1" get="inline" set="null" expr="0x00" line="7" static="1">
			<x path="lime.ui.JoystickHatPosition"/>
			<meta><m n=":value"><e>0x00</e></m></meta>
		</CENTER>
		<DOWN public="1" get="inline" set="null" expr="0x04" line="8" static="1">
			<x path="lime.ui.JoystickHatPosition"/>
			<meta><m n=":value"><e>0x04</e></m></meta>
		</DOWN>
		<LEFT public="1" get="inline" set="null" expr="0x08" line="9" static="1">
			<x path="lime.ui.JoystickHatPosition"/>
			<meta><m n=":value"><e>0x08</e></m></meta>
		</LEFT>
		<RIGHT public="1" get="inline" set="null" expr="0x02" line="10" static="1">
			<x path="lime.ui.JoystickHatPosition"/>
			<meta><m n=":value"><e>0x02</e></m></meta>
		</RIGHT>
		<UP public="1" get="inline" set="null" expr="0x01" line="11" static="1">
			<x path="lime.ui.JoystickHatPosition"/>
			<meta><m n=":value"><e>0x01</e></m></meta>
		</UP>
		<DOWN_LEFT public="1" get="inline" set="null" expr="(0x04 | 0x08)" line="13" static="1">
			<x path="lime.ui.JoystickHatPosition"/>
			<meta><m n=":value"><e>(0x04 | 0x08)</e></m></meta>
		</DOWN_LEFT>
		<DOWN_RIGHT public="1" get="inline" set="null" expr="(0x04 | 0x02)" line="14" static="1">
			<x path="lime.ui.JoystickHatPosition"/>
			<meta><m n=":value"><e>(0x04 | 0x02)</e></m></meta>
		</DOWN_RIGHT>
		<UP_LEFT public="1" get="inline" set="null" expr="(0x01 | 0x08)" line="15" static="1">
			<x path="lime.ui.JoystickHatPosition"/>
			<meta><m n=":value"><e>(0x01 | 0x08)</e></m></meta>
		</UP_LEFT>
		<UP_RIGHT public="1" get="inline" set="null" expr="(0x01 | 0x02)" line="16" static="1">
			<x path="lime.ui.JoystickHatPosition"/>
			<meta><m n=":value"><e>(0x01 | 0x02)</e></m></meta>
		</UP_RIGHT>
		<center public="1" get="accessor" set="accessor" static="1">
			<x path="Bool"/>
			<meta><m n=":impl"/></meta>
		</center>
		<down public="1" get="accessor" set="accessor" static="1">
			<x path="Bool"/>
			<meta><m n=":impl"/></meta>
		</down>
		<left public="1" get="accessor" set="accessor" static="1">
			<x path="Bool"/>
			<meta><m n=":impl"/></meta>
		</left>
		<right public="1" get="accessor" set="accessor" static="1">
			<x path="Bool"/>
			<meta><m n=":impl"/></meta>
		</right>
		<up public="1" get="accessor" set="accessor" static="1">
			<x path="Bool"/>
			<meta><m n=":impl"/></meta>
		</up>
		<_new public="1" set="method" line="25" static="1">
			<f a="value">
				<x path="Int"/>
				<x path="lime.ui.JoystickHatPosition"/>
			</f>
			<meta><m n=":impl"/></meta>
		</_new>
		<get_center set="method" line="32" static="1">
			<f a="this">
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_center>
		<set_center get="inline" set="null" line="39" static="1">
			<f a="this:value">
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":impl"/></meta>
		</set_center>
		<get_down set="method" line="52" static="1">
			<f a="this">
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_down>
		<set_down get="inline" set="null" line="59" static="1">
			<f a="this:value">
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":impl"/></meta>
		</set_down>
		<get_left set="method" line="76" static="1">
			<f a="this">
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_left>
		<set_left get="inline" set="null" line="83" static="1">
			<f a="this:value">
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":impl"/></meta>
		</set_left>
		<get_right set="method" line="100" static="1">
			<f a="this">
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_right>
		<set_right get="inline" set="null" line="107" static="1">
			<f a="this:value">
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":impl"/></meta>
		</set_right>
		<get_up set="method" line="124" static="1">
			<f a="this">
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_up>
		<set_up get="inline" set="null" line="131" static="1">
			<f a="this:value">
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":impl"/></meta>
		</set_up>
		<meta><m n=":final"/></meta>
	</class>
	<abstract path="lime.ui.KeyCode" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/ui/KeyCode.hx">
		<from>
			<icast><x path="UInt"/></icast>
			<icast><x path="Int"/></icast>
		</from>
		<this><x path="Int"/></this>
		<to>
			<icast><x path="UInt"/></icast>
			<icast><x path="Int"/></icast>
		</to>
		<meta><m n=":enum"/></meta>
		<impl><class path="lime.ui._KeyCode.KeyCode_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/ui/KeyCode.hx" private="1" module="lime.ui.KeyCode">
	<UNKNOWN public="1" get="inline" set="null" expr="cast 0x00" line="7" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x00</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</UNKNOWN>
	<BACKSPACE public="1" get="inline" set="null" expr="cast 0x08" line="8" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x08</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</BACKSPACE>
	<TAB public="1" get="inline" set="null" expr="cast 0x09" line="9" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x09</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</TAB>
	<RETURN public="1" get="inline" set="null" expr="cast 0x0D" line="10" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x0D</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</RETURN>
	<ESCAPE public="1" get="inline" set="null" expr="cast 0x1B" line="11" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x1B</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</ESCAPE>
	<SPACE public="1" get="inline" set="null" expr="cast 0x20" line="12" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x20</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</SPACE>
	<EXCLAMATION public="1" get="inline" set="null" expr="cast 0x21" line="13" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x21</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</EXCLAMATION>
	<QUOTE public="1" get="inline" set="null" expr="cast 0x22" line="14" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x22</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</QUOTE>
	<HASH public="1" get="inline" set="null" expr="cast 0x23" line="15" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x23</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</HASH>
	<DOLLAR public="1" get="inline" set="null" expr="cast 0x24" line="16" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x24</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</DOLLAR>
	<PERCENT public="1" get="inline" set="null" expr="cast 0x25" line="17" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x25</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</PERCENT>
	<AMPERSAND public="1" get="inline" set="null" expr="cast 0x26" line="18" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x26</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</AMPERSAND>
	<SINGLE_QUOTE public="1" get="inline" set="null" expr="cast 0x27" line="19" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x27</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</SINGLE_QUOTE>
	<LEFT_PARENTHESIS public="1" get="inline" set="null" expr="cast 0x28" line="20" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x28</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</LEFT_PARENTHESIS>
	<RIGHT_PARENTHESIS public="1" get="inline" set="null" expr="cast 0x29" line="21" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x29</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</RIGHT_PARENTHESIS>
	<ASTERISK public="1" get="inline" set="null" expr="cast 0x2A" line="22" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x2A</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</ASTERISK>
	<PLUS public="1" get="inline" set="null" expr="cast 0x2B" line="23" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x2B</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</PLUS>
	<COMMA public="1" get="inline" set="null" expr="cast 0x2C" line="24" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x2C</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</COMMA>
	<MINUS public="1" get="inline" set="null" expr="cast 0x2D" line="25" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x2D</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</MINUS>
	<PERIOD public="1" get="inline" set="null" expr="cast 0x2E" line="26" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x2E</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</PERIOD>
	<SLASH public="1" get="inline" set="null" expr="cast 0x2F" line="27" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x2F</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</SLASH>
	<NUMBER_0 public="1" get="inline" set="null" expr="cast 0x30" line="28" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x30</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMBER_0>
	<NUMBER_1 public="1" get="inline" set="null" expr="cast 0x31" line="29" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x31</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMBER_1>
	<NUMBER_2 public="1" get="inline" set="null" expr="cast 0x32" line="30" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x32</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMBER_2>
	<NUMBER_3 public="1" get="inline" set="null" expr="cast 0x33" line="31" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x33</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMBER_3>
	<NUMBER_4 public="1" get="inline" set="null" expr="cast 0x34" line="32" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x34</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMBER_4>
	<NUMBER_5 public="1" get="inline" set="null" expr="cast 0x35" line="33" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x35</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMBER_5>
	<NUMBER_6 public="1" get="inline" set="null" expr="cast 0x36" line="34" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x36</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMBER_6>
	<NUMBER_7 public="1" get="inline" set="null" expr="cast 0x37" line="35" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x37</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMBER_7>
	<NUMBER_8 public="1" get="inline" set="null" expr="cast 0x38" line="36" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x38</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMBER_8>
	<NUMBER_9 public="1" get="inline" set="null" expr="cast 0x39" line="37" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x39</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMBER_9>
	<COLON public="1" get="inline" set="null" expr="cast 0x3A" line="38" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x3A</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</COLON>
	<SEMICOLON public="1" get="inline" set="null" expr="cast 0x3B" line="39" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x3B</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</SEMICOLON>
	<LESS_THAN public="1" get="inline" set="null" expr="cast 0x3C" line="40" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x3C</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</LESS_THAN>
	<EQUALS public="1" get="inline" set="null" expr="cast 0x3D" line="41" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x3D</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</EQUALS>
	<GREATER_THAN public="1" get="inline" set="null" expr="cast 0x3E" line="42" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x3E</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</GREATER_THAN>
	<QUESTION public="1" get="inline" set="null" expr="cast 0x3F" line="43" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x3F</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</QUESTION>
	<AT public="1" get="inline" set="null" expr="cast 0x40" line="44" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x40</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</AT>
	<LEFT_BRACKET public="1" get="inline" set="null" expr="cast 0x5B" line="45" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x5B</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</LEFT_BRACKET>
	<BACKSLASH public="1" get="inline" set="null" expr="cast 0x5C" line="46" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x5C</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</BACKSLASH>
	<RIGHT_BRACKET public="1" get="inline" set="null" expr="cast 0x5D" line="47" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x5D</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</RIGHT_BRACKET>
	<CARET public="1" get="inline" set="null" expr="cast 0x5E" line="48" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x5E</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</CARET>
	<UNDERSCORE public="1" get="inline" set="null" expr="cast 0x5F" line="49" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x5F</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</UNDERSCORE>
	<GRAVE public="1" get="inline" set="null" expr="cast 0x60" line="50" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x60</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</GRAVE>
	<A public="1" get="inline" set="null" expr="cast 0x61" line="51" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x61</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</A>
	<B public="1" get="inline" set="null" expr="cast 0x62" line="52" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x62</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</B>
	<C public="1" get="inline" set="null" expr="cast 0x63" line="53" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x63</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</C>
	<D public="1" get="inline" set="null" expr="cast 0x64" line="54" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x64</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</D>
	<E public="1" get="inline" set="null" expr="cast 0x65" line="55" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x65</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</E>
	<F public="1" get="inline" set="null" expr="cast 0x66" line="56" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x66</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</F>
	<G public="1" get="inline" set="null" expr="cast 0x67" line="57" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x67</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</G>
	<H public="1" get="inline" set="null" expr="cast 0x68" line="58" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x68</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</H>
	<I public="1" get="inline" set="null" expr="cast 0x69" line="59" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x69</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</I>
	<J public="1" get="inline" set="null" expr="cast 0x6A" line="60" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x6A</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</J>
	<K public="1" get="inline" set="null" expr="cast 0x6B" line="61" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x6B</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</K>
	<L public="1" get="inline" set="null" expr="cast 0x6C" line="62" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x6C</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</L>
	<M public="1" get="inline" set="null" expr="cast 0x6D" line="63" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x6D</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</M>
	<N public="1" get="inline" set="null" expr="cast 0x6E" line="64" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x6E</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</N>
	<O public="1" get="inline" set="null" expr="cast 0x6F" line="65" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x6F</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</O>
	<P public="1" get="inline" set="null" expr="cast 0x70" line="66" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x70</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</P>
	<Q public="1" get="inline" set="null" expr="cast 0x71" line="67" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x71</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Q>
	<R public="1" get="inline" set="null" expr="cast 0x72" line="68" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x72</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</R>
	<S public="1" get="inline" set="null" expr="cast 0x73" line="69" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x73</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</S>
	<T public="1" get="inline" set="null" expr="cast 0x74" line="70" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x74</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</T>
	<U public="1" get="inline" set="null" expr="cast 0x75" line="71" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x75</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</U>
	<V public="1" get="inline" set="null" expr="cast 0x76" line="72" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x76</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</V>
	<W public="1" get="inline" set="null" expr="cast 0x77" line="73" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x77</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</W>
	<X public="1" get="inline" set="null" expr="cast 0x78" line="74" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x78</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</X>
	<Y public="1" get="inline" set="null" expr="cast 0x79" line="75" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x79</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Y>
	<Z public="1" get="inline" set="null" expr="cast 0x7A" line="76" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x7A</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Z>
	<DELETE public="1" get="inline" set="null" expr="cast 0x7F" line="77" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x7F</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</DELETE>
	<CAPS_LOCK public="1" get="inline" set="null" expr="cast 0x40000039" line="78" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x40000039</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</CAPS_LOCK>
	<F1 public="1" get="inline" set="null" expr="cast 0x4000003A" line="79" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x4000003A</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</F1>
	<F2 public="1" get="inline" set="null" expr="cast 0x4000003B" line="80" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x4000003B</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</F2>
	<F3 public="1" get="inline" set="null" expr="cast 0x4000003C" line="81" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x4000003C</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</F3>
	<F4 public="1" get="inline" set="null" expr="cast 0x4000003D" line="82" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x4000003D</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</F4>
	<F5 public="1" get="inline" set="null" expr="cast 0x4000003E" line="83" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x4000003E</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</F5>
	<F6 public="1" get="inline" set="null" expr="cast 0x4000003F" line="84" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x4000003F</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</F6>
	<F7 public="1" get="inline" set="null" expr="cast 0x40000040" line="85" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x40000040</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</F7>
	<F8 public="1" get="inline" set="null" expr="cast 0x40000041" line="86" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x40000041</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</F8>
	<F9 public="1" get="inline" set="null" expr="cast 0x40000042" line="87" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x40000042</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</F9>
	<F10 public="1" get="inline" set="null" expr="cast 0x40000043" line="88" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x40000043</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</F10>
	<F11 public="1" get="inline" set="null" expr="cast 0x40000044" line="89" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x40000044</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</F11>
	<F12 public="1" get="inline" set="null" expr="cast 0x40000045" line="90" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x40000045</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</F12>
	<PRINT_SCREEN public="1" get="inline" set="null" expr="cast 0x40000046" line="91" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x40000046</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</PRINT_SCREEN>
	<SCROLL_LOCK public="1" get="inline" set="null" expr="cast 0x40000047" line="92" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x40000047</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</SCROLL_LOCK>
	<PAUSE public="1" get="inline" set="null" expr="cast 0x40000048" line="93" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x40000048</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</PAUSE>
	<INSERT public="1" get="inline" set="null" expr="cast 0x40000049" line="94" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x40000049</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</INSERT>
	<HOME public="1" get="inline" set="null" expr="cast 0x4000004A" line="95" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x4000004A</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</HOME>
	<PAGE_UP public="1" get="inline" set="null" expr="cast 0x4000004B" line="96" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x4000004B</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</PAGE_UP>
	<END public="1" get="inline" set="null" expr="cast 0x4000004D" line="97" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x4000004D</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</END>
	<PAGE_DOWN public="1" get="inline" set="null" expr="cast 0x4000004E" line="98" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x4000004E</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</PAGE_DOWN>
	<RIGHT public="1" get="inline" set="null" expr="cast 0x4000004F" line="99" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x4000004F</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</RIGHT>
	<LEFT public="1" get="inline" set="null" expr="cast 0x40000050" line="100" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x40000050</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</LEFT>
	<DOWN public="1" get="inline" set="null" expr="cast 0x40000051" line="101" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x40000051</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</DOWN>
	<UP public="1" get="inline" set="null" expr="cast 0x40000052" line="102" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x40000052</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</UP>
	<NUM_LOCK public="1" get="inline" set="null" expr="cast 0x40000053" line="103" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x40000053</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUM_LOCK>
	<NUMPAD_DIVIDE public="1" get="inline" set="null" expr="cast 0x40000054" line="104" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x40000054</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_DIVIDE>
	<NUMPAD_MULTIPLY public="1" get="inline" set="null" expr="cast 0x40000055" line="105" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x40000055</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_MULTIPLY>
	<NUMPAD_MINUS public="1" get="inline" set="null" expr="cast 0x40000056" line="106" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x40000056</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_MINUS>
	<NUMPAD_PLUS public="1" get="inline" set="null" expr="cast 0x40000057" line="107" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x40000057</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_PLUS>
	<NUMPAD_ENTER public="1" get="inline" set="null" expr="cast 0x40000058" line="108" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x40000058</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_ENTER>
	<NUMPAD_1 public="1" get="inline" set="null" expr="cast 0x40000059" line="109" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x40000059</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_1>
	<NUMPAD_2 public="1" get="inline" set="null" expr="cast 0x4000005A" line="110" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x4000005A</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_2>
	<NUMPAD_3 public="1" get="inline" set="null" expr="cast 0x4000005B" line="111" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x4000005B</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_3>
	<NUMPAD_4 public="1" get="inline" set="null" expr="cast 0x4000005C" line="112" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x4000005C</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_4>
	<NUMPAD_5 public="1" get="inline" set="null" expr="cast 0x4000005D" line="113" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x4000005D</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_5>
	<NUMPAD_6 public="1" get="inline" set="null" expr="cast 0x4000005E" line="114" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x4000005E</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_6>
	<NUMPAD_7 public="1" get="inline" set="null" expr="cast 0x4000005F" line="115" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x4000005F</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_7>
	<NUMPAD_8 public="1" get="inline" set="null" expr="cast 0x40000060" line="116" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x40000060</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_8>
	<NUMPAD_9 public="1" get="inline" set="null" expr="cast 0x40000061" line="117" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x40000061</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_9>
	<NUMPAD_0 public="1" get="inline" set="null" expr="cast 0x40000062" line="118" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x40000062</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_0>
	<NUMPAD_PERIOD public="1" get="inline" set="null" expr="cast 0x40000063" line="119" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x40000063</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_PERIOD>
	<APPLICATION public="1" get="inline" set="null" expr="cast 0x40000065" line="120" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x40000065</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</APPLICATION>
	<POWER public="1" get="inline" set="null" expr="cast 0x40000066" line="121" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x40000066</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</POWER>
	<NUMPAD_EQUALS public="1" get="inline" set="null" expr="cast 0x40000067" line="122" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x40000067</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_EQUALS>
	<F13 public="1" get="inline" set="null" expr="cast 0x40000068" line="123" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x40000068</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</F13>
	<F14 public="1" get="inline" set="null" expr="cast 0x40000069" line="124" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x40000069</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</F14>
	<F15 public="1" get="inline" set="null" expr="cast 0x4000006A" line="125" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x4000006A</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</F15>
	<F16 public="1" get="inline" set="null" expr="cast 0x4000006B" line="126" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x4000006B</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</F16>
	<F17 public="1" get="inline" set="null" expr="cast 0x4000006C" line="127" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x4000006C</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</F17>
	<F18 public="1" get="inline" set="null" expr="cast 0x4000006D" line="128" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x4000006D</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</F18>
	<F19 public="1" get="inline" set="null" expr="cast 0x4000006E" line="129" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x4000006E</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</F19>
	<F20 public="1" get="inline" set="null" expr="cast 0x4000006F" line="130" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x4000006F</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</F20>
	<F21 public="1" get="inline" set="null" expr="cast 0x40000070" line="131" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x40000070</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</F21>
	<F22 public="1" get="inline" set="null" expr="cast 0x40000071" line="132" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x40000071</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</F22>
	<F23 public="1" get="inline" set="null" expr="cast 0x40000072" line="133" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x40000072</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</F23>
	<F24 public="1" get="inline" set="null" expr="cast 0x40000073" line="134" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x40000073</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</F24>
	<EXECUTE public="1" get="inline" set="null" expr="cast 0x40000074" line="135" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x40000074</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</EXECUTE>
	<HELP public="1" get="inline" set="null" expr="cast 0x40000075" line="136" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x40000075</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</HELP>
	<MENU public="1" get="inline" set="null" expr="cast 0x40000076" line="137" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x40000076</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</MENU>
	<SELECT public="1" get="inline" set="null" expr="cast 0x40000077" line="138" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x40000077</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</SELECT>
	<STOP public="1" get="inline" set="null" expr="cast 0x40000078" line="139" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x40000078</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</STOP>
	<AGAIN public="1" get="inline" set="null" expr="cast 0x40000079" line="140" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x40000079</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</AGAIN>
	<UNDO public="1" get="inline" set="null" expr="cast 0x4000007A" line="141" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x4000007A</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</UNDO>
	<CUT public="1" get="inline" set="null" expr="cast 0x4000007B" line="142" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x4000007B</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</CUT>
	<COPY public="1" get="inline" set="null" expr="cast 0x4000007C" line="143" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x4000007C</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</COPY>
	<PASTE public="1" get="inline" set="null" expr="cast 0x4000007D" line="144" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x4000007D</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</PASTE>
	<FIND public="1" get="inline" set="null" expr="cast 0x4000007E" line="145" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x4000007E</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</FIND>
	<MUTE public="1" get="inline" set="null" expr="cast 0x4000007F" line="146" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x4000007F</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</MUTE>
	<VOLUME_UP public="1" get="inline" set="null" expr="cast 0x40000080" line="147" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x40000080</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</VOLUME_UP>
	<VOLUME_DOWN public="1" get="inline" set="null" expr="cast 0x40000081" line="148" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x40000081</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</VOLUME_DOWN>
	<NUMPAD_COMMA public="1" get="inline" set="null" expr="cast 0x40000085" line="149" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x40000085</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_COMMA>
	<ALT_ERASE public="1" get="inline" set="null" expr="cast 0x40000099" line="151" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x40000099</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</ALT_ERASE>
	<SYSTEM_REQUEST public="1" get="inline" set="null" expr="cast 0x4000009A" line="152" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x4000009A</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</SYSTEM_REQUEST>
	<CANCEL public="1" get="inline" set="null" expr="cast 0x4000009B" line="153" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x4000009B</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</CANCEL>
	<CLEAR public="1" get="inline" set="null" expr="cast 0x4000009C" line="154" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x4000009C</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</CLEAR>
	<PRIOR public="1" get="inline" set="null" expr="cast 0x4000009D" line="155" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x4000009D</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</PRIOR>
	<RETURN2 public="1" get="inline" set="null" expr="cast 0x4000009E" line="156" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x4000009E</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</RETURN2>
	<SEPARATOR public="1" get="inline" set="null" expr="cast 0x4000009F" line="157" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x4000009F</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</SEPARATOR>
	<OUT public="1" get="inline" set="null" expr="cast 0x400000A0" line="158" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x400000A0</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</OUT>
	<OPER public="1" get="inline" set="null" expr="cast 0x400000A1" line="159" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x400000A1</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</OPER>
	<CLEAR_AGAIN public="1" get="inline" set="null" expr="cast 0x400000A2" line="160" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x400000A2</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</CLEAR_AGAIN>
	<CRSEL public="1" get="inline" set="null" expr="cast 0x400000A3" line="161" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x400000A3</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</CRSEL>
	<EXSEL public="1" get="inline" set="null" expr="cast 0x400000A4" line="162" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x400000A4</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</EXSEL>
	<NUMPAD_00 public="1" get="inline" set="null" expr="cast 0x400000B0" line="163" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x400000B0</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_00>
	<NUMPAD_000 public="1" get="inline" set="null" expr="cast 0x400000B1" line="164" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x400000B1</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_000>
	<THOUSAND_SEPARATOR public="1" get="inline" set="null" expr="cast 0x400000B2" line="165" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x400000B2</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</THOUSAND_SEPARATOR>
	<DECIMAL_SEPARATOR public="1" get="inline" set="null" expr="cast 0x400000B3" line="166" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x400000B3</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</DECIMAL_SEPARATOR>
	<CURRENCY_UNIT public="1" get="inline" set="null" expr="cast 0x400000B4" line="167" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x400000B4</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</CURRENCY_UNIT>
	<CURRENCY_SUBUNIT public="1" get="inline" set="null" expr="cast 0x400000B5" line="168" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x400000B5</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</CURRENCY_SUBUNIT>
	<NUMPAD_LEFT_PARENTHESIS public="1" get="inline" set="null" expr="cast 0x400000B6" line="169" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x400000B6</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_LEFT_PARENTHESIS>
	<NUMPAD_RIGHT_PARENTHESIS public="1" get="inline" set="null" expr="cast 0x400000B7" line="170" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x400000B7</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_RIGHT_PARENTHESIS>
	<NUMPAD_LEFT_BRACE public="1" get="inline" set="null" expr="cast 0x400000B8" line="171" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x400000B8</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_LEFT_BRACE>
	<NUMPAD_RIGHT_BRACE public="1" get="inline" set="null" expr="cast 0x400000B9" line="172" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x400000B9</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_RIGHT_BRACE>
	<NUMPAD_TAB public="1" get="inline" set="null" expr="cast 0x400000BA" line="173" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x400000BA</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_TAB>
	<NUMPAD_BACKSPACE public="1" get="inline" set="null" expr="cast 0x400000BB" line="174" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x400000BB</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_BACKSPACE>
	<NUMPAD_A public="1" get="inline" set="null" expr="cast 0x400000BC" line="175" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x400000BC</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_A>
	<NUMPAD_B public="1" get="inline" set="null" expr="cast 0x400000BD" line="176" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x400000BD</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_B>
	<NUMPAD_C public="1" get="inline" set="null" expr="cast 0x400000BE" line="177" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x400000BE</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_C>
	<NUMPAD_D public="1" get="inline" set="null" expr="cast 0x400000BF" line="178" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x400000BF</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_D>
	<NUMPAD_E public="1" get="inline" set="null" expr="cast 0x400000C0" line="179" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x400000C0</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_E>
	<NUMPAD_F public="1" get="inline" set="null" expr="cast 0x400000C1" line="180" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x400000C1</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_F>
	<NUMPAD_XOR public="1" get="inline" set="null" expr="cast 0x400000C2" line="181" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x400000C2</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_XOR>
	<NUMPAD_POWER public="1" get="inline" set="null" expr="cast 0x400000C3" line="182" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x400000C3</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_POWER>
	<NUMPAD_PERCENT public="1" get="inline" set="null" expr="cast 0x400000C4" line="183" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x400000C4</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_PERCENT>
	<NUMPAD_LESS_THAN public="1" get="inline" set="null" expr="cast 0x400000C5" line="184" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x400000C5</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_LESS_THAN>
	<NUMPAD_GREATER_THAN public="1" get="inline" set="null" expr="cast 0x400000C6" line="185" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x400000C6</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_GREATER_THAN>
	<NUMPAD_AMPERSAND public="1" get="inline" set="null" expr="cast 0x400000C7" line="186" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x400000C7</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_AMPERSAND>
	<NUMPAD_DOUBLE_AMPERSAND public="1" get="inline" set="null" expr="cast 0x400000C8" line="187" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x400000C8</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_DOUBLE_AMPERSAND>
	<NUMPAD_VERTICAL_BAR public="1" get="inline" set="null" expr="cast 0x400000C9" line="188" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x400000C9</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_VERTICAL_BAR>
	<NUMPAD_DOUBLE_VERTICAL_BAR public="1" get="inline" set="null" expr="cast 0x400000CA" line="189" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x400000CA</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_DOUBLE_VERTICAL_BAR>
	<NUMPAD_COLON public="1" get="inline" set="null" expr="cast 0x400000CB" line="190" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x400000CB</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_COLON>
	<NUMPAD_HASH public="1" get="inline" set="null" expr="cast 0x400000CC" line="191" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x400000CC</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_HASH>
	<NUMPAD_SPACE public="1" get="inline" set="null" expr="cast 0x400000CD" line="192" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x400000CD</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_SPACE>
	<NUMPAD_AT public="1" get="inline" set="null" expr="cast 0x400000CE" line="193" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x400000CE</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_AT>
	<NUMPAD_EXCLAMATION public="1" get="inline" set="null" expr="cast 0x400000CF" line="194" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x400000CF</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_EXCLAMATION>
	<NUMPAD_MEM_STORE public="1" get="inline" set="null" expr="cast 0x400000D0" line="195" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x400000D0</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_MEM_STORE>
	<NUMPAD_MEM_RECALL public="1" get="inline" set="null" expr="cast 0x400000D1" line="196" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x400000D1</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_MEM_RECALL>
	<NUMPAD_MEM_CLEAR public="1" get="inline" set="null" expr="cast 0x400000D2" line="197" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x400000D2</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_MEM_CLEAR>
	<NUMPAD_MEM_ADD public="1" get="inline" set="null" expr="cast 0x400000D3" line="198" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x400000D3</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_MEM_ADD>
	<NUMPAD_MEM_SUBTRACT public="1" get="inline" set="null" expr="cast 0x400000D4" line="199" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x400000D4</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_MEM_SUBTRACT>
	<NUMPAD_MEM_MULTIPLY public="1" get="inline" set="null" expr="cast 0x400000D5" line="200" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x400000D5</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_MEM_MULTIPLY>
	<NUMPAD_MEM_DIVIDE public="1" get="inline" set="null" expr="cast 0x400000D6" line="201" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x400000D6</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_MEM_DIVIDE>
	<NUMPAD_PLUS_MINUS public="1" get="inline" set="null" expr="cast 0x400000D7" line="202" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x400000D7</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_PLUS_MINUS>
	<NUMPAD_CLEAR public="1" get="inline" set="null" expr="cast 0x400000D8" line="203" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x400000D8</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_CLEAR>
	<NUMPAD_CLEAR_ENTRY public="1" get="inline" set="null" expr="cast 0x400000D9" line="204" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x400000D9</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_CLEAR_ENTRY>
	<NUMPAD_BINARY public="1" get="inline" set="null" expr="cast 0x400000DA" line="205" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x400000DA</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_BINARY>
	<NUMPAD_OCTAL public="1" get="inline" set="null" expr="cast 0x400000DB" line="206" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x400000DB</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_OCTAL>
	<NUMPAD_DECIMAL public="1" get="inline" set="null" expr="cast 0x400000DC" line="207" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x400000DC</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_DECIMAL>
	<NUMPAD_HEXADECIMAL public="1" get="inline" set="null" expr="cast 0x400000DD" line="208" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x400000DD</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUMPAD_HEXADECIMAL>
	<LEFT_CTRL public="1" get="inline" set="null" expr="cast 0x400000E0" line="209" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x400000E0</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</LEFT_CTRL>
	<LEFT_SHIFT public="1" get="inline" set="null" expr="cast 0x400000E1" line="210" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x400000E1</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</LEFT_SHIFT>
	<LEFT_ALT public="1" get="inline" set="null" expr="cast 0x400000E2" line="211" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x400000E2</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</LEFT_ALT>
	<LEFT_META public="1" get="inline" set="null" expr="cast 0x400000E3" line="212" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x400000E3</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</LEFT_META>
	<RIGHT_CTRL public="1" get="inline" set="null" expr="cast 0x400000E4" line="213" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x400000E4</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</RIGHT_CTRL>
	<RIGHT_SHIFT public="1" get="inline" set="null" expr="cast 0x400000E5" line="214" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x400000E5</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</RIGHT_SHIFT>
	<RIGHT_ALT public="1" get="inline" set="null" expr="cast 0x400000E6" line="215" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x400000E6</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</RIGHT_ALT>
	<RIGHT_META public="1" get="inline" set="null" expr="cast 0x400000E7" line="216" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x400000E7</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</RIGHT_META>
	<MODE public="1" get="inline" set="null" expr="cast 0x40000101" line="217" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x40000101</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</MODE>
	<AUDIO_NEXT public="1" get="inline" set="null" expr="cast 0x40000102" line="218" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x40000102</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</AUDIO_NEXT>
	<AUDIO_PREVIOUS public="1" get="inline" set="null" expr="cast 0x40000103" line="219" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x40000103</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</AUDIO_PREVIOUS>
	<AUDIO_STOP public="1" get="inline" set="null" expr="cast 0x40000104" line="220" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x40000104</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</AUDIO_STOP>
	<AUDIO_PLAY public="1" get="inline" set="null" expr="cast 0x40000105" line="221" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x40000105</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</AUDIO_PLAY>
	<AUDIO_MUTE public="1" get="inline" set="null" expr="cast 0x40000106" line="222" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x40000106</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</AUDIO_MUTE>
	<MEDIA_SELECT public="1" get="inline" set="null" expr="cast 0x40000107" line="223" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x40000107</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</MEDIA_SELECT>
	<WWW public="1" get="inline" set="null" expr="cast 0x40000108" line="224" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x40000108</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</WWW>
	<MAIL public="1" get="inline" set="null" expr="cast 0x40000109" line="225" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x40000109</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</MAIL>
	<CALCULATOR public="1" get="inline" set="null" expr="cast 0x4000010A" line="226" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x4000010A</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</CALCULATOR>
	<COMPUTER public="1" get="inline" set="null" expr="cast 0x4000010B" line="227" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x4000010B</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</COMPUTER>
	<APP_CONTROL_SEARCH public="1" get="inline" set="null" expr="cast 0x4000010C" line="228" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x4000010C</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</APP_CONTROL_SEARCH>
	<APP_CONTROL_HOME public="1" get="inline" set="null" expr="cast 0x4000010D" line="229" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x4000010D</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</APP_CONTROL_HOME>
	<APP_CONTROL_BACK public="1" get="inline" set="null" expr="cast 0x4000010E" line="230" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x4000010E</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</APP_CONTROL_BACK>
	<APP_CONTROL_FORWARD public="1" get="inline" set="null" expr="cast 0x4000010F" line="231" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x4000010F</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</APP_CONTROL_FORWARD>
	<APP_CONTROL_STOP public="1" get="inline" set="null" expr="cast 0x40000110" line="232" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x40000110</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</APP_CONTROL_STOP>
	<APP_CONTROL_REFRESH public="1" get="inline" set="null" expr="cast 0x40000111" line="233" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x40000111</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</APP_CONTROL_REFRESH>
	<APP_CONTROL_BOOKMARKS public="1" get="inline" set="null" expr="cast 0x40000112" line="234" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x40000112</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</APP_CONTROL_BOOKMARKS>
	<BRIGHTNESS_DOWN public="1" get="inline" set="null" expr="cast 0x40000113" line="235" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x40000113</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</BRIGHTNESS_DOWN>
	<BRIGHTNESS_UP public="1" get="inline" set="null" expr="cast 0x40000114" line="236" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x40000114</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</BRIGHTNESS_UP>
	<DISPLAY_SWITCH public="1" get="inline" set="null" expr="cast 0x40000115" line="237" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x40000115</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</DISPLAY_SWITCH>
	<BACKLIGHT_TOGGLE public="1" get="inline" set="null" expr="cast 0x40000116" line="238" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x40000116</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</BACKLIGHT_TOGGLE>
	<BACKLIGHT_DOWN public="1" get="inline" set="null" expr="cast 0x40000117" line="239" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x40000117</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</BACKLIGHT_DOWN>
	<BACKLIGHT_UP public="1" get="inline" set="null" expr="cast 0x40000118" line="240" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x40000118</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</BACKLIGHT_UP>
	<EJECT public="1" get="inline" set="null" expr="cast 0x40000119" line="241" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x40000119</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</EJECT>
	<SLEEP public="1" get="inline" set="null" expr="cast 0x4000011A" line="242" static="1">
		<x path="lime.ui.KeyCode"/>
		<meta>
			<m n=":value"><e>cast 0x4000011A</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</SLEEP>
	<gt get="inline" set="null" line="244" static="1">
		<f a="a:b">
			<x path="lime.ui.KeyCode"/>
			<x path="lime.ui.KeyCode"/>
			<x path="Bool"/>
		</f>
		<meta><m n=":op"><e><![CDATA[A > B]]></e></m></meta>
	</gt>
	<gte get="inline" set="null" line="245" static="1">
		<f a="a:b">
			<x path="lime.ui.KeyCode"/>
			<x path="lime.ui.KeyCode"/>
			<x path="Bool"/>
		</f>
		<meta><m n=":op"><e><![CDATA[A >= B]]></e></m></meta>
	</gte>
	<lt get="inline" set="null" line="246" static="1">
		<f a="a:b">
			<x path="lime.ui.KeyCode"/>
			<x path="lime.ui.KeyCode"/>
			<x path="Bool"/>
		</f>
		<meta><m n=":op"><e><![CDATA[A < B]]></e></m></meta>
	</lt>
	<lte get="inline" set="null" line="247" static="1">
		<f a="a:b">
			<x path="lime.ui.KeyCode"/>
			<x path="lime.ui.KeyCode"/>
			<x path="Bool"/>
		</f>
		<meta><m n=":op"><e><![CDATA[A <= B]]></e></m></meta>
	</lte>
	<plus get="inline" set="null" line="248" static="1">
		<f a="a:b">
			<x path="lime.ui.KeyCode"/>
			<x path="Int"/>
			<x path="lime.ui.KeyCode"/>
		</f>
		<meta><m n=":op"><e>A + B</e></m></meta>
	</plus>
	<meta>
		<m n=":final"/>
		<m n=":enum"/>
	</meta>
</class></impl>
	</abstract>
	<class path="lime.ui._KeyCode.KeyCode_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/ui/KeyCode.hx" private="1" module="lime.ui.KeyCode">
		<UNKNOWN public="1" get="inline" set="null" expr="cast 0x00" line="7" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x00</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</UNKNOWN>
		<BACKSPACE public="1" get="inline" set="null" expr="cast 0x08" line="8" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x08</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</BACKSPACE>
		<TAB public="1" get="inline" set="null" expr="cast 0x09" line="9" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x09</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</TAB>
		<RETURN public="1" get="inline" set="null" expr="cast 0x0D" line="10" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x0D</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</RETURN>
		<ESCAPE public="1" get="inline" set="null" expr="cast 0x1B" line="11" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x1B</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</ESCAPE>
		<SPACE public="1" get="inline" set="null" expr="cast 0x20" line="12" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x20</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</SPACE>
		<EXCLAMATION public="1" get="inline" set="null" expr="cast 0x21" line="13" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x21</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</EXCLAMATION>
		<QUOTE public="1" get="inline" set="null" expr="cast 0x22" line="14" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x22</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</QUOTE>
		<HASH public="1" get="inline" set="null" expr="cast 0x23" line="15" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x23</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</HASH>
		<DOLLAR public="1" get="inline" set="null" expr="cast 0x24" line="16" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x24</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</DOLLAR>
		<PERCENT public="1" get="inline" set="null" expr="cast 0x25" line="17" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x25</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</PERCENT>
		<AMPERSAND public="1" get="inline" set="null" expr="cast 0x26" line="18" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x26</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</AMPERSAND>
		<SINGLE_QUOTE public="1" get="inline" set="null" expr="cast 0x27" line="19" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x27</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</SINGLE_QUOTE>
		<LEFT_PARENTHESIS public="1" get="inline" set="null" expr="cast 0x28" line="20" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x28</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</LEFT_PARENTHESIS>
		<RIGHT_PARENTHESIS public="1" get="inline" set="null" expr="cast 0x29" line="21" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x29</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</RIGHT_PARENTHESIS>
		<ASTERISK public="1" get="inline" set="null" expr="cast 0x2A" line="22" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x2A</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</ASTERISK>
		<PLUS public="1" get="inline" set="null" expr="cast 0x2B" line="23" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x2B</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</PLUS>
		<COMMA public="1" get="inline" set="null" expr="cast 0x2C" line="24" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x2C</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</COMMA>
		<MINUS public="1" get="inline" set="null" expr="cast 0x2D" line="25" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x2D</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</MINUS>
		<PERIOD public="1" get="inline" set="null" expr="cast 0x2E" line="26" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x2E</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</PERIOD>
		<SLASH public="1" get="inline" set="null" expr="cast 0x2F" line="27" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x2F</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</SLASH>
		<NUMBER_0 public="1" get="inline" set="null" expr="cast 0x30" line="28" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x30</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMBER_0>
		<NUMBER_1 public="1" get="inline" set="null" expr="cast 0x31" line="29" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x31</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMBER_1>
		<NUMBER_2 public="1" get="inline" set="null" expr="cast 0x32" line="30" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x32</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMBER_2>
		<NUMBER_3 public="1" get="inline" set="null" expr="cast 0x33" line="31" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x33</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMBER_3>
		<NUMBER_4 public="1" get="inline" set="null" expr="cast 0x34" line="32" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x34</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMBER_4>
		<NUMBER_5 public="1" get="inline" set="null" expr="cast 0x35" line="33" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x35</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMBER_5>
		<NUMBER_6 public="1" get="inline" set="null" expr="cast 0x36" line="34" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x36</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMBER_6>
		<NUMBER_7 public="1" get="inline" set="null" expr="cast 0x37" line="35" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x37</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMBER_7>
		<NUMBER_8 public="1" get="inline" set="null" expr="cast 0x38" line="36" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x38</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMBER_8>
		<NUMBER_9 public="1" get="inline" set="null" expr="cast 0x39" line="37" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x39</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMBER_9>
		<COLON public="1" get="inline" set="null" expr="cast 0x3A" line="38" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x3A</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</COLON>
		<SEMICOLON public="1" get="inline" set="null" expr="cast 0x3B" line="39" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x3B</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</SEMICOLON>
		<LESS_THAN public="1" get="inline" set="null" expr="cast 0x3C" line="40" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x3C</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</LESS_THAN>
		<EQUALS public="1" get="inline" set="null" expr="cast 0x3D" line="41" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x3D</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</EQUALS>
		<GREATER_THAN public="1" get="inline" set="null" expr="cast 0x3E" line="42" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x3E</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</GREATER_THAN>
		<QUESTION public="1" get="inline" set="null" expr="cast 0x3F" line="43" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x3F</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</QUESTION>
		<AT public="1" get="inline" set="null" expr="cast 0x40" line="44" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x40</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</AT>
		<LEFT_BRACKET public="1" get="inline" set="null" expr="cast 0x5B" line="45" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x5B</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</LEFT_BRACKET>
		<BACKSLASH public="1" get="inline" set="null" expr="cast 0x5C" line="46" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x5C</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</BACKSLASH>
		<RIGHT_BRACKET public="1" get="inline" set="null" expr="cast 0x5D" line="47" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x5D</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</RIGHT_BRACKET>
		<CARET public="1" get="inline" set="null" expr="cast 0x5E" line="48" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x5E</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</CARET>
		<UNDERSCORE public="1" get="inline" set="null" expr="cast 0x5F" line="49" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x5F</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</UNDERSCORE>
		<GRAVE public="1" get="inline" set="null" expr="cast 0x60" line="50" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x60</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</GRAVE>
		<A public="1" get="inline" set="null" expr="cast 0x61" line="51" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x61</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</A>
		<B public="1" get="inline" set="null" expr="cast 0x62" line="52" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x62</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</B>
		<C public="1" get="inline" set="null" expr="cast 0x63" line="53" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x63</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</C>
		<D public="1" get="inline" set="null" expr="cast 0x64" line="54" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x64</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</D>
		<E public="1" get="inline" set="null" expr="cast 0x65" line="55" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x65</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</E>
		<F public="1" get="inline" set="null" expr="cast 0x66" line="56" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x66</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</F>
		<G public="1" get="inline" set="null" expr="cast 0x67" line="57" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x67</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</G>
		<H public="1" get="inline" set="null" expr="cast 0x68" line="58" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x68</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</H>
		<I public="1" get="inline" set="null" expr="cast 0x69" line="59" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x69</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</I>
		<J public="1" get="inline" set="null" expr="cast 0x6A" line="60" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x6A</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</J>
		<K public="1" get="inline" set="null" expr="cast 0x6B" line="61" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x6B</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</K>
		<L public="1" get="inline" set="null" expr="cast 0x6C" line="62" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x6C</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</L>
		<M public="1" get="inline" set="null" expr="cast 0x6D" line="63" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x6D</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</M>
		<N public="1" get="inline" set="null" expr="cast 0x6E" line="64" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x6E</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</N>
		<O public="1" get="inline" set="null" expr="cast 0x6F" line="65" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x6F</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</O>
		<P public="1" get="inline" set="null" expr="cast 0x70" line="66" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x70</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</P>
		<Q public="1" get="inline" set="null" expr="cast 0x71" line="67" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x71</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Q>
		<R public="1" get="inline" set="null" expr="cast 0x72" line="68" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x72</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</R>
		<S public="1" get="inline" set="null" expr="cast 0x73" line="69" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x73</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</S>
		<T public="1" get="inline" set="null" expr="cast 0x74" line="70" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x74</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</T>
		<U public="1" get="inline" set="null" expr="cast 0x75" line="71" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x75</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</U>
		<V public="1" get="inline" set="null" expr="cast 0x76" line="72" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x76</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</V>
		<W public="1" get="inline" set="null" expr="cast 0x77" line="73" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x77</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</W>
		<X public="1" get="inline" set="null" expr="cast 0x78" line="74" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x78</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</X>
		<Y public="1" get="inline" set="null" expr="cast 0x79" line="75" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x79</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Y>
		<Z public="1" get="inline" set="null" expr="cast 0x7A" line="76" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x7A</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Z>
		<DELETE public="1" get="inline" set="null" expr="cast 0x7F" line="77" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x7F</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</DELETE>
		<CAPS_LOCK public="1" get="inline" set="null" expr="cast 0x40000039" line="78" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x40000039</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</CAPS_LOCK>
		<F1 public="1" get="inline" set="null" expr="cast 0x4000003A" line="79" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x4000003A</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</F1>
		<F2 public="1" get="inline" set="null" expr="cast 0x4000003B" line="80" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x4000003B</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</F2>
		<F3 public="1" get="inline" set="null" expr="cast 0x4000003C" line="81" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x4000003C</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</F3>
		<F4 public="1" get="inline" set="null" expr="cast 0x4000003D" line="82" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x4000003D</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</F4>
		<F5 public="1" get="inline" set="null" expr="cast 0x4000003E" line="83" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x4000003E</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</F5>
		<F6 public="1" get="inline" set="null" expr="cast 0x4000003F" line="84" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x4000003F</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</F6>
		<F7 public="1" get="inline" set="null" expr="cast 0x40000040" line="85" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x40000040</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</F7>
		<F8 public="1" get="inline" set="null" expr="cast 0x40000041" line="86" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x40000041</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</F8>
		<F9 public="1" get="inline" set="null" expr="cast 0x40000042" line="87" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x40000042</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</F9>
		<F10 public="1" get="inline" set="null" expr="cast 0x40000043" line="88" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x40000043</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</F10>
		<F11 public="1" get="inline" set="null" expr="cast 0x40000044" line="89" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x40000044</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</F11>
		<F12 public="1" get="inline" set="null" expr="cast 0x40000045" line="90" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x40000045</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</F12>
		<PRINT_SCREEN public="1" get="inline" set="null" expr="cast 0x40000046" line="91" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x40000046</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</PRINT_SCREEN>
		<SCROLL_LOCK public="1" get="inline" set="null" expr="cast 0x40000047" line="92" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x40000047</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</SCROLL_LOCK>
		<PAUSE public="1" get="inline" set="null" expr="cast 0x40000048" line="93" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x40000048</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</PAUSE>
		<INSERT public="1" get="inline" set="null" expr="cast 0x40000049" line="94" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x40000049</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</INSERT>
		<HOME public="1" get="inline" set="null" expr="cast 0x4000004A" line="95" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x4000004A</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</HOME>
		<PAGE_UP public="1" get="inline" set="null" expr="cast 0x4000004B" line="96" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x4000004B</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</PAGE_UP>
		<END public="1" get="inline" set="null" expr="cast 0x4000004D" line="97" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x4000004D</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</END>
		<PAGE_DOWN public="1" get="inline" set="null" expr="cast 0x4000004E" line="98" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x4000004E</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</PAGE_DOWN>
		<RIGHT public="1" get="inline" set="null" expr="cast 0x4000004F" line="99" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x4000004F</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</RIGHT>
		<LEFT public="1" get="inline" set="null" expr="cast 0x40000050" line="100" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x40000050</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</LEFT>
		<DOWN public="1" get="inline" set="null" expr="cast 0x40000051" line="101" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x40000051</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</DOWN>
		<UP public="1" get="inline" set="null" expr="cast 0x40000052" line="102" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x40000052</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</UP>
		<NUM_LOCK public="1" get="inline" set="null" expr="cast 0x40000053" line="103" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x40000053</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUM_LOCK>
		<NUMPAD_DIVIDE public="1" get="inline" set="null" expr="cast 0x40000054" line="104" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x40000054</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_DIVIDE>
		<NUMPAD_MULTIPLY public="1" get="inline" set="null" expr="cast 0x40000055" line="105" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x40000055</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_MULTIPLY>
		<NUMPAD_MINUS public="1" get="inline" set="null" expr="cast 0x40000056" line="106" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x40000056</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_MINUS>
		<NUMPAD_PLUS public="1" get="inline" set="null" expr="cast 0x40000057" line="107" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x40000057</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_PLUS>
		<NUMPAD_ENTER public="1" get="inline" set="null" expr="cast 0x40000058" line="108" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x40000058</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_ENTER>
		<NUMPAD_1 public="1" get="inline" set="null" expr="cast 0x40000059" line="109" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x40000059</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_1>
		<NUMPAD_2 public="1" get="inline" set="null" expr="cast 0x4000005A" line="110" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x4000005A</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_2>
		<NUMPAD_3 public="1" get="inline" set="null" expr="cast 0x4000005B" line="111" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x4000005B</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_3>
		<NUMPAD_4 public="1" get="inline" set="null" expr="cast 0x4000005C" line="112" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x4000005C</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_4>
		<NUMPAD_5 public="1" get="inline" set="null" expr="cast 0x4000005D" line="113" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x4000005D</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_5>
		<NUMPAD_6 public="1" get="inline" set="null" expr="cast 0x4000005E" line="114" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x4000005E</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_6>
		<NUMPAD_7 public="1" get="inline" set="null" expr="cast 0x4000005F" line="115" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x4000005F</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_7>
		<NUMPAD_8 public="1" get="inline" set="null" expr="cast 0x40000060" line="116" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x40000060</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_8>
		<NUMPAD_9 public="1" get="inline" set="null" expr="cast 0x40000061" line="117" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x40000061</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_9>
		<NUMPAD_0 public="1" get="inline" set="null" expr="cast 0x40000062" line="118" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x40000062</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_0>
		<NUMPAD_PERIOD public="1" get="inline" set="null" expr="cast 0x40000063" line="119" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x40000063</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_PERIOD>
		<APPLICATION public="1" get="inline" set="null" expr="cast 0x40000065" line="120" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x40000065</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</APPLICATION>
		<POWER public="1" get="inline" set="null" expr="cast 0x40000066" line="121" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x40000066</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</POWER>
		<NUMPAD_EQUALS public="1" get="inline" set="null" expr="cast 0x40000067" line="122" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x40000067</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_EQUALS>
		<F13 public="1" get="inline" set="null" expr="cast 0x40000068" line="123" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x40000068</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</F13>
		<F14 public="1" get="inline" set="null" expr="cast 0x40000069" line="124" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x40000069</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</F14>
		<F15 public="1" get="inline" set="null" expr="cast 0x4000006A" line="125" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x4000006A</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</F15>
		<F16 public="1" get="inline" set="null" expr="cast 0x4000006B" line="126" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x4000006B</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</F16>
		<F17 public="1" get="inline" set="null" expr="cast 0x4000006C" line="127" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x4000006C</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</F17>
		<F18 public="1" get="inline" set="null" expr="cast 0x4000006D" line="128" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x4000006D</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</F18>
		<F19 public="1" get="inline" set="null" expr="cast 0x4000006E" line="129" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x4000006E</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</F19>
		<F20 public="1" get="inline" set="null" expr="cast 0x4000006F" line="130" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x4000006F</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</F20>
		<F21 public="1" get="inline" set="null" expr="cast 0x40000070" line="131" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x40000070</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</F21>
		<F22 public="1" get="inline" set="null" expr="cast 0x40000071" line="132" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x40000071</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</F22>
		<F23 public="1" get="inline" set="null" expr="cast 0x40000072" line="133" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x40000072</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</F23>
		<F24 public="1" get="inline" set="null" expr="cast 0x40000073" line="134" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x40000073</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</F24>
		<EXECUTE public="1" get="inline" set="null" expr="cast 0x40000074" line="135" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x40000074</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</EXECUTE>
		<HELP public="1" get="inline" set="null" expr="cast 0x40000075" line="136" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x40000075</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</HELP>
		<MENU public="1" get="inline" set="null" expr="cast 0x40000076" line="137" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x40000076</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</MENU>
		<SELECT public="1" get="inline" set="null" expr="cast 0x40000077" line="138" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x40000077</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</SELECT>
		<STOP public="1" get="inline" set="null" expr="cast 0x40000078" line="139" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x40000078</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</STOP>
		<AGAIN public="1" get="inline" set="null" expr="cast 0x40000079" line="140" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x40000079</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</AGAIN>
		<UNDO public="1" get="inline" set="null" expr="cast 0x4000007A" line="141" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x4000007A</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</UNDO>
		<CUT public="1" get="inline" set="null" expr="cast 0x4000007B" line="142" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x4000007B</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</CUT>
		<COPY public="1" get="inline" set="null" expr="cast 0x4000007C" line="143" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x4000007C</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</COPY>
		<PASTE public="1" get="inline" set="null" expr="cast 0x4000007D" line="144" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x4000007D</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</PASTE>
		<FIND public="1" get="inline" set="null" expr="cast 0x4000007E" line="145" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x4000007E</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</FIND>
		<MUTE public="1" get="inline" set="null" expr="cast 0x4000007F" line="146" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x4000007F</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</MUTE>
		<VOLUME_UP public="1" get="inline" set="null" expr="cast 0x40000080" line="147" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x40000080</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</VOLUME_UP>
		<VOLUME_DOWN public="1" get="inline" set="null" expr="cast 0x40000081" line="148" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x40000081</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</VOLUME_DOWN>
		<NUMPAD_COMMA public="1" get="inline" set="null" expr="cast 0x40000085" line="149" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x40000085</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_COMMA>
		<ALT_ERASE public="1" get="inline" set="null" expr="cast 0x40000099" line="151" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x40000099</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</ALT_ERASE>
		<SYSTEM_REQUEST public="1" get="inline" set="null" expr="cast 0x4000009A" line="152" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x4000009A</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</SYSTEM_REQUEST>
		<CANCEL public="1" get="inline" set="null" expr="cast 0x4000009B" line="153" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x4000009B</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</CANCEL>
		<CLEAR public="1" get="inline" set="null" expr="cast 0x4000009C" line="154" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x4000009C</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</CLEAR>
		<PRIOR public="1" get="inline" set="null" expr="cast 0x4000009D" line="155" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x4000009D</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</PRIOR>
		<RETURN2 public="1" get="inline" set="null" expr="cast 0x4000009E" line="156" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x4000009E</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</RETURN2>
		<SEPARATOR public="1" get="inline" set="null" expr="cast 0x4000009F" line="157" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x4000009F</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</SEPARATOR>
		<OUT public="1" get="inline" set="null" expr="cast 0x400000A0" line="158" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x400000A0</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</OUT>
		<OPER public="1" get="inline" set="null" expr="cast 0x400000A1" line="159" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x400000A1</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</OPER>
		<CLEAR_AGAIN public="1" get="inline" set="null" expr="cast 0x400000A2" line="160" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x400000A2</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</CLEAR_AGAIN>
		<CRSEL public="1" get="inline" set="null" expr="cast 0x400000A3" line="161" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x400000A3</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</CRSEL>
		<EXSEL public="1" get="inline" set="null" expr="cast 0x400000A4" line="162" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x400000A4</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</EXSEL>
		<NUMPAD_00 public="1" get="inline" set="null" expr="cast 0x400000B0" line="163" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x400000B0</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_00>
		<NUMPAD_000 public="1" get="inline" set="null" expr="cast 0x400000B1" line="164" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x400000B1</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_000>
		<THOUSAND_SEPARATOR public="1" get="inline" set="null" expr="cast 0x400000B2" line="165" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x400000B2</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</THOUSAND_SEPARATOR>
		<DECIMAL_SEPARATOR public="1" get="inline" set="null" expr="cast 0x400000B3" line="166" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x400000B3</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</DECIMAL_SEPARATOR>
		<CURRENCY_UNIT public="1" get="inline" set="null" expr="cast 0x400000B4" line="167" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x400000B4</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</CURRENCY_UNIT>
		<CURRENCY_SUBUNIT public="1" get="inline" set="null" expr="cast 0x400000B5" line="168" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x400000B5</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</CURRENCY_SUBUNIT>
		<NUMPAD_LEFT_PARENTHESIS public="1" get="inline" set="null" expr="cast 0x400000B6" line="169" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x400000B6</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_LEFT_PARENTHESIS>
		<NUMPAD_RIGHT_PARENTHESIS public="1" get="inline" set="null" expr="cast 0x400000B7" line="170" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x400000B7</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_RIGHT_PARENTHESIS>
		<NUMPAD_LEFT_BRACE public="1" get="inline" set="null" expr="cast 0x400000B8" line="171" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x400000B8</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_LEFT_BRACE>
		<NUMPAD_RIGHT_BRACE public="1" get="inline" set="null" expr="cast 0x400000B9" line="172" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x400000B9</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_RIGHT_BRACE>
		<NUMPAD_TAB public="1" get="inline" set="null" expr="cast 0x400000BA" line="173" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x400000BA</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_TAB>
		<NUMPAD_BACKSPACE public="1" get="inline" set="null" expr="cast 0x400000BB" line="174" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x400000BB</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_BACKSPACE>
		<NUMPAD_A public="1" get="inline" set="null" expr="cast 0x400000BC" line="175" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x400000BC</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_A>
		<NUMPAD_B public="1" get="inline" set="null" expr="cast 0x400000BD" line="176" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x400000BD</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_B>
		<NUMPAD_C public="1" get="inline" set="null" expr="cast 0x400000BE" line="177" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x400000BE</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_C>
		<NUMPAD_D public="1" get="inline" set="null" expr="cast 0x400000BF" line="178" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x400000BF</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_D>
		<NUMPAD_E public="1" get="inline" set="null" expr="cast 0x400000C0" line="179" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x400000C0</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_E>
		<NUMPAD_F public="1" get="inline" set="null" expr="cast 0x400000C1" line="180" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x400000C1</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_F>
		<NUMPAD_XOR public="1" get="inline" set="null" expr="cast 0x400000C2" line="181" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x400000C2</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_XOR>
		<NUMPAD_POWER public="1" get="inline" set="null" expr="cast 0x400000C3" line="182" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x400000C3</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_POWER>
		<NUMPAD_PERCENT public="1" get="inline" set="null" expr="cast 0x400000C4" line="183" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x400000C4</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_PERCENT>
		<NUMPAD_LESS_THAN public="1" get="inline" set="null" expr="cast 0x400000C5" line="184" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x400000C5</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_LESS_THAN>
		<NUMPAD_GREATER_THAN public="1" get="inline" set="null" expr="cast 0x400000C6" line="185" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x400000C6</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_GREATER_THAN>
		<NUMPAD_AMPERSAND public="1" get="inline" set="null" expr="cast 0x400000C7" line="186" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x400000C7</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_AMPERSAND>
		<NUMPAD_DOUBLE_AMPERSAND public="1" get="inline" set="null" expr="cast 0x400000C8" line="187" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x400000C8</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_DOUBLE_AMPERSAND>
		<NUMPAD_VERTICAL_BAR public="1" get="inline" set="null" expr="cast 0x400000C9" line="188" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x400000C9</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_VERTICAL_BAR>
		<NUMPAD_DOUBLE_VERTICAL_BAR public="1" get="inline" set="null" expr="cast 0x400000CA" line="189" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x400000CA</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_DOUBLE_VERTICAL_BAR>
		<NUMPAD_COLON public="1" get="inline" set="null" expr="cast 0x400000CB" line="190" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x400000CB</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_COLON>
		<NUMPAD_HASH public="1" get="inline" set="null" expr="cast 0x400000CC" line="191" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x400000CC</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_HASH>
		<NUMPAD_SPACE public="1" get="inline" set="null" expr="cast 0x400000CD" line="192" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x400000CD</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_SPACE>
		<NUMPAD_AT public="1" get="inline" set="null" expr="cast 0x400000CE" line="193" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x400000CE</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_AT>
		<NUMPAD_EXCLAMATION public="1" get="inline" set="null" expr="cast 0x400000CF" line="194" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x400000CF</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_EXCLAMATION>
		<NUMPAD_MEM_STORE public="1" get="inline" set="null" expr="cast 0x400000D0" line="195" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x400000D0</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_MEM_STORE>
		<NUMPAD_MEM_RECALL public="1" get="inline" set="null" expr="cast 0x400000D1" line="196" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x400000D1</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_MEM_RECALL>
		<NUMPAD_MEM_CLEAR public="1" get="inline" set="null" expr="cast 0x400000D2" line="197" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x400000D2</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_MEM_CLEAR>
		<NUMPAD_MEM_ADD public="1" get="inline" set="null" expr="cast 0x400000D3" line="198" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x400000D3</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_MEM_ADD>
		<NUMPAD_MEM_SUBTRACT public="1" get="inline" set="null" expr="cast 0x400000D4" line="199" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x400000D4</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_MEM_SUBTRACT>
		<NUMPAD_MEM_MULTIPLY public="1" get="inline" set="null" expr="cast 0x400000D5" line="200" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x400000D5</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_MEM_MULTIPLY>
		<NUMPAD_MEM_DIVIDE public="1" get="inline" set="null" expr="cast 0x400000D6" line="201" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x400000D6</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_MEM_DIVIDE>
		<NUMPAD_PLUS_MINUS public="1" get="inline" set="null" expr="cast 0x400000D7" line="202" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x400000D7</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_PLUS_MINUS>
		<NUMPAD_CLEAR public="1" get="inline" set="null" expr="cast 0x400000D8" line="203" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x400000D8</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_CLEAR>
		<NUMPAD_CLEAR_ENTRY public="1" get="inline" set="null" expr="cast 0x400000D9" line="204" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x400000D9</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_CLEAR_ENTRY>
		<NUMPAD_BINARY public="1" get="inline" set="null" expr="cast 0x400000DA" line="205" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x400000DA</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_BINARY>
		<NUMPAD_OCTAL public="1" get="inline" set="null" expr="cast 0x400000DB" line="206" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x400000DB</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_OCTAL>
		<NUMPAD_DECIMAL public="1" get="inline" set="null" expr="cast 0x400000DC" line="207" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x400000DC</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_DECIMAL>
		<NUMPAD_HEXADECIMAL public="1" get="inline" set="null" expr="cast 0x400000DD" line="208" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x400000DD</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUMPAD_HEXADECIMAL>
		<LEFT_CTRL public="1" get="inline" set="null" expr="cast 0x400000E0" line="209" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x400000E0</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</LEFT_CTRL>
		<LEFT_SHIFT public="1" get="inline" set="null" expr="cast 0x400000E1" line="210" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x400000E1</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</LEFT_SHIFT>
		<LEFT_ALT public="1" get="inline" set="null" expr="cast 0x400000E2" line="211" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x400000E2</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</LEFT_ALT>
		<LEFT_META public="1" get="inline" set="null" expr="cast 0x400000E3" line="212" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x400000E3</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</LEFT_META>
		<RIGHT_CTRL public="1" get="inline" set="null" expr="cast 0x400000E4" line="213" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x400000E4</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</RIGHT_CTRL>
		<RIGHT_SHIFT public="1" get="inline" set="null" expr="cast 0x400000E5" line="214" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x400000E5</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</RIGHT_SHIFT>
		<RIGHT_ALT public="1" get="inline" set="null" expr="cast 0x400000E6" line="215" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x400000E6</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</RIGHT_ALT>
		<RIGHT_META public="1" get="inline" set="null" expr="cast 0x400000E7" line="216" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x400000E7</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</RIGHT_META>
		<MODE public="1" get="inline" set="null" expr="cast 0x40000101" line="217" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x40000101</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</MODE>
		<AUDIO_NEXT public="1" get="inline" set="null" expr="cast 0x40000102" line="218" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x40000102</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</AUDIO_NEXT>
		<AUDIO_PREVIOUS public="1" get="inline" set="null" expr="cast 0x40000103" line="219" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x40000103</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</AUDIO_PREVIOUS>
		<AUDIO_STOP public="1" get="inline" set="null" expr="cast 0x40000104" line="220" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x40000104</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</AUDIO_STOP>
		<AUDIO_PLAY public="1" get="inline" set="null" expr="cast 0x40000105" line="221" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x40000105</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</AUDIO_PLAY>
		<AUDIO_MUTE public="1" get="inline" set="null" expr="cast 0x40000106" line="222" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x40000106</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</AUDIO_MUTE>
		<MEDIA_SELECT public="1" get="inline" set="null" expr="cast 0x40000107" line="223" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x40000107</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</MEDIA_SELECT>
		<WWW public="1" get="inline" set="null" expr="cast 0x40000108" line="224" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x40000108</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</WWW>
		<MAIL public="1" get="inline" set="null" expr="cast 0x40000109" line="225" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x40000109</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</MAIL>
		<CALCULATOR public="1" get="inline" set="null" expr="cast 0x4000010A" line="226" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x4000010A</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</CALCULATOR>
		<COMPUTER public="1" get="inline" set="null" expr="cast 0x4000010B" line="227" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x4000010B</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</COMPUTER>
		<APP_CONTROL_SEARCH public="1" get="inline" set="null" expr="cast 0x4000010C" line="228" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x4000010C</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</APP_CONTROL_SEARCH>
		<APP_CONTROL_HOME public="1" get="inline" set="null" expr="cast 0x4000010D" line="229" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x4000010D</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</APP_CONTROL_HOME>
		<APP_CONTROL_BACK public="1" get="inline" set="null" expr="cast 0x4000010E" line="230" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x4000010E</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</APP_CONTROL_BACK>
		<APP_CONTROL_FORWARD public="1" get="inline" set="null" expr="cast 0x4000010F" line="231" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x4000010F</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</APP_CONTROL_FORWARD>
		<APP_CONTROL_STOP public="1" get="inline" set="null" expr="cast 0x40000110" line="232" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x40000110</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</APP_CONTROL_STOP>
		<APP_CONTROL_REFRESH public="1" get="inline" set="null" expr="cast 0x40000111" line="233" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x40000111</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</APP_CONTROL_REFRESH>
		<APP_CONTROL_BOOKMARKS public="1" get="inline" set="null" expr="cast 0x40000112" line="234" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x40000112</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</APP_CONTROL_BOOKMARKS>
		<BRIGHTNESS_DOWN public="1" get="inline" set="null" expr="cast 0x40000113" line="235" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x40000113</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</BRIGHTNESS_DOWN>
		<BRIGHTNESS_UP public="1" get="inline" set="null" expr="cast 0x40000114" line="236" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x40000114</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</BRIGHTNESS_UP>
		<DISPLAY_SWITCH public="1" get="inline" set="null" expr="cast 0x40000115" line="237" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x40000115</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</DISPLAY_SWITCH>
		<BACKLIGHT_TOGGLE public="1" get="inline" set="null" expr="cast 0x40000116" line="238" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x40000116</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</BACKLIGHT_TOGGLE>
		<BACKLIGHT_DOWN public="1" get="inline" set="null" expr="cast 0x40000117" line="239" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x40000117</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</BACKLIGHT_DOWN>
		<BACKLIGHT_UP public="1" get="inline" set="null" expr="cast 0x40000118" line="240" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x40000118</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</BACKLIGHT_UP>
		<EJECT public="1" get="inline" set="null" expr="cast 0x40000119" line="241" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x40000119</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</EJECT>
		<SLEEP public="1" get="inline" set="null" expr="cast 0x4000011A" line="242" static="1">
			<x path="lime.ui.KeyCode"/>
			<meta>
				<m n=":value"><e>cast 0x4000011A</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</SLEEP>
		<gt get="inline" set="null" line="244" static="1">
			<f a="a:b">
				<x path="lime.ui.KeyCode"/>
				<x path="lime.ui.KeyCode"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":op"><e><![CDATA[A > B]]></e></m></meta>
		</gt>
		<gte get="inline" set="null" line="245" static="1">
			<f a="a:b">
				<x path="lime.ui.KeyCode"/>
				<x path="lime.ui.KeyCode"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":op"><e><![CDATA[A >= B]]></e></m></meta>
		</gte>
		<lt get="inline" set="null" line="246" static="1">
			<f a="a:b">
				<x path="lime.ui.KeyCode"/>
				<x path="lime.ui.KeyCode"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":op"><e><![CDATA[A < B]]></e></m></meta>
		</lt>
		<lte get="inline" set="null" line="247" static="1">
			<f a="a:b">
				<x path="lime.ui.KeyCode"/>
				<x path="lime.ui.KeyCode"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":op"><e><![CDATA[A <= B]]></e></m></meta>
		</lte>
		<plus get="inline" set="null" line="248" static="1">
			<f a="a:b">
				<x path="lime.ui.KeyCode"/>
				<x path="Int"/>
				<x path="lime.ui.KeyCode"/>
			</f>
			<meta><m n=":op"><e>A + B</e></m></meta>
		</plus>
		<meta>
			<m n=":final"/>
			<m n=":enum"/>
		</meta>
	</class>
	<abstract path="lime.ui.KeyModifier" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/ui/KeyModifier.hx">
		<from>
			<icast><x path="UInt"/></icast>
			<icast><x path="Int"/></icast>
		</from>
		<this><x path="Int"/></this>
		<to>
			<icast><x path="UInt"/></icast>
			<icast><x path="Int"/></icast>
		</to>
		<impl><class path="lime.ui._KeyModifier.KeyModifier_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/ui/KeyModifier.hx" private="1" module="lime.ui.KeyModifier">
	<NONE public="1" get="inline" set="null" expr="0x0000" line="7" static="1">
		<x path="lime.ui.KeyModifier"/>
		<meta><m n=":value"><e>0x0000</e></m></meta>
	</NONE>
	<LEFT_SHIFT public="1" get="inline" set="null" expr="0x0001" line="8" static="1">
		<x path="lime.ui.KeyModifier"/>
		<meta><m n=":value"><e>0x0001</e></m></meta>
	</LEFT_SHIFT>
	<RIGHT_SHIFT public="1" get="inline" set="null" expr="0x0002" line="9" static="1">
		<x path="lime.ui.KeyModifier"/>
		<meta><m n=":value"><e>0x0002</e></m></meta>
	</RIGHT_SHIFT>
	<LEFT_CTRL public="1" get="inline" set="null" expr="0x0040" line="10" static="1">
		<x path="lime.ui.KeyModifier"/>
		<meta><m n=":value"><e>0x0040</e></m></meta>
	</LEFT_CTRL>
	<RIGHT_CTRL public="1" get="inline" set="null" expr="0x0080" line="11" static="1">
		<x path="lime.ui.KeyModifier"/>
		<meta><m n=":value"><e>0x0080</e></m></meta>
	</RIGHT_CTRL>
	<LEFT_ALT public="1" get="inline" set="null" expr="0x0100" line="12" static="1">
		<x path="lime.ui.KeyModifier"/>
		<meta><m n=":value"><e>0x0100</e></m></meta>
	</LEFT_ALT>
	<RIGHT_ALT public="1" get="inline" set="null" expr="0x0200" line="13" static="1">
		<x path="lime.ui.KeyModifier"/>
		<meta><m n=":value"><e>0x0200</e></m></meta>
	</RIGHT_ALT>
	<LEFT_META public="1" get="inline" set="null" expr="0x0400" line="14" static="1">
		<x path="lime.ui.KeyModifier"/>
		<meta><m n=":value"><e>0x0400</e></m></meta>
	</LEFT_META>
	<RIGHT_META public="1" get="inline" set="null" expr="0x0800" line="15" static="1">
		<x path="lime.ui.KeyModifier"/>
		<meta><m n=":value"><e>0x0800</e></m></meta>
	</RIGHT_META>
	<NUM_LOCK public="1" get="inline" set="null" expr="0x1000" line="16" static="1">
		<x path="lime.ui.KeyModifier"/>
		<meta><m n=":value"><e>0x1000</e></m></meta>
	</NUM_LOCK>
	<CAPS_LOCK public="1" get="inline" set="null" expr="0x2000" line="17" static="1">
		<x path="lime.ui.KeyModifier"/>
		<meta><m n=":value"><e>0x2000</e></m></meta>
	</CAPS_LOCK>
	<MODE public="1" get="inline" set="null" expr="0x4000" line="18" static="1">
		<x path="lime.ui.KeyModifier"/>
		<meta><m n=":value"><e>0x4000</e></m></meta>
	</MODE>
	<CTRL public="1" get="inline" set="null" expr="(0x0040 | 0x0080)" line="20" static="1">
		<x path="lime.ui.KeyModifier"/>
		<meta><m n=":value"><e>(0x0040 | 0x0080)</e></m></meta>
	</CTRL>
	<SHIFT public="1" get="inline" set="null" expr="(0x001 | 0x0002)" line="21" static="1">
		<x path="lime.ui.KeyModifier"/>
		<meta><m n=":value"><e>(0x001 | 0x0002)</e></m></meta>
	</SHIFT>
	<ALT public="1" get="inline" set="null" expr="(0x0100 | 0x0200)" line="22" static="1">
		<x path="lime.ui.KeyModifier"/>
		<meta><m n=":value"><e>(0x0100 | 0x0200)</e></m></meta>
	</ALT>
	<META public="1" get="inline" set="null" expr="(0x0400 | 0x0800)" line="23" static="1">
		<x path="lime.ui.KeyModifier"/>
		<meta><m n=":value"><e>(0x0400 | 0x0800)</e></m></meta>
	</META>
	<altKey public="1" get="accessor" set="accessor" static="1">
		<x path="Bool"/>
		<meta><m n=":impl"/></meta>
	</altKey>
	<capsLock public="1" get="accessor" set="accessor" static="1">
		<x path="Bool"/>
		<meta><m n=":impl"/></meta>
	</capsLock>
	<ctrlKey public="1" get="accessor" set="accessor" static="1">
		<x path="Bool"/>
		<meta><m n=":impl"/></meta>
	</ctrlKey>
	<metaKey public="1" get="accessor" set="accessor" static="1">
		<x path="Bool"/>
		<meta><m n=":impl"/></meta>
	</metaKey>
	<numLock public="1" get="accessor" set="accessor" static="1">
		<x path="Bool"/>
		<meta><m n=":impl"/></meta>
	</numLock>
	<shiftKey public="1" get="accessor" set="accessor" static="1">
		<x path="Bool"/>
		<meta><m n=":impl"/></meta>
	</shiftKey>
	<get_altKey set="method" line="33" static="1">
		<f a="this">
			<x path="Int"/>
			<x path="Bool"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_altKey>
	<set_altKey get="inline" set="null" line="40" static="1">
		<f a="this:value">
			<x path="Int"/>
			<x path="Bool"/>
			<x path="Bool"/>
		</f>
		<meta><m n=":impl"/></meta>
	</set_altKey>
	<get_capsLock set="method" line="57" static="1">
		<f a="this">
			<x path="Int"/>
			<x path="Bool"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_capsLock>
	<set_capsLock get="inline" set="null" line="64" static="1">
		<f a="this:value">
			<x path="Int"/>
			<x path="Bool"/>
			<x path="Bool"/>
		</f>
		<meta><m n=":impl"/></meta>
	</set_capsLock>
	<get_ctrlKey set="method" line="81" static="1">
		<f a="this">
			<x path="Int"/>
			<x path="Bool"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_ctrlKey>
	<set_ctrlKey get="inline" set="null" line="88" static="1">
		<f a="this:value">
			<x path="Int"/>
			<x path="Bool"/>
			<x path="Bool"/>
		</f>
		<meta><m n=":impl"/></meta>
	</set_ctrlKey>
	<get_metaKey set="method" line="105" static="1">
		<f a="this">
			<x path="Int"/>
			<x path="Bool"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_metaKey>
	<set_metaKey get="inline" set="null" line="112" static="1">
		<f a="this:value">
			<x path="Int"/>
			<x path="Bool"/>
			<x path="Bool"/>
		</f>
		<meta><m n=":impl"/></meta>
	</set_metaKey>
	<get_numLock set="method" line="129" static="1">
		<f a="this">
			<x path="Int"/>
			<x path="Bool"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_numLock>
	<set_numLock get="inline" set="null" line="136" static="1">
		<f a="this:value">
			<x path="Int"/>
			<x path="Bool"/>
			<x path="Bool"/>
		</f>
		<meta><m n=":impl"/></meta>
	</set_numLock>
	<get_shiftKey set="method" line="153" static="1">
		<f a="this">
			<x path="Int"/>
			<x path="Bool"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_shiftKey>
	<set_shiftKey get="inline" set="null" line="160" static="1">
		<f a="this:value">
			<x path="Int"/>
			<x path="Bool"/>
			<x path="Bool"/>
		</f>
		<meta><m n=":impl"/></meta>
	</set_shiftKey>
	<meta>
		<m n=":directlyUsed"/>
		<m n=":final"/>
	</meta>
</class></impl>
	</abstract>
	<class path="lime.ui._KeyModifier.KeyModifier_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/ui/KeyModifier.hx" private="1" module="lime.ui.KeyModifier">
		<NONE public="1" get="inline" set="null" expr="0x0000" line="7" static="1">
			<x path="lime.ui.KeyModifier"/>
			<meta><m n=":value"><e>0x0000</e></m></meta>
		</NONE>
		<LEFT_SHIFT public="1" get="inline" set="null" expr="0x0001" line="8" static="1">
			<x path="lime.ui.KeyModifier"/>
			<meta><m n=":value"><e>0x0001</e></m></meta>
		</LEFT_SHIFT>
		<RIGHT_SHIFT public="1" get="inline" set="null" expr="0x0002" line="9" static="1">
			<x path="lime.ui.KeyModifier"/>
			<meta><m n=":value"><e>0x0002</e></m></meta>
		</RIGHT_SHIFT>
		<LEFT_CTRL public="1" get="inline" set="null" expr="0x0040" line="10" static="1">
			<x path="lime.ui.KeyModifier"/>
			<meta><m n=":value"><e>0x0040</e></m></meta>
		</LEFT_CTRL>
		<RIGHT_CTRL public="1" get="inline" set="null" expr="0x0080" line="11" static="1">
			<x path="lime.ui.KeyModifier"/>
			<meta><m n=":value"><e>0x0080</e></m></meta>
		</RIGHT_CTRL>
		<LEFT_ALT public="1" get="inline" set="null" expr="0x0100" line="12" static="1">
			<x path="lime.ui.KeyModifier"/>
			<meta><m n=":value"><e>0x0100</e></m></meta>
		</LEFT_ALT>
		<RIGHT_ALT public="1" get="inline" set="null" expr="0x0200" line="13" static="1">
			<x path="lime.ui.KeyModifier"/>
			<meta><m n=":value"><e>0x0200</e></m></meta>
		</RIGHT_ALT>
		<LEFT_META public="1" get="inline" set="null" expr="0x0400" line="14" static="1">
			<x path="lime.ui.KeyModifier"/>
			<meta><m n=":value"><e>0x0400</e></m></meta>
		</LEFT_META>
		<RIGHT_META public="1" get="inline" set="null" expr="0x0800" line="15" static="1">
			<x path="lime.ui.KeyModifier"/>
			<meta><m n=":value"><e>0x0800</e></m></meta>
		</RIGHT_META>
		<NUM_LOCK public="1" get="inline" set="null" expr="0x1000" line="16" static="1">
			<x path="lime.ui.KeyModifier"/>
			<meta><m n=":value"><e>0x1000</e></m></meta>
		</NUM_LOCK>
		<CAPS_LOCK public="1" get="inline" set="null" expr="0x2000" line="17" static="1">
			<x path="lime.ui.KeyModifier"/>
			<meta><m n=":value"><e>0x2000</e></m></meta>
		</CAPS_LOCK>
		<MODE public="1" get="inline" set="null" expr="0x4000" line="18" static="1">
			<x path="lime.ui.KeyModifier"/>
			<meta><m n=":value"><e>0x4000</e></m></meta>
		</MODE>
		<CTRL public="1" get="inline" set="null" expr="(0x0040 | 0x0080)" line="20" static="1">
			<x path="lime.ui.KeyModifier"/>
			<meta><m n=":value"><e>(0x0040 | 0x0080)</e></m></meta>
		</CTRL>
		<SHIFT public="1" get="inline" set="null" expr="(0x001 | 0x0002)" line="21" static="1">
			<x path="lime.ui.KeyModifier"/>
			<meta><m n=":value"><e>(0x001 | 0x0002)</e></m></meta>
		</SHIFT>
		<ALT public="1" get="inline" set="null" expr="(0x0100 | 0x0200)" line="22" static="1">
			<x path="lime.ui.KeyModifier"/>
			<meta><m n=":value"><e>(0x0100 | 0x0200)</e></m></meta>
		</ALT>
		<META public="1" get="inline" set="null" expr="(0x0400 | 0x0800)" line="23" static="1">
			<x path="lime.ui.KeyModifier"/>
			<meta><m n=":value"><e>(0x0400 | 0x0800)</e></m></meta>
		</META>
		<altKey public="1" get="accessor" set="accessor" static="1">
			<x path="Bool"/>
			<meta><m n=":impl"/></meta>
		</altKey>
		<capsLock public="1" get="accessor" set="accessor" static="1">
			<x path="Bool"/>
			<meta><m n=":impl"/></meta>
		</capsLock>
		<ctrlKey public="1" get="accessor" set="accessor" static="1">
			<x path="Bool"/>
			<meta><m n=":impl"/></meta>
		</ctrlKey>
		<metaKey public="1" get="accessor" set="accessor" static="1">
			<x path="Bool"/>
			<meta><m n=":impl"/></meta>
		</metaKey>
		<numLock public="1" get="accessor" set="accessor" static="1">
			<x path="Bool"/>
			<meta><m n=":impl"/></meta>
		</numLock>
		<shiftKey public="1" get="accessor" set="accessor" static="1">
			<x path="Bool"/>
			<meta><m n=":impl"/></meta>
		</shiftKey>
		<get_altKey set="method" line="33" static="1">
			<f a="this">
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_altKey>
		<set_altKey get="inline" set="null" line="40" static="1">
			<f a="this:value">
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":impl"/></meta>
		</set_altKey>
		<get_capsLock set="method" line="57" static="1">
			<f a="this">
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_capsLock>
		<set_capsLock get="inline" set="null" line="64" static="1">
			<f a="this:value">
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":impl"/></meta>
		</set_capsLock>
		<get_ctrlKey set="method" line="81" static="1">
			<f a="this">
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_ctrlKey>
		<set_ctrlKey get="inline" set="null" line="88" static="1">
			<f a="this:value">
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":impl"/></meta>
		</set_ctrlKey>
		<get_metaKey set="method" line="105" static="1">
			<f a="this">
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_metaKey>
		<set_metaKey get="inline" set="null" line="112" static="1">
			<f a="this:value">
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":impl"/></meta>
		</set_metaKey>
		<get_numLock set="method" line="129" static="1">
			<f a="this">
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_numLock>
		<set_numLock get="inline" set="null" line="136" static="1">
			<f a="this:value">
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":impl"/></meta>
		</set_numLock>
		<get_shiftKey set="method" line="153" static="1">
			<f a="this">
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_shiftKey>
		<set_shiftKey get="inline" set="null" line="160" static="1">
			<f a="this:value">
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":impl"/></meta>
		</set_shiftKey>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":final"/>
		</meta>
	</class>
	<class path="lime.ui.Mouse" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/ui/Mouse.hx">
		<cursor public="1" get="accessor" set="accessor" static="1"><e path="lime.ui.MouseCursor"/></cursor>
		<lock public="1" get="accessor" set="accessor" static="1"><x path="Bool"/></lock>
		<hide public="1" set="method" line="11" static="1"><f a=""><x path="Void"/></f></hide>
		<show public="1" set="method" line="18" static="1"><f a=""><x path="Void"/></f></show>
		<warp public="1" set="method" line="25" static="1">
			<f a="x:y:?window" v="::null">
				<x path="Int"/>
				<x path="Int"/>
				<c path="lime.ui.Window"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ window : null }</e></m></meta>
		</warp>
		<get_cursor set="method" line="39" static="1"><f a=""><e path="lime.ui.MouseCursor"/></f></get_cursor>
		<set_cursor set="method" line="46" static="1"><f a="value">
	<e path="lime.ui.MouseCursor"/>
	<e path="lime.ui.MouseCursor"/>
</f></set_cursor>
		<get_lock set="method" line="53" static="1"><f a=""><x path="Bool"/></f></get_lock>
		<set_lock set="method" line="60" static="1"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_lock>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<typedef path="lime.ui._Mouse.MouseBackend" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/ui/Mouse.hx" private="1" module="lime.ui.Mouse">
		<c path="lime._backend.native.NativeMouse"/>
		<meta><m n=":noCompletion"/></meta>
	</typedef>
	<enum path="lime.ui.MouseCursor" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/ui/MouseCursor.hx">
		<ARROW/>
		<CROSSHAIR/>
		<DEFAULT/>
		<MOVE/>
		<POINTER/>
		<RESIZE_NESW/>
		<RESIZE_NS/>
		<RESIZE_NWSE/>
		<RESIZE_WE/>
		<TEXT/>
		<WAIT/>
		<WAIT_ARROW/>
		<CUSTOM/>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<class path="lime.ui.Touch" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/ui/Touch.hx">
		<onEnd public="1" expr="new Event&lt;Touch&gt;()" line="10" static="1">
			<c path="lime.app.Event_lime_ui_Touch_Void"><f a="">
	<c path="lime.ui.Touch"/>
	<x path="Void"/>
</f></c>
			<meta><m n=":value"><e><![CDATA[new Event<Touch>()]]></e></m></meta>
		</onEnd>
		<onMove public="1" expr="new Event&lt;Touch&gt;()" line="11" static="1">
			<c path="lime.app.Event_lime_ui_Touch_Void"><f a="">
	<c path="lime.ui.Touch"/>
	<x path="Void"/>
</f></c>
			<meta><m n=":value"><e><![CDATA[new Event<Touch>()]]></e></m></meta>
		</onMove>
		<onStart public="1" expr="new Event&lt;Touch&gt;()" line="12" static="1">
			<c path="lime.app.Event_lime_ui_Touch_Void"><f a="">
	<c path="lime.ui.Touch"/>
	<x path="Void"/>
</f></c>
			<meta><m n=":value"><e><![CDATA[new Event<Touch>()]]></e></m></meta>
		</onStart>
		<device public="1"><x path="Int"/></device>
		<dx public="1"><x path="Float"/></dx>
		<dy public="1"><x path="Float"/></dy>
		<id public="1"><x path="Int"/></id>
		<pressure public="1"><x path="Float"/></pressure>
		<x public="1"><x path="Float"/></x>
		<y public="1"><x path="Float"/></y>
		<new public="1" set="method" line="23"><f a="x:y:id:dx:dy:pressure:device">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="lime.ui.Window" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/ui/Window.hx">
		<application public="1" set="null"><c path="lime.app.Application"/></application>
		<borderless public="1" get="accessor" set="accessor"><x path="Bool"/></borderless>
		<config public="1"><t path="lime.app.WindowConfig"/></config>
		<display public="1" get="accessor" set="null"><c path="lime.system.Display"/></display>
		<enableTextEvents public="1" get="accessor" set="accessor"><x path="Bool"/></enableTextEvents>
		<fullscreen public="1" get="accessor" set="accessor"><x path="Bool"/></fullscreen>
		<height public="1" get="accessor" set="accessor"><x path="Int"/></height>
		<id public="1" set="null"><x path="Int"/></id>
		<maximized public="1" get="accessor" set="accessor"><x path="Bool"/></maximized>
		<minimized public="1" get="accessor" set="accessor"><x path="Bool"/></minimized>
		<onActivate public="1" expr="new Event&lt;Void&gt;()">
			<c path="lime.app.Event_Void_Void"><f a=""><x path="Void"/></f></c>
			<meta><m n=":value"><e><![CDATA[new Event<Void>()]]></e></m></meta>
		</onActivate>
		<onClose public="1" expr="new Event&lt;Void&gt;()">
			<c path="lime.app.Event_Void_Void"><f a=""><x path="Void"/></f></c>
			<meta><m n=":value"><e><![CDATA[new Event<Void>()]]></e></m></meta>
		</onClose>
		<onCreate public="1" expr="new Event&lt;Void&gt;()">
			<c path="lime.app.Event_Void_Void"><f a=""><x path="Void"/></f></c>
			<meta><m n=":value"><e><![CDATA[new Event<Void>()]]></e></m></meta>
		</onCreate>
		<onDeactivate public="1" expr="new Event&lt;Void&gt;()">
			<c path="lime.app.Event_Void_Void"><f a=""><x path="Void"/></f></c>
			<meta><m n=":value"><e><![CDATA[new Event<Void>()]]></e></m></meta>
		</onDeactivate>
		<onDropFile public="1" expr="new Event&lt;String&gt;()">
			<c path="lime.app.Event_String_Void"><f a="">
	<c path="String"/>
	<x path="Void"/>
</f></c>
			<meta><m n=":value"><e><![CDATA[new Event<String>()]]></e></m></meta>
		</onDropFile>
		<onEnter public="1" expr="new Event&lt;Void&gt;()">
			<c path="lime.app.Event_Void_Void"><f a=""><x path="Void"/></f></c>
			<meta><m n=":value"><e><![CDATA[new Event<Void>()]]></e></m></meta>
		</onEnter>
		<onFocusIn public="1" expr="new Event&lt;Void&gt;()">
			<c path="lime.app.Event_Void_Void"><f a=""><x path="Void"/></f></c>
			<meta><m n=":value"><e><![CDATA[new Event<Void>()]]></e></m></meta>
		</onFocusIn>
		<onFocusOut public="1" expr="new Event&lt;Void&gt;()">
			<c path="lime.app.Event_Void_Void"><f a=""><x path="Void"/></f></c>
			<meta><m n=":value"><e><![CDATA[new Event<Void>()]]></e></m></meta>
		</onFocusOut>
		<onFullscreen public="1" expr="new Event&lt;Void&gt;()">
			<c path="lime.app.Event_Void_Void"><f a=""><x path="Void"/></f></c>
			<meta><m n=":value"><e><![CDATA[new Event<Void>()]]></e></m></meta>
		</onFullscreen>
		<onKeyDown public="1" expr="new Event&lt;KeyCode -&gt; KeyModifier&gt;()">
			<c path="lime.app.Event_lime_ui_KeyCode_lime_ui_KeyModifier_Void"><f a=":">
	<x path="lime.ui.KeyCode"/>
	<x path="lime.ui.KeyModifier"/>
	<x path="Void"/>
</f></c>
			<meta><m n=":value"><e><![CDATA[new Event<KeyCode -> KeyModifier>()]]></e></m></meta>
		</onKeyDown>
		<onKeyUp public="1" expr="new Event&lt;KeyCode -&gt; KeyModifier&gt;()">
			<c path="lime.app.Event_lime_ui_KeyCode_lime_ui_KeyModifier_Void"><f a=":">
	<x path="lime.ui.KeyCode"/>
	<x path="lime.ui.KeyModifier"/>
	<x path="Void"/>
</f></c>
			<meta><m n=":value"><e><![CDATA[new Event<KeyCode -> KeyModifier>()]]></e></m></meta>
		</onKeyUp>
		<onLeave public="1" expr="new Event&lt;Void&gt;()">
			<c path="lime.app.Event_Void_Void"><f a=""><x path="Void"/></f></c>
			<meta><m n=":value"><e><![CDATA[new Event<Void>()]]></e></m></meta>
		</onLeave>
		<onMinimize public="1" expr="new Event&lt;Void&gt;()">
			<c path="lime.app.Event_Void_Void"><f a=""><x path="Void"/></f></c>
			<meta><m n=":value"><e><![CDATA[new Event<Void>()]]></e></m></meta>
		</onMinimize>
		<onMouseDown public="1" expr="new Event&lt;Float -&gt; Float -&gt; Int&gt;()">
			<c path="lime.app.Event_Float_Float_Int_Void"><f a="::">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Int"/>
	<x path="Void"/>
</f></c>
			<meta><m n=":value"><e><![CDATA[new Event<Float -> Float -> Int>()]]></e></m></meta>
		</onMouseDown>
		<onMouseMove public="1" expr="new Event&lt;Float -&gt; Float&gt;()">
			<c path="lime.app.Event_Float_Float_Void"><f a=":">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></c>
			<meta><m n=":value"><e><![CDATA[new Event<Float -> Float>()]]></e></m></meta>
		</onMouseMove>
		<onMouseMoveRelative public="1" expr="new Event&lt;Float -&gt; Float&gt;()">
			<c path="lime.app.Event_Float_Float_Void"><f a=":">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></c>
			<meta><m n=":value"><e><![CDATA[new Event<Float -> Float>()]]></e></m></meta>
		</onMouseMoveRelative>
		<onMouseUp public="1" expr="new Event&lt;Float -&gt; Float -&gt; Int&gt;()">
			<c path="lime.app.Event_Float_Float_Int_Void"><f a="::">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Int"/>
	<x path="Void"/>
</f></c>
			<meta><m n=":value"><e><![CDATA[new Event<Float -> Float -> Int>()]]></e></m></meta>
		</onMouseUp>
		<onMouseWheel public="1" expr="new Event&lt;Float -&gt; Float&gt;()">
			<c path="lime.app.Event_Float_Float_Void"><f a=":">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></c>
			<meta><m n=":value"><e><![CDATA[new Event<Float -> Float>()]]></e></m></meta>
		</onMouseWheel>
		<onMove public="1" expr="new Event&lt;Float -&gt; Float&gt;()">
			<c path="lime.app.Event_Float_Float_Void"><f a=":">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></c>
			<meta><m n=":value"><e><![CDATA[new Event<Float -> Float>()]]></e></m></meta>
		</onMove>
		<onResize public="1" expr="new Event&lt;Int -&gt; Int&gt;()">
			<c path="lime.app.Event_Int_Int_Void"><f a=":">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></c>
			<meta><m n=":value"><e><![CDATA[new Event<Int -> Int>()]]></e></m></meta>
		</onResize>
		<onRestore public="1" expr="new Event&lt;Void&gt;()">
			<c path="lime.app.Event_Void_Void"><f a=""><x path="Void"/></f></c>
			<meta><m n=":value"><e><![CDATA[new Event<Void>()]]></e></m></meta>
		</onRestore>
		<onTextEdit public="1" expr="new Event&lt;String -&gt; Int -&gt; Int&gt;()">
			<c path="lime.app.Event_String_Int_Int_Void"><f a="::">
	<c path="String"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></c>
			<meta><m n=":value"><e><![CDATA[new Event<String -> Int -> Int>()]]></e></m></meta>
		</onTextEdit>
		<onTextInput public="1" expr="new Event&lt;String&gt;()">
			<c path="lime.app.Event_String_Void"><f a="">
	<c path="String"/>
	<x path="Void"/>
</f></c>
			<meta><m n=":value"><e><![CDATA[new Event<String>()]]></e></m></meta>
		</onTextInput>
		<renderer public="1"><c path="lime.graphics.Renderer"/></renderer>
		<resizable public="1" get="accessor" set="accessor"><x path="Bool"/></resizable>
		<scale public="1" get="accessor" set="null"><x path="Float"/></scale>
		<stage public="1"><c path="openfl.display.Stage"/></stage>
		<title public="1" get="accessor" set="accessor"><c path="String"/></title>
		<width public="1" get="accessor" set="accessor"><x path="Int"/></width>
		<x public="1" get="accessor" set="accessor"><x path="Int"/></x>
		<y public="1" get="accessor" set="accessor"><x path="Int"/></y>
		<backend>
			<t path="lime.ui._Window.WindowBackend"/>
			<meta><m n=":noCompletion"/></meta>
		</backend>
		<__borderless>
			<x path="Bool"/>
			<meta><m n=":noCompletion"/></meta>
		</__borderless>
		<__fullscreen>
			<x path="Bool"/>
			<meta><m n=":noCompletion"/></meta>
		</__fullscreen>
		<__height>
			<x path="Int"/>
			<meta><m n=":noCompletion"/></meta>
		</__height>
		<__maximized>
			<x path="Bool"/>
			<meta><m n=":noCompletion"/></meta>
		</__maximized>
		<__minimized>
			<x path="Bool"/>
			<meta><m n=":noCompletion"/></meta>
		</__minimized>
		<__resizable>
			<x path="Bool"/>
			<meta><m n=":noCompletion"/></meta>
		</__resizable>
		<__scale>
			<x path="Float"/>
			<meta><m n=":noCompletion"/></meta>
		</__scale>
		<__title>
			<c path="String"/>
			<meta><m n=":noCompletion"/></meta>
		</__title>
		<__width>
			<x path="Int"/>
			<meta><m n=":noCompletion"/></meta>
		</__width>
		<__x>
			<x path="Int"/>
			<meta><m n=":noCompletion"/></meta>
		</__x>
		<__y>
			<x path="Int"/>
			<meta><m n=":noCompletion"/></meta>
		</__y>
		<alert public="1" set="method" line="110">
			<f a="?message:?title" v="null:null">
				<c path="String"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ title : null, message : null }</e></m></meta>
		</alert>
		<close public="1" set="method" line="117"><f a=""><x path="Void"/></f></close>
		<create public="1" set="method" line="124"><f a="application">
	<c path="lime.app.Application"/>
	<x path="Void"/>
</f></create>
		<focus public="1" set="method" line="266"><f a=""><x path="Void"/></f></focus>
		<move public="1" set="method" line="273"><f a="x:y">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></move>
		<resize public="1" set="method" line="283"><f a="width:height">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></resize>
		<setIcon public="1" set="method" line="293"><f a="image">
	<c path="lime.graphics.Image"/>
	<x path="Void"/>
</f></setIcon>
		<toString public="1" set="method" line="306"><f a=""><c path="String"/></f></toString>
		<get_display set="method" line="320">
			<f a=""><c path="lime.system.Display"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_display>
		<get_borderless get="inline" set="null" line="327">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_borderless>
		<set_borderless set="method" line="334">
			<f a="value">
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_borderless>
		<get_enableTextEvents get="inline" set="null" line="341">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_enableTextEvents>
		<set_enableTextEvents get="inline" set="null" line="348">
			<f a="value">
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_enableTextEvents>
		<get_fullscreen get="inline" set="null" line="355">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_fullscreen>
		<set_fullscreen set="method" line="362">
			<f a="value">
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_fullscreen>
		<get_height get="inline" set="null" line="369">
			<f a=""><x path="Int"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_height>
		<set_height set="method" line="376">
			<f a="value">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_height>
		<get_maximized get="inline" set="null" line="384">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_maximized>
		<set_maximized get="inline" set="null" line="391">
			<f a="value">
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_maximized>
		<get_minimized get="inline" set="null" line="399">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_minimized>
		<set_minimized set="method" line="406">
			<f a="value">
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_minimized>
		<get_resizable get="inline" set="null" line="414">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_resizable>
		<set_resizable set="method" line="421">
			<f a="value">
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_resizable>
		<get_scale get="inline" set="null" line="429">
			<f a=""><x path="Float"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_scale>
		<get_title get="inline" set="null" line="436">
			<f a=""><c path="String"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_title>
		<set_title set="method" line="443">
			<f a="value">
				<c path="String"/>
				<c path="String"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_title>
		<get_width get="inline" set="null" line="450">
			<f a=""><x path="Int"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_width>
		<set_width set="method" line="457">
			<f a="value">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_width>
		<get_x get="inline" set="null" line="465">
			<f a=""><x path="Int"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_x>
		<set_x set="method" line="472">
			<f a="value">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_x>
		<get_y get="inline" set="null" line="480">
			<f a=""><x path="Int"/></f>
			<meta><m n=":noCompletion"/></meta>
		</get_y>
		<set_y set="method" line="487">
			<f a="value">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_y>
		<new public="1" set="method" line="79">
			<f a="?config" v="null">
				<t path="lime.app.WindowConfig"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ config : null }</e></m></meta>
		</new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<typedef path="lime.ui._Window.WindowBackend" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/ui/Window.hx" private="1" module="lime.ui.Window">
		<c path="lime._backend.native.NativeWindow"/>
		<meta><m n=":noCompletion"/></meta>
	</typedef>
	<abstract path="lime.utils.ArrayBuffer" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/utils/ArrayBuffer.hx">
		<from><icast><c path="haxe.io.Bytes"/></icast></from>
		<this><c path="haxe.io.Bytes"/></this>
		<to><icast><c path="haxe.io.Bytes"/></icast></to>
		<meta><m n=":forward"/></meta>
		<impl><class path="lime.utils._ArrayBuffer.ArrayBuffer_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/utils/ArrayBuffer.hx" private="1" module="lime.utils.ArrayBuffer">
	<_new public="1" get="inline" set="null" line="13" static="1">
		<f a="byteLength">
			<x path="Int"/>
			<x path="lime.utils.ArrayBuffer"/>
		</f>
		<meta><m n=":impl"/></meta>
	</_new>
	<meta><m n=":final"/></meta>
</class></impl>
	</abstract>
	<class path="lime.utils._ArrayBuffer.ArrayBuffer_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/utils/ArrayBuffer.hx" private="1" module="lime.utils.ArrayBuffer">
		<_new public="1" get="inline" set="null" line="13" static="1">
			<f a="byteLength">
				<x path="Int"/>
				<x path="lime.utils.ArrayBuffer"/>
			</f>
			<meta><m n=":impl"/></meta>
		</_new>
		<meta><m n=":final"/></meta>
	</class>
	<abstract path="lime.utils._ArrayBufferView.TypedArrayType" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/utils/ArrayBufferView.hx" private="1" module="lime.utils.ArrayBufferView">
		<from><icast><x path="Int"/></icast></from>
		<this><x path="Int"/></this>
		<to><icast><x path="Int"/></icast></to>
		<meta>
			<m n=":noCompletion"/>
			<m n=":dox"><e>hide</e></m>
			<m n=":enum"/>
		</meta>
		<impl><class path="lime.utils._ArrayBufferView.TypedArrayType_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/utils/ArrayBufferView.hx" private="1" module="lime.utils.ArrayBufferView" extern="1">
	<None public="1" get="inline" set="null" expr="cast 0" line="362" static="1">
		<x path="lime.utils._ArrayBufferView.TypedArrayType"/>
		<meta>
			<m n=":value"><e>cast 0</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</None>
	<Int8 public="1" get="inline" set="null" expr="cast 1" line="363" static="1">
		<x path="lime.utils._ArrayBufferView.TypedArrayType"/>
		<meta>
			<m n=":value"><e>cast 1</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Int8>
	<Int16 public="1" get="inline" set="null" expr="cast 2" line="364" static="1">
		<x path="lime.utils._ArrayBufferView.TypedArrayType"/>
		<meta>
			<m n=":value"><e>cast 2</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Int16>
	<Int32 public="1" get="inline" set="null" expr="cast 3" line="365" static="1">
		<x path="lime.utils._ArrayBufferView.TypedArrayType"/>
		<meta>
			<m n=":value"><e>cast 3</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Int32>
	<Uint8 public="1" get="inline" set="null" expr="cast 4" line="366" static="1">
		<x path="lime.utils._ArrayBufferView.TypedArrayType"/>
		<meta>
			<m n=":value"><e>cast 4</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Uint8>
	<Uint8Clamped public="1" get="inline" set="null" expr="cast 5" line="367" static="1">
		<x path="lime.utils._ArrayBufferView.TypedArrayType"/>
		<meta>
			<m n=":value"><e>cast 5</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Uint8Clamped>
	<Uint16 public="1" get="inline" set="null" expr="cast 6" line="368" static="1">
		<x path="lime.utils._ArrayBufferView.TypedArrayType"/>
		<meta>
			<m n=":value"><e>cast 6</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Uint16>
	<Uint32 public="1" get="inline" set="null" expr="cast 7" line="369" static="1">
		<x path="lime.utils._ArrayBufferView.TypedArrayType"/>
		<meta>
			<m n=":value"><e>cast 7</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Uint32>
	<Float32 public="1" get="inline" set="null" expr="cast 8" line="370" static="1">
		<x path="lime.utils._ArrayBufferView.TypedArrayType"/>
		<meta>
			<m n=":value"><e>cast 8</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Float32>
	<Float64 public="1" get="inline" set="null" expr="cast 9" line="371" static="1">
		<x path="lime.utils._ArrayBufferView.TypedArrayType"/>
		<meta>
			<m n=":value"><e>cast 9</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Float64>
	<meta>
		<m n=":final"/>
		<m n=":enum"/>
	</meta>
</class></impl>
	</abstract>
	<class path="lime.utils._ArrayBufferView.TypedArrayType_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/utils/ArrayBufferView.hx" private="1" module="lime.utils.ArrayBufferView" extern="1">
		<None public="1" get="inline" set="null" expr="cast 0" line="362" static="1">
			<x path="lime.utils._ArrayBufferView.TypedArrayType"/>
			<meta>
				<m n=":value"><e>cast 0</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</None>
		<Int8 public="1" get="inline" set="null" expr="cast 1" line="363" static="1">
			<x path="lime.utils._ArrayBufferView.TypedArrayType"/>
			<meta>
				<m n=":value"><e>cast 1</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Int8>
		<Int16 public="1" get="inline" set="null" expr="cast 2" line="364" static="1">
			<x path="lime.utils._ArrayBufferView.TypedArrayType"/>
			<meta>
				<m n=":value"><e>cast 2</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Int16>
		<Int32 public="1" get="inline" set="null" expr="cast 3" line="365" static="1">
			<x path="lime.utils._ArrayBufferView.TypedArrayType"/>
			<meta>
				<m n=":value"><e>cast 3</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Int32>
		<Uint8 public="1" get="inline" set="null" expr="cast 4" line="366" static="1">
			<x path="lime.utils._ArrayBufferView.TypedArrayType"/>
			<meta>
				<m n=":value"><e>cast 4</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Uint8>
		<Uint8Clamped public="1" get="inline" set="null" expr="cast 5" line="367" static="1">
			<x path="lime.utils._ArrayBufferView.TypedArrayType"/>
			<meta>
				<m n=":value"><e>cast 5</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Uint8Clamped>
		<Uint16 public="1" get="inline" set="null" expr="cast 6" line="368" static="1">
			<x path="lime.utils._ArrayBufferView.TypedArrayType"/>
			<meta>
				<m n=":value"><e>cast 6</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Uint16>
		<Uint32 public="1" get="inline" set="null" expr="cast 7" line="369" static="1">
			<x path="lime.utils._ArrayBufferView.TypedArrayType"/>
			<meta>
				<m n=":value"><e>cast 7</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Uint32>
		<Float32 public="1" get="inline" set="null" expr="cast 8" line="370" static="1">
			<x path="lime.utils._ArrayBufferView.TypedArrayType"/>
			<meta>
				<m n=":value"><e>cast 8</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Float32>
		<Float64 public="1" get="inline" set="null" expr="cast 9" line="371" static="1">
			<x path="lime.utils._ArrayBufferView.TypedArrayType"/>
			<meta>
				<m n=":value"><e>cast 9</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Float64>
		<meta>
			<m n=":final"/>
			<m n=":enum"/>
		</meta>
	</class>
	<class path="lime.utils.ArrayBufferIO" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/utils/ArrayBufferView.hx" module="lime.utils.ArrayBufferView">
		<getInt8 public="1" get="inline" set="null" line="379" static="1"><f a="buffer:byteOffset">
	<x path="lime.utils.ArrayBuffer"/>
	<x path="Int"/>
	<x path="Int"/>
</f></getInt8>
		<setInt8 public="1" get="inline" set="null" line="391" static="1">
			<f a="buffer:byteOffset:value">
				<x path="lime.utils.ArrayBuffer"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</setInt8>
		<getUint8 public="1" get="inline" set="null" line="406" static="1"><f a="buffer:byteOffset">
	<x path="lime.utils.ArrayBuffer"/>
	<x path="Int"/>
	<t path="Null"><x path="UInt"/></t>
</f></getUint8>
		<setUint8Clamped public="1" get="inline" set="null" line="417" static="1"><f a="buffer:byteOffset:value">
	<x path="lime.utils.ArrayBuffer"/>
	<x path="Int"/>
	<x path="UInt"/>
	<x path="UInt"/>
</f></setUint8Clamped>
		<setUint8 public="1" get="inline" set="null" line="424" static="1"><f a="buffer:byteOffset:value">
	<x path="lime.utils.ArrayBuffer"/>
	<x path="Int"/>
	<x path="UInt"/>
	<x path="UInt"/>
</f></setUint8>
		<getInt16 public="1" set="method" line="436" static="1">
			<f a="buffer:byteOffset:?littleEndian" v="::true">
				<x path="lime.utils.ArrayBuffer"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Int"/>
			</f>
			<meta><m n=":value"><e>{ littleEndian : true }</e></m></meta>
		</getInt16>
		<setInt16 public="1" set="method" line="456" static="1">
			<f a="buffer:byteOffset:value:?littleEndian" v=":::true">
				<x path="lime.utils.ArrayBuffer"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Int"/>
			</f>
			<meta>
				<m n=":has_untyped"/>
				<m n=":value"><e>{ littleEndian : true }</e></m>
			</meta>
		</setInt16>
		<getUint16 public="1" get="inline" set="null" line="485" static="1">
			<f a="buffer:byteOffset:?littleEndian" v="::true">
				<x path="lime.utils.ArrayBuffer"/>
				<x path="Int"/>
				<x path="Bool"/>
				<t path="Null"><x path="UInt"/></t>
			</f>
			<meta><m n=":value"><e>{ littleEndian : true }</e></m></meta>
		</getUint16>
		<setUint16 public="1" get="inline" set="null" line="504" static="1">
			<f a="buffer:byteOffset:value:?littleEndian" v=":::true">
				<x path="lime.utils.ArrayBuffer"/>
				<x path="Int"/>
				<x path="UInt"/>
				<x path="Bool"/>
				<x path="UInt"/>
			</f>
			<meta><m n=":value"><e>{ littleEndian : true }</e></m></meta>
		</setUint16>
		<getInt32 public="1" get="inline" set="null" line="517" static="1">
			<f a="buffer:byteOffset:?littleEndian" v="::true">
				<x path="lime.utils.ArrayBuffer"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Int"/>
			</f>
			<meta><m n=":value"><e>{ littleEndian : true }</e></m></meta>
		</getInt32>
		<setInt32 public="1" get="inline" set="null" line="542" static="1">
			<f a="buffer:byteOffset:value:?littleEndian" v=":::true">
				<x path="lime.utils.ArrayBuffer"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Int"/>
			</f>
			<meta><m n=":value"><e>{ littleEndian : true }</e></m></meta>
		</setInt32>
		<getUint32 public="1" get="inline" set="null" line="569" static="1">
			<f a="buffer:byteOffset:?littleEndian" v="::true">
				<x path="lime.utils.ArrayBuffer"/>
				<x path="Int"/>
				<x path="Bool"/>
				<t path="Null"><x path="UInt"/></t>
			</f>
			<meta><m n=":value"><e>{ littleEndian : true }</e></m></meta>
		</getUint32>
		<setUint32 public="1" get="inline" set="null" line="580" static="1">
			<f a="buffer:byteOffset:value:?littleEndian" v=":::true">
				<x path="lime.utils.ArrayBuffer"/>
				<x path="Int"/>
				<x path="UInt"/>
				<x path="Bool"/>
				<x path="UInt"/>
			</f>
			<meta><m n=":value"><e>{ littleEndian : true }</e></m></meta>
		</setUint32>
		<getFloat32 public="1" get="inline" set="null" line="593" static="1">
			<f a="buffer:byteOffset:?littleEndian" v="::true">
				<x path="lime.utils.ArrayBuffer"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Float"/>
			</f>
			<meta><m n=":value"><e>{ littleEndian : true }</e></m></meta>
		</getFloat32>
		<setFloat32 public="1" get="inline" set="null" line="604" static="1">
			<f a="buffer:byteOffset:value:?littleEndian" v=":::true">
				<x path="lime.utils.ArrayBuffer"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Float"/>
			</f>
			<meta><m n=":value"><e>{ littleEndian : true }</e></m></meta>
		</setFloat32>
		<getFloat64 public="1" get="inline" set="null" line="617" static="1">
			<f a="buffer:byteOffset:?littleEndian" v="::true">
				<x path="lime.utils.ArrayBuffer"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Float"/>
			</f>
			<meta><m n=":value"><e>{ littleEndian : true }</e></m></meta>
		</getFloat64>
		<setFloat64 public="1" get="inline" set="null" line="628" static="1">
			<f a="buffer:byteOffset:value:?littleEndian" v=":::true">
				<x path="lime.utils.ArrayBuffer"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Float"/>
			</f>
			<meta><m n=":value"><e>{ littleEndian : true }</e></m></meta>
		</setFloat64>
		<_clamp get="inline" set="null" line="644" static="1"><f a="_in">
	<x path="Float"/>
	<x path="Int"/>
</f></_clamp>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":noCompletion"/>
			<m n=":dox"><e>hide</e></m>
		</meta>
	</class>
	<class path="lime.utils.Bytes" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/utils/Bytes.hx">
		<extends path="haxe.io.Bytes"/>
		<alloc public="1" set="method" line="28" static="1"><f a="length">
	<x path="Int"/>
	<c path="lime.utils.Bytes"/>
</f></alloc>
		<fastGet public="1" get="inline" set="null" line="36" static="1"><f a="b:pos">
	<t path="haxe.io.BytesData"/>
	<x path="Int"/>
	<x path="Int"/>
</f></fastGet>
		<ofData public="1" set="method" line="43" static="1"><f a="b">
	<t path="haxe.io.BytesData"/>
	<c path="lime.utils.Bytes"/>
</f></ofData>
		<ofString public="1" set="method" line="51" static="1"><f a="s">
	<c path="String"/>
	<c path="lime.utils.Bytes"/>
</f></ofString>
		<readFile public="1" set="method" line="59" static="1"><f a="path">
	<c path="String"/>
	<c path="lime.utils.Bytes"/>
</f></readFile>
		<__fromNativePointer public="1" set="method" line="71" static="1"><f a="data:length">
	<d/>
	<x path="Int"/>
	<c path="lime.utils.Bytes"/>
</f></__fromNativePointer>
		<lime_bytes_from_data_pointer get="inline" set="null" line="88" static="1">
			<f a="data:length">
				<x path="Float"/>
				<x path="Int"/>
				<d/>
			</f>
			<meta><m n=":cffi"/></meta>
		</lime_bytes_from_data_pointer>
		<lime_bytes_get_data_pointer get="inline" set="null" line="89" static="1">
			<f a="data">
				<d/>
				<x path="Float"/>
			</f>
			<meta><m n=":cffi"/></meta>
		</lime_bytes_get_data_pointer>
		<lime_bytes_read_file get="inline" set="null" line="90" static="1">
			<f a="path">
				<c path="String"/>
				<d/>
			</f>
			<meta><m n=":cffi"/></meta>
		</lime_bytes_read_file>
		<cffi_lime_bytes_from_data_pointer expr="new cpp.Callable&lt;Float -&gt; Int&gt;(lime.system.CFFI.load(&quot;lime&quot;, &quot;lime_bytes_from_data_pointer&quot;, 2, false))" line="88" static="1">
			<x path="cpp.Callable"><f a=":">
	<x path="Float"/>
	<x path="Int"/>
	<d/>
</f></x>
			<meta><m n=":value"><e><![CDATA[new cpp.Callable<Float -> Int>(lime.system.CFFI.load("lime", "lime_bytes_from_data_pointer", 2, false))]]></e></m></meta>
		</cffi_lime_bytes_from_data_pointer>
		<cffi_lime_bytes_get_data_pointer expr="new cpp.Callable&lt;Dynamic&gt;(lime.system.CFFI.load(&quot;lime&quot;, &quot;lime_bytes_get_data_pointer&quot;, 1, false))" line="89" static="1">
			<x path="cpp.Callable"><f a="">
	<d/>
	<x path="Float"/>
</f></x>
			<meta><m n=":value"><e><![CDATA[new cpp.Callable<Dynamic>(lime.system.CFFI.load("lime", "lime_bytes_get_data_pointer", 1, false))]]></e></m></meta>
		</cffi_lime_bytes_get_data_pointer>
		<cffi_lime_bytes_read_file expr="new cpp.Callable&lt;String&gt;(lime.system.CFFI.load(&quot;lime&quot;, &quot;lime_bytes_read_file&quot;, 1, false))" line="90" static="1">
			<x path="cpp.Callable"><f a="">
	<c path="String"/>
	<d/>
</f></x>
			<meta><m n=":value"><e><![CDATA[new cpp.Callable<String>(lime.system.CFFI.load("lime", "lime_bytes_read_file", 1, false))]]></e></m></meta>
		</cffi_lime_bytes_read_file>
		<new public="1" set="method" line="17"><f a="length:bytesData">
	<x path="Int"/>
	<t path="haxe.io.BytesData"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>lime.system.CFFI.build()</e></m>
			<m n=":autoBuild"><e>lime.Assets.embedBytes()</e></m>
		</meta>
	</class>
	<abstract path="lime.utils.Float32Array" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/utils/Float32Array.hx">
		<from><icast><c path="lime.utils.ArrayBufferView"/></icast></from>
		<this><c path="lime.utils.ArrayBufferView"/></this>
		<to><icast><c path="lime.utils.ArrayBufferView"/></icast></to>
		<meta>
			<m n=":forward"/>
			<m n=":arrayAccess"/>
		</meta>
		<impl><class path="lime.utils._Float32Array.Float32Array_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/utils/Float32Array.hx" private="1" module="lime.utils.Float32Array">
	<BYTES_PER_ELEMENT public="1" get="inline" set="null" expr="4" line="69" static="1">
		<x path="Int"/>
		<meta><m n=":value"><e>4</e></m></meta>
	</BYTES_PER_ELEMENT>
	<length public="1" get="accessor" set="null" static="1">
		<x path="Int"/>
		<meta><m n=":impl"/></meta>
	</length>
	<_new public="1" params="T" get="inline" set="null" line="74" static="1">
		<f a="?elements:?array:?view:?buffer:?byteoffset:?len" v="::::0:">
			<x path="Int"/>
			<c path="Array"><c path="_new.T"/></c>
			<c path="lime.utils.ArrayBufferView"/>
			<x path="lime.utils.ArrayBuffer"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="lime.utils.Float32Array"/>
		</f>
		<meta>
			<m n=":value"><e>{ byteoffset : 0 }</e></m>
			<m n=":impl"/>
			<m n=":generic"/>
		</meta>
	</_new>
	<subarray public="1" get="inline" set="null" line="96" static="1">
		<f a="this:begin:?end" v="::null">
			<c path="lime.utils.ArrayBufferView"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="lime.utils.Float32Array"/>
		</f>
		<meta>
			<m n=":value"><e>{ end : null }</e></m>
			<m n=":impl"/>
		</meta>
	</subarray>
	<fromBytes public="1" set="method" line="100" static="1">
		<f a="bytes:?byteOffset:?len" v=":0:">
			<c path="haxe.io.Bytes"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="lime.utils.Float32Array"/>
		</f>
		<meta><m n=":value"><e>{ byteOffset : 0 }</e></m></meta>
	</fromBytes>
	<toBytes public="1" set="method" line="104" static="1">
		<f a="this">
			<c path="lime.utils.ArrayBufferView"/>
			<c path="haxe.io.Bytes"/>
		</f>
		<meta><m n=":impl"/></meta>
	</toBytes>
	<toString set="method" line="110" static="1">
		<f a="this">
			<c path="lime.utils.ArrayBufferView"/>
			<t path="Null"><c path="String"/></t>
		</f>
		<meta><m n=":impl"/></meta>
	</toString>
	<get_length get="inline" set="null" line="112" static="1">
		<f a="this">
			<c path="lime.utils.ArrayBufferView"/>
			<x path="Int"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_length>
	<__get public="1" get="inline" set="null" line="117" static="1">
		<f a="this:idx">
			<c path="lime.utils.ArrayBufferView"/>
			<x path="Int"/>
			<x path="Float"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
			<m n=":arrayAccess"/>
		</meta>
	</__get>
	<__set public="1" get="inline" set="null" line="123" static="1">
		<f a="this:idx:val">
			<c path="lime.utils.ArrayBufferView"/>
			<x path="Int"/>
			<x path="Float"/>
			<x path="Float"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
			<m n=":arrayAccess"/>
		</meta>
	</__set>
	<meta><m n=":final"/></meta>
</class></impl>
	</abstract>
	<class path="lime.utils._Float32Array.Float32Array_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/utils/Float32Array.hx" private="1" module="lime.utils.Float32Array">
		<BYTES_PER_ELEMENT public="1" get="inline" set="null" expr="4" line="69" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>4</e></m></meta>
		</BYTES_PER_ELEMENT>
		<length public="1" get="accessor" set="null" static="1">
			<x path="Int"/>
			<meta><m n=":impl"/></meta>
		</length>
		<_new public="1" params="T" get="inline" set="null" line="74" static="1">
			<f a="?elements:?array:?view:?buffer:?byteoffset:?len" v="::::0:">
				<x path="Int"/>
				<c path="Array"><c path="_new.T"/></c>
				<c path="lime.utils.ArrayBufferView"/>
				<x path="lime.utils.ArrayBuffer"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="lime.utils.Float32Array"/>
			</f>
			<meta>
				<m n=":value"><e>{ byteoffset : 0 }</e></m>
				<m n=":impl"/>
				<m n=":generic"/>
			</meta>
		</_new>
		<subarray public="1" get="inline" set="null" line="96" static="1">
			<f a="this:begin:?end" v="::null">
				<c path="lime.utils.ArrayBufferView"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="lime.utils.Float32Array"/>
			</f>
			<meta>
				<m n=":value"><e>{ end : null }</e></m>
				<m n=":impl"/>
			</meta>
		</subarray>
		<fromBytes public="1" set="method" line="100" static="1">
			<f a="bytes:?byteOffset:?len" v=":0:">
				<c path="haxe.io.Bytes"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="lime.utils.Float32Array"/>
			</f>
			<meta><m n=":value"><e>{ byteOffset : 0 }</e></m></meta>
		</fromBytes>
		<toBytes public="1" set="method" line="104" static="1">
			<f a="this">
				<c path="lime.utils.ArrayBufferView"/>
				<c path="haxe.io.Bytes"/>
			</f>
			<meta><m n=":impl"/></meta>
		</toBytes>
		<toString set="method" line="110" static="1">
			<f a="this">
				<c path="lime.utils.ArrayBufferView"/>
				<t path="Null"><c path="String"/></t>
			</f>
			<meta><m n=":impl"/></meta>
		</toString>
		<get_length get="inline" set="null" line="112" static="1">
			<f a="this">
				<c path="lime.utils.ArrayBufferView"/>
				<x path="Int"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_length>
		<__get public="1" get="inline" set="null" line="117" static="1">
			<f a="this:idx">
				<c path="lime.utils.ArrayBufferView"/>
				<x path="Int"/>
				<x path="Float"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
				<m n=":arrayAccess"/>
			</meta>
		</__get>
		<__set public="1" get="inline" set="null" line="123" static="1">
			<f a="this:idx:val">
				<c path="lime.utils.ArrayBufferView"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
				<m n=":arrayAccess"/>
			</meta>
		</__set>
		<meta><m n=":final"/></meta>
	</class>
	<abstract path="lime.utils.Float64Array" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/utils/Float64Array.hx">
		<from><icast><c path="lime.utils.ArrayBufferView"/></icast></from>
		<this><c path="lime.utils.ArrayBufferView"/></this>
		<to><icast><c path="lime.utils.ArrayBufferView"/></icast></to>
		<meta>
			<m n=":forward"/>
			<m n=":arrayAccess"/>
		</meta>
		<impl><class path="lime.utils._Float64Array.Float64Array_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/utils/Float64Array.hx" private="1" module="lime.utils.Float64Array">
	<BYTES_PER_ELEMENT public="1" get="inline" set="null" expr="8" line="68" static="1">
		<x path="Int"/>
		<meta><m n=":value"><e>8</e></m></meta>
	</BYTES_PER_ELEMENT>
	<length public="1" get="accessor" set="null" static="1">
		<x path="Int"/>
		<meta><m n=":impl"/></meta>
	</length>
	<_new public="1" params="T" get="inline" set="null" line="73" static="1">
		<f a="?elements:?array:?view:?buffer:?byteoffset:?len" v="::::0:">
			<x path="Int"/>
			<c path="Array"><c path="_new.T"/></c>
			<c path="lime.utils.ArrayBufferView"/>
			<x path="lime.utils.ArrayBuffer"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="lime.utils.Float64Array"/>
		</f>
		<meta>
			<m n=":value"><e>{ byteoffset : 0 }</e></m>
			<m n=":impl"/>
			<m n=":generic"/>
		</meta>
	</_new>
	<subarray public="1" get="inline" set="null" line="95" static="1">
		<f a="this:begin:?end" v="::null">
			<c path="lime.utils.ArrayBufferView"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="lime.utils.Float64Array"/>
		</f>
		<meta>
			<m n=":value"><e>{ end : null }</e></m>
			<m n=":impl"/>
		</meta>
	</subarray>
	<fromBytes public="1" set="method" line="99" static="1">
		<f a="bytes:?byteOffset:?len" v=":0:">
			<c path="haxe.io.Bytes"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="lime.utils.Float64Array"/>
		</f>
		<meta><m n=":value"><e>{ byteOffset : 0 }</e></m></meta>
	</fromBytes>
	<toBytes public="1" set="method" line="103" static="1">
		<f a="this">
			<c path="lime.utils.ArrayBufferView"/>
			<c path="haxe.io.Bytes"/>
		</f>
		<meta><m n=":impl"/></meta>
	</toBytes>
	<get_length get="inline" set="null" line="109" static="1">
		<f a="this">
			<c path="lime.utils.ArrayBufferView"/>
			<x path="Int"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_length>
	<__get public="1" get="inline" set="null" line="114" static="1">
		<f a="this:idx">
			<c path="lime.utils.ArrayBufferView"/>
			<x path="Int"/>
			<x path="Float"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
			<m n=":arrayAccess"/>
		</meta>
	</__get>
	<__set public="1" get="inline" set="null" line="120" static="1">
		<f a="this:idx:val">
			<c path="lime.utils.ArrayBufferView"/>
			<x path="Int"/>
			<x path="Float"/>
			<x path="Float"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
			<m n=":arrayAccess"/>
		</meta>
	</__set>
	<toString set="method" line="124" static="1">
		<f a="this">
			<c path="lime.utils.ArrayBufferView"/>
			<t path="Null"><c path="String"/></t>
		</f>
		<meta><m n=":impl"/></meta>
	</toString>
	<meta><m n=":final"/></meta>
</class></impl>
	</abstract>
	<class path="lime.utils._Float64Array.Float64Array_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/utils/Float64Array.hx" private="1" module="lime.utils.Float64Array">
		<BYTES_PER_ELEMENT public="1" get="inline" set="null" expr="8" line="68" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>8</e></m></meta>
		</BYTES_PER_ELEMENT>
		<length public="1" get="accessor" set="null" static="1">
			<x path="Int"/>
			<meta><m n=":impl"/></meta>
		</length>
		<_new public="1" params="T" get="inline" set="null" line="73" static="1">
			<f a="?elements:?array:?view:?buffer:?byteoffset:?len" v="::::0:">
				<x path="Int"/>
				<c path="Array"><c path="_new.T"/></c>
				<c path="lime.utils.ArrayBufferView"/>
				<x path="lime.utils.ArrayBuffer"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="lime.utils.Float64Array"/>
			</f>
			<meta>
				<m n=":value"><e>{ byteoffset : 0 }</e></m>
				<m n=":impl"/>
				<m n=":generic"/>
			</meta>
		</_new>
		<subarray public="1" get="inline" set="null" line="95" static="1">
			<f a="this:begin:?end" v="::null">
				<c path="lime.utils.ArrayBufferView"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="lime.utils.Float64Array"/>
			</f>
			<meta>
				<m n=":value"><e>{ end : null }</e></m>
				<m n=":impl"/>
			</meta>
		</subarray>
		<fromBytes public="1" set="method" line="99" static="1">
			<f a="bytes:?byteOffset:?len" v=":0:">
				<c path="haxe.io.Bytes"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="lime.utils.Float64Array"/>
			</f>
			<meta><m n=":value"><e>{ byteOffset : 0 }</e></m></meta>
		</fromBytes>
		<toBytes public="1" set="method" line="103" static="1">
			<f a="this">
				<c path="lime.utils.ArrayBufferView"/>
				<c path="haxe.io.Bytes"/>
			</f>
			<meta><m n=":impl"/></meta>
		</toBytes>
		<get_length get="inline" set="null" line="109" static="1">
			<f a="this">
				<c path="lime.utils.ArrayBufferView"/>
				<x path="Int"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_length>
		<__get public="1" get="inline" set="null" line="114" static="1">
			<f a="this:idx">
				<c path="lime.utils.ArrayBufferView"/>
				<x path="Int"/>
				<x path="Float"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
				<m n=":arrayAccess"/>
			</meta>
		</__get>
		<__set public="1" get="inline" set="null" line="120" static="1">
			<f a="this:idx:val">
				<c path="lime.utils.ArrayBufferView"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
				<m n=":arrayAccess"/>
			</meta>
		</__set>
		<toString set="method" line="124" static="1">
			<f a="this">
				<c path="lime.utils.ArrayBufferView"/>
				<t path="Null"><c path="String"/></t>
			</f>
			<meta><m n=":impl"/></meta>
		</toString>
		<meta><m n=":final"/></meta>
	</class>
	<class path="lime.utils.GLUtils" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/utils/GLUtils.hx">
		<compileShader public="1" set="method" line="12" static="1"><f a="source:type">
	<c path="String"/>
	<x path="Int"/>
	<c path="lime.graphics.opengl.GLShader"/>
</f></compileShader>
		<createProgram public="1" set="method" line="35" static="1"><f a="vertexSource:fragmentSource">
	<c path="String"/>
	<c path="String"/>
	<c path="lime.graphics.opengl.GLProgram"/>
</f></createProgram>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<abstract path="lime.utils.Int16Array" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/utils/Int16Array.hx">
		<from><icast><c path="lime.utils.ArrayBufferView"/></icast></from>
		<this><c path="lime.utils.ArrayBufferView"/></this>
		<to><icast><c path="lime.utils.ArrayBufferView"/></icast></to>
		<meta>
			<m n=":forward"/>
			<m n=":arrayAccess"/>
		</meta>
		<impl><class path="lime.utils._Int16Array.Int16Array_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/utils/Int16Array.hx" private="1" module="lime.utils.Int16Array">
	<BYTES_PER_ELEMENT public="1" get="inline" set="null" expr="2" line="68" static="1">
		<x path="Int"/>
		<meta><m n=":value"><e>2</e></m></meta>
	</BYTES_PER_ELEMENT>
	<length public="1" get="accessor" set="null" static="1">
		<x path="Int"/>
		<meta><m n=":impl"/></meta>
	</length>
	<_new public="1" params="T" get="inline" set="null" line="73" static="1">
		<f a="?elements:?array:?view:?buffer:?byteoffset:?len" v="::::0:">
			<x path="Int"/>
			<c path="Array"><c path="_new.T"/></c>
			<c path="lime.utils.ArrayBufferView"/>
			<x path="lime.utils.ArrayBuffer"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="lime.utils.Int16Array"/>
		</f>
		<meta>
			<m n=":value"><e>{ byteoffset : 0 }</e></m>
			<m n=":impl"/>
			<m n=":generic"/>
		</meta>
	</_new>
	<subarray public="1" get="inline" set="null" line="95" static="1">
		<f a="this:begin:?end" v="::null">
			<c path="lime.utils.ArrayBufferView"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="lime.utils.Int16Array"/>
		</f>
		<meta>
			<m n=":value"><e>{ end : null }</e></m>
			<m n=":impl"/>
		</meta>
	</subarray>
	<fromBytes public="1" set="method" line="99" static="1">
		<f a="bytes:?byteOffset:?len" v=":0:">
			<c path="haxe.io.Bytes"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="lime.utils.Int16Array"/>
		</f>
		<meta><m n=":value"><e>{ byteOffset : 0 }</e></m></meta>
	</fromBytes>
	<toBytes public="1" set="method" line="103" static="1">
		<f a="this">
			<c path="lime.utils.ArrayBufferView"/>
			<c path="haxe.io.Bytes"/>
		</f>
		<meta><m n=":impl"/></meta>
	</toBytes>
	<get_length get="inline" set="null" line="109" static="1">
		<f a="this">
			<c path="lime.utils.ArrayBufferView"/>
			<x path="Int"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_length>
	<__get public="1" get="inline" set="null" line="114" static="1">
		<f a="this:idx">
			<c path="lime.utils.ArrayBufferView"/>
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
			<m n=":arrayAccess"/>
		</meta>
	</__get>
	<__set public="1" get="inline" set="null" line="120" static="1">
		<f a="this:idx:val">
			<c path="lime.utils.ArrayBufferView"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
			<m n=":arrayAccess"/>
		</meta>
	</__set>
	<toString set="method" line="124" static="1">
		<f a="this">
			<c path="lime.utils.ArrayBufferView"/>
			<t path="Null"><c path="String"/></t>
		</f>
		<meta><m n=":impl"/></meta>
	</toString>
	<meta><m n=":final"/></meta>
</class></impl>
	</abstract>
	<class path="lime.utils._Int16Array.Int16Array_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/utils/Int16Array.hx" private="1" module="lime.utils.Int16Array">
		<BYTES_PER_ELEMENT public="1" get="inline" set="null" expr="2" line="68" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>2</e></m></meta>
		</BYTES_PER_ELEMENT>
		<length public="1" get="accessor" set="null" static="1">
			<x path="Int"/>
			<meta><m n=":impl"/></meta>
		</length>
		<_new public="1" params="T" get="inline" set="null" line="73" static="1">
			<f a="?elements:?array:?view:?buffer:?byteoffset:?len" v="::::0:">
				<x path="Int"/>
				<c path="Array"><c path="_new.T"/></c>
				<c path="lime.utils.ArrayBufferView"/>
				<x path="lime.utils.ArrayBuffer"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="lime.utils.Int16Array"/>
			</f>
			<meta>
				<m n=":value"><e>{ byteoffset : 0 }</e></m>
				<m n=":impl"/>
				<m n=":generic"/>
			</meta>
		</_new>
		<subarray public="1" get="inline" set="null" line="95" static="1">
			<f a="this:begin:?end" v="::null">
				<c path="lime.utils.ArrayBufferView"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="lime.utils.Int16Array"/>
			</f>
			<meta>
				<m n=":value"><e>{ end : null }</e></m>
				<m n=":impl"/>
			</meta>
		</subarray>
		<fromBytes public="1" set="method" line="99" static="1">
			<f a="bytes:?byteOffset:?len" v=":0:">
				<c path="haxe.io.Bytes"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="lime.utils.Int16Array"/>
			</f>
			<meta><m n=":value"><e>{ byteOffset : 0 }</e></m></meta>
		</fromBytes>
		<toBytes public="1" set="method" line="103" static="1">
			<f a="this">
				<c path="lime.utils.ArrayBufferView"/>
				<c path="haxe.io.Bytes"/>
			</f>
			<meta><m n=":impl"/></meta>
		</toBytes>
		<get_length get="inline" set="null" line="109" static="1">
			<f a="this">
				<c path="lime.utils.ArrayBufferView"/>
				<x path="Int"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_length>
		<__get public="1" get="inline" set="null" line="114" static="1">
			<f a="this:idx">
				<c path="lime.utils.ArrayBufferView"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
				<m n=":arrayAccess"/>
			</meta>
		</__get>
		<__set public="1" get="inline" set="null" line="120" static="1">
			<f a="this:idx:val">
				<c path="lime.utils.ArrayBufferView"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
				<m n=":arrayAccess"/>
			</meta>
		</__set>
		<toString set="method" line="124" static="1">
			<f a="this">
				<c path="lime.utils.ArrayBufferView"/>
				<t path="Null"><c path="String"/></t>
			</f>
			<meta><m n=":impl"/></meta>
		</toString>
		<meta><m n=":final"/></meta>
	</class>
	<abstract path="lime.utils.Int32Array" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/utils/Int32Array.hx">
		<from><icast><c path="lime.utils.ArrayBufferView"/></icast></from>
		<this><c path="lime.utils.ArrayBufferView"/></this>
		<to><icast><c path="lime.utils.ArrayBufferView"/></icast></to>
		<meta>
			<m n=":forward"/>
			<m n=":arrayAccess"/>
		</meta>
		<impl><class path="lime.utils._Int32Array.Int32Array_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/utils/Int32Array.hx" private="1" module="lime.utils.Int32Array">
	<BYTES_PER_ELEMENT public="1" get="inline" set="null" expr="4" line="68" static="1">
		<x path="Int"/>
		<meta><m n=":value"><e>4</e></m></meta>
	</BYTES_PER_ELEMENT>
	<length public="1" get="accessor" set="null" static="1">
		<x path="Int"/>
		<meta><m n=":impl"/></meta>
	</length>
	<_new public="1" params="T" get="inline" set="null" line="73" static="1">
		<f a="?elements:?array:?view:?buffer:?byteoffset:?len" v="::::0:">
			<x path="Int"/>
			<c path="Array"><c path="_new.T"/></c>
			<c path="lime.utils.ArrayBufferView"/>
			<x path="lime.utils.ArrayBuffer"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="lime.utils.Int32Array"/>
		</f>
		<meta>
			<m n=":value"><e>{ byteoffset : 0 }</e></m>
			<m n=":impl"/>
			<m n=":generic"/>
		</meta>
	</_new>
	<subarray public="1" get="inline" set="null" line="95" static="1">
		<f a="this:begin:?end" v="::null">
			<c path="lime.utils.ArrayBufferView"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="lime.utils.Int32Array"/>
		</f>
		<meta>
			<m n=":value"><e>{ end : null }</e></m>
			<m n=":impl"/>
		</meta>
	</subarray>
	<fromBytes public="1" set="method" line="99" static="1">
		<f a="bytes:?byteOffset:?len" v=":0:">
			<c path="haxe.io.Bytes"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="lime.utils.Int32Array"/>
		</f>
		<meta><m n=":value"><e>{ byteOffset : 0 }</e></m></meta>
	</fromBytes>
	<toBytes public="1" set="method" line="103" static="1">
		<f a="this">
			<c path="lime.utils.ArrayBufferView"/>
			<c path="haxe.io.Bytes"/>
		</f>
		<meta><m n=":impl"/></meta>
	</toBytes>
	<get_length get="inline" set="null" line="109" static="1">
		<f a="this">
			<c path="lime.utils.ArrayBufferView"/>
			<x path="Int"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_length>
	<__get public="1" get="inline" set="null" line="114" static="1">
		<f a="this:idx">
			<c path="lime.utils.ArrayBufferView"/>
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
			<m n=":arrayAccess"/>
		</meta>
	</__get>
	<__set public="1" get="inline" set="null" line="120" static="1">
		<f a="this:idx:val">
			<c path="lime.utils.ArrayBufferView"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
			<m n=":arrayAccess"/>
		</meta>
	</__set>
	<toString set="method" line="124" static="1">
		<f a="this">
			<c path="lime.utils.ArrayBufferView"/>
			<t path="Null"><c path="String"/></t>
		</f>
		<meta><m n=":impl"/></meta>
	</toString>
	<meta><m n=":final"/></meta>
</class></impl>
	</abstract>
	<class path="lime.utils._Int32Array.Int32Array_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/utils/Int32Array.hx" private="1" module="lime.utils.Int32Array">
		<BYTES_PER_ELEMENT public="1" get="inline" set="null" expr="4" line="68" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>4</e></m></meta>
		</BYTES_PER_ELEMENT>
		<length public="1" get="accessor" set="null" static="1">
			<x path="Int"/>
			<meta><m n=":impl"/></meta>
		</length>
		<_new public="1" params="T" get="inline" set="null" line="73" static="1">
			<f a="?elements:?array:?view:?buffer:?byteoffset:?len" v="::::0:">
				<x path="Int"/>
				<c path="Array"><c path="_new.T"/></c>
				<c path="lime.utils.ArrayBufferView"/>
				<x path="lime.utils.ArrayBuffer"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="lime.utils.Int32Array"/>
			</f>
			<meta>
				<m n=":value"><e>{ byteoffset : 0 }</e></m>
				<m n=":impl"/>
				<m n=":generic"/>
			</meta>
		</_new>
		<subarray public="1" get="inline" set="null" line="95" static="1">
			<f a="this:begin:?end" v="::null">
				<c path="lime.utils.ArrayBufferView"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="lime.utils.Int32Array"/>
			</f>
			<meta>
				<m n=":value"><e>{ end : null }</e></m>
				<m n=":impl"/>
			</meta>
		</subarray>
		<fromBytes public="1" set="method" line="99" static="1">
			<f a="bytes:?byteOffset:?len" v=":0:">
				<c path="haxe.io.Bytes"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="lime.utils.Int32Array"/>
			</f>
			<meta><m n=":value"><e>{ byteOffset : 0 }</e></m></meta>
		</fromBytes>
		<toBytes public="1" set="method" line="103" static="1">
			<f a="this">
				<c path="lime.utils.ArrayBufferView"/>
				<c path="haxe.io.Bytes"/>
			</f>
			<meta><m n=":impl"/></meta>
		</toBytes>
		<get_length get="inline" set="null" line="109" static="1">
			<f a="this">
				<c path="lime.utils.ArrayBufferView"/>
				<x path="Int"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_length>
		<__get public="1" get="inline" set="null" line="114" static="1">
			<f a="this:idx">
				<c path="lime.utils.ArrayBufferView"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
				<m n=":arrayAccess"/>
			</meta>
		</__get>
		<__set public="1" get="inline" set="null" line="120" static="1">
			<f a="this:idx:val">
				<c path="lime.utils.ArrayBufferView"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
				<m n=":arrayAccess"/>
			</meta>
		</__set>
		<toString set="method" line="124" static="1">
			<f a="this">
				<c path="lime.utils.ArrayBufferView"/>
				<t path="Null"><c path="String"/></t>
			</f>
			<meta><m n=":impl"/></meta>
		</toString>
		<meta><m n=":final"/></meta>
	</class>
	<abstract path="lime.utils.Int8Array" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/utils/Int8Array.hx">
		<from><icast><c path="lime.utils.ArrayBufferView"/></icast></from>
		<this><c path="lime.utils.ArrayBufferView"/></this>
		<to><icast><c path="lime.utils.ArrayBufferView"/></icast></to>
		<meta>
			<m n=":forward"/>
			<m n=":arrayAccess"/>
		</meta>
		<impl><class path="lime.utils._Int8Array.Int8Array_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/utils/Int8Array.hx" private="1" module="lime.utils.Int8Array">
	<BYTES_PER_ELEMENT public="1" get="inline" set="null" expr="1" line="66" static="1">
		<x path="Int"/>
		<meta><m n=":value"><e>1</e></m></meta>
	</BYTES_PER_ELEMENT>
	<length public="1" get="accessor" set="null" static="1">
		<x path="Int"/>
		<meta><m n=":impl"/></meta>
	</length>
	<_new public="1" params="T" get="inline" set="null" line="71" static="1">
		<f a="?elements:?array:?view:?buffer:?byteoffset:?len" v="::::0:">
			<x path="Int"/>
			<c path="Array"><c path="_new.T"/></c>
			<c path="lime.utils.ArrayBufferView"/>
			<x path="lime.utils.ArrayBuffer"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="lime.utils.Int8Array"/>
		</f>
		<meta>
			<m n=":value"><e>{ byteoffset : 0 }</e></m>
			<m n=":impl"/>
			<m n=":generic"/>
		</meta>
	</_new>
	<subarray public="1" get="inline" set="null" line="93" static="1">
		<f a="this:begin:?end" v="::null">
			<c path="lime.utils.ArrayBufferView"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="lime.utils.Int8Array"/>
		</f>
		<meta>
			<m n=":value"><e>{ end : null }</e></m>
			<m n=":impl"/>
		</meta>
	</subarray>
	<fromBytes public="1" set="method" line="97" static="1">
		<f a="bytes:?byteOffset:?len" v=":0:">
			<c path="haxe.io.Bytes"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="lime.utils.Int8Array"/>
		</f>
		<meta><m n=":value"><e>{ byteOffset : 0 }</e></m></meta>
	</fromBytes>
	<toBytes public="1" set="method" line="103" static="1">
		<f a="this">
			<c path="lime.utils.ArrayBufferView"/>
			<c path="haxe.io.Bytes"/>
		</f>
		<meta><m n=":impl"/></meta>
	</toBytes>
	<get_length get="inline" set="null" line="109" static="1">
		<f a="this">
			<c path="lime.utils.ArrayBufferView"/>
			<x path="Int"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_length>
	<__get public="1" get="inline" set="null" line="114" static="1">
		<f a="this:idx">
			<c path="lime.utils.ArrayBufferView"/>
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
			<m n=":arrayAccess"/>
		</meta>
	</__get>
	<__set public="1" get="inline" set="null" line="120" static="1">
		<f a="this:idx:val">
			<c path="lime.utils.ArrayBufferView"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
			<m n=":arrayAccess"/>
		</meta>
	</__set>
	<toString set="method" line="124" static="1">
		<f a="this">
			<c path="lime.utils.ArrayBufferView"/>
			<t path="Null"><c path="String"/></t>
		</f>
		<meta><m n=":impl"/></meta>
	</toString>
	<meta><m n=":final"/></meta>
</class></impl>
	</abstract>
	<class path="lime.utils._Int8Array.Int8Array_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/utils/Int8Array.hx" private="1" module="lime.utils.Int8Array">
		<BYTES_PER_ELEMENT public="1" get="inline" set="null" expr="1" line="66" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</BYTES_PER_ELEMENT>
		<length public="1" get="accessor" set="null" static="1">
			<x path="Int"/>
			<meta><m n=":impl"/></meta>
		</length>
		<_new public="1" params="T" get="inline" set="null" line="71" static="1">
			<f a="?elements:?array:?view:?buffer:?byteoffset:?len" v="::::0:">
				<x path="Int"/>
				<c path="Array"><c path="_new.T"/></c>
				<c path="lime.utils.ArrayBufferView"/>
				<x path="lime.utils.ArrayBuffer"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="lime.utils.Int8Array"/>
			</f>
			<meta>
				<m n=":value"><e>{ byteoffset : 0 }</e></m>
				<m n=":impl"/>
				<m n=":generic"/>
			</meta>
		</_new>
		<subarray public="1" get="inline" set="null" line="93" static="1">
			<f a="this:begin:?end" v="::null">
				<c path="lime.utils.ArrayBufferView"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="lime.utils.Int8Array"/>
			</f>
			<meta>
				<m n=":value"><e>{ end : null }</e></m>
				<m n=":impl"/>
			</meta>
		</subarray>
		<fromBytes public="1" set="method" line="97" static="1">
			<f a="bytes:?byteOffset:?len" v=":0:">
				<c path="haxe.io.Bytes"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="lime.utils.Int8Array"/>
			</f>
			<meta><m n=":value"><e>{ byteOffset : 0 }</e></m></meta>
		</fromBytes>
		<toBytes public="1" set="method" line="103" static="1">
			<f a="this">
				<c path="lime.utils.ArrayBufferView"/>
				<c path="haxe.io.Bytes"/>
			</f>
			<meta><m n=":impl"/></meta>
		</toBytes>
		<get_length get="inline" set="null" line="109" static="1">
			<f a="this">
				<c path="lime.utils.ArrayBufferView"/>
				<x path="Int"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_length>
		<__get public="1" get="inline" set="null" line="114" static="1">
			<f a="this:idx">
				<c path="lime.utils.ArrayBufferView"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
				<m n=":arrayAccess"/>
			</meta>
		</__get>
		<__set public="1" get="inline" set="null" line="120" static="1">
			<f a="this:idx:val">
				<c path="lime.utils.ArrayBufferView"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
				<m n=":arrayAccess"/>
			</meta>
		</__set>
		<toString set="method" line="124" static="1">
			<f a="this">
				<c path="lime.utils.ArrayBufferView"/>
				<t path="Null"><c path="String"/></t>
			</f>
			<meta><m n=":impl"/></meta>
		</toString>
		<meta><m n=":final"/></meta>
	</class>
	<class path="lime.utils.LZMA" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/utils/LZMA.hx">
		<decode public="1" set="method" line="14" static="1"><f a="bytes">
	<c path="haxe.io.Bytes"/>
	<c path="haxe.io.Bytes"/>
</f></decode>
		<encode public="1" set="method" line="26" static="1"><f a="bytes">
	<c path="haxe.io.Bytes"/>
	<c path="haxe.io.Bytes"/>
</f></encode>
		<lime_lzma_decode get="inline" set="null" line="46" static="1">
			<f a="data">
				<d/>
				<d/>
			</f>
			<meta><m n=":cffi"/></meta>
		</lime_lzma_decode>
		<lime_lzma_encode get="inline" set="null" line="47" static="1">
			<f a="data">
				<d/>
				<d/>
			</f>
			<meta><m n=":cffi"/></meta>
		</lime_lzma_encode>
		<cffi_lime_lzma_decode expr="new cpp.Callable&lt;Dynamic&gt;(lime.system.CFFI.load(&quot;lime&quot;, &quot;lime_lzma_decode&quot;, 1, false))" line="46" static="1">
			<x path="cpp.Callable"><f a="">
	<d/>
	<d/>
</f></x>
			<meta><m n=":value"><e><![CDATA[new cpp.Callable<Dynamic>(lime.system.CFFI.load("lime", "lime_lzma_decode", 1, false))]]></e></m></meta>
		</cffi_lime_lzma_decode>
		<cffi_lime_lzma_encode expr="new cpp.Callable&lt;Dynamic&gt;(lime.system.CFFI.load(&quot;lime&quot;, &quot;lime_lzma_encode&quot;, 1, false))" line="47" static="1">
			<x path="cpp.Callable"><f a="">
	<d/>
	<d/>
</f></x>
			<meta><m n=":value"><e><![CDATA[new cpp.Callable<Dynamic>(lime.system.CFFI.load("lime", "lime_lzma_encode", 1, false))]]></e></m></meta>
		</cffi_lime_lzma_encode>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>lime.system.CFFI.build()</e></m>
		</meta>
	</class>
	<abstract path="lime.utils.UInt16Array" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/utils/UInt16Array.hx">
		<from><icast><c path="lime.utils.ArrayBufferView"/></icast></from>
		<this><c path="lime.utils.ArrayBufferView"/></this>
		<to><icast><c path="lime.utils.ArrayBufferView"/></icast></to>
		<meta>
			<m n=":forward"/>
			<m n=":arrayAccess"/>
		</meta>
		<impl><class path="lime.utils._UInt16Array.UInt16Array_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/utils/UInt16Array.hx" private="1" module="lime.utils.UInt16Array">
	<BYTES_PER_ELEMENT public="1" get="inline" set="null" expr="2" line="68" static="1">
		<x path="Int"/>
		<meta><m n=":value"><e>2</e></m></meta>
	</BYTES_PER_ELEMENT>
	<length public="1" get="accessor" set="null" static="1">
		<x path="Int"/>
		<meta><m n=":impl"/></meta>
	</length>
	<_new public="1" params="T" get="inline" set="null" line="73" static="1">
		<f a="?elements:?array:?view:?buffer:?byteoffset:?len" v="::::0:">
			<x path="Int"/>
			<c path="Array"><c path="_new.T"/></c>
			<c path="lime.utils.ArrayBufferView"/>
			<x path="lime.utils.ArrayBuffer"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="lime.utils.UInt16Array"/>
		</f>
		<meta>
			<m n=":value"><e>{ byteoffset : 0 }</e></m>
			<m n=":impl"/>
			<m n=":generic"/>
		</meta>
	</_new>
	<subarray public="1" get="inline" set="null" line="95" static="1">
		<f a="this:begin:?end" v="::null">
			<c path="lime.utils.ArrayBufferView"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="lime.utils.UInt16Array"/>
		</f>
		<meta>
			<m n=":value"><e>{ end : null }</e></m>
			<m n=":impl"/>
		</meta>
	</subarray>
	<fromBytes public="1" set="method" line="99" static="1">
		<f a="bytes:?byteOffset:?len" v=":0:">
			<c path="haxe.io.Bytes"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="lime.utils.UInt16Array"/>
		</f>
		<meta><m n=":value"><e>{ byteOffset : 0 }</e></m></meta>
	</fromBytes>
	<toBytes public="1" set="method" line="103" static="1">
		<f a="this">
			<c path="lime.utils.ArrayBufferView"/>
			<c path="haxe.io.Bytes"/>
		</f>
		<meta><m n=":impl"/></meta>
	</toBytes>
	<get_length get="inline" set="null" line="109" static="1">
		<f a="this">
			<c path="lime.utils.ArrayBufferView"/>
			<x path="Int"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_length>
	<__get public="1" get="inline" set="null" line="114" static="1">
		<f a="this:idx">
			<c path="lime.utils.ArrayBufferView"/>
			<x path="Int"/>
			<t path="Null"><x path="UInt"/></t>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
			<m n=":arrayAccess"/>
		</meta>
	</__get>
	<__set public="1" get="inline" set="null" line="120" static="1">
		<f a="this:idx:val">
			<c path="lime.utils.ArrayBufferView"/>
			<x path="Int"/>
			<x path="UInt"/>
			<x path="UInt"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
			<m n=":arrayAccess"/>
		</meta>
	</__set>
	<toString set="method" line="124" static="1">
		<f a="this">
			<c path="lime.utils.ArrayBufferView"/>
			<t path="Null"><c path="String"/></t>
		</f>
		<meta><m n=":impl"/></meta>
	</toString>
	<meta><m n=":final"/></meta>
</class></impl>
	</abstract>
	<class path="lime.utils._UInt16Array.UInt16Array_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/utils/UInt16Array.hx" private="1" module="lime.utils.UInt16Array">
		<BYTES_PER_ELEMENT public="1" get="inline" set="null" expr="2" line="68" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>2</e></m></meta>
		</BYTES_PER_ELEMENT>
		<length public="1" get="accessor" set="null" static="1">
			<x path="Int"/>
			<meta><m n=":impl"/></meta>
		</length>
		<_new public="1" params="T" get="inline" set="null" line="73" static="1">
			<f a="?elements:?array:?view:?buffer:?byteoffset:?len" v="::::0:">
				<x path="Int"/>
				<c path="Array"><c path="_new.T"/></c>
				<c path="lime.utils.ArrayBufferView"/>
				<x path="lime.utils.ArrayBuffer"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="lime.utils.UInt16Array"/>
			</f>
			<meta>
				<m n=":value"><e>{ byteoffset : 0 }</e></m>
				<m n=":impl"/>
				<m n=":generic"/>
			</meta>
		</_new>
		<subarray public="1" get="inline" set="null" line="95" static="1">
			<f a="this:begin:?end" v="::null">
				<c path="lime.utils.ArrayBufferView"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="lime.utils.UInt16Array"/>
			</f>
			<meta>
				<m n=":value"><e>{ end : null }</e></m>
				<m n=":impl"/>
			</meta>
		</subarray>
		<fromBytes public="1" set="method" line="99" static="1">
			<f a="bytes:?byteOffset:?len" v=":0:">
				<c path="haxe.io.Bytes"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="lime.utils.UInt16Array"/>
			</f>
			<meta><m n=":value"><e>{ byteOffset : 0 }</e></m></meta>
		</fromBytes>
		<toBytes public="1" set="method" line="103" static="1">
			<f a="this">
				<c path="lime.utils.ArrayBufferView"/>
				<c path="haxe.io.Bytes"/>
			</f>
			<meta><m n=":impl"/></meta>
		</toBytes>
		<get_length get="inline" set="null" line="109" static="1">
			<f a="this">
				<c path="lime.utils.ArrayBufferView"/>
				<x path="Int"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_length>
		<__get public="1" get="inline" set="null" line="114" static="1">
			<f a="this:idx">
				<c path="lime.utils.ArrayBufferView"/>
				<x path="Int"/>
				<t path="Null"><x path="UInt"/></t>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
				<m n=":arrayAccess"/>
			</meta>
		</__get>
		<__set public="1" get="inline" set="null" line="120" static="1">
			<f a="this:idx:val">
				<c path="lime.utils.ArrayBufferView"/>
				<x path="Int"/>
				<x path="UInt"/>
				<x path="UInt"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
				<m n=":arrayAccess"/>
			</meta>
		</__set>
		<toString set="method" line="124" static="1">
			<f a="this">
				<c path="lime.utils.ArrayBufferView"/>
				<t path="Null"><c path="String"/></t>
			</f>
			<meta><m n=":impl"/></meta>
		</toString>
		<meta><m n=":final"/></meta>
	</class>
	<abstract path="lime.utils.UInt32Array" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/utils/UInt32Array.hx">
		<from><icast><c path="lime.utils.ArrayBufferView"/></icast></from>
		<this><c path="lime.utils.ArrayBufferView"/></this>
		<to><icast><c path="lime.utils.ArrayBufferView"/></icast></to>
		<meta>
			<m n=":forward"/>
			<m n=":arrayAccess"/>
		</meta>
		<impl><class path="lime.utils._UInt32Array.UInt32Array_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/utils/UInt32Array.hx" private="1" module="lime.utils.UInt32Array">
	<BYTES_PER_ELEMENT public="1" get="inline" set="null" expr="4" line="68" static="1">
		<x path="Int"/>
		<meta><m n=":value"><e>4</e></m></meta>
	</BYTES_PER_ELEMENT>
	<length public="1" get="accessor" set="null" static="1">
		<x path="Int"/>
		<meta><m n=":impl"/></meta>
	</length>
	<_new public="1" params="T" get="inline" set="null" line="73" static="1">
		<f a="?elements:?array:?view:?buffer:?byteoffset:?len" v="::::0:">
			<x path="Int"/>
			<c path="Array"><c path="_new.T"/></c>
			<c path="lime.utils.ArrayBufferView"/>
			<x path="lime.utils.ArrayBuffer"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="lime.utils.UInt32Array"/>
		</f>
		<meta>
			<m n=":value"><e>{ byteoffset : 0 }</e></m>
			<m n=":impl"/>
			<m n=":generic"/>
		</meta>
	</_new>
	<subarray public="1" get="inline" set="null" line="95" static="1">
		<f a="this:begin:?end" v="::null">
			<c path="lime.utils.ArrayBufferView"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="lime.utils.UInt32Array"/>
		</f>
		<meta>
			<m n=":value"><e>{ end : null }</e></m>
			<m n=":impl"/>
		</meta>
	</subarray>
	<fromBytes public="1" set="method" line="99" static="1">
		<f a="bytes:?byteOffset:?len" v=":0:">
			<c path="haxe.io.Bytes"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="lime.utils.UInt32Array"/>
		</f>
		<meta><m n=":value"><e>{ byteOffset : 0 }</e></m></meta>
	</fromBytes>
	<toBytes public="1" set="method" line="103" static="1">
		<f a="this">
			<c path="lime.utils.ArrayBufferView"/>
			<c path="haxe.io.Bytes"/>
		</f>
		<meta><m n=":impl"/></meta>
	</toBytes>
	<get_length get="inline" set="null" line="109" static="1">
		<f a="this">
			<c path="lime.utils.ArrayBufferView"/>
			<x path="Int"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_length>
	<__get public="1" get="inline" set="null" line="114" static="1">
		<f a="this:idx">
			<c path="lime.utils.ArrayBufferView"/>
			<x path="Int"/>
			<t path="Null"><x path="UInt"/></t>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
			<m n=":arrayAccess"/>
		</meta>
	</__get>
	<__set public="1" get="inline" set="null" line="120" static="1">
		<f a="this:idx:val">
			<c path="lime.utils.ArrayBufferView"/>
			<x path="Int"/>
			<x path="UInt"/>
			<x path="UInt"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
			<m n=":arrayAccess"/>
		</meta>
	</__set>
	<toString set="method" line="124" static="1">
		<f a="this">
			<c path="lime.utils.ArrayBufferView"/>
			<t path="Null"><c path="String"/></t>
		</f>
		<meta><m n=":impl"/></meta>
	</toString>
	<meta><m n=":final"/></meta>
</class></impl>
	</abstract>
	<class path="lime.utils._UInt32Array.UInt32Array_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/utils/UInt32Array.hx" private="1" module="lime.utils.UInt32Array">
		<BYTES_PER_ELEMENT public="1" get="inline" set="null" expr="4" line="68" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>4</e></m></meta>
		</BYTES_PER_ELEMENT>
		<length public="1" get="accessor" set="null" static="1">
			<x path="Int"/>
			<meta><m n=":impl"/></meta>
		</length>
		<_new public="1" params="T" get="inline" set="null" line="73" static="1">
			<f a="?elements:?array:?view:?buffer:?byteoffset:?len" v="::::0:">
				<x path="Int"/>
				<c path="Array"><c path="_new.T"/></c>
				<c path="lime.utils.ArrayBufferView"/>
				<x path="lime.utils.ArrayBuffer"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="lime.utils.UInt32Array"/>
			</f>
			<meta>
				<m n=":value"><e>{ byteoffset : 0 }</e></m>
				<m n=":impl"/>
				<m n=":generic"/>
			</meta>
		</_new>
		<subarray public="1" get="inline" set="null" line="95" static="1">
			<f a="this:begin:?end" v="::null">
				<c path="lime.utils.ArrayBufferView"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="lime.utils.UInt32Array"/>
			</f>
			<meta>
				<m n=":value"><e>{ end : null }</e></m>
				<m n=":impl"/>
			</meta>
		</subarray>
		<fromBytes public="1" set="method" line="99" static="1">
			<f a="bytes:?byteOffset:?len" v=":0:">
				<c path="haxe.io.Bytes"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="lime.utils.UInt32Array"/>
			</f>
			<meta><m n=":value"><e>{ byteOffset : 0 }</e></m></meta>
		</fromBytes>
		<toBytes public="1" set="method" line="103" static="1">
			<f a="this">
				<c path="lime.utils.ArrayBufferView"/>
				<c path="haxe.io.Bytes"/>
			</f>
			<meta><m n=":impl"/></meta>
		</toBytes>
		<get_length get="inline" set="null" line="109" static="1">
			<f a="this">
				<c path="lime.utils.ArrayBufferView"/>
				<x path="Int"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_length>
		<__get public="1" get="inline" set="null" line="114" static="1">
			<f a="this:idx">
				<c path="lime.utils.ArrayBufferView"/>
				<x path="Int"/>
				<t path="Null"><x path="UInt"/></t>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
				<m n=":arrayAccess"/>
			</meta>
		</__get>
		<__set public="1" get="inline" set="null" line="120" static="1">
			<f a="this:idx:val">
				<c path="lime.utils.ArrayBufferView"/>
				<x path="Int"/>
				<x path="UInt"/>
				<x path="UInt"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
				<m n=":arrayAccess"/>
			</meta>
		</__set>
		<toString set="method" line="124" static="1">
			<f a="this">
				<c path="lime.utils.ArrayBufferView"/>
				<t path="Null"><c path="String"/></t>
			</f>
			<meta><m n=":impl"/></meta>
		</toString>
		<meta><m n=":final"/></meta>
	</class>
	<abstract path="lime.utils.UInt8Array" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/utils/UInt8Array.hx">
		<from><icast><c path="lime.utils.ArrayBufferView"/></icast></from>
		<this><c path="lime.utils.ArrayBufferView"/></this>
		<to><icast><c path="lime.utils.ArrayBufferView"/></icast></to>
		<meta>
			<m n=":forward"/>
			<m n=":arrayAccess"/>
		</meta>
		<impl><class path="lime.utils._UInt8Array.UInt8Array_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/utils/UInt8Array.hx" private="1" module="lime.utils.UInt8Array">
	<BYTES_PER_ELEMENT public="1" get="inline" set="null" expr="1" line="68" static="1">
		<x path="Int"/>
		<meta><m n=":value"><e>1</e></m></meta>
	</BYTES_PER_ELEMENT>
	<length public="1" get="accessor" set="null" static="1">
		<x path="Int"/>
		<meta><m n=":impl"/></meta>
	</length>
	<_new public="1" params="T" get="inline" set="null" line="73" static="1">
		<f a="?elements:?array:?view:?buffer:?byteoffset:?len" v="::::0:">
			<x path="Int"/>
			<c path="Array"><c path="_new.T"/></c>
			<c path="lime.utils.ArrayBufferView"/>
			<x path="lime.utils.ArrayBuffer"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="lime.utils.UInt8Array"/>
		</f>
		<meta>
			<m n=":value"><e>{ byteoffset : 0 }</e></m>
			<m n=":impl"/>
			<m n=":generic"/>
		</meta>
	</_new>
	<subarray public="1" get="inline" set="null" line="95" static="1">
		<f a="this:begin:?end" v="::null">
			<c path="lime.utils.ArrayBufferView"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="lime.utils.UInt8Array"/>
		</f>
		<meta>
			<m n=":value"><e>{ end : null }</e></m>
			<m n=":impl"/>
		</meta>
	</subarray>
	<fromBytes public="1" set="method" line="99" static="1">
		<f a="bytes:?byteOffset:?len" v=":0:">
			<c path="haxe.io.Bytes"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="lime.utils.UInt8Array"/>
		</f>
		<meta><m n=":value"><e>{ byteOffset : 0 }</e></m></meta>
	</fromBytes>
	<toBytes public="1" set="method" line="103" static="1">
		<f a="this">
			<c path="lime.utils.ArrayBufferView"/>
			<c path="haxe.io.Bytes"/>
		</f>
		<meta><m n=":impl"/></meta>
	</toBytes>
	<toString set="method" line="109" static="1">
		<f a="this">
			<c path="lime.utils.ArrayBufferView"/>
			<t path="Null"><c path="String"/></t>
		</f>
		<meta><m n=":impl"/></meta>
	</toString>
	<get_length get="inline" set="null" line="111" static="1">
		<f a="this">
			<c path="lime.utils.ArrayBufferView"/>
			<x path="Int"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_length>
	<__get public="1" get="inline" set="null" line="116" static="1">
		<f a="this:idx">
			<c path="lime.utils.ArrayBufferView"/>
			<x path="Int"/>
			<t path="Null"><x path="UInt"/></t>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
			<m n=":arrayAccess"/>
		</meta>
	</__get>
	<__set public="1" get="inline" set="null" line="122" static="1">
		<f a="this:idx:val">
			<c path="lime.utils.ArrayBufferView"/>
			<x path="Int"/>
			<x path="UInt"/>
			<x path="UInt"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
			<m n=":arrayAccess"/>
		</meta>
	</__set>
	<meta><m n=":final"/></meta>
</class></impl>
	</abstract>
	<class path="lime.utils._UInt8Array.UInt8Array_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/utils/UInt8Array.hx" private="1" module="lime.utils.UInt8Array">
		<BYTES_PER_ELEMENT public="1" get="inline" set="null" expr="1" line="68" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</BYTES_PER_ELEMENT>
		<length public="1" get="accessor" set="null" static="1">
			<x path="Int"/>
			<meta><m n=":impl"/></meta>
		</length>
		<_new public="1" params="T" get="inline" set="null" line="73" static="1">
			<f a="?elements:?array:?view:?buffer:?byteoffset:?len" v="::::0:">
				<x path="Int"/>
				<c path="Array"><c path="_new.T"/></c>
				<c path="lime.utils.ArrayBufferView"/>
				<x path="lime.utils.ArrayBuffer"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="lime.utils.UInt8Array"/>
			</f>
			<meta>
				<m n=":value"><e>{ byteoffset : 0 }</e></m>
				<m n=":impl"/>
				<m n=":generic"/>
			</meta>
		</_new>
		<subarray public="1" get="inline" set="null" line="95" static="1">
			<f a="this:begin:?end" v="::null">
				<c path="lime.utils.ArrayBufferView"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="lime.utils.UInt8Array"/>
			</f>
			<meta>
				<m n=":value"><e>{ end : null }</e></m>
				<m n=":impl"/>
			</meta>
		</subarray>
		<fromBytes public="1" set="method" line="99" static="1">
			<f a="bytes:?byteOffset:?len" v=":0:">
				<c path="haxe.io.Bytes"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="lime.utils.UInt8Array"/>
			</f>
			<meta><m n=":value"><e>{ byteOffset : 0 }</e></m></meta>
		</fromBytes>
		<toBytes public="1" set="method" line="103" static="1">
			<f a="this">
				<c path="lime.utils.ArrayBufferView"/>
				<c path="haxe.io.Bytes"/>
			</f>
			<meta><m n=":impl"/></meta>
		</toBytes>
		<toString set="method" line="109" static="1">
			<f a="this">
				<c path="lime.utils.ArrayBufferView"/>
				<t path="Null"><c path="String"/></t>
			</f>
			<meta><m n=":impl"/></meta>
		</toString>
		<get_length get="inline" set="null" line="111" static="1">
			<f a="this">
				<c path="lime.utils.ArrayBufferView"/>
				<x path="Int"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_length>
		<__get public="1" get="inline" set="null" line="116" static="1">
			<f a="this:idx">
				<c path="lime.utils.ArrayBufferView"/>
				<x path="Int"/>
				<t path="Null"><x path="UInt"/></t>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
				<m n=":arrayAccess"/>
			</meta>
		</__get>
		<__set public="1" get="inline" set="null" line="122" static="1">
			<f a="this:idx:val">
				<c path="lime.utils.ArrayBufferView"/>
				<x path="Int"/>
				<x path="UInt"/>
				<x path="UInt"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
				<m n=":arrayAccess"/>
			</meta>
		</__set>
		<meta><m n=":final"/></meta>
	</class>
	<abstract path="lime.utils.UInt8ClampedArray" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/utils/UInt8ClampedArray.hx">
		<from><icast><c path="lime.utils.ArrayBufferView"/></icast></from>
		<this><c path="lime.utils.ArrayBufferView"/></this>
		<to><icast><c path="lime.utils.ArrayBufferView"/></icast></to>
		<meta>
			<m n=":forward"/>
			<m n=":arrayAccess"/>
		</meta>
		<impl><class path="lime.utils._UInt8ClampedArray.UInt8ClampedArray_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/utils/UInt8ClampedArray.hx" private="1" module="lime.utils.UInt8ClampedArray">
	<BYTES_PER_ELEMENT public="1" get="inline" set="null" expr="1" line="76" static="1">
		<x path="Int"/>
		<meta><m n=":value"><e>1</e></m></meta>
	</BYTES_PER_ELEMENT>
	<length public="1" get="accessor" set="null" static="1">
		<x path="Int"/>
		<meta><m n=":impl"/></meta>
	</length>
	<_new public="1" params="T" get="inline" set="null" line="81" static="1">
		<f a="?elements:?array:?view:?buffer:?byteoffset:?len" v="::::0:">
			<x path="Int"/>
			<c path="Array"><c path="_new.T"/></c>
			<c path="lime.utils.ArrayBufferView"/>
			<x path="lime.utils.ArrayBuffer"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="lime.utils.UInt8ClampedArray"/>
		</f>
		<meta>
			<m n=":value"><e>{ byteoffset : 0 }</e></m>
			<m n=":impl"/>
			<m n=":generic"/>
		</meta>
	</_new>
	<subarray public="1" get="inline" set="null" line="103" static="1">
		<f a="this:begin:?end" v="::null">
			<c path="lime.utils.ArrayBufferView"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="lime.utils.UInt8ClampedArray"/>
		</f>
		<meta>
			<m n=":value"><e>{ end : null }</e></m>
			<m n=":impl"/>
		</meta>
	</subarray>
	<fromBytes public="1" set="method" line="107" static="1">
		<f a="bytes:?byteOffset:?len" v=":0:">
			<c path="haxe.io.Bytes"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="lime.utils.UInt8ClampedArray"/>
		</f>
		<meta><m n=":value"><e>{ byteOffset : 0 }</e></m></meta>
	</fromBytes>
	<toBytes public="1" set="method" line="111" static="1">
		<f a="this">
			<c path="lime.utils.ArrayBufferView"/>
			<c path="haxe.io.Bytes"/>
		</f>
		<meta><m n=":impl"/></meta>
	</toBytes>
	<get_length get="inline" set="null" line="117" static="1">
		<f a="this">
			<c path="lime.utils.ArrayBufferView"/>
			<x path="Int"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_length>
	<__get public="1" get="inline" set="null" line="122" static="1">
		<f a="this:idx">
			<c path="lime.utils.ArrayBufferView"/>
			<x path="Int"/>
			<t path="Null"><x path="UInt"/></t>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
			<m n=":arrayAccess"/>
		</meta>
	</__get>
	<__set public="1" get="inline" set="null" line="128" static="1">
		<f a="this:idx:val">
			<c path="lime.utils.ArrayBufferView"/>
			<x path="Int"/>
			<x path="UInt"/>
			<x path="UInt"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
			<m n=":arrayAccess"/>
		</meta>
	</__set>
	<toString set="method" line="132" static="1">
		<f a="this">
			<c path="lime.utils.ArrayBufferView"/>
			<t path="Null"><c path="String"/></t>
		</f>
		<meta><m n=":impl"/></meta>
	</toString>
	<meta><m n=":final"/></meta>
</class></impl>
	</abstract>
	<class path="lime.utils._UInt8ClampedArray.UInt8ClampedArray_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\lime/2,9,1/lime/utils/UInt8ClampedArray.hx" private="1" module="lime.utils.UInt8ClampedArray">
		<BYTES_PER_ELEMENT public="1" get="inline" set="null" expr="1" line="76" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</BYTES_PER_ELEMENT>
		<length public="1" get="accessor" set="null" static="1">
			<x path="Int"/>
			<meta><m n=":impl"/></meta>
		</length>
		<_new public="1" params="T" get="inline" set="null" line="81" static="1">
			<f a="?elements:?array:?view:?buffer:?byteoffset:?len" v="::::0:">
				<x path="Int"/>
				<c path="Array"><c path="_new.T"/></c>
				<c path="lime.utils.ArrayBufferView"/>
				<x path="lime.utils.ArrayBuffer"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="lime.utils.UInt8ClampedArray"/>
			</f>
			<meta>
				<m n=":value"><e>{ byteoffset : 0 }</e></m>
				<m n=":impl"/>
				<m n=":generic"/>
			</meta>
		</_new>
		<subarray public="1" get="inline" set="null" line="103" static="1">
			<f a="this:begin:?end" v="::null">
				<c path="lime.utils.ArrayBufferView"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="lime.utils.UInt8ClampedArray"/>
			</f>
			<meta>
				<m n=":value"><e>{ end : null }</e></m>
				<m n=":impl"/>
			</meta>
		</subarray>
		<fromBytes public="1" set="method" line="107" static="1">
			<f a="bytes:?byteOffset:?len" v=":0:">
				<c path="haxe.io.Bytes"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="lime.utils.UInt8ClampedArray"/>
			</f>
			<meta><m n=":value"><e>{ byteOffset : 0 }</e></m></meta>
		</fromBytes>
		<toBytes public="1" set="method" line="111" static="1">
			<f a="this">
				<c path="lime.utils.ArrayBufferView"/>
				<c path="haxe.io.Bytes"/>
			</f>
			<meta><m n=":impl"/></meta>
		</toBytes>
		<get_length get="inline" set="null" line="117" static="1">
			<f a="this">
				<c path="lime.utils.ArrayBufferView"/>
				<x path="Int"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_length>
		<__get public="1" get="inline" set="null" line="122" static="1">
			<f a="this:idx">
				<c path="lime.utils.ArrayBufferView"/>
				<x path="Int"/>
				<t path="Null"><x path="UInt"/></t>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
				<m n=":arrayAccess"/>
			</meta>
		</__get>
		<__set public="1" get="inline" set="null" line="128" static="1">
			<f a="this:idx:val">
				<c path="lime.utils.ArrayBufferView"/>
				<x path="Int"/>
				<x path="UInt"/>
				<x path="UInt"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
				<m n=":arrayAccess"/>
			</meta>
		</__set>
		<toString set="method" line="132" static="1">
			<f a="this">
				<c path="lime.utils.ArrayBufferView"/>
				<t path="Null"><c path="String"/></t>
			</f>
			<meta><m n=":impl"/></meta>
		</toString>
		<meta><m n=":final"/></meta>
	</class>
	<class path="neko.NativeString" params="" file="D:\HaxeToolkit\haxe\std/neko/NativeString.hx"><meta><m n=":keep"/></meta></class>
	<class path="neko.vm.Deque" params="T" file="D:\HaxeToolkit\haxe\std/neko/vm/Deque.hx">
		<deque_create expr="neko.Lib.loadLazy(&quot;std&quot;, &quot;deque_create&quot;, 0)" line="59" static="1">
			<f a=""><unknown/></f>
			<meta><m n=":value"><e>neko.Lib.loadLazy("std", "deque_create", 0)</e></m></meta>
		</deque_create>
		<deque_add expr="neko.Lib.loadLazy(&quot;std&quot;, &quot;deque_add&quot;, 2)" line="60" static="1">
			<f a=":">
				<d/>
				<c path="neko.vm.Deque.T"/>
				<unknown/>
			</f>
			<meta><m n=":value"><e>neko.Lib.loadLazy("std", "deque_add", 2)</e></m></meta>
		</deque_add>
		<deque_pop expr="neko.Lib.loadLazy(&quot;std&quot;, &quot;deque_pop&quot;, 2)" line="62" static="1">
			<f a=":">
				<d/>
				<x path="Bool"/>
				<t path="Null"><c path="neko.vm.Deque.T"/></t>
			</f>
			<meta><m n=":value"><e>neko.Lib.loadLazy("std", "deque_pop", 2)</e></m></meta>
		</deque_pop>
		<q><d/></q>
		<add public="1" set="method" line="40">
			<f a="i">
				<c path="neko.vm.Deque.T"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Add a message at the end of the queue.</haxe_doc>
		</add>
		<pop public="1" set="method" line="55">
			<f a="block">
				<x path="Bool"/>
				<t path="Null"><c path="neko.vm.Deque.T"/></t>
			</f>
			<haxe_doc>Pop a message from the queue head. Either block until a message 
		is available or return immediately with `null`.</haxe_doc>
		</pop>
		<new public="1" set="method" line="33">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Create a message queue for multithread access.</haxe_doc>
		</new>
		<haxe_doc>A message queue for multithread access.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="neko.vm.Gc" params="" file="D:\HaxeToolkit\haxe\std/neko/vm/Gc.hx">
		<run public="1" set="method" line="31" static="1">
			<f a="major">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Run the Neko garbage collector.</haxe_doc>
		</run>
		<stats public="1" set="method" line="39" static="1">
			<f a=""><a>
	<heap><x path="Int"/></heap>
	<free><x path="Int"/></free>
</a></f>
			<haxe_doc>Return the size of the GC heap and the among of free space, 
		in bytes.</haxe_doc>
		</stats>
		<_run expr="neko.Lib.load(&quot;std&quot;, &quot;run_gc&quot;, 1)" line="43" static="1">
			<f a="">
				<x path="Bool"/>
				<unknown/>
			</f>
			<meta><m n=":value"><e>neko.Lib.load("std", "run_gc", 1)</e></m></meta>
		</_run>
		<_stats expr="neko.Lib.load(&quot;std&quot;, &quot;gc_stats&quot;, 0)" line="44" static="1">
			<f a=""><a>
	<heap><x path="Int"/></heap>
	<free><x path="Int"/></free>
</a></f>
			<meta><m n=":value"><e>neko.Lib.load("std", "gc_stats", 0)</e></m></meta>
		</_stats>
		<haxe_doc>Neko garbage collector utility.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<enum path="neko.vm.ModuleHandle" params="" file="D:\HaxeToolkit\haxe\std/neko/vm/Module.hx" module="neko.vm.Module">
		<haxe_doc>The abstract Neko module handle.</haxe_doc>
		<meta><m n=":flatEnum"/></meta>
	</enum>
	<enum path="neko.vm.ThreadHandle" params="" file="D:\HaxeToolkit\haxe\std/neko/vm/Thread.hx" module="neko.vm.Thread"><meta><m n=":flatEnum"/></meta></enum>
	<class path="neko.vm.Thread" params="" file="D:\HaxeToolkit\haxe\std/neko/vm/Thread.hx">
		<create public="1" set="method" line="53" static="1">
			<f a="callb">
				<f a=""><x path="Void"/></f>
				<c path="neko.vm.Thread"/>
			</f>
			<haxe_doc>Creates a new thread that will execute the `callb` function, then exit.</haxe_doc>
		</create>
		<thread_create expr="neko.Lib.load(&quot;std&quot;, &quot;thread_create&quot;, 2)" line="129" static="1">
			<f a=":">
				<f a="_">
					<unknown/>
					<x path="Void"/>
				</f>
				<unknown/>
				<e path="neko.vm.ThreadHandle"/>
			</f>
			<meta><m n=":value"><e>neko.Lib.load("std", "thread_create", 2)</e></m></meta>
			<haxe_doc><![CDATA[Starts an OS message loop after [osInitialize] has been done.
		In that state, the UI handled by this thread will be updated and
		[sync] calls can be performed. The loop returns when [exitLoop] is
		called for this thread.
	**
	public static function osLoop() {
		if( os_loop == null ) throw "Please call osInitialize() first";
		os_loop();
	}

	/**
		The function [f] will be called by this thread if it's in [osLoop].
		[sync] returns immediatly. See [osInitialize] remarks.
	**
	public function sync( f : Void -> Void ) {
		os_sync(handle,f);
	}

	/**
		The function [f] will be called by this thread and the calling thread
		will wait until the result is available then return its value.
	**
	public function syncResult<T>( f : Void -> T ) : T {
		if( this == current() )
			return f();
		var v = new neko.vm.Lock();
		var r = null;
		sync(function() {
			r = f();
			v.release();
		});
		v.wait();
		return r;
	}

	/**
		Exit from [osLoop].
	**
	public function exitLoop() {
		os_loop_stop(handle);
	}

	/**
		If you want to use the [osLoop], [sync] and [syncResult] methods, you
		need to call [osInitialize] before creating any thread or calling [current].
		This will load [os.ndll] library and initialize UI methods for each thread.
	**
	public static function osInitialize() {
		os_loop = neko.Lib.load("os","os_loop",0);
		os_loop_stop = neko.Lib.load("os","os_loop_stop",1);
		os_sync = neko.Lib.load("os","os_sync",2);
	}

	static var os_loop = null;
	static var os_loop_stop = null;
	static var os_sync = null;]]></haxe_doc>
		</thread_create>
		<handle><e path="neko.vm.ThreadHandle"/></handle>
		<__compare set="method" line="66">
			<f a="t">
				<a><handle set="null"><unknown/></handle></a>
				<unknown/>
			</f>
			<meta>
				<m n=":has_untyped"/>
				<m n=":keep"/>
			</meta>
		</__compare>
		<new set="method" line="31"><f a="h">
	<e path="neko.vm.ThreadHandle"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="openfl.IAssetCache" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/Assets.hx" module="openfl.Assets" interface="1">
		<get_enabled public="1" set="method">
			<f a=""><x path="Bool"/></f>
			<meta><m n=":compilerGenerated"/></meta>
		</get_enabled>
		<set_enabled public="1" set="method">
			<f a="value">
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":compilerGenerated"/></meta>
		</set_enabled>
		<enabled public="1" get="accessor" set="accessor"><x path="Bool"/></enabled>
		<clear public="1" set="method">
			<f a="?prefix" v="null">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ prefix : null }</e></m></meta>
		</clear>
		<getBitmapData public="1" set="method"><f a="id">
	<c path="String"/>
	<c path="openfl.display.BitmapData"/>
</f></getBitmapData>
		<getFont public="1" set="method"><f a="id">
	<c path="String"/>
	<c path="openfl.text.Font"/>
</f></getFont>
		<getSound public="1" set="method"><f a="id">
	<c path="String"/>
	<c path="openfl.media.Sound"/>
</f></getSound>
		<hasBitmapData public="1" set="method"><f a="id">
	<c path="String"/>
	<x path="Bool"/>
</f></hasBitmapData>
		<hasFont public="1" set="method"><f a="id">
	<c path="String"/>
	<x path="Bool"/>
</f></hasFont>
		<hasSound public="1" set="method"><f a="id">
	<c path="String"/>
	<x path="Bool"/>
</f></hasSound>
		<removeBitmapData public="1" set="method"><f a="id">
	<c path="String"/>
	<x path="Bool"/>
</f></removeBitmapData>
		<removeFont public="1" set="method"><f a="id">
	<c path="String"/>
	<x path="Bool"/>
</f></removeFont>
		<removeSound public="1" set="method"><f a="id">
	<c path="String"/>
	<x path="Bool"/>
</f></removeSound>
		<setBitmapData public="1" set="method"><f a="id:bitmapData">
	<c path="String"/>
	<c path="openfl.display.BitmapData"/>
	<x path="Void"/>
</f></setBitmapData>
		<setFont public="1" set="method"><f a="id:font">
	<c path="String"/>
	<c path="openfl.text.Font"/>
	<x path="Void"/>
</f></setFont>
		<setSound public="1" set="method"><f a="id:sound">
	<c path="String"/>
	<c path="openfl.media.Sound"/>
	<x path="Void"/>
</f></setSound>
		<meta><m n=":dox"><e>hide</e></m></meta>
	</class>
	<class path="openfl.AssetCache" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/Assets.hx" module="openfl.Assets">
		<implements path="openfl.IAssetCache"/>
		<enabled public="1" get="accessor" set="accessor"><x path="Bool"/></enabled>
		<bitmapData public="1">
			<x path="Map">
				<c path="String"/>
				<c path="openfl.display.BitmapData"/>
			</x>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</bitmapData>
		<font public="1">
			<x path="Map">
				<c path="String"/>
				<c path="openfl.text.Font"/>
			</x>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</font>
		<sound public="1">
			<x path="Map">
				<c path="String"/>
				<c path="openfl.media.Sound"/>
			</x>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</sound>
		<__enabled expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</__enabled>
		<clear public="1" set="method" line="932">
			<f a="?prefix" v="null">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ prefix : null }</e></m></meta>
		</clear>
		<getBitmapData public="1" set="method" line="983"><f a="id">
	<c path="String"/>
	<c path="openfl.display.BitmapData"/>
</f></getBitmapData>
		<getFont public="1" set="method" line="990"><f a="id">
	<c path="String"/>
	<c path="openfl.text.Font"/>
</f></getFont>
		<getSound public="1" set="method" line="997"><f a="id">
	<c path="String"/>
	<c path="openfl.media.Sound"/>
</f></getSound>
		<hasBitmapData public="1" set="method" line="1004"><f a="id">
	<c path="String"/>
	<x path="Bool"/>
</f></hasBitmapData>
		<hasFont public="1" set="method" line="1011"><f a="id">
	<c path="String"/>
	<x path="Bool"/>
</f></hasFont>
		<hasSound public="1" set="method" line="1018"><f a="id">
	<c path="String"/>
	<x path="Bool"/>
</f></hasSound>
		<removeBitmapData public="1" set="method" line="1025"><f a="id">
	<c path="String"/>
	<x path="Bool"/>
</f></removeBitmapData>
		<removeFont public="1" set="method" line="1032"><f a="id">
	<c path="String"/>
	<x path="Bool"/>
</f></removeFont>
		<removeSound public="1" set="method" line="1039"><f a="id">
	<c path="String"/>
	<x path="Bool"/>
</f></removeSound>
		<setBitmapData public="1" set="method" line="1046"><f a="id:bitmapData">
	<c path="String"/>
	<c path="openfl.display.BitmapData"/>
	<x path="Void"/>
</f></setBitmapData>
		<setFont public="1" set="method" line="1053"><f a="id:font">
	<c path="String"/>
	<c path="openfl.text.Font"/>
	<x path="Void"/>
</f></setFont>
		<setSound public="1" set="method" line="1060"><f a="id:sound">
	<c path="String"/>
	<c path="openfl.media.Sound"/>
	<x path="Void"/>
</f></setSound>
		<get_enabled set="method" line="1074"><f a=""><x path="Bool"/></f></get_enabled>
		<set_enabled set="method" line="1081"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_enabled>
		<new public="1" set="method" line="923"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":dox"><e>hide</e></m>
		</meta>
	</class>
	<class path="openfl.Assets" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/Assets.hx">
		<cache public="1" expr="new AssetCache()" line="48" static="1">
			<c path="openfl.IAssetCache"/>
			<meta><m n=":value"><e>new AssetCache()</e></m></meta>
		</cache>
		<dispatcher expr="new EventDispatcher()" line="50" static="1">
			<c path="openfl.events.EventDispatcher"/>
			<meta><m n=":value"><e>new EventDispatcher()</e></m></meta>
		</dispatcher>
		<addEventListener public="1" set="method" line="53" static="1">
			<f a="type:listener:?useCapture:?priority:?useWeakReference" v="::false:0:false">
				<c path="String"/>
				<d/>
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ useWeakReference : false, priority : 0, useCapture : false }</e></m></meta>
		</addEventListener>
		<dispatchEvent public="1" set="method" line="66" static="1"><f a="event">
	<c path="openfl.events.Event"/>
	<x path="Bool"/>
</f></dispatchEvent>
		<exists public="1" set="method" line="78" static="1">
			<f a="id:?type" v=":null">
				<c path="String"/>
				<x path="openfl.AssetType"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":value"><e>{ type : null }</e></m></meta>
			<haxe_doc>* Returns whether a specific asset exists
	 * @param	id 		The ID or asset path for the asset
	 * @param	type	The asset type to match, or null to match any type
	 * @return		Whether the requested asset ID and type exists</haxe_doc>
		</exists>
		<getBitmapData public="1" set="method" line="92" static="1">
			<f a="id:?useCache" v=":true">
				<c path="String"/>
				<x path="Bool"/>
				<c path="openfl.display.BitmapData"/>
			</f>
			<meta><m n=":value"><e>{ useCache : true }</e></m></meta>
			<haxe_doc>* Gets an instance of an embedded bitmap
	 * @usage		var bitmap = new Bitmap (Assets.getBitmapData ("image.png"));
	 * @param	id		The ID or asset path for the bitmap
	 * @param	useCache		(Optional) Whether to allow use of the asset cache (Default: true)
	 * @return		A new BitmapData object</haxe_doc>
		</getBitmapData>
		<getBytes public="1" set="method" line="141" static="1">
			<f a="id">
				<c path="String"/>
				<x path="openfl.utils.ByteArray"/>
			</f>
			<haxe_doc>* Gets an instance of an embedded binary asset
	 * @usage		var bytes = Assets.getBytes ("file.zip");
	 * @param	id		The ID or asset path for the asset
	 * @return		A new ByteArray object</haxe_doc>
		</getBytes>
		<getFont public="1" set="method" line="155" static="1">
			<f a="id:?useCache" v=":true">
				<c path="String"/>
				<x path="Bool"/>
				<c path="openfl.text.Font"/>
			</f>
			<meta><m n=":value"><e>{ useCache : true }</e></m></meta>
			<haxe_doc>* Gets an instance of an embedded font
	 * @usage		var fontName = Assets.getFont ("font.ttf").fontName;
	 * @param	id		The ID or asset path for the font
	 * @param	useCache		(Optional) Whether to allow use of the asset cache (Default: true)
	 * @return		A new Font object</haxe_doc>
		</getFont>
		<getLibrary set="method" line="192" static="1"><f a="name">
	<c path="String"/>
	<t path="lime._Assets.LimeAssetLibrary"/>
</f></getLibrary>
		<getMovieClip public="1" set="method" line="205" static="1">
			<f a="id">
				<c path="String"/>
				<c path="openfl.display.MovieClip"/>
			</f>
			<haxe_doc>* Gets an instance of an included MovieClip
	 * @usage		var movieClip = Assets.getMovieClip ("library:BouncingBall");
	 * @param	id		The ID for the MovieClip
	 * @return		A new MovieClip object</haxe_doc>
		</getMovieClip>
		<getMusic public="1" set="method" line="253" static="1">
			<f a="id:?useCache" v=":true">
				<c path="String"/>
				<x path="Bool"/>
				<c path="openfl.media.Sound"/>
			</f>
			<meta><m n=":value"><e>{ useCache : true }</e></m></meta>
			<haxe_doc>* Gets an instance of an embedded streaming sound
	 * @usage		var sound = Assets.getMusic ("sound.ogg");
	 * @param	id		The ID or asset path for the audio stream
	 * @param	useCache		(Optional) Whether to allow use of the asset cache (Default: true)
	 * @return		A new Sound object</haxe_doc>
		</getMusic>
		<getPath public="1" set="method" line="283" static="1">
			<f a="id">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>* Gets the file path (if available) for an asset
	 * @usage		var path = Assets.getPath ("file.txt");
	 * @param	id		The ID or asset path for the asset
	 * @return		The path to the asset, or null if it does not exist</haxe_doc>
		</getPath>
		<getSound public="1" set="method" line="297" static="1">
			<f a="id:?useCache" v=":true">
				<c path="String"/>
				<x path="Bool"/>
				<c path="openfl.media.Sound"/>
			</f>
			<meta><m n=":value"><e>{ useCache : true }</e></m></meta>
			<haxe_doc>* Gets an instance of an embedded sound
	 * @usage		var sound = Assets.getSound ("sound.wav");
	 * @param	id		The ID or asset path for the sound
	 * @param	useCache		(Optional) Whether to allow use of the asset cache (Default: true)
	 * @return		A new Sound object</haxe_doc>
		</getSound>
		<getText public="1" set="method" line="356" static="1">
			<f a="id">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>* Gets an instance of an embedded text asset
	 * @usage		var text = Assets.getText ("text.txt");
	 * @param	id		The ID or asset path for the asset
	 * @return		A new String object</haxe_doc>
		</getText>
		<hasEventListener public="1" set="method" line="363" static="1"><f a="type">
	<c path="String"/>
	<x path="Bool"/>
</f></hasEventListener>
		<isLocal public="1" set="method" line="377" static="1">
			<f a="id:?type:?useCache" v=":null:true">
				<c path="String"/>
				<x path="openfl.AssetType"/>
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":value"><e>{ useCache : true, type : null }</e></m></meta>
			<haxe_doc>* Returns whether an asset is "local", and therefore can be loaded synchronously
	 * @param	id 		The ID or asset path for the asset
	 * @param	type	The asset type to match, or null to match any type
	 * @param	useCache		(Optional) Whether to allow use of the asset cache (Default: true)
	 * @return	Whether the asset is local</haxe_doc>
		</isLocal>
		<isValidBitmapData set="method" line="420" static="1"><f a="bitmapData">
	<c path="openfl.display.BitmapData"/>
	<x path="Bool"/>
</f></isValidBitmapData>
		<isValidSound set="method" line="450" static="1"><f a="sound">
	<c path="openfl.media.Sound"/>
	<x path="Bool"/>
</f></isValidSound>
		<list public="1" set="method" line="471" static="1">
			<f a="?type" v="null">
				<x path="openfl.AssetType"/>
				<c path="Array"><c path="String"/></c>
			</f>
			<meta><m n=":value"><e>{ type : null }</e></m></meta>
			<haxe_doc>* Returns a list of all embedded assets (by type)
	 * @param	type	The asset type to match, or null to match any type
	 * @return	An array of asset ID values</haxe_doc>
		</list>
		<loadBitmapData public="1" set="method" line="486" static="1">
			<f a="id:?useCache:?handler" v=":true:null">
				<c path="String"/>
				<x path="Bool"/>
				<f a="">
					<c path="openfl.display.BitmapData"/>
					<x path="Void"/>
				</f>
				<c path="lime.app.Future"><c path="openfl.display.BitmapData"/></c>
			</f>
			<meta><m n=":value"><e>{ handler : null, useCache : true }</e></m></meta>
			<haxe_doc><![CDATA[* Loads an included bitmap asset asynchronously
	 * @usage		Asset.loadBitmapData ("image.png").onComplete (handleImage);
	 * @param	id 		The ID or asset path for the asset
	 * @param	useCache		(Optional) Whether to allow use of the asset cache (Default: true)
	 * @param	handler		(Deprecated) A callback function when the load is completed
	 * @return		Returns a Future<BitmapData>]]></haxe_doc>
		</loadBitmapData>
		<loadBytes public="1" set="method" line="555" static="1">
			<f a="id:?handler" v=":null">
				<c path="String"/>
				<f a="">
					<x path="openfl.utils.ByteArray"/>
					<x path="Void"/>
				</f>
				<c path="lime.app.Future"><x path="openfl.utils.ByteArray"/></c>
			</f>
			<meta><m n=":value"><e>{ handler : null }</e></m></meta>
			<haxe_doc><![CDATA[* Loads an included byte asset asynchronously
	 * @usage		Asset.loadBytes ("file.zip").onComplete (handleBytes);
	 * @param	id 		The ID or asset path for the asset
	 * @param	useCache		(Optional) Whether to allow use of the asset cache (Default: true)
	 * @param	handler		(Deprecated) A callback function when the load is completed
	 * @return		Returns a Future<ByteArray>]]></haxe_doc>
		</loadBytes>
		<loadFont public="1" set="method" line="584" static="1">
			<f a="id:?useCache:?handler" v=":true:null">
				<c path="String"/>
				<x path="Bool"/>
				<f a="">
					<c path="openfl.text.Font"/>
					<x path="Void"/>
				</f>
				<c path="lime.app.Future"><c path="openfl.text.Font"/></c>
			</f>
			<meta><m n=":value"><e>{ handler : null, useCache : true }</e></m></meta>
			<haxe_doc><![CDATA[* Loads an included font asset asynchronously
	 * @usage		Asset.loadFont ("font.ttf").onComplete (handleFont);
	 * @param	id 		The ID or asset path for the asset
	 * @param	useCache		(Optional) Whether to allow use of the asset cache (Default: true)
	 * @param	handler		(Deprecated) A callback function when the load is completed
	 * @return		Returns a Future<Font>]]></haxe_doc>
		</loadFont>
		<loadLibrary public="1" set="method" line="637" static="1">
			<f a="name:?handler" v=":null">
				<c path="String"/>
				<f a="">
					<t path="lime._Assets.LimeAssetLibrary"/>
					<x path="Void"/>
				</f>
				<c path="lime.app.Future"><t path="lime._Assets.LimeAssetLibrary"/></c>
			</f>
			<meta><m n=":value"><e>{ handler : null }</e></m></meta>
			<haxe_doc><![CDATA[* Load an included AssetLibrary
	 * @param	name		The name of the AssetLibrary to load
	 * @param	handler		(Deprecated) A callback function when the load is completed
	 * @return		Returns a Future<AssetLibrary>]]></haxe_doc>
		</loadLibrary>
		<loadMusic public="1" set="method" line="661" static="1">
			<f a="id:?useCache:?handler" v=":true:null">
				<c path="String"/>
				<x path="Bool"/>
				<f a="">
					<c path="openfl.media.Sound"/>
					<x path="Void"/>
				</f>
				<c path="lime.app.Future"><c path="openfl.media.Sound"/></c>
			</f>
			<meta><m n=":value"><e>{ handler : null, useCache : true }</e></m></meta>
			<haxe_doc><![CDATA[* Loads an included music asset asynchronously
	 * @usage		Asset.loadMusic ("music.ogg").onComplete (handleMusic);
	 * @param	id 		The ID or asset path for the asset
	 * @param	useCache		(Optional) Whether to allow use of the asset cache (Default: true)
	 * @param	handler		(Deprecated) A callback function when the load is completed
	 * @return		Returns a Future<Sound>]]></haxe_doc>
		</loadMusic>
		<loadMovieClip public="1" set="method" line="705" static="1">
			<f a="id:?handler" v=":null">
				<c path="String"/>
				<f a="">
					<c path="openfl.display.MovieClip"/>
					<x path="Void"/>
				</f>
				<c path="lime.app.Future"><c path="openfl.display.MovieClip"/></c>
			</f>
			<meta><m n=":value"><e>{ handler : null }</e></m></meta>
			<haxe_doc><![CDATA[* Loads an included MovieClip asset asynchronously
	 * @usage		Asset.loadMovieClip ("library:BouncingBall").onComplete (handleMovieClip);
	 * @param	id 		The ID for the asset
	 * @param	useCache		(Optional) Whether to allow use of the asset cache (Default: true)
	 * @param	handler		(Deprecated) A callback function when the load is completed
	 * @return		Returns a Future<MovieClip>]]></haxe_doc>
		</loadMovieClip>
		<loadSound public="1" set="method" line="755" static="1">
			<f a="id:?useCache:?handler" v=":true:null">
				<c path="String"/>
				<x path="Bool"/>
				<f a="">
					<c path="openfl.media.Sound"/>
					<x path="Void"/>
				</f>
				<c path="lime.app.Future"><c path="openfl.media.Sound"/></c>
			</f>
			<meta><m n=":value"><e>{ handler : null, useCache : true }</e></m></meta>
			<haxe_doc><![CDATA[* Loads an included sound asset asynchronously
	 * @usage		Asset.loadSound ("sound.wav").onComplete (handleSound);
	 * @param	id 		The ID or asset path for the asset
	 * @param	useCache		(Optional) Whether to allow use of the asset cache (Default: true)
	 * @param	handler		(Deprecated) A callback function when the load is completed
	 * @return		Returns a Future<Sound>]]></haxe_doc>
		</loadSound>
		<loadText public="1" set="method" line="799" static="1">
			<f a="id:?handler" v=":null">
				<c path="String"/>
				<f a="">
					<c path="String"/>
					<x path="Void"/>
				</f>
				<c path="lime.app.Future"><c path="String"/></c>
			</f>
			<meta><m n=":value"><e>{ handler : null }</e></m></meta>
			<haxe_doc><![CDATA[* Loads an included text asset asynchronously
	 * @usage		Asset.loadText ("text.txt").onComplete (handleString);
	 * @param	id 		The ID or asset path for the asset
	 * @param	useCache		(Optional) Whether to allow use of the asset cache (Default: true)
	 * @param	handler		(Deprecated) A callback function when the load is completed
	 * @return		Returns a Future<String>]]></haxe_doc>
		</loadText>
		<registerLibrary public="1" set="method" line="820" static="1">
			<f a="name:library">
				<c path="String"/>
				<c path="openfl.AssetLibrary"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Registers a new AssetLibrary with the Assets class
	 * @param	name		The name (prefix) to use for the library
	 * @param	library		An AssetLibrary instance to register</haxe_doc>
		</registerLibrary>
		<removeEventListener public="1" set="method" line="827" static="1">
			<f a="type:listener:?capture" v="::false">
				<c path="String"/>
				<d/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ capture : false }</e></m></meta>
		</removeEventListener>
		<resolveClass set="method" line="834" static="1"><f a="name">
	<c path="String"/>
	<x path="Class"><d/></x>
</f></resolveClass>
		<resolveEnum set="method" line="841" static="1"><f a="name">
	<c path="String"/>
	<x path="Enum"><d/></x>
</f></resolveEnum>
		<unloadLibrary public="1" set="method" line="860" static="1"><f a="name">
	<c path="String"/>
	<x path="Void"/>
</f></unloadLibrary>
		<LimeAssets_onChange set="method" line="874" static="1"><f a=""><x path="Void"/></f></LimeAssets_onChange>
		<haxe_doc><![CDATA[* <p>The Assets class provides a cross-platform interface to access 
 * embedded images, fonts, sounds and other resource files.</p>
 * 
 * <p>The contents are populated automatically when an application
 * is compiled using the OpenFL command-line tools, based on the
 * contents of the *.xml project file.</p>
 * 
 * <p>For most platforms, the assets are included in the same directory
 * or package as the application, and the paths are handled
 * automatically. For web content, the assets are preloaded before
 * the start of the rest of the application. You can customize the 
 * preloader by extending the <code>NMEPreloader</code> class,
 * and specifying a custom preloader using <window preloader="" />
 * in the project file.</p>]]></haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":access"><e>lime.Assets</e></m>
			<m n=":access"><e>openfl.AssetLibrary</e></m>
			<m n=":access"><e>openfl.display.BitmapData</e></m>
			<m n=":access"><e>openfl.text.Font</e></m>
		</meta>
	</class>
	<class path="openfl.AssetLibrary" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/Assets.hx" module="openfl.Assets">
		<extends path="lime.AssetLibrary"/>
		<getMovieClip public="1" set="method" line="894"><f a="id">
	<c path="String"/>
	<c path="openfl.display.MovieClip"/>
</f></getMovieClip>
		<loadMovieClip public="1" set="method" line="901"><f a="id">
	<c path="String"/>
	<c path="lime.app.Future"><c path="openfl.display.MovieClip"/></c>
</f></loadMovieClip>
		<new public="1" set="method" line="887"><f a=""><x path="Void"/></f></new>
		<meta><m n=":dox"><e>hide</e></m></meta>
	</class>
	<abstract path="openfl.AssetType" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/Assets.hx" module="openfl.Assets">
		<this><c path="String"/></this>
		<meta>
			<m n=":dox"><e>hide</e></m>
			<m n=":enum"/>
		</meta>
		<impl><class path="openfl._Assets.AssetType_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/Assets.hx" private="1" module="openfl.Assets" extern="1">
	<BINARY public="1" get="inline" set="null" expr="cast &quot;BINARY&quot;" line="1114" static="1">
		<x path="openfl.AssetType"/>
		<meta>
			<m n=":value"><e>cast "BINARY"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</BINARY>
	<FONT public="1" get="inline" set="null" expr="cast &quot;FONT&quot;" line="1115" static="1">
		<x path="openfl.AssetType"/>
		<meta>
			<m n=":value"><e>cast "FONT"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</FONT>
	<IMAGE public="1" get="inline" set="null" expr="cast &quot;IMAGE&quot;" line="1116" static="1">
		<x path="openfl.AssetType"/>
		<meta>
			<m n=":value"><e>cast "IMAGE"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</IMAGE>
	<MOVIE_CLIP public="1" get="inline" set="null" expr="cast &quot;MOVIE_CLIP&quot;" line="1117" static="1">
		<x path="openfl.AssetType"/>
		<meta>
			<m n=":value"><e>cast "MOVIE_CLIP"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</MOVIE_CLIP>
	<MUSIC public="1" get="inline" set="null" expr="cast &quot;MUSIC&quot;" line="1118" static="1">
		<x path="openfl.AssetType"/>
		<meta>
			<m n=":value"><e>cast "MUSIC"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</MUSIC>
	<SOUND public="1" get="inline" set="null" expr="cast &quot;SOUND&quot;" line="1119" static="1">
		<x path="openfl.AssetType"/>
		<meta>
			<m n=":value"><e>cast "SOUND"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</SOUND>
	<TEMPLATE public="1" get="inline" set="null" expr="cast &quot;TEMPLATE&quot;" line="1120" static="1">
		<x path="openfl.AssetType"/>
		<meta>
			<m n=":value"><e>cast "TEMPLATE"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</TEMPLATE>
	<TEXT public="1" get="inline" set="null" expr="cast &quot;TEXT&quot;" line="1121" static="1">
		<x path="openfl.AssetType"/>
		<meta>
			<m n=":value"><e>cast "TEXT"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</TEXT>
	<meta>
		<m n=":final"/>
		<m n=":enum"/>
	</meta>
</class></impl>
	</abstract>
	<class path="openfl._Assets.AssetType_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/Assets.hx" private="1" module="openfl.Assets" extern="1">
		<BINARY public="1" get="inline" set="null" expr="cast &quot;BINARY&quot;" line="1114" static="1">
			<x path="openfl.AssetType"/>
			<meta>
				<m n=":value"><e>cast "BINARY"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</BINARY>
		<FONT public="1" get="inline" set="null" expr="cast &quot;FONT&quot;" line="1115" static="1">
			<x path="openfl.AssetType"/>
			<meta>
				<m n=":value"><e>cast "FONT"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</FONT>
		<IMAGE public="1" get="inline" set="null" expr="cast &quot;IMAGE&quot;" line="1116" static="1">
			<x path="openfl.AssetType"/>
			<meta>
				<m n=":value"><e>cast "IMAGE"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</IMAGE>
		<MOVIE_CLIP public="1" get="inline" set="null" expr="cast &quot;MOVIE_CLIP&quot;" line="1117" static="1">
			<x path="openfl.AssetType"/>
			<meta>
				<m n=":value"><e>cast "MOVIE_CLIP"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</MOVIE_CLIP>
		<MUSIC public="1" get="inline" set="null" expr="cast &quot;MUSIC&quot;" line="1118" static="1">
			<x path="openfl.AssetType"/>
			<meta>
				<m n=":value"><e>cast "MUSIC"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</MUSIC>
		<SOUND public="1" get="inline" set="null" expr="cast &quot;SOUND&quot;" line="1119" static="1">
			<x path="openfl.AssetType"/>
			<meta>
				<m n=":value"><e>cast "SOUND"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</SOUND>
		<TEMPLATE public="1" get="inline" set="null" expr="cast &quot;TEMPLATE&quot;" line="1120" static="1">
			<x path="openfl.AssetType"/>
			<meta>
				<m n=":value"><e>cast "TEMPLATE"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</TEMPLATE>
		<TEXT public="1" get="inline" set="null" expr="cast &quot;TEXT&quot;" line="1121" static="1">
			<x path="openfl.AssetType"/>
			<meta>
				<m n=":value"><e>cast "TEXT"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</TEXT>
		<meta>
			<m n=":final"/>
			<m n=":enum"/>
		</meta>
	</class>
	<class path="openfl.display.MovieClip" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/display/MovieClip.hx">
		<extends path="openfl.display.Sprite"/>
		<currentFrame public="1" get="accessor" set="null"><x path="Int"/></currentFrame>
		<currentFrameLabel public="1" get="accessor" set="null"><c path="String"/></currentFrameLabel>
		<currentLabel public="1" get="accessor" set="null"><c path="String"/></currentLabel>
		<currentLabels public="1" get="accessor" set="null"><c path="Array"><c path="openfl.display.FrameLabel"/></c></currentLabels>
		<enabled public="1"><x path="Bool"/></enabled>
		<framesLoaded public="1" get="accessor" set="null"><x path="Int"/></framesLoaded>
		<totalFrames public="1" get="accessor" set="null"><x path="Int"/></totalFrames>
		<__currentFrame><x path="Int"/></__currentFrame>
		<__currentFrameLabel><c path="String"/></__currentFrameLabel>
		<__currentLabel><c path="String"/></__currentLabel>
		<__currentLabels><c path="Array"><c path="openfl.display.FrameLabel"/></c></__currentLabels>
		<__frameScripts><x path="Map">
	<x path="Int"/>
	<f a=""><x path="Void"/></f>
</x></__frameScripts>
		<__totalFrames><x path="Int"/></__totalFrames>
		<addFrameScript public="1" set="method" line="35"><f a="index:method">
	<x path="Int"/>
	<f a=""><x path="Void"/></f>
	<x path="Void"/>
</f></addFrameScript>
		<gotoAndPlay public="1" set="method" line="56">
			<f a="frame:?scene" v=":null">
				<d/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ scene : null }</e></m></meta>
		</gotoAndPlay>
		<gotoAndStop public="1" set="method" line="63">
			<f a="frame:?scene" v=":null">
				<d/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ scene : null }</e></m></meta>
		</gotoAndStop>
		<nextFrame public="1" set="method" line="70"><f a=""><x path="Void"/></f></nextFrame>
		<play public="1" set="method" line="77"><f a=""><x path="Void"/></f></play>
		<prevFrame public="1" set="method" line="84"><f a=""><x path="Void"/></f></prevFrame>
		<stop public="1" set="method" line="91"><f a=""><x path="Void"/></f></stop>
		<get_currentFrame set="method" line="105"><f a=""><x path="Int"/></f></get_currentFrame>
		<get_currentFrameLabel set="method" line="106"><f a=""><c path="String"/></f></get_currentFrameLabel>
		<get_currentLabel set="method" line="107"><f a=""><c path="String"/></f></get_currentLabel>
		<get_currentLabels set="method" line="108"><f a=""><c path="Array"><c path="openfl.display.FrameLabel"/></c></f></get_currentLabels>
		<get_framesLoaded set="method" line="109"><f a=""><x path="Int"/></f></get_framesLoaded>
		<get_totalFrames set="method" line="110"><f a=""><x path="Int"/></f></get_totalFrames>
		<new public="1" set="method" line="23"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="openfl.Lib" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/Lib.hx">
		<application public="1" static="1"><c path="openfl.display.Application"/></application>
		<current public="1" set="null" expr="new MovieClip()" line="21" static="1">
			<c path="openfl.display.MovieClip"/>
			<meta><m n=":value"><e>new MovieClip()</e></m></meta>
		</current>
		<__sentWarnings expr="new Map&lt;String,Bool&gt;()" line="26" static="1">
			<x path="Map">
				<c path="String"/>
				<x path="Bool"/>
			</x>
			<meta>
				<m n=":value"><e><![CDATA[new Map<String,Bool>()]]></e></m>
				<m n=":noCompletion"/>
			</meta>
		</__sentWarnings>
		<as public="1" params="T" set="method" line="29" static="1"><f a="v:c">
	<d/>
	<x path="Class"><c path="as.T"/></x>
	<t path="Null"><c path="as.T"/></t>
</f></as>
		<attach public="1" set="method" line="40" static="1"><f a="name">
	<c path="String"/>
	<c path="openfl.display.MovieClip"/>
</f></attach>
		<getTimer public="1" set="method" line="79" static="1"><f a=""><x path="Int"/></f></getTimer>
		<getURL public="1" set="method" line="90" static="1">
			<f a="request:?target" v=":null">
				<c path="openfl.net.URLRequest"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ target : null }</e></m></meta>
		</getURL>
		<notImplemented public="1" set="method" line="107" static="1"><f a="api">
	<c path="String"/>
	<x path="Void"/>
</f></notImplemented>
		<preventDefaultTouchMove public="1" set="method" line="120" static="1"><f a=""><x path="Void"/></f></preventDefaultTouchMove>
		<trace public="1" set="method" line="142" static="1"><f a="arg">
	<d/>
	<x path="Void"/>
</f></trace>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":access"><e>openfl.display.Stage</e></m>
		</meta>
	</class>
	<abstract path="openfl.Vector" params="T" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/Vector.hx">
		<from>
			<icast field="fromArray"><c path="Array"><c path="fromArray.T"/></c></icast>
			<icast field="fromHaxeVector"><x path="haxe.ds.Vector"><c path="fromHaxeVector.T"/></x></icast>
			<icast field="fromVectorData"><c path="openfl.VectorData"><c path="fromVectorData.T"/></c></icast>
		</from>
		<this><c path="openfl.VectorData"><c path="openfl.Vector.T"/></c></this>
		<to>
			<icast field="toArray"><c path="Array"><c path="toArray.T"/></c></icast>
			<icast field="toHaxeVector"><x path="haxe.ds.Vector"><c path="toHaxeVector.T"/></x></icast>
			<icast field="toVectorData"><c path="openfl.VectorData"><c path="toVectorData.T"/></c></icast>
		</to>
		<impl><class path="openfl._Vector.Vector_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/Vector.hx" private="1" module="openfl.Vector">
	<length public="1" get="accessor" set="accessor" static="1">
		<x path="Int"/>
		<meta><m n=":impl"/></meta>
	</length>
	<fixed public="1" get="accessor" set="accessor" static="1">
		<x path="Bool"/>
		<meta><m n=":impl"/></meta>
	</fixed>
	<_new public="1" get="inline" set="null" line="215" static="1">
		<f a="?length:?fixed" v="0:false">
			<x path="Int"/>
			<x path="Bool"/>
			<x path="openfl.Vector"><c path="openfl.Vector.T"/></x>
		</f>
		<meta>
			<m n=":value"><e>{ fixed : false, length : 0 }</e></m>
			<m n=":impl"/>
		</meta>
	</_new>
	<concat public="1" get="inline" set="null" line="230" static="1">
		<f a="this:?a">
			<c path="openfl.VectorData"><c path="openfl.Vector.T"/></c>
			<c path="openfl.VectorData"><c path="openfl.Vector.T"/></c>
			<x path="openfl.Vector"><c path="openfl.Vector.T"/></x>
		</f>
		<meta><m n=":impl"/></meta>
	</concat>
	<copy public="1" get="inline" set="null" line="251" static="1">
		<f a="this">
			<c path="openfl.VectorData"><c path="openfl.Vector.T"/></c>
			<x path="openfl.Vector"><c path="openfl.Vector.T"/></x>
		</f>
		<meta><m n=":impl"/></meta>
	</copy>
	<iterator public="1" params="T" get="inline" set="null" line="267" static="1">
		<f a="this">
			<c path="openfl.VectorData"><c path="iterator.T"/></c>
			<t path="Iterator"><c path="iterator.T"/></t>
		</f>
		<meta><m n=":impl"/></meta>
	</iterator>
	<join public="1" get="inline" set="null" line="274" static="1">
		<f a="this:sep">
			<c path="openfl.VectorData"><c path="openfl.Vector.T"/></c>
			<c path="String"/>
			<c path="String"/>
		</f>
		<meta><m n=":impl"/></meta>
	</join>
	<pop public="1" get="inline" set="null" line="290" static="1">
		<f a="this">
			<c path="openfl.VectorData"><c path="openfl.Vector.T"/></c>
			<t path="Null"><c path="openfl.Vector.T"/></t>
		</f>
		<meta><m n=":impl"/></meta>
	</pop>
	<push public="1" get="inline" set="null" line="310" static="1">
		<f a="this:x">
			<c path="openfl.VectorData"><c path="openfl.Vector.T"/></c>
			<c path="openfl.Vector.T"/>
			<x path="Int"/>
		</f>
		<meta><m n=":impl"/></meta>
	</push>
	<reverse public="1" get="inline" set="null" line="337" static="1">
		<f a="this">
			<c path="openfl.VectorData"><c path="openfl.Vector.T"/></c>
			<x path="Void"/>
		</f>
		<meta><m n=":impl"/></meta>
	</reverse>
	<shift public="1" get="inline" set="null" line="353" static="1">
		<f a="this">
			<c path="openfl.VectorData"><c path="openfl.Vector.T"/></c>
			<t path="Null"><c path="openfl.Vector.T"/></t>
		</f>
		<meta><m n=":impl"/></meta>
	</shift>
	<unshift public="1" get="inline" set="null" line="374" static="1">
		<f a="this:x">
			<c path="openfl.VectorData"><c path="openfl.Vector.T"/></c>
			<c path="openfl.Vector.T"/>
			<x path="Void"/>
		</f>
		<meta><m n=":impl"/></meta>
	</unshift>
	<slice public="1" get="inline" set="null" line="409" static="1">
		<f a="this:?pos:?end" v=":0:0">
			<c path="openfl.VectorData"><c path="openfl.Vector.T"/></c>
			<x path="Int"/>
			<x path="Int"/>
			<x path="openfl.Vector"><c path="openfl.Vector.T"/></x>
		</f>
		<meta>
			<m n=":value"><e>{ end : 0, pos : 0 }</e></m>
			<m n=":impl"/>
		</meta>
	</slice>
	<sort public="1" get="inline" set="null" line="431" static="1">
		<f a="this:f">
			<c path="openfl.VectorData"><c path="openfl.Vector.T"/></c>
			<f a=":">
				<c path="openfl.Vector.T"/>
				<c path="openfl.Vector.T"/>
				<x path="Int"/>
			</f>
			<x path="Void"/>
		</f>
		<meta><m n=":impl"/></meta>
	</sort>
	<splice public="1" get="inline" set="null" line="444" static="1">
		<f a="this:pos:len">
			<c path="openfl.VectorData"><c path="openfl.Vector.T"/></c>
			<x path="Int"/>
			<x path="Int"/>
			<x path="openfl.Vector"><c path="openfl.Vector.T"/></x>
		</f>
		<meta><m n=":impl"/></meta>
	</splice>
	<toString public="1" get="inline" set="null" line="476" static="1">
		<f a="this">
			<c path="openfl.VectorData"><c path="openfl.Vector.T"/></c>
			<c path="String"/>
		</f>
		<meta><m n=":impl"/></meta>
	</toString>
	<indexOf public="1" get="inline" set="null" line="487" static="1">
		<f a="this:x:?from" v="::0">
			<c path="openfl.VectorData"><c path="openfl.Vector.T"/></c>
			<c path="openfl.Vector.T"/>
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<meta>
			<m n=":value"><e>{ from : 0 }</e></m>
			<m n=":impl"/>
		</meta>
	</indexOf>
	<lastIndexOf public="1" get="inline" set="null" line="507" static="1">
		<f a="this:x:?from" v="::0">
			<c path="openfl.VectorData"><c path="openfl.Vector.T"/></c>
			<c path="openfl.Vector.T"/>
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<meta>
			<m n=":value"><e>{ from : 0 }</e></m>
			<m n=":impl"/>
		</meta>
	</lastIndexOf>
	<ofArray public="1" params="T" get="inline" set="null" line="530" static="1"><f a="a">
	<c path="Array"><d/></c>
	<x path="openfl.Vector"><c path="ofArray.T"/></x>
</f></ofArray>
	<convert public="1" params="T:U" get="inline" set="null" line="545" static="1"><f a="v">
	<x path="openfl.Vector"><c path="convert.T"/></x>
	<x path="openfl.Vector"><c path="convert.U"/></x>
</f></convert>
	<get public="1" get="inline" set="null" line="552" static="1">
		<f a="this:index">
			<c path="openfl.VectorData"><c path="openfl.Vector.T"/></c>
			<x path="Int"/>
			<t path="Null"><c path="openfl.Vector.T"/></t>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
			<m n=":dox"><e>hide</e></m>
			<m n=":arrayAccess"/>
		</meta>
	</get>
	<set public="1" get="inline" set="null" line="559" static="1">
		<f a="this:key:value">
			<c path="openfl.VectorData"><c path="openfl.Vector.T"/></c>
			<x path="Int"/>
			<c path="openfl.Vector.T"/>
			<c path="openfl.Vector.T"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
			<m n=":dox"><e>hide</e></m>
			<m n=":arrayAccess"/>
		</meta>
	</set>
	<fromArray public="1" params="T" get="inline" set="null" line="582" static="1">
		<f a="value">
			<c path="Array"><c path="fromArray.T"/></c>
			<x path="openfl.Vector"><c path="fromArray.T"/></x>
		</f>
		<meta>
			<m n=":noCompletion"/>
			<m n=":dox"><e>hide</e></m>
			<m n=":from"/>
		</meta>
	</fromArray>
	<toArray public="1" params="T" get="inline" set="null" line="597" static="1">
		<f a="this">
			<c path="openfl.VectorData"><c path="toArray.T"/></c>
			<c path="Array"><c path="toArray.T"/></c>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
			<m n=":dox"><e>hide</e></m>
			<m n=":to"/>
		</meta>
	</toArray>
	<fromHaxeVector public="1" params="T" get="inline" set="null" line="612" static="1">
		<f a="value">
			<x path="haxe.ds.Vector"><c path="fromHaxeVector.T"/></x>
			<x path="openfl.Vector"><c path="fromHaxeVector.T"/></x>
		</f>
		<meta>
			<m n=":noCompletion"/>
			<m n=":dox"><e>hide</e></m>
			<m n=":from"/>
		</meta>
	</fromHaxeVector>
	<toHaxeVector public="1" params="T" get="inline" set="null" line="631" static="1">
		<f a="this">
			<c path="openfl.VectorData"><c path="toHaxeVector.T"/></c>
			<x path="haxe.ds.Vector"><c path="toHaxeVector.T"/></x>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
			<m n=":dox"><e>hide</e></m>
			<m n=":to"/>
		</meta>
	</toHaxeVector>
	<fromVectorData public="1" params="T" get="inline" set="null" line="642" static="1">
		<f a="value">
			<c path="openfl.VectorData"><c path="fromVectorData.T"/></c>
			<x path="openfl.Vector"><c path="fromVectorData.T"/></x>
		</f>
		<meta>
			<m n=":noCompletion"/>
			<m n=":dox"><e>hide</e></m>
			<m n=":from"/>
		</meta>
	</fromVectorData>
	<toVectorData public="1" params="T" get="inline" set="null" line="649" static="1">
		<f a="this">
			<c path="openfl.VectorData"><c path="toVectorData.T"/></c>
			<c path="openfl.VectorData"><c path="toVectorData.T"/></c>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
			<m n=":dox"><e>hide</e></m>
			<m n=":to"/>
		</meta>
	</toVectorData>
	<get_length get="inline" set="null" line="663" static="1">
		<f a="this">
			<c path="openfl.VectorData"><c path="openfl.Vector.T"/></c>
			<x path="Int"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
	</get_length>
	<set_length get="inline" set="null" line="670" static="1">
		<f a="this:value">
			<c path="openfl.VectorData"><c path="openfl.Vector.T"/></c>
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
	</set_length>
	<get_fixed get="inline" set="null" line="695" static="1">
		<f a="this">
			<c path="openfl.VectorData"><c path="openfl.Vector.T"/></c>
			<x path="Bool"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
	</get_fixed>
	<set_fixed get="inline" set="null" line="702" static="1">
		<f a="this:value">
			<c path="openfl.VectorData"><c path="openfl.Vector.T"/></c>
			<x path="Bool"/>
			<x path="Bool"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
	</set_fixed>
	<meta><m n=":final"/></meta>
</class></impl>
	</abstract>
	<class path="openfl._Vector.Vector_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/Vector.hx" private="1" module="openfl.Vector">
		<length public="1" get="accessor" set="accessor" static="1">
			<x path="Int"/>
			<meta><m n=":impl"/></meta>
		</length>
		<fixed public="1" get="accessor" set="accessor" static="1">
			<x path="Bool"/>
			<meta><m n=":impl"/></meta>
		</fixed>
		<_new public="1" get="inline" set="null" line="215" static="1">
			<f a="?length:?fixed" v="0:false">
				<x path="Int"/>
				<x path="Bool"/>
				<x path="openfl.Vector"><c path="openfl.Vector.T"/></x>
			</f>
			<meta>
				<m n=":value"><e>{ fixed : false, length : 0 }</e></m>
				<m n=":impl"/>
			</meta>
		</_new>
		<concat public="1" get="inline" set="null" line="230" static="1">
			<f a="this:?a">
				<c path="openfl.VectorData"><c path="openfl.Vector.T"/></c>
				<c path="openfl.VectorData"><c path="openfl.Vector.T"/></c>
				<x path="openfl.Vector"><c path="openfl.Vector.T"/></x>
			</f>
			<meta><m n=":impl"/></meta>
		</concat>
		<copy public="1" get="inline" set="null" line="251" static="1">
			<f a="this">
				<c path="openfl.VectorData"><c path="openfl.Vector.T"/></c>
				<x path="openfl.Vector"><c path="openfl.Vector.T"/></x>
			</f>
			<meta><m n=":impl"/></meta>
		</copy>
		<iterator public="1" params="T" get="inline" set="null" line="267" static="1">
			<f a="this">
				<c path="openfl.VectorData"><c path="iterator.T"/></c>
				<t path="Iterator"><c path="iterator.T"/></t>
			</f>
			<meta><m n=":impl"/></meta>
		</iterator>
		<join public="1" get="inline" set="null" line="274" static="1">
			<f a="this:sep">
				<c path="openfl.VectorData"><c path="openfl.Vector.T"/></c>
				<c path="String"/>
				<c path="String"/>
			</f>
			<meta><m n=":impl"/></meta>
		</join>
		<pop public="1" get="inline" set="null" line="290" static="1">
			<f a="this">
				<c path="openfl.VectorData"><c path="openfl.Vector.T"/></c>
				<t path="Null"><c path="openfl.Vector.T"/></t>
			</f>
			<meta><m n=":impl"/></meta>
		</pop>
		<push public="1" get="inline" set="null" line="310" static="1">
			<f a="this:x">
				<c path="openfl.VectorData"><c path="openfl.Vector.T"/></c>
				<c path="openfl.Vector.T"/>
				<x path="Int"/>
			</f>
			<meta><m n=":impl"/></meta>
		</push>
		<reverse public="1" get="inline" set="null" line="337" static="1">
			<f a="this">
				<c path="openfl.VectorData"><c path="openfl.Vector.T"/></c>
				<x path="Void"/>
			</f>
			<meta><m n=":impl"/></meta>
		</reverse>
		<shift public="1" get="inline" set="null" line="353" static="1">
			<f a="this">
				<c path="openfl.VectorData"><c path="openfl.Vector.T"/></c>
				<t path="Null"><c path="openfl.Vector.T"/></t>
			</f>
			<meta><m n=":impl"/></meta>
		</shift>
		<unshift public="1" get="inline" set="null" line="374" static="1">
			<f a="this:x">
				<c path="openfl.VectorData"><c path="openfl.Vector.T"/></c>
				<c path="openfl.Vector.T"/>
				<x path="Void"/>
			</f>
			<meta><m n=":impl"/></meta>
		</unshift>
		<slice public="1" get="inline" set="null" line="409" static="1">
			<f a="this:?pos:?end" v=":0:0">
				<c path="openfl.VectorData"><c path="openfl.Vector.T"/></c>
				<x path="Int"/>
				<x path="Int"/>
				<x path="openfl.Vector"><c path="openfl.Vector.T"/></x>
			</f>
			<meta>
				<m n=":value"><e>{ end : 0, pos : 0 }</e></m>
				<m n=":impl"/>
			</meta>
		</slice>
		<sort public="1" get="inline" set="null" line="431" static="1">
			<f a="this:f">
				<c path="openfl.VectorData"><c path="openfl.Vector.T"/></c>
				<f a=":">
					<c path="openfl.Vector.T"/>
					<c path="openfl.Vector.T"/>
					<x path="Int"/>
				</f>
				<x path="Void"/>
			</f>
			<meta><m n=":impl"/></meta>
		</sort>
		<splice public="1" get="inline" set="null" line="444" static="1">
			<f a="this:pos:len">
				<c path="openfl.VectorData"><c path="openfl.Vector.T"/></c>
				<x path="Int"/>
				<x path="Int"/>
				<x path="openfl.Vector"><c path="openfl.Vector.T"/></x>
			</f>
			<meta><m n=":impl"/></meta>
		</splice>
		<toString public="1" get="inline" set="null" line="476" static="1">
			<f a="this">
				<c path="openfl.VectorData"><c path="openfl.Vector.T"/></c>
				<c path="String"/>
			</f>
			<meta><m n=":impl"/></meta>
		</toString>
		<indexOf public="1" get="inline" set="null" line="487" static="1">
			<f a="this:x:?from" v="::0">
				<c path="openfl.VectorData"><c path="openfl.Vector.T"/></c>
				<c path="openfl.Vector.T"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta>
				<m n=":value"><e>{ from : 0 }</e></m>
				<m n=":impl"/>
			</meta>
		</indexOf>
		<lastIndexOf public="1" get="inline" set="null" line="507" static="1">
			<f a="this:x:?from" v="::0">
				<c path="openfl.VectorData"><c path="openfl.Vector.T"/></c>
				<c path="openfl.Vector.T"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta>
				<m n=":value"><e>{ from : 0 }</e></m>
				<m n=":impl"/>
			</meta>
		</lastIndexOf>
		<ofArray public="1" params="T" get="inline" set="null" line="530" static="1"><f a="a">
	<c path="Array"><d/></c>
	<x path="openfl.Vector"><c path="ofArray.T"/></x>
</f></ofArray>
		<convert public="1" params="T:U" get="inline" set="null" line="545" static="1"><f a="v">
	<x path="openfl.Vector"><c path="convert.T"/></x>
	<x path="openfl.Vector"><c path="convert.U"/></x>
</f></convert>
		<get public="1" get="inline" set="null" line="552" static="1">
			<f a="this:index">
				<c path="openfl.VectorData"><c path="openfl.Vector.T"/></c>
				<x path="Int"/>
				<t path="Null"><c path="openfl.Vector.T"/></t>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
				<m n=":dox"><e>hide</e></m>
				<m n=":arrayAccess"/>
			</meta>
		</get>
		<set public="1" get="inline" set="null" line="559" static="1">
			<f a="this:key:value">
				<c path="openfl.VectorData"><c path="openfl.Vector.T"/></c>
				<x path="Int"/>
				<c path="openfl.Vector.T"/>
				<c path="openfl.Vector.T"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
				<m n=":dox"><e>hide</e></m>
				<m n=":arrayAccess"/>
			</meta>
		</set>
		<fromArray public="1" params="T" get="inline" set="null" line="582" static="1">
			<f a="value">
				<c path="Array"><c path="fromArray.T"/></c>
				<x path="openfl.Vector"><c path="fromArray.T"/></x>
			</f>
			<meta>
				<m n=":noCompletion"/>
				<m n=":dox"><e>hide</e></m>
				<m n=":from"/>
			</meta>
		</fromArray>
		<toArray public="1" params="T" get="inline" set="null" line="597" static="1">
			<f a="this">
				<c path="openfl.VectorData"><c path="toArray.T"/></c>
				<c path="Array"><c path="toArray.T"/></c>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
				<m n=":dox"><e>hide</e></m>
				<m n=":to"/>
			</meta>
		</toArray>
		<fromHaxeVector public="1" params="T" get="inline" set="null" line="612" static="1">
			<f a="value">
				<x path="haxe.ds.Vector"><c path="fromHaxeVector.T"/></x>
				<x path="openfl.Vector"><c path="fromHaxeVector.T"/></x>
			</f>
			<meta>
				<m n=":noCompletion"/>
				<m n=":dox"><e>hide</e></m>
				<m n=":from"/>
			</meta>
		</fromHaxeVector>
		<toHaxeVector public="1" params="T" get="inline" set="null" line="631" static="1">
			<f a="this">
				<c path="openfl.VectorData"><c path="toHaxeVector.T"/></c>
				<x path="haxe.ds.Vector"><c path="toHaxeVector.T"/></x>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
				<m n=":dox"><e>hide</e></m>
				<m n=":to"/>
			</meta>
		</toHaxeVector>
		<fromVectorData public="1" params="T" get="inline" set="null" line="642" static="1">
			<f a="value">
				<c path="openfl.VectorData"><c path="fromVectorData.T"/></c>
				<x path="openfl.Vector"><c path="fromVectorData.T"/></x>
			</f>
			<meta>
				<m n=":noCompletion"/>
				<m n=":dox"><e>hide</e></m>
				<m n=":from"/>
			</meta>
		</fromVectorData>
		<toVectorData public="1" params="T" get="inline" set="null" line="649" static="1">
			<f a="this">
				<c path="openfl.VectorData"><c path="toVectorData.T"/></c>
				<c path="openfl.VectorData"><c path="toVectorData.T"/></c>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
				<m n=":dox"><e>hide</e></m>
				<m n=":to"/>
			</meta>
		</toVectorData>
		<get_length get="inline" set="null" line="663" static="1">
			<f a="this">
				<c path="openfl.VectorData"><c path="openfl.Vector.T"/></c>
				<x path="Int"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
		</get_length>
		<set_length get="inline" set="null" line="670" static="1">
			<f a="this:value">
				<c path="openfl.VectorData"><c path="openfl.Vector.T"/></c>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
		</set_length>
		<get_fixed get="inline" set="null" line="695" static="1">
			<f a="this">
				<c path="openfl.VectorData"><c path="openfl.Vector.T"/></c>
				<x path="Bool"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
		</get_fixed>
		<set_fixed get="inline" set="null" line="702" static="1">
			<f a="this:value">
				<c path="openfl.VectorData"><c path="openfl.Vector.T"/></c>
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
		</set_fixed>
		<meta><m n=":final"/></meta>
	</class>
	<class path="openfl.VectorDataIterator" params="T" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/Vector.hx" module="openfl.Vector">
		<index><x path="Int"/></index>
		<vectorData><c path="openfl.VectorData"><c path="openfl.VectorDataIterator.T"/></c></vectorData>
		<hasNext public="1" set="method" line="749"><f a=""><x path="Bool"/></f></hasNext>
		<next public="1" set="method" line="756"><f a=""><c path="openfl.VectorDataIterator.T"/></f></next>
		<new public="1" set="method" line="741"><f a="data">
	<c path="openfl.VectorData"><c path="openfl.VectorDataIterator.T"/></c>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":dox"><e>hide</e></m>
		</meta>
	</class>
	<class path="openfl._internal.renderer.AbstractMaskManager" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/_internal/renderer/AbstractMaskManager.hx">
		<renderSession><c path="openfl._internal.renderer.RenderSession"/></renderSession>
		<pushMask public="1" set="method" line="24"><f a="mask">
	<c path="openfl.display.DisplayObject"/>
	<x path="Void"/>
</f></pushMask>
		<pushRect public="1" set="method" line="31"><f a="rect:transform">
	<c path="openfl.geom.Rectangle"/>
	<c path="openfl.geom.Matrix"/>
	<x path="Void"/>
</f></pushRect>
		<popMask public="1" set="method" line="38"><f a=""><x path="Void"/></f></popMask>
		<popRect public="1" set="method" line="45"><f a=""><x path="Void"/></f></popRect>
		<saveState public="1" set="method" line="52"><f a=""><x path="Void"/></f></saveState>
		<restoreState public="1" set="method" line="59"><f a=""><x path="Void"/></f></restoreState>
		<new public="1" set="method" line="17"><f a="renderSession">
	<c path="openfl._internal.renderer.RenderSession"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":access"><e>openfl.display.DisplayObject</e></m>
			<m n=":keep"/>
		</meta>
	</class>
	<class path="openfl._internal.renderer.AbstractRenderer" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/_internal/renderer/AbstractRenderer.hx">
		<height public="1"><x path="Int"/></height>
		<width public="1"><x path="Int"/></width>
		<transparent public="1"><x path="Bool"/></transparent>
		<viewport public="1"><c path="openfl.geom.Rectangle"/></viewport>
		<renderSession><c path="openfl._internal.renderer.RenderSession"/></renderSession>
		<render public="1" set="method" line="28"><f a="stage">
	<c path="openfl.display.Stage"/>
	<x path="Void"/>
</f></render>
		<renderShape public="1" set="method" line="35"><f a="shape">
	<c path="openfl.display.Shape"/>
	<x path="Void"/>
</f></renderShape>
		<setViewport public="1" set="method" line="42"><f a="x:y:width:height">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></setViewport>
		<resize public="1" set="method" line="49"><f a="width:height">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></resize>
		<new set="method" line="20"><f a="width:height">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="openfl._internal.renderer.DrawCommandBuffer" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/_internal/renderer/DrawCommandBuffer.hx">
		<length public="1" get="accessor" set="null"><x path="Int"/></length>
		<types public="1"><c path="Array"><e path="openfl._internal.renderer.DrawCommandType"/></c></types>
		<b><c path="Array"><x path="Bool"/></c></b>
		<f><c path="Array"><x path="Float"/></c></f>
		<ff><c path="Array"><c path="Array"><x path="Float"/></c></c></ff>
		<i><c path="Array"><x path="Int"/></c></i>
		<ii><c path="Array"><c path="Array"><x path="Int"/></c></c></ii>
		<o><c path="Array"><d/></c></o>
		<ts><c path="Array"><c path="openfl.display.Tilesheet"/></c></ts>
		<append public="1" set="method" line="51"><f a="other">
	<c path="openfl._internal.renderer.DrawCommandBuffer"/>
	<c path="openfl._internal.renderer.DrawCommandBuffer"/>
</f></append>
		<beginBitmapFill public="1" set="method" line="90"><f a="bitmap:matrix:repeat:smooth">
	<c path="openfl.display.BitmapData"/>
	<c path="openfl.geom.Matrix"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></beginBitmapFill>
		<beginFill public="1" set="method" line="100"><f a="color:alpha">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Void"/>
</f></beginFill>
		<beginGradientFill public="1" set="method" line="109"><f a="type:colors:alphas:ratios:matrix:spreadMethod:interpolationMethod:focalPointRatio">
	<x path="openfl.display.GradientType"/>
	<c path="Array"><x path="Int"/></c>
	<c path="Array"><x path="Float"/></c>
	<c path="Array"><x path="Int"/></c>
	<c path="openfl.geom.Matrix"/>
	<x path="openfl.display.SpreadMethod"/>
	<x path="openfl.display.InterpolationMethod"/>
	<x path="Float"/>
	<x path="Void"/>
</f></beginGradientFill>
		<clear public="1" set="method" line="124"><f a=""><x path="Void"/></f></clear>
		<copy public="1" set="method" line="139"><f a=""><c path="openfl._internal.renderer.DrawCommandBuffer"/></f></copy>
		<cubicCurveTo public="1" set="method" line="148"><f a="controlX1:controlY1:controlX2:controlY2:anchorX:anchorY">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></cubicCurveTo>
		<curveTo public="1" set="method" line="160"><f a="controlX:controlY:anchorX:anchorY">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></curveTo>
		<destroy public="1" set="method" line="171"><f a=""><x path="Void"/></f></destroy>
		<drawCircle public="1" set="method" line="188"><f a="x:y:radius">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></drawCircle>
		<drawEllipse public="1" set="method" line="198"><f a="x:y:width:height">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></drawEllipse>
		<drawPath public="1" set="method" line="209"><f a="commands:data:winding">
	<x path="openfl.Vector"><x path="Int"/></x>
	<x path="openfl.Vector"><x path="Float"/></x>
	<x path="openfl.display.GraphicsPathWinding"/>
	<x path="Void"/>
</f></drawPath>
		<drawRect public="1" set="method" line="219"><f a="x:y:width:height">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></drawRect>
		<drawRoundRect public="1" set="method" line="229"><f a="x:y:width:height:ellipseWidth:ellipseHeight">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<t path="Null"><x path="Float"/></t>
	<x path="Void"/>
</f></drawRoundRect>
		<drawTiles public="1" set="method" line="242"><f a="sheet:tileData:smooth:flags:?shader:count">
	<c path="openfl.display.Tilesheet"/>
	<c path="Array"><x path="Float"/></c>
	<x path="Bool"/>
	<x path="Int"/>
	<c path="openfl.display.Shader"/>
	<x path="Int"/>
	<x path="Void"/>
</f></drawTiles>
		<drawTriangles public="1" set="method" line="255"><f a="vertices:indices:uvtData:culling">
	<x path="openfl.Vector"><x path="Float"/></x>
	<x path="openfl.Vector"><x path="Int"/></x>
	<x path="openfl.Vector"><x path="Float"/></x>
	<x path="openfl.display.TriangleCulling"/>
	<x path="Void"/>
</f></drawTriangles>
		<endFill public="1" set="method" line="266"><f a=""><x path="Void"/></f></endFill>
		<lineBitmapStyle public="1" set="method" line="273"><f a="bitmap:matrix:repeat:smooth">
	<c path="openfl.display.BitmapData"/>
	<c path="openfl.geom.Matrix"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></lineBitmapStyle>
		<lineGradientStyle public="1" set="method" line="284"><f a="type:colors:alphas:ratios:matrix:spreadMethod:interpolationMethod:focalPointRatio">
	<x path="openfl.display.GradientType"/>
	<c path="Array"><x path="Int"/></c>
	<c path="Array"><x path="Float"/></c>
	<c path="Array"><x path="Int"/></c>
	<c path="openfl.geom.Matrix"/>
	<x path="openfl.display.SpreadMethod"/>
	<x path="openfl.display.InterpolationMethod"/>
	<x path="Float"/>
	<x path="Void"/>
</f></lineGradientStyle>
		<lineStyle public="1" set="method" line="299"><f a="thickness:color:alpha:pixelHinting:scaleMode:caps:joints:miterLimit">
	<t path="Null"><x path="Float"/></t>
	<x path="Int"/>
	<x path="Float"/>
	<x path="Bool"/>
	<x path="openfl.display.LineScaleMode"/>
	<x path="openfl.display.CapsStyle"/>
	<x path="openfl.display.JointStyle"/>
	<x path="Float"/>
	<x path="Void"/>
</f></lineStyle>
		<lineTo public="1" set="method" line="314"><f a="x:y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></lineTo>
		<moveTo public="1" set="method" line="323"><f a="x:y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></moveTo>
		<overrideMatrix public="1" set="method" line="332"><f a="matrix">
	<c path="openfl.geom.Matrix"/>
	<x path="Void"/>
</f></overrideMatrix>
		<get_length set="method" line="347"><f a=""><x path="Int"/></f></get_length>
		<new public="1" set="method" line="36"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":allow"><e>openfl._internal.renderer.DrawCommandReader</e></m>
		</meta>
	</class>
	<class path="openfl._internal.renderer.DrawCommandReader" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/_internal/renderer/DrawCommandReader.hx">
		<buffer public="1"><c path="openfl._internal.renderer.DrawCommandBuffer"/></buffer>
		<bPos><x path="Int"/></bPos>
		<iiPos><x path="Int"/></iiPos>
		<iPos><x path="Int"/></iPos>
		<ffPos><x path="Int"/></ffPos>
		<fPos><x path="Int"/></fPos>
		<oPos><x path="Int"/></oPos>
		<prev><e path="openfl._internal.renderer.DrawCommandType"/></prev>
		<tsPos><x path="Int"/></tsPos>
		<advance get="inline" set="null" line="47"><f a=""><x path="Void"/></f></advance>
		<bool get="inline" set="null" line="153"><f a="index">
	<x path="Int"/>
	<x path="Bool"/>
</f></bool>
		<destroy public="1" set="method" line="160"><f a=""><x path="Void"/></f></destroy>
		<fArr get="inline" set="null" line="168"><f a="index">
	<x path="Int"/>
	<c path="Array"><x path="Float"/></c>
</f></fArr>
		<float get="inline" set="null" line="175"><f a="index">
	<x path="Int"/>
	<x path="Float"/>
</f></float>
		<iArr get="inline" set="null" line="182"><f a="index">
	<x path="Int"/>
	<c path="Array"><x path="Int"/></c>
</f></iArr>
		<int get="inline" set="null" line="189"><f a="index">
	<x path="Int"/>
	<x path="Int"/>
</f></int>
		<obj get="inline" set="null" line="196"><f a="index">
	<x path="Int"/>
	<d/>
</f></obj>
		<readBeginBitmapFill public="1" get="inline" set="null" line="203"><f a=""><x path="openfl._internal.renderer.BeginBitmapFillView"/></f></readBeginBitmapFill>
		<readBeginFill public="1" get="inline" set="null" line="204"><f a=""><x path="openfl._internal.renderer.BeginFillView"/></f></readBeginFill>
		<readBeginGradientFill public="1" get="inline" set="null" line="205"><f a=""><x path="openfl._internal.renderer.BeginGradientFillView"/></f></readBeginGradientFill>
		<readCubicCurveTo public="1" get="inline" set="null" line="206"><f a=""><x path="openfl._internal.renderer.CubicCurveToView"/></f></readCubicCurveTo>
		<readCurveTo public="1" get="inline" set="null" line="207"><f a=""><x path="openfl._internal.renderer.CurveToView"/></f></readCurveTo>
		<readDrawCircle public="1" get="inline" set="null" line="208"><f a=""><x path="openfl._internal.renderer.DrawCircleView"/></f></readDrawCircle>
		<readDrawEllipse public="1" get="inline" set="null" line="209"><f a=""><x path="openfl._internal.renderer.DrawEllipseView"/></f></readDrawEllipse>
		<readDrawPath public="1" get="inline" set="null" line="210"><f a=""><x path="openfl._internal.renderer.DrawPathView"/></f></readDrawPath>
		<readDrawRect public="1" get="inline" set="null" line="211"><f a=""><x path="openfl._internal.renderer.DrawRectView"/></f></readDrawRect>
		<readDrawRoundRect public="1" get="inline" set="null" line="212"><f a=""><x path="openfl._internal.renderer.DrawRoundRectView"/></f></readDrawRoundRect>
		<readDrawTiles public="1" get="inline" set="null" line="213"><f a=""><x path="openfl._internal.renderer.DrawTilesView"/></f></readDrawTiles>
		<readDrawTriangles public="1" get="inline" set="null" line="214"><f a=""><x path="openfl._internal.renderer.DrawTrianglesView"/></f></readDrawTriangles>
		<readEndFill public="1" get="inline" set="null" line="215"><f a=""><x path="openfl._internal.renderer.EndFillView"/></f></readEndFill>
		<readLineBitmapStyle public="1" get="inline" set="null" line="216"><f a=""><x path="openfl._internal.renderer.LineBitmapStyleView"/></f></readLineBitmapStyle>
		<readLineGradientStyle public="1" get="inline" set="null" line="217"><f a=""><x path="openfl._internal.renderer.LineGradientStyleView"/></f></readLineGradientStyle>
		<readLineStyle public="1" get="inline" set="null" line="218"><f a=""><x path="openfl._internal.renderer.LineStyleView"/></f></readLineStyle>
		<readLineTo public="1" get="inline" set="null" line="219"><f a=""><x path="openfl._internal.renderer.LineToView"/></f></readLineTo>
		<readMoveTo public="1" get="inline" set="null" line="220"><f a=""><x path="openfl._internal.renderer.MoveToView"/></f></readMoveTo>
		<readOverrideMatrix public="1" get="inline" set="null" line="221"><f a=""><x path="openfl._internal.renderer.OverrideMatrixView"/></f></readOverrideMatrix>
		<reset public="1" set="method" line="224"><f a=""><x path="Void"/></f></reset>
		<skip public="1" get="inline" set="null" line="231"><f a="type">
	<e path="openfl._internal.renderer.DrawCommandType"/>
	<x path="Void"/>
</f></skip>
		<tileSheet get="inline" set="null" line="239"><f a="index">
	<x path="Int"/>
	<c path="openfl.display.Tilesheet"/>
</f></tileSheet>
		<new public="1" set="method" line="37"><f a="buffer">
	<c path="openfl._internal.renderer.DrawCommandBuffer"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":allow"><e>openfl._internal.renderer</e></m>
		</meta>
	</class>
	<abstract path="openfl._internal.renderer.BeginBitmapFillView" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/_internal/renderer/DrawCommandReader.hx" module="openfl._internal.renderer.DrawCommandReader">
		<this><c path="openfl._internal.renderer.DrawCommandReader"/></this>
		<impl><class path="openfl._internal.renderer._DrawCommandReader.BeginBitmapFillView_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/_internal/renderer/DrawCommandReader.hx" private="1" module="openfl._internal.renderer.DrawCommandReader">
	<_new public="1" get="inline" set="null" line="251" static="1">
		<f a="d">
			<c path="openfl._internal.renderer.DrawCommandReader"/>
			<x path="openfl._internal.renderer.BeginBitmapFillView"/>
		</f>
		<meta><m n=":impl"/></meta>
	</_new>
	<bitmap public="1" get="accessor" set="null" static="1">
		<c path="openfl.display.BitmapData"/>
		<meta><m n=":impl"/></meta>
	</bitmap>
	<get_bitmap get="inline" set="null" line="252" static="1">
		<f a="this">
			<c path="openfl._internal.renderer.DrawCommandReader"/>
			<c path="openfl.display.BitmapData"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_bitmap>
	<matrix public="1" get="accessor" set="null" static="1">
		<c path="openfl.geom.Matrix"/>
		<meta><m n=":impl"/></meta>
	</matrix>
	<get_matrix get="inline" set="null" line="253" static="1">
		<f a="this">
			<c path="openfl._internal.renderer.DrawCommandReader"/>
			<c path="openfl.geom.Matrix"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_matrix>
	<repeat public="1" get="accessor" set="null" static="1">
		<x path="Bool"/>
		<meta><m n=":impl"/></meta>
	</repeat>
	<get_repeat get="inline" set="null" line="254" static="1">
		<f a="this">
			<c path="openfl._internal.renderer.DrawCommandReader"/>
			<x path="Bool"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_repeat>
	<smooth public="1" get="accessor" set="null" static="1">
		<x path="Bool"/>
		<meta><m n=":impl"/></meta>
	</smooth>
	<get_smooth get="inline" set="null" line="255" static="1">
		<f a="this">
			<c path="openfl._internal.renderer.DrawCommandReader"/>
			<x path="Bool"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_smooth>
	<meta><m n=":final"/></meta>
</class></impl>
	</abstract>
	<class path="openfl._internal.renderer._DrawCommandReader.BeginBitmapFillView_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/_internal/renderer/DrawCommandReader.hx" private="1" module="openfl._internal.renderer.DrawCommandReader">
		<_new public="1" get="inline" set="null" line="251" static="1">
			<f a="d">
				<c path="openfl._internal.renderer.DrawCommandReader"/>
				<x path="openfl._internal.renderer.BeginBitmapFillView"/>
			</f>
			<meta><m n=":impl"/></meta>
		</_new>
		<bitmap public="1" get="accessor" set="null" static="1">
			<c path="openfl.display.BitmapData"/>
			<meta><m n=":impl"/></meta>
		</bitmap>
		<get_bitmap get="inline" set="null" line="252" static="1">
			<f a="this">
				<c path="openfl._internal.renderer.DrawCommandReader"/>
				<c path="openfl.display.BitmapData"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_bitmap>
		<matrix public="1" get="accessor" set="null" static="1">
			<c path="openfl.geom.Matrix"/>
			<meta><m n=":impl"/></meta>
		</matrix>
		<get_matrix get="inline" set="null" line="253" static="1">
			<f a="this">
				<c path="openfl._internal.renderer.DrawCommandReader"/>
				<c path="openfl.geom.Matrix"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_matrix>
		<repeat public="1" get="accessor" set="null" static="1">
			<x path="Bool"/>
			<meta><m n=":impl"/></meta>
		</repeat>
		<get_repeat get="inline" set="null" line="254" static="1">
			<f a="this">
				<c path="openfl._internal.renderer.DrawCommandReader"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_repeat>
		<smooth public="1" get="accessor" set="null" static="1">
			<x path="Bool"/>
			<meta><m n=":impl"/></meta>
		</smooth>
		<get_smooth get="inline" set="null" line="255" static="1">
			<f a="this">
				<c path="openfl._internal.renderer.DrawCommandReader"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_smooth>
		<meta><m n=":final"/></meta>
	</class>
	<abstract path="openfl._internal.renderer.BeginFillView" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/_internal/renderer/DrawCommandReader.hx" module="openfl._internal.renderer.DrawCommandReader">
		<this><c path="openfl._internal.renderer.DrawCommandReader"/></this>
		<impl><class path="openfl._internal.renderer._DrawCommandReader.BeginFillView_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/_internal/renderer/DrawCommandReader.hx" private="1" module="openfl._internal.renderer.DrawCommandReader">
	<_new public="1" get="inline" set="null" line="262" static="1">
		<f a="d">
			<c path="openfl._internal.renderer.DrawCommandReader"/>
			<x path="openfl._internal.renderer.BeginFillView"/>
		</f>
		<meta><m n=":impl"/></meta>
	</_new>
	<color public="1" get="accessor" set="null" static="1">
		<x path="Int"/>
		<meta><m n=":impl"/></meta>
	</color>
	<get_color get="inline" set="null" line="263" static="1">
		<f a="this">
			<c path="openfl._internal.renderer.DrawCommandReader"/>
			<x path="Int"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_color>
	<alpha public="1" get="accessor" set="null" static="1">
		<x path="Float"/>
		<meta><m n=":impl"/></meta>
	</alpha>
	<get_alpha get="inline" set="null" line="264" static="1">
		<f a="this">
			<c path="openfl._internal.renderer.DrawCommandReader"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_alpha>
	<meta><m n=":final"/></meta>
</class></impl>
	</abstract>
	<class path="openfl._internal.renderer._DrawCommandReader.BeginFillView_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/_internal/renderer/DrawCommandReader.hx" private="1" module="openfl._internal.renderer.DrawCommandReader">
		<_new public="1" get="inline" set="null" line="262" static="1">
			<f a="d">
				<c path="openfl._internal.renderer.DrawCommandReader"/>
				<x path="openfl._internal.renderer.BeginFillView"/>
			</f>
			<meta><m n=":impl"/></meta>
		</_new>
		<color public="1" get="accessor" set="null" static="1">
			<x path="Int"/>
			<meta><m n=":impl"/></meta>
		</color>
		<get_color get="inline" set="null" line="263" static="1">
			<f a="this">
				<c path="openfl._internal.renderer.DrawCommandReader"/>
				<x path="Int"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_color>
		<alpha public="1" get="accessor" set="null" static="1">
			<x path="Float"/>
			<meta><m n=":impl"/></meta>
		</alpha>
		<get_alpha get="inline" set="null" line="264" static="1">
			<f a="this">
				<c path="openfl._internal.renderer.DrawCommandReader"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_alpha>
		<meta><m n=":final"/></meta>
	</class>
	<abstract path="openfl._internal.renderer.BeginGradientFillView" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/_internal/renderer/DrawCommandReader.hx" module="openfl._internal.renderer.DrawCommandReader">
		<this><c path="openfl._internal.renderer.DrawCommandReader"/></this>
		<impl><class path="openfl._internal.renderer._DrawCommandReader.BeginGradientFillView_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/_internal/renderer/DrawCommandReader.hx" private="1" module="openfl._internal.renderer.DrawCommandReader">
	<_new public="1" get="inline" set="null" line="271" static="1">
		<f a="d">
			<c path="openfl._internal.renderer.DrawCommandReader"/>
			<x path="openfl._internal.renderer.BeginGradientFillView"/>
		</f>
		<meta><m n=":impl"/></meta>
	</_new>
	<type public="1" get="accessor" set="null" static="1">
		<x path="openfl.display.GradientType"/>
		<meta><m n=":impl"/></meta>
	</type>
	<get_type get="inline" set="null" line="272" static="1">
		<f a="this">
			<c path="openfl._internal.renderer.DrawCommandReader"/>
			<x path="openfl.display.GradientType"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_type>
	<colors public="1" get="accessor" set="null" static="1">
		<c path="Array"><x path="Int"/></c>
		<meta><m n=":impl"/></meta>
	</colors>
	<get_colors get="inline" set="null" line="273" static="1">
		<f a="this">
			<c path="openfl._internal.renderer.DrawCommandReader"/>
			<c path="Array"><x path="Int"/></c>
		</f>
		<meta><m n=":impl"/></meta>
	</get_colors>
	<alphas public="1" get="accessor" set="null" static="1">
		<c path="Array"><x path="Float"/></c>
		<meta><m n=":impl"/></meta>
	</alphas>
	<get_alphas get="inline" set="null" line="274" static="1">
		<f a="this">
			<c path="openfl._internal.renderer.DrawCommandReader"/>
			<c path="Array"><x path="Float"/></c>
		</f>
		<meta><m n=":impl"/></meta>
	</get_alphas>
	<ratios public="1" get="accessor" set="null" static="1">
		<c path="Array"><x path="Int"/></c>
		<meta><m n=":impl"/></meta>
	</ratios>
	<get_ratios get="inline" set="null" line="275" static="1">
		<f a="this">
			<c path="openfl._internal.renderer.DrawCommandReader"/>
			<c path="Array"><x path="Int"/></c>
		</f>
		<meta><m n=":impl"/></meta>
	</get_ratios>
	<matrix public="1" get="accessor" set="null" static="1">
		<c path="openfl.geom.Matrix"/>
		<meta><m n=":impl"/></meta>
	</matrix>
	<get_matrix get="inline" set="null" line="276" static="1">
		<f a="this">
			<c path="openfl._internal.renderer.DrawCommandReader"/>
			<c path="openfl.geom.Matrix"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_matrix>
	<spreadMethod public="1" get="accessor" set="null" static="1">
		<x path="openfl.display.SpreadMethod"/>
		<meta><m n=":impl"/></meta>
	</spreadMethod>
	<get_spreadMethod get="inline" set="null" line="277" static="1">
		<f a="this">
			<c path="openfl._internal.renderer.DrawCommandReader"/>
			<x path="openfl.display.SpreadMethod"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_spreadMethod>
	<interpolationMethod public="1" get="accessor" set="null" static="1">
		<x path="openfl.display.InterpolationMethod"/>
		<meta><m n=":impl"/></meta>
	</interpolationMethod>
	<get_interpolationMethod get="inline" set="null" line="278" static="1">
		<f a="this">
			<c path="openfl._internal.renderer.DrawCommandReader"/>
			<x path="openfl.display.InterpolationMethod"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_interpolationMethod>
	<focalPointRatio public="1" get="accessor" set="null" static="1">
		<x path="Float"/>
		<meta><m n=":impl"/></meta>
	</focalPointRatio>
	<get_focalPointRatio get="inline" set="null" line="279" static="1">
		<f a="this">
			<c path="openfl._internal.renderer.DrawCommandReader"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_focalPointRatio>
	<meta><m n=":final"/></meta>
</class></impl>
	</abstract>
	<class path="openfl._internal.renderer._DrawCommandReader.BeginGradientFillView_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/_internal/renderer/DrawCommandReader.hx" private="1" module="openfl._internal.renderer.DrawCommandReader">
		<_new public="1" get="inline" set="null" line="271" static="1">
			<f a="d">
				<c path="openfl._internal.renderer.DrawCommandReader"/>
				<x path="openfl._internal.renderer.BeginGradientFillView"/>
			</f>
			<meta><m n=":impl"/></meta>
		</_new>
		<type public="1" get="accessor" set="null" static="1">
			<x path="openfl.display.GradientType"/>
			<meta><m n=":impl"/></meta>
		</type>
		<get_type get="inline" set="null" line="272" static="1">
			<f a="this">
				<c path="openfl._internal.renderer.DrawCommandReader"/>
				<x path="openfl.display.GradientType"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_type>
		<colors public="1" get="accessor" set="null" static="1">
			<c path="Array"><x path="Int"/></c>
			<meta><m n=":impl"/></meta>
		</colors>
		<get_colors get="inline" set="null" line="273" static="1">
			<f a="this">
				<c path="openfl._internal.renderer.DrawCommandReader"/>
				<c path="Array"><x path="Int"/></c>
			</f>
			<meta><m n=":impl"/></meta>
		</get_colors>
		<alphas public="1" get="accessor" set="null" static="1">
			<c path="Array"><x path="Float"/></c>
			<meta><m n=":impl"/></meta>
		</alphas>
		<get_alphas get="inline" set="null" line="274" static="1">
			<f a="this">
				<c path="openfl._internal.renderer.DrawCommandReader"/>
				<c path="Array"><x path="Float"/></c>
			</f>
			<meta><m n=":impl"/></meta>
		</get_alphas>
		<ratios public="1" get="accessor" set="null" static="1">
			<c path="Array"><x path="Int"/></c>
			<meta><m n=":impl"/></meta>
		</ratios>
		<get_ratios get="inline" set="null" line="275" static="1">
			<f a="this">
				<c path="openfl._internal.renderer.DrawCommandReader"/>
				<c path="Array"><x path="Int"/></c>
			</f>
			<meta><m n=":impl"/></meta>
		</get_ratios>
		<matrix public="1" get="accessor" set="null" static="1">
			<c path="openfl.geom.Matrix"/>
			<meta><m n=":impl"/></meta>
		</matrix>
		<get_matrix get="inline" set="null" line="276" static="1">
			<f a="this">
				<c path="openfl._internal.renderer.DrawCommandReader"/>
				<c path="openfl.geom.Matrix"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_matrix>
		<spreadMethod public="1" get="accessor" set="null" static="1">
			<x path="openfl.display.SpreadMethod"/>
			<meta><m n=":impl"/></meta>
		</spreadMethod>
		<get_spreadMethod get="inline" set="null" line="277" static="1">
			<f a="this">
				<c path="openfl._internal.renderer.DrawCommandReader"/>
				<x path="openfl.display.SpreadMethod"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_spreadMethod>
		<interpolationMethod public="1" get="accessor" set="null" static="1">
			<x path="openfl.display.InterpolationMethod"/>
			<meta><m n=":impl"/></meta>
		</interpolationMethod>
		<get_interpolationMethod get="inline" set="null" line="278" static="1">
			<f a="this">
				<c path="openfl._internal.renderer.DrawCommandReader"/>
				<x path="openfl.display.InterpolationMethod"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_interpolationMethod>
		<focalPointRatio public="1" get="accessor" set="null" static="1">
			<x path="Float"/>
			<meta><m n=":impl"/></meta>
		</focalPointRatio>
		<get_focalPointRatio get="inline" set="null" line="279" static="1">
			<f a="this">
				<c path="openfl._internal.renderer.DrawCommandReader"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_focalPointRatio>
		<meta><m n=":final"/></meta>
	</class>
	<abstract path="openfl._internal.renderer.CubicCurveToView" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/_internal/renderer/DrawCommandReader.hx" module="openfl._internal.renderer.DrawCommandReader">
		<this><c path="openfl._internal.renderer.DrawCommandReader"/></this>
		<impl><class path="openfl._internal.renderer._DrawCommandReader.CubicCurveToView_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/_internal/renderer/DrawCommandReader.hx" private="1" module="openfl._internal.renderer.DrawCommandReader">
	<_new public="1" get="inline" set="null" line="286" static="1">
		<f a="d">
			<c path="openfl._internal.renderer.DrawCommandReader"/>
			<x path="openfl._internal.renderer.CubicCurveToView"/>
		</f>
		<meta><m n=":impl"/></meta>
	</_new>
	<controlX1 public="1" get="accessor" set="null" static="1">
		<x path="Float"/>
		<meta><m n=":impl"/></meta>
	</controlX1>
	<get_controlX1 get="inline" set="null" line="287" static="1">
		<f a="this">
			<c path="openfl._internal.renderer.DrawCommandReader"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_controlX1>
	<controlY1 public="1" get="accessor" set="null" static="1">
		<x path="Float"/>
		<meta><m n=":impl"/></meta>
	</controlY1>
	<get_controlY1 get="inline" set="null" line="288" static="1">
		<f a="this">
			<c path="openfl._internal.renderer.DrawCommandReader"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_controlY1>
	<controlX2 public="1" get="accessor" set="null" static="1">
		<x path="Float"/>
		<meta><m n=":impl"/></meta>
	</controlX2>
	<get_controlX2 get="inline" set="null" line="289" static="1">
		<f a="this">
			<c path="openfl._internal.renderer.DrawCommandReader"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_controlX2>
	<controlY2 public="1" get="accessor" set="null" static="1">
		<x path="Float"/>
		<meta><m n=":impl"/></meta>
	</controlY2>
	<get_controlY2 get="inline" set="null" line="290" static="1">
		<f a="this">
			<c path="openfl._internal.renderer.DrawCommandReader"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_controlY2>
	<anchorX public="1" get="accessor" set="null" static="1">
		<x path="Float"/>
		<meta><m n=":impl"/></meta>
	</anchorX>
	<get_anchorX get="inline" set="null" line="291" static="1">
		<f a="this">
			<c path="openfl._internal.renderer.DrawCommandReader"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_anchorX>
	<anchorY public="1" get="accessor" set="null" static="1">
		<x path="Float"/>
		<meta><m n=":impl"/></meta>
	</anchorY>
	<get_anchorY get="inline" set="null" line="292" static="1">
		<f a="this">
			<c path="openfl._internal.renderer.DrawCommandReader"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_anchorY>
	<meta><m n=":final"/></meta>
</class></impl>
	</abstract>
	<class path="openfl._internal.renderer._DrawCommandReader.CubicCurveToView_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/_internal/renderer/DrawCommandReader.hx" private="1" module="openfl._internal.renderer.DrawCommandReader">
		<_new public="1" get="inline" set="null" line="286" static="1">
			<f a="d">
				<c path="openfl._internal.renderer.DrawCommandReader"/>
				<x path="openfl._internal.renderer.CubicCurveToView"/>
			</f>
			<meta><m n=":impl"/></meta>
		</_new>
		<controlX1 public="1" get="accessor" set="null" static="1">
			<x path="Float"/>
			<meta><m n=":impl"/></meta>
		</controlX1>
		<get_controlX1 get="inline" set="null" line="287" static="1">
			<f a="this">
				<c path="openfl._internal.renderer.DrawCommandReader"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_controlX1>
		<controlY1 public="1" get="accessor" set="null" static="1">
			<x path="Float"/>
			<meta><m n=":impl"/></meta>
		</controlY1>
		<get_controlY1 get="inline" set="null" line="288" static="1">
			<f a="this">
				<c path="openfl._internal.renderer.DrawCommandReader"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_controlY1>
		<controlX2 public="1" get="accessor" set="null" static="1">
			<x path="Float"/>
			<meta><m n=":impl"/></meta>
		</controlX2>
		<get_controlX2 get="inline" set="null" line="289" static="1">
			<f a="this">
				<c path="openfl._internal.renderer.DrawCommandReader"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_controlX2>
		<controlY2 public="1" get="accessor" set="null" static="1">
			<x path="Float"/>
			<meta><m n=":impl"/></meta>
		</controlY2>
		<get_controlY2 get="inline" set="null" line="290" static="1">
			<f a="this">
				<c path="openfl._internal.renderer.DrawCommandReader"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_controlY2>
		<anchorX public="1" get="accessor" set="null" static="1">
			<x path="Float"/>
			<meta><m n=":impl"/></meta>
		</anchorX>
		<get_anchorX get="inline" set="null" line="291" static="1">
			<f a="this">
				<c path="openfl._internal.renderer.DrawCommandReader"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_anchorX>
		<anchorY public="1" get="accessor" set="null" static="1">
			<x path="Float"/>
			<meta><m n=":impl"/></meta>
		</anchorY>
		<get_anchorY get="inline" set="null" line="292" static="1">
			<f a="this">
				<c path="openfl._internal.renderer.DrawCommandReader"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_anchorY>
		<meta><m n=":final"/></meta>
	</class>
	<abstract path="openfl._internal.renderer.CurveToView" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/_internal/renderer/DrawCommandReader.hx" module="openfl._internal.renderer.DrawCommandReader">
		<this><c path="openfl._internal.renderer.DrawCommandReader"/></this>
		<impl><class path="openfl._internal.renderer._DrawCommandReader.CurveToView_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/_internal/renderer/DrawCommandReader.hx" private="1" module="openfl._internal.renderer.DrawCommandReader">
	<_new public="1" get="inline" set="null" line="299" static="1">
		<f a="d">
			<c path="openfl._internal.renderer.DrawCommandReader"/>
			<x path="openfl._internal.renderer.CurveToView"/>
		</f>
		<meta><m n=":impl"/></meta>
	</_new>
	<controlX public="1" get="accessor" set="null" static="1">
		<x path="Float"/>
		<meta><m n=":impl"/></meta>
	</controlX>
	<get_controlX get="inline" set="null" line="300" static="1">
		<f a="this">
			<c path="openfl._internal.renderer.DrawCommandReader"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_controlX>
	<controlY public="1" get="accessor" set="null" static="1">
		<x path="Float"/>
		<meta><m n=":impl"/></meta>
	</controlY>
	<get_controlY get="inline" set="null" line="301" static="1">
		<f a="this">
			<c path="openfl._internal.renderer.DrawCommandReader"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_controlY>
	<anchorX public="1" get="accessor" set="null" static="1">
		<x path="Float"/>
		<meta><m n=":impl"/></meta>
	</anchorX>
	<get_anchorX get="inline" set="null" line="302" static="1">
		<f a="this">
			<c path="openfl._internal.renderer.DrawCommandReader"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_anchorX>
	<anchorY public="1" get="accessor" set="null" static="1">
		<x path="Float"/>
		<meta><m n=":impl"/></meta>
	</anchorY>
	<get_anchorY get="inline" set="null" line="303" static="1">
		<f a="this">
			<c path="openfl._internal.renderer.DrawCommandReader"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_anchorY>
	<meta><m n=":final"/></meta>
</class></impl>
	</abstract>
	<class path="openfl._internal.renderer._DrawCommandReader.CurveToView_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/_internal/renderer/DrawCommandReader.hx" private="1" module="openfl._internal.renderer.DrawCommandReader">
		<_new public="1" get="inline" set="null" line="299" static="1">
			<f a="d">
				<c path="openfl._internal.renderer.DrawCommandReader"/>
				<x path="openfl._internal.renderer.CurveToView"/>
			</f>
			<meta><m n=":impl"/></meta>
		</_new>
		<controlX public="1" get="accessor" set="null" static="1">
			<x path="Float"/>
			<meta><m n=":impl"/></meta>
		</controlX>
		<get_controlX get="inline" set="null" line="300" static="1">
			<f a="this">
				<c path="openfl._internal.renderer.DrawCommandReader"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_controlX>
		<controlY public="1" get="accessor" set="null" static="1">
			<x path="Float"/>
			<meta><m n=":impl"/></meta>
		</controlY>
		<get_controlY get="inline" set="null" line="301" static="1">
			<f a="this">
				<c path="openfl._internal.renderer.DrawCommandReader"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_controlY>
		<anchorX public="1" get="accessor" set="null" static="1">
			<x path="Float"/>
			<meta><m n=":impl"/></meta>
		</anchorX>
		<get_anchorX get="inline" set="null" line="302" static="1">
			<f a="this">
				<c path="openfl._internal.renderer.DrawCommandReader"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_anchorX>
		<anchorY public="1" get="accessor" set="null" static="1">
			<x path="Float"/>
			<meta><m n=":impl"/></meta>
		</anchorY>
		<get_anchorY get="inline" set="null" line="303" static="1">
			<f a="this">
				<c path="openfl._internal.renderer.DrawCommandReader"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_anchorY>
		<meta><m n=":final"/></meta>
	</class>
	<abstract path="openfl._internal.renderer.DrawCircleView" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/_internal/renderer/DrawCommandReader.hx" module="openfl._internal.renderer.DrawCommandReader">
		<this><c path="openfl._internal.renderer.DrawCommandReader"/></this>
		<impl><class path="openfl._internal.renderer._DrawCommandReader.DrawCircleView_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/_internal/renderer/DrawCommandReader.hx" private="1" module="openfl._internal.renderer.DrawCommandReader">
	<_new public="1" get="inline" set="null" line="310" static="1">
		<f a="d">
			<c path="openfl._internal.renderer.DrawCommandReader"/>
			<x path="openfl._internal.renderer.DrawCircleView"/>
		</f>
		<meta><m n=":impl"/></meta>
	</_new>
	<x public="1" get="accessor" set="null" static="1">
		<x path="Float"/>
		<meta><m n=":impl"/></meta>
	</x>
	<get_x get="inline" set="null" line="311" static="1">
		<f a="this">
			<c path="openfl._internal.renderer.DrawCommandReader"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_x>
	<y public="1" get="accessor" set="null" static="1">
		<x path="Float"/>
		<meta><m n=":impl"/></meta>
	</y>
	<get_y get="inline" set="null" line="312" static="1">
		<f a="this">
			<c path="openfl._internal.renderer.DrawCommandReader"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_y>
	<radius public="1" get="accessor" set="null" static="1">
		<x path="Float"/>
		<meta><m n=":impl"/></meta>
	</radius>
	<get_radius get="inline" set="null" line="313" static="1">
		<f a="this">
			<c path="openfl._internal.renderer.DrawCommandReader"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_radius>
	<meta><m n=":final"/></meta>
</class></impl>
	</abstract>
	<class path="openfl._internal.renderer._DrawCommandReader.DrawCircleView_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/_internal/renderer/DrawCommandReader.hx" private="1" module="openfl._internal.renderer.DrawCommandReader">
		<_new public="1" get="inline" set="null" line="310" static="1">
			<f a="d">
				<c path="openfl._internal.renderer.DrawCommandReader"/>
				<x path="openfl._internal.renderer.DrawCircleView"/>
			</f>
			<meta><m n=":impl"/></meta>
		</_new>
		<x public="1" get="accessor" set="null" static="1">
			<x path="Float"/>
			<meta><m n=":impl"/></meta>
		</x>
		<get_x get="inline" set="null" line="311" static="1">
			<f a="this">
				<c path="openfl._internal.renderer.DrawCommandReader"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_x>
		<y public="1" get="accessor" set="null" static="1">
			<x path="Float"/>
			<meta><m n=":impl"/></meta>
		</y>
		<get_y get="inline" set="null" line="312" static="1">
			<f a="this">
				<c path="openfl._internal.renderer.DrawCommandReader"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_y>
		<radius public="1" get="accessor" set="null" static="1">
			<x path="Float"/>
			<meta><m n=":impl"/></meta>
		</radius>
		<get_radius get="inline" set="null" line="313" static="1">
			<f a="this">
				<c path="openfl._internal.renderer.DrawCommandReader"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_radius>
		<meta><m n=":final"/></meta>
	</class>
	<abstract path="openfl._internal.renderer.DrawEllipseView" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/_internal/renderer/DrawCommandReader.hx" module="openfl._internal.renderer.DrawCommandReader">
		<this><c path="openfl._internal.renderer.DrawCommandReader"/></this>
		<impl><class path="openfl._internal.renderer._DrawCommandReader.DrawEllipseView_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/_internal/renderer/DrawCommandReader.hx" private="1" module="openfl._internal.renderer.DrawCommandReader">
	<_new public="1" get="inline" set="null" line="320" static="1">
		<f a="d">
			<c path="openfl._internal.renderer.DrawCommandReader"/>
			<x path="openfl._internal.renderer.DrawEllipseView"/>
		</f>
		<meta><m n=":impl"/></meta>
	</_new>
	<x public="1" get="accessor" set="null" static="1">
		<x path="Float"/>
		<meta><m n=":impl"/></meta>
	</x>
	<get_x get="inline" set="null" line="321" static="1">
		<f a="this">
			<c path="openfl._internal.renderer.DrawCommandReader"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_x>
	<y public="1" get="accessor" set="null" static="1">
		<x path="Float"/>
		<meta><m n=":impl"/></meta>
	</y>
	<get_y get="inline" set="null" line="322" static="1">
		<f a="this">
			<c path="openfl._internal.renderer.DrawCommandReader"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_y>
	<width public="1" get="accessor" set="null" static="1">
		<x path="Float"/>
		<meta><m n=":impl"/></meta>
	</width>
	<get_width get="inline" set="null" line="323" static="1">
		<f a="this">
			<c path="openfl._internal.renderer.DrawCommandReader"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_width>
	<height public="1" get="accessor" set="null" static="1">
		<x path="Float"/>
		<meta><m n=":impl"/></meta>
	</height>
	<get_height get="inline" set="null" line="324" static="1">
		<f a="this">
			<c path="openfl._internal.renderer.DrawCommandReader"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_height>
	<meta><m n=":final"/></meta>
</class></impl>
	</abstract>
	<class path="openfl._internal.renderer._DrawCommandReader.DrawEllipseView_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/_internal/renderer/DrawCommandReader.hx" private="1" module="openfl._internal.renderer.DrawCommandReader">
		<_new public="1" get="inline" set="null" line="320" static="1">
			<f a="d">
				<c path="openfl._internal.renderer.DrawCommandReader"/>
				<x path="openfl._internal.renderer.DrawEllipseView"/>
			</f>
			<meta><m n=":impl"/></meta>
		</_new>
		<x public="1" get="accessor" set="null" static="1">
			<x path="Float"/>
			<meta><m n=":impl"/></meta>
		</x>
		<get_x get="inline" set="null" line="321" static="1">
			<f a="this">
				<c path="openfl._internal.renderer.DrawCommandReader"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_x>
		<y public="1" get="accessor" set="null" static="1">
			<x path="Float"/>
			<meta><m n=":impl"/></meta>
		</y>
		<get_y get="inline" set="null" line="322" static="1">
			<f a="this">
				<c path="openfl._internal.renderer.DrawCommandReader"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_y>
		<width public="1" get="accessor" set="null" static="1">
			<x path="Float"/>
			<meta><m n=":impl"/></meta>
		</width>
		<get_width get="inline" set="null" line="323" static="1">
			<f a="this">
				<c path="openfl._internal.renderer.DrawCommandReader"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_width>
		<height public="1" get="accessor" set="null" static="1">
			<x path="Float"/>
			<meta><m n=":impl"/></meta>
		</height>
		<get_height get="inline" set="null" line="324" static="1">
			<f a="this">
				<c path="openfl._internal.renderer.DrawCommandReader"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_height>
		<meta><m n=":final"/></meta>
	</class>
	<abstract path="openfl._internal.renderer.DrawPathView" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/_internal/renderer/DrawCommandReader.hx" module="openfl._internal.renderer.DrawCommandReader">
		<this><c path="openfl._internal.renderer.DrawCommandReader"/></this>
		<impl><class path="openfl._internal.renderer._DrawCommandReader.DrawPathView_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/_internal/renderer/DrawCommandReader.hx" private="1" module="openfl._internal.renderer.DrawCommandReader">
	<_new public="1" get="inline" set="null" line="331" static="1">
		<f a="d">
			<c path="openfl._internal.renderer.DrawCommandReader"/>
			<x path="openfl._internal.renderer.DrawPathView"/>
		</f>
		<meta><m n=":impl"/></meta>
	</_new>
	<commands public="1" get="accessor" set="null" static="1">
		<x path="openfl.Vector"><x path="Int"/></x>
		<meta><m n=":impl"/></meta>
	</commands>
	<get_commands get="inline" set="null" line="332" static="1">
		<f a="this">
			<c path="openfl._internal.renderer.DrawCommandReader"/>
			<x path="openfl.Vector"><x path="Int"/></x>
		</f>
		<meta><m n=":impl"/></meta>
	</get_commands>
	<data public="1" get="accessor" set="null" static="1">
		<x path="openfl.Vector"><x path="Float"/></x>
		<meta><m n=":impl"/></meta>
	</data>
	<get_data get="inline" set="null" line="333" static="1">
		<f a="this">
			<c path="openfl._internal.renderer.DrawCommandReader"/>
			<x path="openfl.Vector"><x path="Float"/></x>
		</f>
		<meta><m n=":impl"/></meta>
	</get_data>
	<winding public="1" get="accessor" set="null" static="1">
		<x path="openfl.display.GraphicsPathWinding"/>
		<meta><m n=":impl"/></meta>
	</winding>
	<get_winding get="inline" set="null" line="334" static="1">
		<f a="this">
			<c path="openfl._internal.renderer.DrawCommandReader"/>
			<x path="openfl.display.GraphicsPathWinding"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_winding>
	<meta><m n=":final"/></meta>
</class></impl>
	</abstract>
	<class path="openfl._internal.renderer._DrawCommandReader.DrawPathView_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/_internal/renderer/DrawCommandReader.hx" private="1" module="openfl._internal.renderer.DrawCommandReader">
		<_new public="1" get="inline" set="null" line="331" static="1">
			<f a="d">
				<c path="openfl._internal.renderer.DrawCommandReader"/>
				<x path="openfl._internal.renderer.DrawPathView"/>
			</f>
			<meta><m n=":impl"/></meta>
		</_new>
		<commands public="1" get="accessor" set="null" static="1">
			<x path="openfl.Vector"><x path="Int"/></x>
			<meta><m n=":impl"/></meta>
		</commands>
		<get_commands get="inline" set="null" line="332" static="1">
			<f a="this">
				<c path="openfl._internal.renderer.DrawCommandReader"/>
				<x path="openfl.Vector"><x path="Int"/></x>
			</f>
			<meta><m n=":impl"/></meta>
		</get_commands>
		<data public="1" get="accessor" set="null" static="1">
			<x path="openfl.Vector"><x path="Float"/></x>
			<meta><m n=":impl"/></meta>
		</data>
		<get_data get="inline" set="null" line="333" static="1">
			<f a="this">
				<c path="openfl._internal.renderer.DrawCommandReader"/>
				<x path="openfl.Vector"><x path="Float"/></x>
			</f>
			<meta><m n=":impl"/></meta>
		</get_data>
		<winding public="1" get="accessor" set="null" static="1">
			<x path="openfl.display.GraphicsPathWinding"/>
			<meta><m n=":impl"/></meta>
		</winding>
		<get_winding get="inline" set="null" line="334" static="1">
			<f a="this">
				<c path="openfl._internal.renderer.DrawCommandReader"/>
				<x path="openfl.display.GraphicsPathWinding"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_winding>
		<meta><m n=":final"/></meta>
	</class>
	<abstract path="openfl._internal.renderer.DrawRectView" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/_internal/renderer/DrawCommandReader.hx" module="openfl._internal.renderer.DrawCommandReader">
		<this><c path="openfl._internal.renderer.DrawCommandReader"/></this>
		<impl><class path="openfl._internal.renderer._DrawCommandReader.DrawRectView_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/_internal/renderer/DrawCommandReader.hx" private="1" module="openfl._internal.renderer.DrawCommandReader">
	<_new public="1" get="inline" set="null" line="341" static="1">
		<f a="d">
			<c path="openfl._internal.renderer.DrawCommandReader"/>
			<x path="openfl._internal.renderer.DrawRectView"/>
		</f>
		<meta><m n=":impl"/></meta>
	</_new>
	<x public="1" get="accessor" set="null" static="1">
		<x path="Float"/>
		<meta><m n=":impl"/></meta>
	</x>
	<get_x get="inline" set="null" line="342" static="1">
		<f a="this">
			<c path="openfl._internal.renderer.DrawCommandReader"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_x>
	<y public="1" get="accessor" set="null" static="1">
		<x path="Float"/>
		<meta><m n=":impl"/></meta>
	</y>
	<get_y get="inline" set="null" line="343" static="1">
		<f a="this">
			<c path="openfl._internal.renderer.DrawCommandReader"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_y>
	<width public="1" get="accessor" set="null" static="1">
		<x path="Float"/>
		<meta><m n=":impl"/></meta>
	</width>
	<get_width get="inline" set="null" line="344" static="1">
		<f a="this">
			<c path="openfl._internal.renderer.DrawCommandReader"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_width>
	<height public="1" get="accessor" set="null" static="1">
		<x path="Float"/>
		<meta><m n=":impl"/></meta>
	</height>
	<get_height get="inline" set="null" line="345" static="1">
		<f a="this">
			<c path="openfl._internal.renderer.DrawCommandReader"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_height>
	<meta><m n=":final"/></meta>
</class></impl>
	</abstract>
	<class path="openfl._internal.renderer._DrawCommandReader.DrawRectView_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/_internal/renderer/DrawCommandReader.hx" private="1" module="openfl._internal.renderer.DrawCommandReader">
		<_new public="1" get="inline" set="null" line="341" static="1">
			<f a="d">
				<c path="openfl._internal.renderer.DrawCommandReader"/>
				<x path="openfl._internal.renderer.DrawRectView"/>
			</f>
			<meta><m n=":impl"/></meta>
		</_new>
		<x public="1" get="accessor" set="null" static="1">
			<x path="Float"/>
			<meta><m n=":impl"/></meta>
		</x>
		<get_x get="inline" set="null" line="342" static="1">
			<f a="this">
				<c path="openfl._internal.renderer.DrawCommandReader"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_x>
		<y public="1" get="accessor" set="null" static="1">
			<x path="Float"/>
			<meta><m n=":impl"/></meta>
		</y>
		<get_y get="inline" set="null" line="343" static="1">
			<f a="this">
				<c path="openfl._internal.renderer.DrawCommandReader"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_y>
		<width public="1" get="accessor" set="null" static="1">
			<x path="Float"/>
			<meta><m n=":impl"/></meta>
		</width>
		<get_width get="inline" set="null" line="344" static="1">
			<f a="this">
				<c path="openfl._internal.renderer.DrawCommandReader"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_width>
		<height public="1" get="accessor" set="null" static="1">
			<x path="Float"/>
			<meta><m n=":impl"/></meta>
		</height>
		<get_height get="inline" set="null" line="345" static="1">
			<f a="this">
				<c path="openfl._internal.renderer.DrawCommandReader"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_height>
		<meta><m n=":final"/></meta>
	</class>
	<abstract path="openfl._internal.renderer.DrawRoundRectView" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/_internal/renderer/DrawCommandReader.hx" module="openfl._internal.renderer.DrawCommandReader">
		<this><c path="openfl._internal.renderer.DrawCommandReader"/></this>
		<impl><class path="openfl._internal.renderer._DrawCommandReader.DrawRoundRectView_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/_internal/renderer/DrawCommandReader.hx" private="1" module="openfl._internal.renderer.DrawCommandReader">
	<_new public="1" get="inline" set="null" line="352" static="1">
		<f a="d">
			<c path="openfl._internal.renderer.DrawCommandReader"/>
			<x path="openfl._internal.renderer.DrawRoundRectView"/>
		</f>
		<meta><m n=":impl"/></meta>
	</_new>
	<x public="1" get="accessor" set="null" static="1">
		<x path="Float"/>
		<meta><m n=":impl"/></meta>
	</x>
	<get_x get="inline" set="null" line="353" static="1">
		<f a="this">
			<c path="openfl._internal.renderer.DrawCommandReader"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_x>
	<y public="1" get="accessor" set="null" static="1">
		<x path="Float"/>
		<meta><m n=":impl"/></meta>
	</y>
	<get_y get="inline" set="null" line="354" static="1">
		<f a="this">
			<c path="openfl._internal.renderer.DrawCommandReader"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_y>
	<width public="1" get="accessor" set="null" static="1">
		<x path="Float"/>
		<meta><m n=":impl"/></meta>
	</width>
	<get_width get="inline" set="null" line="355" static="1">
		<f a="this">
			<c path="openfl._internal.renderer.DrawCommandReader"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_width>
	<height public="1" get="accessor" set="null" static="1">
		<x path="Float"/>
		<meta><m n=":impl"/></meta>
	</height>
	<get_height get="inline" set="null" line="356" static="1">
		<f a="this">
			<c path="openfl._internal.renderer.DrawCommandReader"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_height>
	<ellipseWidth public="1" get="accessor" set="null" static="1">
		<x path="Float"/>
		<meta><m n=":impl"/></meta>
	</ellipseWidth>
	<get_ellipseWidth get="inline" set="null" line="357" static="1">
		<f a="this">
			<c path="openfl._internal.renderer.DrawCommandReader"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_ellipseWidth>
	<ellipseHeight public="1" get="accessor" set="null" static="1">
		<t path="Null"><x path="Float"/></t>
		<meta><m n=":impl"/></meta>
	</ellipseHeight>
	<get_ellipseHeight get="inline" set="null" line="358" static="1">
		<f a="this">
			<c path="openfl._internal.renderer.DrawCommandReader"/>
			<t path="Null"><x path="Float"/></t>
		</f>
		<meta><m n=":impl"/></meta>
	</get_ellipseHeight>
	<meta><m n=":final"/></meta>
</class></impl>
	</abstract>
	<class path="openfl._internal.renderer._DrawCommandReader.DrawRoundRectView_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/_internal/renderer/DrawCommandReader.hx" private="1" module="openfl._internal.renderer.DrawCommandReader">
		<_new public="1" get="inline" set="null" line="352" static="1">
			<f a="d">
				<c path="openfl._internal.renderer.DrawCommandReader"/>
				<x path="openfl._internal.renderer.DrawRoundRectView"/>
			</f>
			<meta><m n=":impl"/></meta>
		</_new>
		<x public="1" get="accessor" set="null" static="1">
			<x path="Float"/>
			<meta><m n=":impl"/></meta>
		</x>
		<get_x get="inline" set="null" line="353" static="1">
			<f a="this">
				<c path="openfl._internal.renderer.DrawCommandReader"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_x>
		<y public="1" get="accessor" set="null" static="1">
			<x path="Float"/>
			<meta><m n=":impl"/></meta>
		</y>
		<get_y get="inline" set="null" line="354" static="1">
			<f a="this">
				<c path="openfl._internal.renderer.DrawCommandReader"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_y>
		<width public="1" get="accessor" set="null" static="1">
			<x path="Float"/>
			<meta><m n=":impl"/></meta>
		</width>
		<get_width get="inline" set="null" line="355" static="1">
			<f a="this">
				<c path="openfl._internal.renderer.DrawCommandReader"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_width>
		<height public="1" get="accessor" set="null" static="1">
			<x path="Float"/>
			<meta><m n=":impl"/></meta>
		</height>
		<get_height get="inline" set="null" line="356" static="1">
			<f a="this">
				<c path="openfl._internal.renderer.DrawCommandReader"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_height>
		<ellipseWidth public="1" get="accessor" set="null" static="1">
			<x path="Float"/>
			<meta><m n=":impl"/></meta>
		</ellipseWidth>
		<get_ellipseWidth get="inline" set="null" line="357" static="1">
			<f a="this">
				<c path="openfl._internal.renderer.DrawCommandReader"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_ellipseWidth>
		<ellipseHeight public="1" get="accessor" set="null" static="1">
			<t path="Null"><x path="Float"/></t>
			<meta><m n=":impl"/></meta>
		</ellipseHeight>
		<get_ellipseHeight get="inline" set="null" line="358" static="1">
			<f a="this">
				<c path="openfl._internal.renderer.DrawCommandReader"/>
				<t path="Null"><x path="Float"/></t>
			</f>
			<meta><m n=":impl"/></meta>
		</get_ellipseHeight>
		<meta><m n=":final"/></meta>
	</class>
	<abstract path="openfl._internal.renderer.DrawTilesView" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/_internal/renderer/DrawCommandReader.hx" module="openfl._internal.renderer.DrawCommandReader">
		<this><c path="openfl._internal.renderer.DrawCommandReader"/></this>
		<impl><class path="openfl._internal.renderer._DrawCommandReader.DrawTilesView_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/_internal/renderer/DrawCommandReader.hx" private="1" module="openfl._internal.renderer.DrawCommandReader">
	<_new public="1" get="inline" set="null" line="365" static="1">
		<f a="d">
			<c path="openfl._internal.renderer.DrawCommandReader"/>
			<x path="openfl._internal.renderer.DrawTilesView"/>
		</f>
		<meta><m n=":impl"/></meta>
	</_new>
	<sheet public="1" get="accessor" set="null" static="1">
		<c path="openfl.display.Tilesheet"/>
		<meta><m n=":impl"/></meta>
	</sheet>
	<get_sheet get="inline" set="null" line="366" static="1">
		<f a="this">
			<c path="openfl._internal.renderer.DrawCommandReader"/>
			<c path="openfl.display.Tilesheet"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_sheet>
	<tileData public="1" get="accessor" set="null" static="1">
		<c path="Array"><x path="Float"/></c>
		<meta><m n=":impl"/></meta>
	</tileData>
	<get_tileData get="inline" set="null" line="367" static="1">
		<f a="this">
			<c path="openfl._internal.renderer.DrawCommandReader"/>
			<c path="Array"><x path="Float"/></c>
		</f>
		<meta><m n=":impl"/></meta>
	</get_tileData>
	<smooth public="1" get="accessor" set="null" static="1">
		<x path="Bool"/>
		<meta><m n=":impl"/></meta>
	</smooth>
	<get_smooth get="inline" set="null" line="368" static="1">
		<f a="this">
			<c path="openfl._internal.renderer.DrawCommandReader"/>
			<x path="Bool"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_smooth>
	<flags public="1" get="accessor" set="null" static="1">
		<x path="Int"/>
		<meta><m n=":impl"/></meta>
	</flags>
	<get_flags get="inline" set="null" line="369" static="1">
		<f a="this">
			<c path="openfl._internal.renderer.DrawCommandReader"/>
			<x path="Int"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_flags>
	<shader public="1" get="accessor" set="null" static="1">
		<c path="openfl.display.Shader"/>
		<meta><m n=":impl"/></meta>
	</shader>
	<get_shader get="inline" set="null" line="370" static="1">
		<f a="this">
			<c path="openfl._internal.renderer.DrawCommandReader"/>
			<c path="openfl.display.Shader"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_shader>
	<count public="1" get="accessor" set="null" static="1">
		<x path="Int"/>
		<meta><m n=":impl"/></meta>
	</count>
	<get_count get="inline" set="null" line="371" static="1">
		<f a="this">
			<c path="openfl._internal.renderer.DrawCommandReader"/>
			<x path="Int"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_count>
	<meta><m n=":final"/></meta>
</class></impl>
	</abstract>
	<class path="openfl._internal.renderer._DrawCommandReader.DrawTilesView_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/_internal/renderer/DrawCommandReader.hx" private="1" module="openfl._internal.renderer.DrawCommandReader">
		<_new public="1" get="inline" set="null" line="365" static="1">
			<f a="d">
				<c path="openfl._internal.renderer.DrawCommandReader"/>
				<x path="openfl._internal.renderer.DrawTilesView"/>
			</f>
			<meta><m n=":impl"/></meta>
		</_new>
		<sheet public="1" get="accessor" set="null" static="1">
			<c path="openfl.display.Tilesheet"/>
			<meta><m n=":impl"/></meta>
		</sheet>
		<get_sheet get="inline" set="null" line="366" static="1">
			<f a="this">
				<c path="openfl._internal.renderer.DrawCommandReader"/>
				<c path="openfl.display.Tilesheet"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_sheet>
		<tileData public="1" get="accessor" set="null" static="1">
			<c path="Array"><x path="Float"/></c>
			<meta><m n=":impl"/></meta>
		</tileData>
		<get_tileData get="inline" set="null" line="367" static="1">
			<f a="this">
				<c path="openfl._internal.renderer.DrawCommandReader"/>
				<c path="Array"><x path="Float"/></c>
			</f>
			<meta><m n=":impl"/></meta>
		</get_tileData>
		<smooth public="1" get="accessor" set="null" static="1">
			<x path="Bool"/>
			<meta><m n=":impl"/></meta>
		</smooth>
		<get_smooth get="inline" set="null" line="368" static="1">
			<f a="this">
				<c path="openfl._internal.renderer.DrawCommandReader"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_smooth>
		<flags public="1" get="accessor" set="null" static="1">
			<x path="Int"/>
			<meta><m n=":impl"/></meta>
		</flags>
		<get_flags get="inline" set="null" line="369" static="1">
			<f a="this">
				<c path="openfl._internal.renderer.DrawCommandReader"/>
				<x path="Int"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_flags>
		<shader public="1" get="accessor" set="null" static="1">
			<c path="openfl.display.Shader"/>
			<meta><m n=":impl"/></meta>
		</shader>
		<get_shader get="inline" set="null" line="370" static="1">
			<f a="this">
				<c path="openfl._internal.renderer.DrawCommandReader"/>
				<c path="openfl.display.Shader"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_shader>
		<count public="1" get="accessor" set="null" static="1">
			<x path="Int"/>
			<meta><m n=":impl"/></meta>
		</count>
		<get_count get="inline" set="null" line="371" static="1">
			<f a="this">
				<c path="openfl._internal.renderer.DrawCommandReader"/>
				<x path="Int"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_count>
		<meta><m n=":final"/></meta>
	</class>
	<abstract path="openfl._internal.renderer.DrawTrianglesView" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/_internal/renderer/DrawCommandReader.hx" module="openfl._internal.renderer.DrawCommandReader">
		<this><c path="openfl._internal.renderer.DrawCommandReader"/></this>
		<impl><class path="openfl._internal.renderer._DrawCommandReader.DrawTrianglesView_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/_internal/renderer/DrawCommandReader.hx" private="1" module="openfl._internal.renderer.DrawCommandReader">
	<_new public="1" get="inline" set="null" line="378" static="1">
		<f a="d">
			<c path="openfl._internal.renderer.DrawCommandReader"/>
			<x path="openfl._internal.renderer.DrawTrianglesView"/>
		</f>
		<meta><m n=":impl"/></meta>
	</_new>
	<vertices public="1" get="accessor" set="null" static="1">
		<x path="openfl.Vector"><x path="Float"/></x>
		<meta><m n=":impl"/></meta>
	</vertices>
	<get_vertices get="inline" set="null" line="379" static="1">
		<f a="this">
			<c path="openfl._internal.renderer.DrawCommandReader"/>
			<x path="openfl.Vector"><x path="Float"/></x>
		</f>
		<meta><m n=":impl"/></meta>
	</get_vertices>
	<indices public="1" get="accessor" set="null" static="1">
		<x path="openfl.Vector"><x path="Int"/></x>
		<meta><m n=":impl"/></meta>
	</indices>
	<get_indices get="inline" set="null" line="380" static="1">
		<f a="this">
			<c path="openfl._internal.renderer.DrawCommandReader"/>
			<x path="openfl.Vector"><x path="Int"/></x>
		</f>
		<meta><m n=":impl"/></meta>
	</get_indices>
	<uvtData public="1" get="accessor" set="null" static="1">
		<x path="openfl.Vector"><x path="Float"/></x>
		<meta><m n=":impl"/></meta>
	</uvtData>
	<get_uvtData get="inline" set="null" line="381" static="1">
		<f a="this">
			<c path="openfl._internal.renderer.DrawCommandReader"/>
			<x path="openfl.Vector"><x path="Float"/></x>
		</f>
		<meta><m n=":impl"/></meta>
	</get_uvtData>
	<culling public="1" get="accessor" set="null" static="1">
		<x path="openfl.display.TriangleCulling"/>
		<meta><m n=":impl"/></meta>
	</culling>
	<get_culling get="inline" set="null" line="382" static="1">
		<f a="this">
			<c path="openfl._internal.renderer.DrawCommandReader"/>
			<x path="openfl.display.TriangleCulling"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_culling>
	<meta><m n=":final"/></meta>
</class></impl>
	</abstract>
	<class path="openfl._internal.renderer._DrawCommandReader.DrawTrianglesView_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/_internal/renderer/DrawCommandReader.hx" private="1" module="openfl._internal.renderer.DrawCommandReader">
		<_new public="1" get="inline" set="null" line="378" static="1">
			<f a="d">
				<c path="openfl._internal.renderer.DrawCommandReader"/>
				<x path="openfl._internal.renderer.DrawTrianglesView"/>
			</f>
			<meta><m n=":impl"/></meta>
		</_new>
		<vertices public="1" get="accessor" set="null" static="1">
			<x path="openfl.Vector"><x path="Float"/></x>
			<meta><m n=":impl"/></meta>
		</vertices>
		<get_vertices get="inline" set="null" line="379" static="1">
			<f a="this">
				<c path="openfl._internal.renderer.DrawCommandReader"/>
				<x path="openfl.Vector"><x path="Float"/></x>
			</f>
			<meta><m n=":impl"/></meta>
		</get_vertices>
		<indices public="1" get="accessor" set="null" static="1">
			<x path="openfl.Vector"><x path="Int"/></x>
			<meta><m n=":impl"/></meta>
		</indices>
		<get_indices get="inline" set="null" line="380" static="1">
			<f a="this">
				<c path="openfl._internal.renderer.DrawCommandReader"/>
				<x path="openfl.Vector"><x path="Int"/></x>
			</f>
			<meta><m n=":impl"/></meta>
		</get_indices>
		<uvtData public="1" get="accessor" set="null" static="1">
			<x path="openfl.Vector"><x path="Float"/></x>
			<meta><m n=":impl"/></meta>
		</uvtData>
		<get_uvtData get="inline" set="null" line="381" static="1">
			<f a="this">
				<c path="openfl._internal.renderer.DrawCommandReader"/>
				<x path="openfl.Vector"><x path="Float"/></x>
			</f>
			<meta><m n=":impl"/></meta>
		</get_uvtData>
		<culling public="1" get="accessor" set="null" static="1">
			<x path="openfl.display.TriangleCulling"/>
			<meta><m n=":impl"/></meta>
		</culling>
		<get_culling get="inline" set="null" line="382" static="1">
			<f a="this">
				<c path="openfl._internal.renderer.DrawCommandReader"/>
				<x path="openfl.display.TriangleCulling"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_culling>
		<meta><m n=":final"/></meta>
	</class>
	<abstract path="openfl._internal.renderer.EndFillView" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/_internal/renderer/DrawCommandReader.hx" module="openfl._internal.renderer.DrawCommandReader">
		<this><c path="openfl._internal.renderer.DrawCommandReader"/></this>
		<impl><class path="openfl._internal.renderer._DrawCommandReader.EndFillView_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/_internal/renderer/DrawCommandReader.hx" private="1" module="openfl._internal.renderer.DrawCommandReader">
	<_new public="1" get="inline" set="null" line="389" static="1">
		<f a="d">
			<c path="openfl._internal.renderer.DrawCommandReader"/>
			<x path="openfl._internal.renderer.EndFillView"/>
		</f>
		<meta><m n=":impl"/></meta>
	</_new>
	<meta><m n=":final"/></meta>
</class></impl>
	</abstract>
	<class path="openfl._internal.renderer._DrawCommandReader.EndFillView_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/_internal/renderer/DrawCommandReader.hx" private="1" module="openfl._internal.renderer.DrawCommandReader">
		<_new public="1" get="inline" set="null" line="389" static="1">
			<f a="d">
				<c path="openfl._internal.renderer.DrawCommandReader"/>
				<x path="openfl._internal.renderer.EndFillView"/>
			</f>
			<meta><m n=":impl"/></meta>
		</_new>
		<meta><m n=":final"/></meta>
	</class>
	<abstract path="openfl._internal.renderer.LineBitmapStyleView" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/_internal/renderer/DrawCommandReader.hx" module="openfl._internal.renderer.DrawCommandReader">
		<this><c path="openfl._internal.renderer.DrawCommandReader"/></this>
		<impl><class path="openfl._internal.renderer._DrawCommandReader.LineBitmapStyleView_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/_internal/renderer/DrawCommandReader.hx" private="1" module="openfl._internal.renderer.DrawCommandReader">
	<_new public="1" get="inline" set="null" line="396" static="1">
		<f a="d">
			<c path="openfl._internal.renderer.DrawCommandReader"/>
			<x path="openfl._internal.renderer.LineBitmapStyleView"/>
		</f>
		<meta><m n=":impl"/></meta>
	</_new>
	<bitmap public="1" get="accessor" set="null" static="1">
		<c path="openfl.display.BitmapData"/>
		<meta><m n=":impl"/></meta>
	</bitmap>
	<get_bitmap get="inline" set="null" line="397" static="1">
		<f a="this">
			<c path="openfl._internal.renderer.DrawCommandReader"/>
			<c path="openfl.display.BitmapData"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_bitmap>
	<matrix public="1" get="accessor" set="null" static="1">
		<c path="openfl.geom.Matrix"/>
		<meta><m n=":impl"/></meta>
	</matrix>
	<get_matrix get="inline" set="null" line="398" static="1">
		<f a="this">
			<c path="openfl._internal.renderer.DrawCommandReader"/>
			<c path="openfl.geom.Matrix"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_matrix>
	<repeat public="1" get="accessor" set="null" static="1">
		<x path="Bool"/>
		<meta><m n=":impl"/></meta>
	</repeat>
	<get_repeat get="inline" set="null" line="399" static="1">
		<f a="this">
			<c path="openfl._internal.renderer.DrawCommandReader"/>
			<x path="Bool"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_repeat>
	<smooth public="1" get="accessor" set="null" static="1">
		<x path="Bool"/>
		<meta><m n=":impl"/></meta>
	</smooth>
	<get_smooth get="inline" set="null" line="400" static="1">
		<f a="this">
			<c path="openfl._internal.renderer.DrawCommandReader"/>
			<x path="Bool"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_smooth>
	<meta><m n=":final"/></meta>
</class></impl>
	</abstract>
	<class path="openfl._internal.renderer._DrawCommandReader.LineBitmapStyleView_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/_internal/renderer/DrawCommandReader.hx" private="1" module="openfl._internal.renderer.DrawCommandReader">
		<_new public="1" get="inline" set="null" line="396" static="1">
			<f a="d">
				<c path="openfl._internal.renderer.DrawCommandReader"/>
				<x path="openfl._internal.renderer.LineBitmapStyleView"/>
			</f>
			<meta><m n=":impl"/></meta>
		</_new>
		<bitmap public="1" get="accessor" set="null" static="1">
			<c path="openfl.display.BitmapData"/>
			<meta><m n=":impl"/></meta>
		</bitmap>
		<get_bitmap get="inline" set="null" line="397" static="1">
			<f a="this">
				<c path="openfl._internal.renderer.DrawCommandReader"/>
				<c path="openfl.display.BitmapData"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_bitmap>
		<matrix public="1" get="accessor" set="null" static="1">
			<c path="openfl.geom.Matrix"/>
			<meta><m n=":impl"/></meta>
		</matrix>
		<get_matrix get="inline" set="null" line="398" static="1">
			<f a="this">
				<c path="openfl._internal.renderer.DrawCommandReader"/>
				<c path="openfl.geom.Matrix"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_matrix>
		<repeat public="1" get="accessor" set="null" static="1">
			<x path="Bool"/>
			<meta><m n=":impl"/></meta>
		</repeat>
		<get_repeat get="inline" set="null" line="399" static="1">
			<f a="this">
				<c path="openfl._internal.renderer.DrawCommandReader"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_repeat>
		<smooth public="1" get="accessor" set="null" static="1">
			<x path="Bool"/>
			<meta><m n=":impl"/></meta>
		</smooth>
		<get_smooth get="inline" set="null" line="400" static="1">
			<f a="this">
				<c path="openfl._internal.renderer.DrawCommandReader"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_smooth>
		<meta><m n=":final"/></meta>
	</class>
	<abstract path="openfl._internal.renderer.LineGradientStyleView" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/_internal/renderer/DrawCommandReader.hx" module="openfl._internal.renderer.DrawCommandReader">
		<this><c path="openfl._internal.renderer.DrawCommandReader"/></this>
		<impl><class path="openfl._internal.renderer._DrawCommandReader.LineGradientStyleView_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/_internal/renderer/DrawCommandReader.hx" private="1" module="openfl._internal.renderer.DrawCommandReader">
	<_new public="1" get="inline" set="null" line="407" static="1">
		<f a="d">
			<c path="openfl._internal.renderer.DrawCommandReader"/>
			<x path="openfl._internal.renderer.LineGradientStyleView"/>
		</f>
		<meta><m n=":impl"/></meta>
	</_new>
	<type public="1" get="accessor" set="null" static="1">
		<x path="openfl.display.GradientType"/>
		<meta><m n=":impl"/></meta>
	</type>
	<get_type get="inline" set="null" line="408" static="1">
		<f a="this">
			<c path="openfl._internal.renderer.DrawCommandReader"/>
			<x path="openfl.display.GradientType"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_type>
	<colors public="1" get="accessor" set="null" static="1">
		<c path="Array"><x path="Int"/></c>
		<meta><m n=":impl"/></meta>
	</colors>
	<get_colors get="inline" set="null" line="409" static="1">
		<f a="this">
			<c path="openfl._internal.renderer.DrawCommandReader"/>
			<c path="Array"><x path="Int"/></c>
		</f>
		<meta><m n=":impl"/></meta>
	</get_colors>
	<alphas public="1" get="accessor" set="null" static="1">
		<c path="Array"><x path="Float"/></c>
		<meta><m n=":impl"/></meta>
	</alphas>
	<get_alphas get="inline" set="null" line="410" static="1">
		<f a="this">
			<c path="openfl._internal.renderer.DrawCommandReader"/>
			<c path="Array"><x path="Float"/></c>
		</f>
		<meta><m n=":impl"/></meta>
	</get_alphas>
	<ratios public="1" get="accessor" set="null" static="1">
		<c path="Array"><x path="Int"/></c>
		<meta><m n=":impl"/></meta>
	</ratios>
	<get_ratios get="inline" set="null" line="411" static="1">
		<f a="this">
			<c path="openfl._internal.renderer.DrawCommandReader"/>
			<c path="Array"><x path="Int"/></c>
		</f>
		<meta><m n=":impl"/></meta>
	</get_ratios>
	<matrix public="1" get="accessor" set="null" static="1">
		<c path="openfl.geom.Matrix"/>
		<meta><m n=":impl"/></meta>
	</matrix>
	<get_matrix get="inline" set="null" line="412" static="1">
		<f a="this">
			<c path="openfl._internal.renderer.DrawCommandReader"/>
			<c path="openfl.geom.Matrix"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_matrix>
	<spreadMethod public="1" get="accessor" set="null" static="1">
		<x path="openfl.display.SpreadMethod"/>
		<meta><m n=":impl"/></meta>
	</spreadMethod>
	<get_spreadMethod get="inline" set="null" line="413" static="1">
		<f a="this">
			<c path="openfl._internal.renderer.DrawCommandReader"/>
			<x path="openfl.display.SpreadMethod"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_spreadMethod>
	<interpolationMethod public="1" get="accessor" set="null" static="1">
		<x path="openfl.display.InterpolationMethod"/>
		<meta><m n=":impl"/></meta>
	</interpolationMethod>
	<get_interpolationMethod get="inline" set="null" line="414" static="1">
		<f a="this">
			<c path="openfl._internal.renderer.DrawCommandReader"/>
			<x path="openfl.display.InterpolationMethod"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_interpolationMethod>
	<focalPointRatio public="1" get="accessor" set="null" static="1">
		<x path="Float"/>
		<meta><m n=":impl"/></meta>
	</focalPointRatio>
	<get_focalPointRatio get="inline" set="null" line="415" static="1">
		<f a="this">
			<c path="openfl._internal.renderer.DrawCommandReader"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_focalPointRatio>
	<meta><m n=":final"/></meta>
</class></impl>
	</abstract>
	<class path="openfl._internal.renderer._DrawCommandReader.LineGradientStyleView_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/_internal/renderer/DrawCommandReader.hx" private="1" module="openfl._internal.renderer.DrawCommandReader">
		<_new public="1" get="inline" set="null" line="407" static="1">
			<f a="d">
				<c path="openfl._internal.renderer.DrawCommandReader"/>
				<x path="openfl._internal.renderer.LineGradientStyleView"/>
			</f>
			<meta><m n=":impl"/></meta>
		</_new>
		<type public="1" get="accessor" set="null" static="1">
			<x path="openfl.display.GradientType"/>
			<meta><m n=":impl"/></meta>
		</type>
		<get_type get="inline" set="null" line="408" static="1">
			<f a="this">
				<c path="openfl._internal.renderer.DrawCommandReader"/>
				<x path="openfl.display.GradientType"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_type>
		<colors public="1" get="accessor" set="null" static="1">
			<c path="Array"><x path="Int"/></c>
			<meta><m n=":impl"/></meta>
		</colors>
		<get_colors get="inline" set="null" line="409" static="1">
			<f a="this">
				<c path="openfl._internal.renderer.DrawCommandReader"/>
				<c path="Array"><x path="Int"/></c>
			</f>
			<meta><m n=":impl"/></meta>
		</get_colors>
		<alphas public="1" get="accessor" set="null" static="1">
			<c path="Array"><x path="Float"/></c>
			<meta><m n=":impl"/></meta>
		</alphas>
		<get_alphas get="inline" set="null" line="410" static="1">
			<f a="this">
				<c path="openfl._internal.renderer.DrawCommandReader"/>
				<c path="Array"><x path="Float"/></c>
			</f>
			<meta><m n=":impl"/></meta>
		</get_alphas>
		<ratios public="1" get="accessor" set="null" static="1">
			<c path="Array"><x path="Int"/></c>
			<meta><m n=":impl"/></meta>
		</ratios>
		<get_ratios get="inline" set="null" line="411" static="1">
			<f a="this">
				<c path="openfl._internal.renderer.DrawCommandReader"/>
				<c path="Array"><x path="Int"/></c>
			</f>
			<meta><m n=":impl"/></meta>
		</get_ratios>
		<matrix public="1" get="accessor" set="null" static="1">
			<c path="openfl.geom.Matrix"/>
			<meta><m n=":impl"/></meta>
		</matrix>
		<get_matrix get="inline" set="null" line="412" static="1">
			<f a="this">
				<c path="openfl._internal.renderer.DrawCommandReader"/>
				<c path="openfl.geom.Matrix"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_matrix>
		<spreadMethod public="1" get="accessor" set="null" static="1">
			<x path="openfl.display.SpreadMethod"/>
			<meta><m n=":impl"/></meta>
		</spreadMethod>
		<get_spreadMethod get="inline" set="null" line="413" static="1">
			<f a="this">
				<c path="openfl._internal.renderer.DrawCommandReader"/>
				<x path="openfl.display.SpreadMethod"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_spreadMethod>
		<interpolationMethod public="1" get="accessor" set="null" static="1">
			<x path="openfl.display.InterpolationMethod"/>
			<meta><m n=":impl"/></meta>
		</interpolationMethod>
		<get_interpolationMethod get="inline" set="null" line="414" static="1">
			<f a="this">
				<c path="openfl._internal.renderer.DrawCommandReader"/>
				<x path="openfl.display.InterpolationMethod"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_interpolationMethod>
		<focalPointRatio public="1" get="accessor" set="null" static="1">
			<x path="Float"/>
			<meta><m n=":impl"/></meta>
		</focalPointRatio>
		<get_focalPointRatio get="inline" set="null" line="415" static="1">
			<f a="this">
				<c path="openfl._internal.renderer.DrawCommandReader"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_focalPointRatio>
		<meta><m n=":final"/></meta>
	</class>
	<abstract path="openfl._internal.renderer.LineStyleView" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/_internal/renderer/DrawCommandReader.hx" module="openfl._internal.renderer.DrawCommandReader">
		<this><c path="openfl._internal.renderer.DrawCommandReader"/></this>
		<impl><class path="openfl._internal.renderer._DrawCommandReader.LineStyleView_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/_internal/renderer/DrawCommandReader.hx" private="1" module="openfl._internal.renderer.DrawCommandReader">
	<_new public="1" get="inline" set="null" line="422" static="1">
		<f a="d">
			<c path="openfl._internal.renderer.DrawCommandReader"/>
			<x path="openfl._internal.renderer.LineStyleView"/>
		</f>
		<meta><m n=":impl"/></meta>
	</_new>
	<thickness public="1" get="accessor" set="null" static="1">
		<t path="Null"><x path="Float"/></t>
		<meta><m n=":impl"/></meta>
	</thickness>
	<get_thickness get="inline" set="null" line="423" static="1">
		<f a="this">
			<c path="openfl._internal.renderer.DrawCommandReader"/>
			<t path="Null"><x path="Float"/></t>
		</f>
		<meta><m n=":impl"/></meta>
	</get_thickness>
	<color public="1" get="accessor" set="null" static="1">
		<x path="Int"/>
		<meta><m n=":impl"/></meta>
	</color>
	<get_color get="inline" set="null" line="424" static="1">
		<f a="this">
			<c path="openfl._internal.renderer.DrawCommandReader"/>
			<x path="Int"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_color>
	<alpha public="1" get="accessor" set="null" static="1">
		<x path="Float"/>
		<meta><m n=":impl"/></meta>
	</alpha>
	<get_alpha get="inline" set="null" line="425" static="1">
		<f a="this">
			<c path="openfl._internal.renderer.DrawCommandReader"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_alpha>
	<pixelHinting public="1" get="accessor" set="null" static="1">
		<x path="Bool"/>
		<meta><m n=":impl"/></meta>
	</pixelHinting>
	<get_pixelHinting get="inline" set="null" line="426" static="1">
		<f a="this">
			<c path="openfl._internal.renderer.DrawCommandReader"/>
			<x path="Bool"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_pixelHinting>
	<scaleMode public="1" get="accessor" set="null" static="1">
		<x path="openfl.display.LineScaleMode"/>
		<meta><m n=":impl"/></meta>
	</scaleMode>
	<get_scaleMode get="inline" set="null" line="427" static="1">
		<f a="this">
			<c path="openfl._internal.renderer.DrawCommandReader"/>
			<x path="openfl.display.LineScaleMode"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_scaleMode>
	<caps public="1" get="accessor" set="null" static="1">
		<x path="openfl.display.CapsStyle"/>
		<meta><m n=":impl"/></meta>
	</caps>
	<get_caps get="inline" set="null" line="428" static="1">
		<f a="this">
			<c path="openfl._internal.renderer.DrawCommandReader"/>
			<x path="openfl.display.CapsStyle"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_caps>
	<joints public="1" get="accessor" set="null" static="1">
		<x path="openfl.display.JointStyle"/>
		<meta><m n=":impl"/></meta>
	</joints>
	<get_joints get="inline" set="null" line="429" static="1">
		<f a="this">
			<c path="openfl._internal.renderer.DrawCommandReader"/>
			<x path="openfl.display.JointStyle"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_joints>
	<miterLimit public="1" get="accessor" set="null" static="1">
		<x path="Float"/>
		<meta><m n=":impl"/></meta>
	</miterLimit>
	<get_miterLimit get="inline" set="null" line="430" static="1">
		<f a="this">
			<c path="openfl._internal.renderer.DrawCommandReader"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_miterLimit>
	<meta><m n=":final"/></meta>
</class></impl>
	</abstract>
	<class path="openfl._internal.renderer._DrawCommandReader.LineStyleView_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/_internal/renderer/DrawCommandReader.hx" private="1" module="openfl._internal.renderer.DrawCommandReader">
		<_new public="1" get="inline" set="null" line="422" static="1">
			<f a="d">
				<c path="openfl._internal.renderer.DrawCommandReader"/>
				<x path="openfl._internal.renderer.LineStyleView"/>
			</f>
			<meta><m n=":impl"/></meta>
		</_new>
		<thickness public="1" get="accessor" set="null" static="1">
			<t path="Null"><x path="Float"/></t>
			<meta><m n=":impl"/></meta>
		</thickness>
		<get_thickness get="inline" set="null" line="423" static="1">
			<f a="this">
				<c path="openfl._internal.renderer.DrawCommandReader"/>
				<t path="Null"><x path="Float"/></t>
			</f>
			<meta><m n=":impl"/></meta>
		</get_thickness>
		<color public="1" get="accessor" set="null" static="1">
			<x path="Int"/>
			<meta><m n=":impl"/></meta>
		</color>
		<get_color get="inline" set="null" line="424" static="1">
			<f a="this">
				<c path="openfl._internal.renderer.DrawCommandReader"/>
				<x path="Int"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_color>
		<alpha public="1" get="accessor" set="null" static="1">
			<x path="Float"/>
			<meta><m n=":impl"/></meta>
		</alpha>
		<get_alpha get="inline" set="null" line="425" static="1">
			<f a="this">
				<c path="openfl._internal.renderer.DrawCommandReader"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_alpha>
		<pixelHinting public="1" get="accessor" set="null" static="1">
			<x path="Bool"/>
			<meta><m n=":impl"/></meta>
		</pixelHinting>
		<get_pixelHinting get="inline" set="null" line="426" static="1">
			<f a="this">
				<c path="openfl._internal.renderer.DrawCommandReader"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_pixelHinting>
		<scaleMode public="1" get="accessor" set="null" static="1">
			<x path="openfl.display.LineScaleMode"/>
			<meta><m n=":impl"/></meta>
		</scaleMode>
		<get_scaleMode get="inline" set="null" line="427" static="1">
			<f a="this">
				<c path="openfl._internal.renderer.DrawCommandReader"/>
				<x path="openfl.display.LineScaleMode"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_scaleMode>
		<caps public="1" get="accessor" set="null" static="1">
			<x path="openfl.display.CapsStyle"/>
			<meta><m n=":impl"/></meta>
		</caps>
		<get_caps get="inline" set="null" line="428" static="1">
			<f a="this">
				<c path="openfl._internal.renderer.DrawCommandReader"/>
				<x path="openfl.display.CapsStyle"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_caps>
		<joints public="1" get="accessor" set="null" static="1">
			<x path="openfl.display.JointStyle"/>
			<meta><m n=":impl"/></meta>
		</joints>
		<get_joints get="inline" set="null" line="429" static="1">
			<f a="this">
				<c path="openfl._internal.renderer.DrawCommandReader"/>
				<x path="openfl.display.JointStyle"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_joints>
		<miterLimit public="1" get="accessor" set="null" static="1">
			<x path="Float"/>
			<meta><m n=":impl"/></meta>
		</miterLimit>
		<get_miterLimit get="inline" set="null" line="430" static="1">
			<f a="this">
				<c path="openfl._internal.renderer.DrawCommandReader"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_miterLimit>
		<meta><m n=":final"/></meta>
	</class>
	<abstract path="openfl._internal.renderer.LineToView" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/_internal/renderer/DrawCommandReader.hx" module="openfl._internal.renderer.DrawCommandReader">
		<this><c path="openfl._internal.renderer.DrawCommandReader"/></this>
		<impl><class path="openfl._internal.renderer._DrawCommandReader.LineToView_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/_internal/renderer/DrawCommandReader.hx" private="1" module="openfl._internal.renderer.DrawCommandReader">
	<_new public="1" get="inline" set="null" line="437" static="1">
		<f a="d">
			<c path="openfl._internal.renderer.DrawCommandReader"/>
			<x path="openfl._internal.renderer.LineToView"/>
		</f>
		<meta><m n=":impl"/></meta>
	</_new>
	<x public="1" get="accessor" set="null" static="1">
		<x path="Float"/>
		<meta><m n=":impl"/></meta>
	</x>
	<get_x get="inline" set="null" line="438" static="1">
		<f a="this">
			<c path="openfl._internal.renderer.DrawCommandReader"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_x>
	<y public="1" get="accessor" set="null" static="1">
		<x path="Float"/>
		<meta><m n=":impl"/></meta>
	</y>
	<get_y get="inline" set="null" line="439" static="1">
		<f a="this">
			<c path="openfl._internal.renderer.DrawCommandReader"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_y>
	<meta><m n=":final"/></meta>
</class></impl>
	</abstract>
	<class path="openfl._internal.renderer._DrawCommandReader.LineToView_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/_internal/renderer/DrawCommandReader.hx" private="1" module="openfl._internal.renderer.DrawCommandReader">
		<_new public="1" get="inline" set="null" line="437" static="1">
			<f a="d">
				<c path="openfl._internal.renderer.DrawCommandReader"/>
				<x path="openfl._internal.renderer.LineToView"/>
			</f>
			<meta><m n=":impl"/></meta>
		</_new>
		<x public="1" get="accessor" set="null" static="1">
			<x path="Float"/>
			<meta><m n=":impl"/></meta>
		</x>
		<get_x get="inline" set="null" line="438" static="1">
			<f a="this">
				<c path="openfl._internal.renderer.DrawCommandReader"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_x>
		<y public="1" get="accessor" set="null" static="1">
			<x path="Float"/>
			<meta><m n=":impl"/></meta>
		</y>
		<get_y get="inline" set="null" line="439" static="1">
			<f a="this">
				<c path="openfl._internal.renderer.DrawCommandReader"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_y>
		<meta><m n=":final"/></meta>
	</class>
	<abstract path="openfl._internal.renderer.MoveToView" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/_internal/renderer/DrawCommandReader.hx" module="openfl._internal.renderer.DrawCommandReader">
		<this><c path="openfl._internal.renderer.DrawCommandReader"/></this>
		<impl><class path="openfl._internal.renderer._DrawCommandReader.MoveToView_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/_internal/renderer/DrawCommandReader.hx" private="1" module="openfl._internal.renderer.DrawCommandReader">
	<_new public="1" get="inline" set="null" line="446" static="1">
		<f a="d">
			<c path="openfl._internal.renderer.DrawCommandReader"/>
			<x path="openfl._internal.renderer.MoveToView"/>
		</f>
		<meta><m n=":impl"/></meta>
	</_new>
	<x public="1" get="accessor" set="null" static="1">
		<x path="Float"/>
		<meta><m n=":impl"/></meta>
	</x>
	<get_x get="inline" set="null" line="447" static="1">
		<f a="this">
			<c path="openfl._internal.renderer.DrawCommandReader"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_x>
	<y public="1" get="accessor" set="null" static="1">
		<x path="Float"/>
		<meta><m n=":impl"/></meta>
	</y>
	<get_y get="inline" set="null" line="448" static="1">
		<f a="this">
			<c path="openfl._internal.renderer.DrawCommandReader"/>
			<x path="Float"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_y>
	<meta><m n=":final"/></meta>
</class></impl>
	</abstract>
	<class path="openfl._internal.renderer._DrawCommandReader.MoveToView_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/_internal/renderer/DrawCommandReader.hx" private="1" module="openfl._internal.renderer.DrawCommandReader">
		<_new public="1" get="inline" set="null" line="446" static="1">
			<f a="d">
				<c path="openfl._internal.renderer.DrawCommandReader"/>
				<x path="openfl._internal.renderer.MoveToView"/>
			</f>
			<meta><m n=":impl"/></meta>
		</_new>
		<x public="1" get="accessor" set="null" static="1">
			<x path="Float"/>
			<meta><m n=":impl"/></meta>
		</x>
		<get_x get="inline" set="null" line="447" static="1">
			<f a="this">
				<c path="openfl._internal.renderer.DrawCommandReader"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_x>
		<y public="1" get="accessor" set="null" static="1">
			<x path="Float"/>
			<meta><m n=":impl"/></meta>
		</y>
		<get_y get="inline" set="null" line="448" static="1">
			<f a="this">
				<c path="openfl._internal.renderer.DrawCommandReader"/>
				<x path="Float"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_y>
		<meta><m n=":final"/></meta>
	</class>
	<abstract path="openfl._internal.renderer.OverrideMatrixView" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/_internal/renderer/DrawCommandReader.hx" module="openfl._internal.renderer.DrawCommandReader">
		<this><c path="openfl._internal.renderer.DrawCommandReader"/></this>
		<impl><class path="openfl._internal.renderer._DrawCommandReader.OverrideMatrixView_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/_internal/renderer/DrawCommandReader.hx" private="1" module="openfl._internal.renderer.DrawCommandReader">
	<_new public="1" get="inline" set="null" line="455" static="1">
		<f a="d">
			<c path="openfl._internal.renderer.DrawCommandReader"/>
			<x path="openfl._internal.renderer.OverrideMatrixView"/>
		</f>
		<meta><m n=":impl"/></meta>
	</_new>
	<matrix public="1" get="accessor" set="null" static="1">
		<c path="openfl.geom.Matrix"/>
		<meta><m n=":impl"/></meta>
	</matrix>
	<get_matrix get="inline" set="null" line="456" static="1">
		<f a="this">
			<c path="openfl._internal.renderer.DrawCommandReader"/>
			<c path="openfl.geom.Matrix"/>
		</f>
		<meta><m n=":impl"/></meta>
	</get_matrix>
	<meta><m n=":final"/></meta>
</class></impl>
	</abstract>
	<class path="openfl._internal.renderer._DrawCommandReader.OverrideMatrixView_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/_internal/renderer/DrawCommandReader.hx" private="1" module="openfl._internal.renderer.DrawCommandReader">
		<_new public="1" get="inline" set="null" line="455" static="1">
			<f a="d">
				<c path="openfl._internal.renderer.DrawCommandReader"/>
				<x path="openfl._internal.renderer.OverrideMatrixView"/>
			</f>
			<meta><m n=":impl"/></meta>
		</_new>
		<matrix public="1" get="accessor" set="null" static="1">
			<c path="openfl.geom.Matrix"/>
			<meta><m n=":impl"/></meta>
		</matrix>
		<get_matrix get="inline" set="null" line="456" static="1">
			<f a="this">
				<c path="openfl._internal.renderer.DrawCommandReader"/>
				<c path="openfl.geom.Matrix"/>
			</f>
			<meta><m n=":impl"/></meta>
		</get_matrix>
		<meta><m n=":final"/></meta>
	</class>
	<enum path="openfl._internal.renderer.DrawCommandType" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/_internal/renderer/DrawCommandType.hx">
		<BEGIN_BITMAP_FILL/>
		<BEGIN_FILL/>
		<BEGIN_GRADIENT_FILL/>
		<CUBIC_CURVE_TO/>
		<CURVE_TO/>
		<DRAW_CIRCLE/>
		<DRAW_ELLIPSE/>
		<DRAW_PATH/>
		<DRAW_RECT/>
		<DRAW_ROUND_RECT/>
		<DRAW_TILES/>
		<DRAW_TRIANGLES/>
		<END_FILL/>
		<LINE_BITMAP_STYLE/>
		<LINE_GRADIENT_STYLE/>
		<LINE_STYLE/>
		<LINE_TO/>
		<MOVE_TO/>
		<OVERRIDE_MATRIX/>
		<UNKNOWN/>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<class path="openfl._internal.renderer.GraphicsPaths" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/_internal/renderer/GraphicsPaths.hx">
		<SIN45 expr="0.70710678118654752440084436210485" line="7" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>0.70710678118654752440084436210485</e></m></meta>
		</SIN45>
		<TAN22 expr="0.4142135623730950488016887242097" line="8" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>0.4142135623730950488016887242097</e></m></meta>
		</TAN22>
		<ellipse public="1" get="inline" set="null" line="11" static="1"><f a="points:x:y:rx:ry:segmentCount">
	<c path="Array"><x path="Float"/></c>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Int"/>
	<x path="Void"/>
</f></ellipse>
		<cubicCurveTo public="1" get="inline" set="null" line="30" static="1"><f a="points:cx:cy:cx2:cy2:x:y">
	<c path="Array"><x path="Float"/></c>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></cubicCurveTo>
		<curveTo public="1" set="method" line="74" static="1"><f a="points:cx:cy:x:y">
	<c path="Array"><x path="Float"/></c>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></curveTo>
		<roundRectangle public="1" set="method" line="108" static="1"><f a="points:x:y:width:height:rx:ry">
	<c path="Array"><x path="Float"/></c>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></roundRectangle>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="openfl._internal.renderer.PolyK" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/_internal/renderer/PolyK.hx">
		<triangulate public="1" set="method" line="36" static="1"><f a="tgs:p">
	<c path="Array"><x path="Int"/></c>
	<c path="Array"><x path="Float"/></c>
	<c path="Array"><x path="Int"/></c>
</f></triangulate>
		<_PointInTriangle public="1" set="method" line="121" static="1"><f a="px:py:ax:ay:bx:by:cx:cy">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Bool"/>
</f></_PointInTriangle>
		<_convex public="1" set="method" line="145" static="1"><f a="ax:ay:bx:by:cx:cy:sign">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Bool"/>
	<x path="Bool"/>
</f></_convex>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="openfl._internal.renderer.RenderSession" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/_internal/renderer/RenderSession.hx">
		<cairo public="1"><t path="lime.graphics.CairoRenderContext"/></cairo>
		<context public="1"><c path="lime.graphics.CanvasRenderContext"/></context>
		<element public="1"><c path="lime.graphics.DOMRenderContext"/></element>
		<gl public="1"><c path="lime.graphics.GLRenderContext"/></gl>
		<renderer public="1"><c path="openfl._internal.renderer.AbstractRenderer"/></renderer>
		<roundPixels public="1"><x path="Bool"/></roundPixels>
		<transformProperty public="1"><c path="String"/></transformProperty>
		<transformOriginProperty public="1"><c path="String"/></transformOriginProperty>
		<vendorPrefix public="1"><c path="String"/></vendorPrefix>
		<z public="1"><x path="Int"/></z>
		<projectionMatrix public="1"><c path="openfl.geom.Matrix"/></projectionMatrix>
		<drawCount public="1"><x path="Int"/></drawCount>
		<currentBlendMode public="1"><x path="openfl.display.BlendMode"/></currentBlendMode>
		<activeTextures public="1" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</activeTextures>
		<shaderManager public="1"><c path="openfl._internal.renderer.opengl.utils.ShaderManager"/></shaderManager>
		<maskManager public="1"><c path="openfl._internal.renderer.AbstractMaskManager"/></maskManager>
		<filterManager public="1"><c path="openfl._internal.renderer.opengl.utils.FilterManager"/></filterManager>
		<blendModeManager public="1"><c path="openfl._internal.renderer.opengl.utils.BlendModeManager"/></blendModeManager>
		<spriteBatch public="1"><c path="openfl._internal.renderer.opengl.utils.SpriteBatch"/></spriteBatch>
		<stencilManager public="1"><c path="openfl._internal.renderer.opengl.utils.StencilManager"/></stencilManager>
		<defaultFramebuffer public="1"><c path="lime.graphics.opengl.GLFramebuffer"/></defaultFramebuffer>
		<new public="1" set="method" line="47"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="openfl._internal.renderer.cairo.CairoBitmap" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/_internal/renderer/cairo/CairoBitmap.hx">
		<render public="1" get="inline" set="null" line="20" static="1"><f a="bitmap:renderSession">
	<c path="openfl.display.Bitmap"/>
	<c path="openfl._internal.renderer.RenderSession"/>
	<x path="Void"/>
</f></render>
		<meta>
			<m n=":access"><e>lime.graphics.ImageBuffer</e></m>
			<m n=":access"><e>openfl.display.Bitmap</e></m>
			<m n=":access"><e>openfl.display.BitmapData</e></m>
			<m n=":access"><e>openfl.geom.Matrix</e></m>
		</meta>
	</class>
	<class path="openfl._internal.renderer.cairo.CairoGraphics" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/_internal/renderer/cairo/CairoGraphics.hx">
		<SIN45 expr="0.70710678118654752440084436210485" line="38" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>0.70710678118654752440084436210485</e></m></meta>
		</SIN45>
		<TAN22 expr="0.4142135623730950488016887242097" line="39" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>0.4142135623730950488016887242097</e></m></meta>
		</TAN22>
		<bitmapFill static="1"><c path="openfl.display.BitmapData"/></bitmapFill>
		<bitmapRepeat static="1"><x path="Bool"/></bitmapRepeat>
		<bounds static="1"><c path="openfl.geom.Rectangle"/></bounds>
		<cairo static="1"><c path="lime.graphics.cairo.Cairo"/></cairo>
		<fillCommands expr="new DrawCommandBuffer()" line="45" static="1">
			<c path="openfl._internal.renderer.DrawCommandBuffer"/>
			<meta><m n=":value"><e>new DrawCommandBuffer()</e></m></meta>
		</fillCommands>
		<fillPattern static="1"><x path="lime.graphics.cairo.CairoPattern"/></fillPattern>
		<fillPatternMatrix static="1"><c path="openfl.geom.Matrix"/></fillPatternMatrix>
		<graphics static="1"><c path="openfl.display.Graphics"/></graphics>
		<hasFill static="1"><x path="Bool"/></hasFill>
		<hasStroke static="1"><x path="Bool"/></hasStroke>
		<hitTesting static="1"><x path="Bool"/></hitTesting>
		<inversePendingMatrix static="1"><c path="openfl.geom.Matrix"/></inversePendingMatrix>
		<pendingMatrix static="1"><c path="openfl.geom.Matrix"/></pendingMatrix>
		<strokeCommands expr="new DrawCommandBuffer()" line="54" static="1">
			<c path="openfl._internal.renderer.DrawCommandBuffer"/>
			<meta><m n=":value"><e>new DrawCommandBuffer()</e></m></meta>
		</strokeCommands>
		<strokePattern static="1"><x path="lime.graphics.cairo.CairoPattern"/></strokePattern>
		<closePath set="method" line="58" static="1"><f a=""><x path="Void"/></f></closePath>
		<createGradientPattern set="method" line="74" static="1"><f a="type:colors:alphas:ratios:matrix:spreadMethod:interpolationMethod:focalPointRatio">
	<x path="openfl.display.GradientType"/>
	<c path="Array"><d/></c>
	<c path="Array"><d/></c>
	<c path="Array"><d/></c>
	<c path="openfl.geom.Matrix"/>
	<x path="openfl.display.SpreadMethod"/>
	<x path="openfl.display.InterpolationMethod"/>
	<x path="Float"/>
	<x path="lime.graphics.cairo.CairoPattern"/>
</f></createGradientPattern>
		<createImagePattern set="method" line="135" static="1"><f a="bitmapFill:matrix:bitmapRepeat">
	<c path="openfl.display.BitmapData"/>
	<c path="openfl.geom.Matrix"/>
	<x path="Bool"/>
	<x path="lime.graphics.cairo.CairoPattern"/>
</f></createImagePattern>
		<drawRoundRect set="method" line="152" static="1"><f a="x:y:width:height:ellipseWidth:ellipseHeight">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<t path="Null"><x path="Float"/></t>
	<x path="Void"/>
</f></drawRoundRect>
		<endFill set="method" line="186" static="1"><f a=""><x path="Void"/></f></endFill>
		<endStroke set="method" line="195" static="1"><f a=""><x path="Void"/></f></endStroke>
		<hitTest public="1" set="method" line="205" static="1"><f a="graphics:x:y">
	<c path="openfl.display.Graphics"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Bool"/>
</f></hitTest>
		<isCCW get="inline" set="null" line="417" static="1"><f a="x1:y1:x2:y2:x3:y3">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Bool"/>
</f></isCCW>
		<normalizeUVT set="method" line="424" static="1">
			<f a="uvt:?skipT" v=":false">
				<x path="openfl.Vector"><x path="Float"/></x>
				<x path="Bool"/>
				<a>
					<uvt><x path="openfl.Vector"><x path="Float"/></x></uvt>
					<max><x path="Float"/></max>
				</a>
			</f>
			<meta><m n=":value"><e>{ skipT : false }</e></m></meta>
		</normalizeUVT>
		<playCommands set="method" line="467" static="1">
			<f a="commands:?stroke" v=":false">
				<c path="openfl._internal.renderer.DrawCommandBuffer"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ stroke : false }</e></m></meta>
		</playCommands>
		<quadraticCurveTo set="method" line="1118" static="1"><f a="cx:cy:x:y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></quadraticCurveTo>
		<render public="1" set="method" line="1143" static="1"><f a="graphics:renderSession">
	<c path="openfl.display.Graphics"/>
	<c path="openfl._internal.renderer.RenderSession"/>
	<x path="Void"/>
</f></render>
		<renderMask public="1" set="method" line="1342" static="1"><f a="graphics:renderSession">
	<c path="openfl.display.Graphics"/>
	<c path="openfl._internal.renderer.RenderSession"/>
	<x path="Void"/>
</f></renderMask>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":access"><e>openfl.display.DisplayObject</e></m>
			<m n=":access"><e>openfl.display.BitmapData</e></m>
			<m n=":access"><e>openfl.display.Graphics</e></m>
			<m n=":access"><e>openfl.display.Tilesheet</e></m>
			<m n=":access"><e>openfl.geom.Matrix</e></m>
		</meta>
	</class>
	<class path="openfl._internal.renderer.cairo.CairoMaskManager" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/_internal/renderer/cairo/CairoMaskManager.hx">
		<extends path="openfl._internal.renderer.AbstractMaskManager"/>
		<pushMask public="1" set="method" line="24" override="1"><f a="mask">
	<c path="openfl.display.DisplayObject"/>
	<x path="Void"/>
</f></pushMask>
		<pushRect public="1" set="method" line="44" override="1"><f a="rect:transform">
	<c path="openfl.geom.Rectangle"/>
	<c path="openfl.geom.Matrix"/>
	<x path="Void"/>
</f></pushRect>
		<popMask public="1" set="method" line="58" override="1"><f a=""><x path="Void"/></f></popMask>
		<popRect public="1" set="method" line="65" override="1"><f a=""><x path="Void"/></f></popRect>
		<new public="1" set="method" line="17"><f a="renderSession">
	<c path="openfl._internal.renderer.RenderSession"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":access"><e>openfl.display.DisplayObject</e></m>
			<m n=":access"><e>openfl.geom.Matrix</e></m>
			<m n=":keep"/>
		</meta>
	</class>
	<class path="openfl._internal.renderer.cairo.CairoRenderer" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/_internal/renderer/cairo/CairoRenderer.hx">
		<extends path="openfl._internal.renderer.AbstractRenderer"/>
		<cairo><c path="lime.graphics.cairo.Cairo"/></cairo>
		<render public="1" set="method" line="36" override="1"><f a="stage">
	<c path="openfl.display.Stage"/>
	<x path="Void"/>
</f></render>
		<renderDisplayObject public="1" set="method" line="52"><f a="object">
	<c path="openfl.display.DisplayObject"/>
	<x path="Void"/>
</f></renderDisplayObject>
		<new public="1" set="method" line="21"><f a="width:height:cairo">
	<x path="Int"/>
	<x path="Int"/>
	<c path="lime.graphics.cairo.Cairo"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":access"><e>openfl.display.Graphics</e></m>
			<m n=":access"><e>openfl.display.Stage</e></m>
			<m n=":allow"><e>openfl.display.Stage</e></m>
		</meta>
	</class>
	<class path="openfl._internal.renderer.cairo.CairoShape" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/_internal/renderer/cairo/CairoShape.hx">
		<render public="1" set="method" line="15" static="1"><f a="shape:renderSession">
	<c path="openfl.display.DisplayObject"/>
	<c path="openfl._internal.renderer.RenderSession"/>
	<x path="Void"/>
</f></render>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":access"><e>openfl.display.DisplayObject</e></m>
			<m n=":access"><e>openfl.display.Graphics</e></m>
			<m n=":access"><e>openfl.geom.Matrix</e></m>
		</meta>
	</class>
	<class path="openfl._internal.renderer.cairo.CairoTextField" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/_internal/renderer/cairo/CairoTextField.hx">
		<render public="1" set="method" line="27" static="1"><f a="textField:renderSession">
	<c path="openfl.text.TextField"/>
	<c path="openfl._internal.renderer.RenderSession"/>
	<x path="Void"/>
</f></render>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":access"><e>openfl.display.BitmapData</e></m>
			<m n=":access"><e>openfl.display.Graphics</e></m>
			<m n=":access"><e>openfl.text.TextField</e></m>
		</meta>
	</class>
	<class path="openfl._internal.renderer.canvas.CanvasBitmap" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/_internal/renderer/canvas/CanvasBitmap.hx">
		<render public="1" get="inline" set="null" line="14" static="1"><f a="bitmap:renderSession">
	<c path="openfl.display.Bitmap"/>
	<c path="openfl._internal.renderer.RenderSession"/>
	<x path="Void"/>
</f></render>
		<meta>
			<m n=":access"><e>openfl.display.Bitmap</e></m>
			<m n=":access"><e>openfl.display.BitmapData</e></m>
		</meta>
	</class>
	<class path="openfl._internal.renderer.canvas.CanvasGraphics" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/_internal/renderer/canvas/CanvasGraphics.hx">
		<SIN45 expr="0.70710678118654752440084436210485" line="40" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>0.70710678118654752440084436210485</e></m></meta>
		</SIN45>
		<TAN22 expr="0.4142135623730950488016887242097" line="41" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>0.4142135623730950488016887242097</e></m></meta>
		</TAN22>
		<bitmapFill static="1"><c path="openfl.display.BitmapData"/></bitmapFill>
		<bitmapStroke static="1"><c path="openfl.display.BitmapData"/></bitmapStroke>
		<bitmapRepeat static="1"><x path="Bool"/></bitmapRepeat>
		<bounds static="1"><c path="openfl.geom.Rectangle"/></bounds>
		<fillCommands expr="new DrawCommandBuffer()" line="47" static="1">
			<c path="openfl._internal.renderer.DrawCommandBuffer"/>
			<meta><m n=":value"><e>new DrawCommandBuffer()</e></m></meta>
		</fillCommands>
		<graphics static="1"><c path="openfl.display.Graphics"/></graphics>
		<hasFill static="1"><x path="Bool"/></hasFill>
		<hasStroke static="1"><x path="Bool"/></hasStroke>
		<hitTesting static="1"><x path="Bool"/></hitTesting>
		<inversePendingMatrix static="1"><c path="openfl.geom.Matrix"/></inversePendingMatrix>
		<pendingMatrix static="1"><c path="openfl.geom.Matrix"/></pendingMatrix>
		<strokeCommands expr="new DrawCommandBuffer()" line="54" static="1">
			<c path="openfl._internal.renderer.DrawCommandBuffer"/>
			<meta><m n=":value"><e>new DrawCommandBuffer()</e></m></meta>
		</strokeCommands>
		<closePath set="method" line="61" static="1"><f a=""><x path="Void"/></f></closePath>
		<createBitmapFill set="method" line="80" static="1"><f a="bitmap:bitmapRepeat">
	<c path="openfl.display.BitmapData"/>
	<x path="Bool"/>
	<unknown/>
</f></createBitmapFill>
		<createGradientPattern set="method" line="96" static="1"><f a="type:colors:alphas:ratios:matrix:spreadMethod:interpolationMethod:focalPointRatio">
	<x path="openfl.display.GradientType"/>
	<c path="Array"><d/></c>
	<c path="Array"><d/></c>
	<c path="Array"><d/></c>
	<c path="openfl.geom.Matrix"/>
	<x path="openfl.display.SpreadMethod"/>
	<x path="openfl.display.InterpolationMethod"/>
	<x path="Float"/>
	<x path="Void"/>
</f></createGradientPattern>
		<createTempPatternCanvas set="method" line="143" static="1"><f a="bitmap:repeat:width:height">
	<c path="openfl.display.BitmapData"/>
	<x path="Bool"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></createTempPatternCanvas>
		<drawRoundRect set="method" line="169" static="1"><f a="x:y:width:height:ellipseWidth:ellipseHeight">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<t path="Null"><x path="Float"/></t>
	<x path="Void"/>
</f></drawRoundRect>
		<endFill set="method" line="205" static="1"><f a=""><x path="Void"/></f></endFill>
		<endStroke set="method" line="216" static="1"><f a=""><x path="Void"/></f></endStroke>
		<hitTest public="1" set="method" line="228" static="1"><f a="graphics:x:y">
	<c path="openfl.display.Graphics"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Bool"/>
</f></hitTest>
		<isCCW get="inline" set="null" line="436" static="1"><f a="x1:y1:x2:y2:x3:y3">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Bool"/>
</f></isCCW>
		<normalizeUVT set="method" line="443" static="1">
			<f a="uvt:?skipT" v=":false">
				<x path="openfl.Vector"><x path="Float"/></x>
				<x path="Bool"/>
				<a>
					<uvt><x path="openfl.Vector"><x path="Float"/></x></uvt>
					<max><x path="Float"/></max>
				</a>
			</f>
			<meta><m n=":value"><e>{ skipT : false }</e></m></meta>
		</normalizeUVT>
		<playCommands set="method" line="486" static="1">
			<f a="commands:?stroke" v=":false">
				<c path="openfl._internal.renderer.DrawCommandBuffer"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ stroke : false }</e></m></meta>
		</playCommands>
		<render public="1" set="method" line="812" static="1"><f a="graphics:renderSession">
	<c path="openfl.display.Graphics"/>
	<c path="openfl._internal.renderer.RenderSession"/>
	<x path="Void"/>
</f></render>
		<renderMask public="1" set="method" line="1293" static="1"><f a="graphics:renderSession">
	<c path="openfl.display.Graphics"/>
	<c path="openfl._internal.renderer.RenderSession"/>
	<x path="Void"/>
</f></renderMask>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":access"><e>openfl.display.DisplayObject</e></m>
			<m n=":access"><e>openfl.display.BitmapData</e></m>
			<m n=":access"><e>openfl.display.Graphics</e></m>
			<m n=":access"><e>openfl.display.Tilesheet</e></m>
		</meta>
	</class>
	<class path="openfl._internal.renderer.canvas.CanvasMaskManager" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/_internal/renderer/canvas/CanvasMaskManager.hx">
		<extends path="openfl._internal.renderer.AbstractMaskManager"/>
		<pushMask public="1" set="method" line="22" override="1"><f a="mask">
	<c path="openfl.display.DisplayObject"/>
	<x path="Void"/>
</f></pushMask>
		<pushRect public="1" set="method" line="43" override="1"><f a="rect:transform">
	<c path="openfl.geom.Rectangle"/>
	<c path="openfl.geom.Matrix"/>
	<x path="Void"/>
</f></pushRect>
		<popMask public="1" set="method" line="57" override="1"><f a=""><x path="Void"/></f></popMask>
		<popRect public="1" set="method" line="64" override="1"><f a=""><x path="Void"/></f></popRect>
		<new public="1" set="method" line="15"><f a="renderSession">
	<c path="openfl._internal.renderer.RenderSession"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":access"><e>openfl.display.DisplayObject</e></m>
			<m n=":keep"/>
		</meta>
	</class>
	<class path="openfl._internal.renderer.canvas.CanvasRenderer" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/_internal/renderer/canvas/CanvasRenderer.hx">
		<extends path="openfl._internal.renderer.AbstractRenderer"/>
		<context><c path="lime.graphics.CanvasRenderContext"/></context>
		<render public="1" set="method" line="35" override="1"><f a="stage">
	<c path="openfl.display.Stage"/>
	<x path="Void"/>
</f></render>
		<new public="1" set="method" line="18"><f a="width:height:context">
	<x path="Int"/>
	<x path="Int"/>
	<c path="lime.graphics.CanvasRenderContext"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":access"><e>openfl.display.Stage</e></m>
		</meta>
	</class>
	<class path="openfl._internal.renderer.canvas.CanvasShape" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/_internal/renderer/canvas/CanvasShape.hx">
		<render public="1" get="inline" set="null" line="13" static="1"><f a="shape:renderSession">
	<c path="openfl.display.DisplayObject"/>
	<c path="openfl._internal.renderer.RenderSession"/>
	<x path="Void"/>
</f></render>
		<meta>
			<m n=":access"><e>openfl.display.DisplayObject</e></m>
			<m n=":access"><e>openfl.display.Graphics</e></m>
		</meta>
	</class>
	<class path="openfl._internal.renderer.canvas.CanvasTextField" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/_internal/renderer/canvas/CanvasTextField.hx">
		<disableInputMode public="1" set="method" line="38" static="1"><f a="textEngine">
	<c path="openfl._internal.text.TextEngine"/>
	<x path="Void"/>
</f></disableInputMode>
		<enableInputMode public="1" set="method" line="47" static="1"><f a="textEngine">
	<c path="openfl._internal.text.TextEngine"/>
	<x path="Void"/>
</f></enableInputMode>
		<render public="1" get="inline" set="null" line="110" static="1"><f a="textField:renderSession">
	<c path="openfl.text.TextField"/>
	<c path="openfl._internal.renderer.RenderSession"/>
	<x path="Void"/>
</f></render>
		<meta>
			<m n=":access"><e>openfl._internal.text.TextEngine</e></m>
			<m n=":access"><e>openfl.display.Graphics</e></m>
			<m n=":access"><e>openfl.text.TextField</e></m>
		</meta>
	</class>
	<class path="openfl._internal.renderer.console.ConsoleRenderer" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/_internal/renderer/console/ConsoleRenderer.hx">
		<extends path="openfl._internal.renderer.AbstractRenderer"/>
		<render public="1" set="method" line="1346" override="1"><f a="stage">
	<c path="openfl.display.Stage"/>
	<x path="Void"/>
</f></render>
		<new public="1" set="method" line="1337"><f a="width:height:ctx">
	<x path="Int"/>
	<x path="Int"/>
	<c path="lime.graphics.ConsoleRenderContext"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="openfl._internal.renderer.dom.DOMBitmap" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/_internal/renderer/dom/DOMBitmap.hx">
		<render public="1" get="inline" set="null" line="20" static="1"><f a="bitmap:renderSession">
	<c path="openfl.display.Bitmap"/>
	<c path="openfl._internal.renderer.RenderSession"/>
	<x path="Void"/>
</f></render>
		<renderCanvas set="method" line="59" static="1"><f a="bitmap:renderSession">
	<c path="openfl.display.Bitmap"/>
	<c path="openfl._internal.renderer.RenderSession"/>
	<x path="Void"/>
</f></renderCanvas>
		<renderImage set="method" line="101" static="1"><f a="bitmap:renderSession">
	<c path="openfl.display.Bitmap"/>
	<c path="openfl._internal.renderer.RenderSession"/>
	<x path="Void"/>
</f></renderImage>
		<meta>
			<m n=":access"><e>lime.graphics.ImageBuffer</e></m>
			<m n=":access"><e>openfl.display.Bitmap</e></m>
			<m n=":access"><e>openfl.display.BitmapData</e></m>
		</meta>
	</class>
	<class path="openfl._internal.renderer.dom.DOMMaskManager" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/_internal/renderer/dom/DOMMaskManager.hx">
		<extends path="openfl._internal.renderer.AbstractMaskManager"/>
		<pushMask public="1" set="method" line="22" override="1"><f a="mask">
	<c path="openfl.display.DisplayObject"/>
	<x path="Void"/>
</f></pushMask>
		<pushRect public="1" set="method" line="43" override="1"><f a="rect:transform">
	<c path="openfl.geom.Rectangle"/>
	<c path="openfl.geom.Matrix"/>
	<x path="Void"/>
</f></pushRect>
		<popMask public="1" set="method" line="57" override="1"><f a=""><x path="Void"/></f></popMask>
		<new public="1" set="method" line="15"><f a="renderSession">
	<c path="openfl._internal.renderer.RenderSession"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":access"><e>openfl.display.DisplayObject</e></m>
			<m n=":keep"/>
		</meta>
	</class>
	<class path="openfl._internal.renderer.dom.DOMRenderer" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/_internal/renderer/dom/DOMRenderer.hx">
		<extends path="openfl._internal.renderer.AbstractRenderer"/>
		<applyStyle public="1" set="method" line="67" static="1"><f a="displayObject:renderSession:setTransform:setAlpha:setClip">
	<c path="openfl.display.DisplayObject"/>
	<c path="openfl._internal.renderer.RenderSession"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></applyStyle>
		<element><c path="lime.graphics.DOMRenderContext"/></element>
		<render public="1" set="method" line="146" override="1"><f a="stage">
	<c path="openfl.display.Stage"/>
	<x path="Void"/>
</f></render>
		<new public="1" set="method" line="28"><f a="width:height:element">
	<x path="Int"/>
	<x path="Int"/>
	<c path="lime.graphics.DOMRenderContext"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":access"><e>openfl.display.DisplayObject</e></m>
			<m n=":access"><e>openfl.display.Stage</e></m>
			<m n=":access"><e>openfl.geom.Matrix</e></m>
			<m n=":access"><e>openfl.geom.Rectangle</e></m>
		</meta>
	</class>
	<class path="openfl._internal.renderer.dom.DOMShape" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/_internal/renderer/dom/DOMShape.hx">
		<render public="1" get="inline" set="null" line="20" static="1"><f a="shape:renderSession">
	<c path="openfl.display.DisplayObject"/>
	<c path="openfl._internal.renderer.RenderSession"/>
	<x path="Void"/>
</f></render>
		<meta>
			<m n=":access"><e>openfl.display.DisplayObject</e></m>
			<m n=":access"><e>openfl.display.Graphics</e></m>
			<m n=":access"><e>openfl.geom.Matrix</e></m>
		</meta>
	</class>
	<class path="openfl._internal.renderer.dom.DOMTextField" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/_internal/renderer/dom/DOMTextField.hx">
		<measureText public="1" set="method" line="23" static="1"><f a="textField">
	<c path="openfl.text.TextField"/>
	<x path="Void"/>
</f></measureText>
		<render public="1" get="inline" set="null" line="66" static="1"><f a="textField:renderSession">
	<c path="openfl.text.TextField"/>
	<c path="openfl._internal.renderer.RenderSession"/>
	<x path="Void"/>
</f></render>
		<meta>
			<m n=":access"><e>openfl._internal.text.TextEngine</e></m>
			<m n=":access"><e>openfl.text.TextField</e></m>
		</meta>
	</class>
	<class path="openfl._internal.renderer.opengl.GLBitmap" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/_internal/renderer/opengl/GLBitmap.hx">
		<fbData expr="[]" line="26" static="1">
			<c path="Array"><a>
	<viewPort><c path="openfl.geom.Rectangle"/></viewPort>
	<transparent><x path="Bool"/></transparent>
	<texture><c path="openfl._internal.renderer.opengl.utils.PingPongTexture"/></texture>
</a></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</fbData>
		<render public="1" get="inline" set="null" line="28" static="1"><f a="bitmap:renderSession">
	<c path="openfl.display.Bitmap"/>
	<c path="openfl._internal.renderer.RenderSession"/>
	<x path="Void"/>
</f></render>
		<pushFramebuffer public="1" set="method" line="44" static="1">
			<f a="renderSession:texture:viewPort:smoothing:?transparent:?clearBuffer:?powerOfTwo" v="::::true:false:true">
				<c path="openfl._internal.renderer.RenderSession"/>
				<c path="openfl._internal.renderer.opengl.utils.PingPongTexture"/>
				<c path="openfl.geom.Rectangle"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<c path="openfl._internal.renderer.opengl.utils.PingPongTexture"/>
			</f>
			<meta><m n=":value"><e>{ powerOfTwo : true, clearBuffer : false, transparent : true }</e></m></meta>
			<haxe_doc>* Push a texture to render. Binds the framebuffer of that texture.
	 * @param	renderSession
	 * @param	texture
	 * @param	viewPort
	 * @param	smoothing
	 * @param	transparent
	 * @param	clearBuffer</haxe_doc>
		</pushFramebuffer>
		<drawBitmapDrawable public="1" set="method" line="98" static="1">
			<f a="renderSession:target:source:?matrix:?colorTransform:?blendMode:?clipRect">
				<c path="openfl._internal.renderer.RenderSession"/>
				<c path="openfl.display.BitmapData"/>
				<c path="openfl.display.IBitmapDrawable"/>
				<c path="openfl.geom.Matrix"/>
				<c path="openfl.geom.ColorTransform"/>
				<x path="openfl.display.BlendMode"/>
				<c path="openfl.geom.Rectangle"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Render an object to the binded framebuffer
	 * @param	renderSession
	 * @param	self
	 * @param	source
	 * @param	matrix
	 * @param	colorTransform
	 * @param	blendMode
	 * @param	clipRect</haxe_doc>
		</drawBitmapDrawable>
		<popFramebuffer public="1" set="method" line="160" static="1">
			<f a="renderSession:?image">
				<c path="openfl._internal.renderer.RenderSession"/>
				<c path="lime.graphics.Image"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Pop the framebuffer and binds the last framebuffer
	 * @param	renderSession
	 * @param	transparent
	 * @param	image</haxe_doc>
		</popFramebuffer>
		<flipMatrix get="inline" set="null" line="211" static="1"><f a="m:height">
	<c path="openfl.geom.Matrix"/>
	<x path="Float"/>
	<x path="Void"/>
</f></flipMatrix>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":access"><e>openfl.display.Bitmap</e></m>
			<m n=":access"><e>openfl.display.BitmapData</e></m>
			<m n=":access"><e>openfl.display.DisplayObject</e></m>
			<m n=":access"><e>openfl.display.IBitmapDrawable</e></m>
		</meta>
	</class>
	<class path="openfl._internal.renderer.opengl.GLRenderer" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/_internal/renderer/opengl/GLRenderer.hx">
		<extends path="openfl._internal.renderer.AbstractRenderer"/>
		<glContextId public="1" expr="0" line="46" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</glContextId>
		<glContexts public="1" expr="[]" line="47" static="1">
			<c path="Array"><c path="lime.graphics.GLRenderContext"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</glContexts>
		<renderBitmap public="1" set="method" line="308" static="1">
			<f a="shape:renderSession:?smooth" v="::true">
				<c path="openfl.display.DisplayObject"/>
				<c path="openfl._internal.renderer.RenderSession"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ smooth : true }</e></m></meta>
		</renderBitmap>
		<blendModeManager public="1"><c path="openfl._internal.renderer.opengl.utils.BlendModeManager"/></blendModeManager>
		<contextLost public="1"><x path="Bool"/></contextLost>
		<defaultFramebuffer public="1"><c path="lime.graphics.opengl.GLFramebuffer"/></defaultFramebuffer>
		<filterManager public="1"><c path="openfl._internal.renderer.opengl.utils.FilterManager"/></filterManager>
		<gl public="1"><c path="lime.graphics.GLRenderContext"/></gl>
		<_glContextId public="1"><x path="Int"/></_glContextId>
		<maskManager public="1"><c path="openfl._internal.renderer.opengl.utils.GLMaskManager"/></maskManager>
		<offset public="1"><c path="openfl.geom.Point"/></offset>
		<options public="1"><d/></options>
		<preserveDrawingBuffer public="1"><x path="Bool"/></preserveDrawingBuffer>
		<projection public="1"><c path="openfl.geom.Point"/></projection>
		<shaderManager public="1"><c path="openfl._internal.renderer.opengl.utils.ShaderManager"/></shaderManager>
		<spriteBatch public="1"><c path="openfl._internal.renderer.opengl.utils.SpriteBatch"/></spriteBatch>
		<stencilManager public="1"><c path="openfl._internal.renderer.opengl.utils.StencilManager"/></stencilManager>
		<view public="1"><d/></view>
		<projectionMatrix public="1"><c path="openfl.geom.Matrix"/></projectionMatrix>
		<__stage><d/></__stage>
		<vpX expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</vpX>
		<vpY expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</vpY>
		<vpWidth expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</vpWidth>
		<vpHeight expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</vpHeight>
		<destroy public="1" set="method" line="146"><f a=""><x path="Void"/></f></destroy>
		<setViewport public="1" set="method" line="172" override="1"><f a="x:y:width:height">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></setViewport>
		<setOrtho public="1" set="method" line="184"><f a="x:y:width:height">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></setOrtho>
		<handleContextLost set="method" line="217"><f a="event">
	<d/>
	<x path="Void"/>
</f></handleContextLost>
		<handleContextRestored set="method" line="225"><f a=""><x path="Void"/></f></handleContextRestored>
		<render public="1" set="method" line="281" override="1"><f a="stage">
	<c path="openfl.display.Stage"/>
	<x path="Void"/>
</f></render>
		<renderDisplayObject public="1" set="method" line="331">
			<f a="displayObject:projection:?buffer" v="::null">
				<c path="openfl.display.DisplayObject"/>
				<c path="openfl.geom.Point"/>
				<c path="lime.graphics.opengl.GLFramebuffer"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ buffer : null }</e></m></meta>
		</renderDisplayObject>
		<resize public="1" set="method" line="347" override="1"><f a="width:height">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></resize>
		<new public="1" set="method" line="74">
			<f a="?width:?height:gl:?transparent:?antialias:?preserveDrawingBuffer" v="800:600::false:false:false">
				<x path="Int"/>
				<x path="Int"/>
				<c path="lime.graphics.GLRenderContext"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ preserveDrawingBuffer : false, antialias : false, transparent : false, height : 600, width : 800 }</e></m></meta>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":access"><e>lime.graphics.opengl.GL</e></m>
			<m n=":access"><e>openfl.display.Stage</e></m>
			<m n=":access"><e>openfl.display.DisplayObject</e></m>
			<m n=":access"><e>openfl.display.Graphics</e></m>
			<m n=":access"><e>openfl.display.BitmapData</e></m>
			<m n=":access"><e>openfl.geom.Matrix</e></m>
			<m n=":access"><e>openfl.geom.Rectangle</e></m>
		</meta>
	</class>
	<class path="openfl._internal.renderer.opengl.shaders2.Shader" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/_internal/renderer/opengl/shaders2/Shader.hx">
		<UID expr="0" line="22" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</UID>
		<compileProgram public="1" set="method" line="202" static="1"><f a="gl:vertexSrc:fragmentSrc">
	<c path="lime.graphics.GLRenderContext"/>
	<c path="String"/>
	<c path="String"/>
	<t path="openfl.gl.GLProgram"/>
</f></compileProgram>
		<compileShader set="method" line="237" static="1"><f a="gl:shaderSrc:type">
	<c path="lime.graphics.GLRenderContext"/>
	<c path="String"/>
	<x path="Int"/>
	<t path="openfl.gl.GLShader"/>
</f></compileShader>
		<gl public="1"><c path="lime.graphics.GLRenderContext"/></gl>
		<vertexSrc public="1"><c path="Array"><c path="String"/></c></vertexSrc>
		<fragmentSrc public="1"><c path="Array"><c path="String"/></c></fragmentSrc>
		<attributes public="1" expr="new Map()">
			<x path="Map">
				<c path="String"/>
				<x path="Int"/>
			</x>
			<meta><m n=":value"><e>new Map()</e></m></meta>
		</attributes>
		<uniforms public="1" expr="new Map()">
			<x path="Map">
				<c path="String"/>
				<t path="openfl.gl.GLUniformLocation"/>
			</x>
			<meta><m n=":value"><e>new Map()</e></m></meta>
		</uniforms>
		<compiled public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</compiled>
		<ID public="1" set="null"><x path="Int"/></ID>
		<program public="1"><t path="openfl.gl.GLProgram"/></program>
		<wrapS public="1" expr="NONE">
			<x path="openfl.display.RepeatMode"/>
			<meta><m n=":value"><e>NONE</e></m></meta>
		</wrapS>
		<wrapT public="1" expr="NONE">
			<x path="openfl.display.RepeatMode"/>
			<meta><m n=":value"><e>NONE</e></m></meta>
		</wrapT>
		<smooth public="1"><t path="Null"><x path="Bool"/></t></smooth>
		<blendMode public="1"><x path="openfl.display.BlendMode"/></blendMode>
		<vertexString><c path="String"/></vertexString>
		<fragmentString><c path="String"/></fragmentString>
		<init set="method" line="50">
			<f a="?force" v="false">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ force : false }</e></m></meta>
		</init>
		<destroy public="1" set="method" line="71"><f a=""><x path="Void"/></f></destroy>
		<applyData public="1" set="method" line="79"><f a="shaderData:renderSession">
	<t path="openfl.display.GLShaderData"/>
	<c path="openfl._internal.renderer.RenderSession"/>
	<x path="Void"/>
</f></applyData>
		<getAttribLocation public="1" set="method" line="132"><f a="attribute">
	<c path="String"/>
	<x path="Int"/>
</f></getAttribLocation>
		<getUniformLocation public="1" set="method" line="145"><f a="uniform">
	<c path="String"/>
	<t path="openfl.gl.GLUniformLocation"/>
</f></getUniformLocation>
		<enableVertexAttribute public="1" set="method" line="158"><f a="attribute:stride:offset">
	<c path="openfl._internal.renderer.opengl.utils.VertexAttribute"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></enableVertexAttribute>
		<disableVertexAttribute public="1" set="method" line="164">
			<f a="attribute:?setDefault" v=":true">
				<c path="openfl._internal.renderer.opengl.utils.VertexAttribute"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ setDefault : true }</e></m></meta>
		</disableVertexAttribute>
		<bindVertexArray public="1" set="method" line="181"><f a="va">
	<c path="openfl._internal.renderer.opengl.utils.VertexArray"/>
	<x path="Void"/>
</f></bindVertexArray>
		<unbindVertexArray public="1" set="method" line="195"><f a="va">
	<c path="openfl._internal.renderer.opengl.utils.VertexArray"/>
	<x path="Void"/>
</f></unbindVertexArray>
		<new public="1" set="method" line="43"><f a="gl">
	<c path="lime.graphics.GLRenderContext"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":allow"><e>openfl.display.Shader</e></m>
			<m n=":access"><e>openfl._internal.renderer.opengl.utils.ShaderManager</e></m>
		</meta>
	</class>
	<class path="openfl._internal.renderer.opengl.shaders2.DefaultShader" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/_internal/renderer/opengl/shaders2/DefaultShader.hx">
		<extends path="openfl._internal.renderer.opengl.shaders2.Shader"/>
		<VERTEX_SRC public="1" set="null" expr="[&quot;attribute vec2 ${Attrib.Position};&quot;, &quot;attribute vec2 ${Attrib.TexCoord};&quot;, &quot;attribute vec4 ${Attrib.Color};&quot;, &quot;uniform mat3 ${Uniform.ProjectionMatrix};&quot;, &quot;uniform bool ${Uniform.UseColorTransform};&quot;, &quot;varying vec2 ${Varying.TexCoord};&quot;, &quot;varying vec4 ${Varying.Color};&quot;, &quot;void main(void) {&quot;, &quot;   gl_Position = vec4((${Uniform.ProjectionMatrix} * vec3(${Attrib.Position}, 1.0)).xy, 0.0, 1.0);&quot;, &quot;   ${Varying.TexCoord} = ${Attrib.TexCoord};&quot;, &quot;   if(${Uniform.UseColorTransform})&quot;, &quot;   \t${Varying.Color} = ${Attrib.Color};&quot;, &quot;   else&quot;, &quot;   \t${Varying.Color} = vec4(${Attrib.Color}.bgr * ${Attrib.Color}.a, ${Attrib.Color}.a);&quot;, &quot;}&quot;]" line="8" static="1">
			<c path="Array"><c path="String"/></c>
			<meta><m n=":value"><e>["attribute vec2 ${Attrib.Position};", "attribute vec2 ${Attrib.TexCoord};", "attribute vec4 ${Attrib.Color};", "uniform mat3 ${Uniform.ProjectionMatrix};", "uniform bool ${Uniform.UseColorTransform};", "varying vec2 ${Varying.TexCoord};", "varying vec4 ${Varying.Color};", "void main(void) {", "   gl_Position = vec4((${Uniform.ProjectionMatrix} * vec3(${Attrib.Position}, 1.0)).xy, 0.0, 1.0);", "   ${Varying.TexCoord} = ${Attrib.TexCoord};", "   if(${Uniform.UseColorTransform})", "   \t${Varying.Color} = ${Attrib.Color};", "   else", "   \t${Varying.Color} = vec4(${Attrib.Color}.bgr * ${Attrib.Color}.a, ${Attrib.Color}.a);", "}"]</e></m></meta>
		</VERTEX_SRC>
		<init set="method" line="80" override="1">
			<f a="?force" v="false">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ force : false }</e></m></meta>
		</init>
		<new public="1" set="method" line="33"><f a="gl">
	<c path="lime.graphics.GLRenderContext"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<abstract path="openfl._internal.renderer.opengl.shaders2.Attrib" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/_internal/renderer/opengl/shaders2/DefaultShader.hx" module="openfl._internal.renderer.opengl.shaders2.DefaultShader">
		<from><icast><c path="String"/></icast></from>
		<this><c path="String"/></this>
		<to><icast><c path="String"/></icast></to>
		<meta><m n=":enum"/></meta>
		<impl><class path="openfl._internal.renderer.opengl.shaders2._DefaultShader.Attrib_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/_internal/renderer/opengl/shaders2/DefaultShader.hx" private="1" module="openfl._internal.renderer.opengl.shaders2.DefaultShader" extern="1">
	<Position public="1" get="inline" set="null" expr="cast &quot;openfl_aPosition&quot;" line="97" static="1">
		<x path="openfl._internal.renderer.opengl.shaders2.Attrib"/>
		<meta>
			<m n=":value"><e>cast "openfl_aPosition"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Position>
	<TexCoord public="1" get="inline" set="null" expr="cast &quot;openfl_aTexCoord0&quot;" line="98" static="1">
		<x path="openfl._internal.renderer.opengl.shaders2.Attrib"/>
		<meta>
			<m n=":value"><e>cast "openfl_aTexCoord0"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</TexCoord>
	<Color public="1" get="inline" set="null" expr="cast &quot;openfl_aColor&quot;" line="99" static="1">
		<x path="openfl._internal.renderer.opengl.shaders2.Attrib"/>
		<meta>
			<m n=":value"><e>cast "openfl_aColor"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Color>
	<meta>
		<m n=":final"/>
		<m n=":enum"/>
	</meta>
</class></impl>
	</abstract>
	<class path="openfl._internal.renderer.opengl.shaders2._DefaultShader.Attrib_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/_internal/renderer/opengl/shaders2/DefaultShader.hx" private="1" module="openfl._internal.renderer.opengl.shaders2.DefaultShader" extern="1">
		<Position public="1" get="inline" set="null" expr="cast &quot;openfl_aPosition&quot;" line="97" static="1">
			<x path="openfl._internal.renderer.opengl.shaders2.Attrib"/>
			<meta>
				<m n=":value"><e>cast "openfl_aPosition"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Position>
		<TexCoord public="1" get="inline" set="null" expr="cast &quot;openfl_aTexCoord0&quot;" line="98" static="1">
			<x path="openfl._internal.renderer.opengl.shaders2.Attrib"/>
			<meta>
				<m n=":value"><e>cast "openfl_aTexCoord0"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</TexCoord>
		<Color public="1" get="inline" set="null" expr="cast &quot;openfl_aColor&quot;" line="99" static="1">
			<x path="openfl._internal.renderer.opengl.shaders2.Attrib"/>
			<meta>
				<m n=":value"><e>cast "openfl_aColor"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Color>
		<meta>
			<m n=":final"/>
			<m n=":enum"/>
		</meta>
	</class>
	<abstract path="openfl._internal.renderer.opengl.shaders2.Uniform" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/_internal/renderer/opengl/shaders2/DefaultShader.hx" module="openfl._internal.renderer.opengl.shaders2.DefaultShader">
		<from><icast><c path="String"/></icast></from>
		<this><c path="String"/></this>
		<to><icast><c path="String"/></icast></to>
		<meta><m n=":enum"/></meta>
		<impl><class path="openfl._internal.renderer.opengl.shaders2._DefaultShader.Uniform_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/_internal/renderer/opengl/shaders2/DefaultShader.hx" private="1" module="openfl._internal.renderer.opengl.shaders2.DefaultShader" extern="1">
	<Sampler public="1" get="inline" set="null" expr="cast &quot;openfl_uSampler0&quot;" line="103" static="1">
		<x path="openfl._internal.renderer.opengl.shaders2.Uniform"/>
		<meta>
			<m n=":value"><e>cast "openfl_uSampler0"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Sampler>
	<ProjectionMatrix public="1" get="inline" set="null" expr="cast &quot;openfl_uProjectionMatrix&quot;" line="104" static="1">
		<x path="openfl._internal.renderer.opengl.shaders2.Uniform"/>
		<meta>
			<m n=":value"><e>cast "openfl_uProjectionMatrix"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</ProjectionMatrix>
	<Color public="1" get="inline" set="null" expr="cast &quot;openfl_uColor&quot;" line="105" static="1">
		<x path="openfl._internal.renderer.opengl.shaders2.Uniform"/>
		<meta>
			<m n=":value"><e>cast "openfl_uColor"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Color>
	<Alpha public="1" get="inline" set="null" expr="cast &quot;openfl_uAlpha&quot;" line="106" static="1">
		<x path="openfl._internal.renderer.opengl.shaders2.Uniform"/>
		<meta>
			<m n=":value"><e>cast "openfl_uAlpha"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Alpha>
	<ColorMultiplier public="1" get="inline" set="null" expr="cast &quot;openfl_uColorMultiplier&quot;" line="107" static="1">
		<x path="openfl._internal.renderer.opengl.shaders2.Uniform"/>
		<meta>
			<m n=":value"><e>cast "openfl_uColorMultiplier"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</ColorMultiplier>
	<ColorOffset public="1" get="inline" set="null" expr="cast &quot;openfl_uColorOffset&quot;" line="108" static="1">
		<x path="openfl._internal.renderer.opengl.shaders2.Uniform"/>
		<meta>
			<m n=":value"><e>cast "openfl_uColorOffset"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</ColorOffset>
	<UseColorTransform public="1" get="inline" set="null" expr="cast &quot;openfl_uUseColorTransform&quot;" line="109" static="1">
		<x path="openfl._internal.renderer.opengl.shaders2.Uniform"/>
		<meta>
			<m n=":value"><e>cast "openfl_uUseColorTransform"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</UseColorTransform>
	<meta>
		<m n=":final"/>
		<m n=":enum"/>
	</meta>
</class></impl>
	</abstract>
	<class path="openfl._internal.renderer.opengl.shaders2._DefaultShader.Uniform_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/_internal/renderer/opengl/shaders2/DefaultShader.hx" private="1" module="openfl._internal.renderer.opengl.shaders2.DefaultShader" extern="1">
		<Sampler public="1" get="inline" set="null" expr="cast &quot;openfl_uSampler0&quot;" line="103" static="1">
			<x path="openfl._internal.renderer.opengl.shaders2.Uniform"/>
			<meta>
				<m n=":value"><e>cast "openfl_uSampler0"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Sampler>
		<ProjectionMatrix public="1" get="inline" set="null" expr="cast &quot;openfl_uProjectionMatrix&quot;" line="104" static="1">
			<x path="openfl._internal.renderer.opengl.shaders2.Uniform"/>
			<meta>
				<m n=":value"><e>cast "openfl_uProjectionMatrix"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</ProjectionMatrix>
		<Color public="1" get="inline" set="null" expr="cast &quot;openfl_uColor&quot;" line="105" static="1">
			<x path="openfl._internal.renderer.opengl.shaders2.Uniform"/>
			<meta>
				<m n=":value"><e>cast "openfl_uColor"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Color>
		<Alpha public="1" get="inline" set="null" expr="cast &quot;openfl_uAlpha&quot;" line="106" static="1">
			<x path="openfl._internal.renderer.opengl.shaders2.Uniform"/>
			<meta>
				<m n=":value"><e>cast "openfl_uAlpha"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Alpha>
		<ColorMultiplier public="1" get="inline" set="null" expr="cast &quot;openfl_uColorMultiplier&quot;" line="107" static="1">
			<x path="openfl._internal.renderer.opengl.shaders2.Uniform"/>
			<meta>
				<m n=":value"><e>cast "openfl_uColorMultiplier"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</ColorMultiplier>
		<ColorOffset public="1" get="inline" set="null" expr="cast &quot;openfl_uColorOffset&quot;" line="108" static="1">
			<x path="openfl._internal.renderer.opengl.shaders2.Uniform"/>
			<meta>
				<m n=":value"><e>cast "openfl_uColorOffset"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</ColorOffset>
		<UseColorTransform public="1" get="inline" set="null" expr="cast &quot;openfl_uUseColorTransform&quot;" line="109" static="1">
			<x path="openfl._internal.renderer.opengl.shaders2.Uniform"/>
			<meta>
				<m n=":value"><e>cast "openfl_uUseColorTransform"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</UseColorTransform>
		<meta>
			<m n=":final"/>
			<m n=":enum"/>
		</meta>
	</class>
	<abstract path="openfl._internal.renderer.opengl.shaders2.Varying" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/_internal/renderer/opengl/shaders2/DefaultShader.hx" module="openfl._internal.renderer.opengl.shaders2.DefaultShader">
		<from><icast><c path="String"/></icast></from>
		<this><c path="String"/></this>
		<to><icast><c path="String"/></icast></to>
		<meta><m n=":enum"/></meta>
		<impl><class path="openfl._internal.renderer.opengl.shaders2._DefaultShader.Varying_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/_internal/renderer/opengl/shaders2/DefaultShader.hx" private="1" module="openfl._internal.renderer.opengl.shaders2.DefaultShader" extern="1">
	<TexCoord public="1" get="inline" set="null" expr="cast &quot;openfl_vTexCoord&quot;" line="113" static="1">
		<x path="openfl._internal.renderer.opengl.shaders2.Varying"/>
		<meta>
			<m n=":value"><e>cast "openfl_vTexCoord"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</TexCoord>
	<Color public="1" get="inline" set="null" expr="cast &quot;openfl_vColor&quot;" line="114" static="1">
		<x path="openfl._internal.renderer.opengl.shaders2.Varying"/>
		<meta>
			<m n=":value"><e>cast "openfl_vColor"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Color>
	<meta>
		<m n=":final"/>
		<m n=":enum"/>
	</meta>
</class></impl>
	</abstract>
	<class path="openfl._internal.renderer.opengl.shaders2._DefaultShader.Varying_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/_internal/renderer/opengl/shaders2/DefaultShader.hx" private="1" module="openfl._internal.renderer.opengl.shaders2.DefaultShader" extern="1">
		<TexCoord public="1" get="inline" set="null" expr="cast &quot;openfl_vTexCoord&quot;" line="113" static="1">
			<x path="openfl._internal.renderer.opengl.shaders2.Varying"/>
			<meta>
				<m n=":value"><e>cast "openfl_vTexCoord"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</TexCoord>
		<Color public="1" get="inline" set="null" expr="cast &quot;openfl_vColor&quot;" line="114" static="1">
			<x path="openfl._internal.renderer.opengl.shaders2.Varying"/>
			<meta>
				<m n=":value"><e>cast "openfl_vColor"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Color>
		<meta>
			<m n=":final"/>
			<m n=":enum"/>
		</meta>
	</class>
	<typedef path="openfl._internal.renderer.opengl.shaders2.DefAttrib" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/_internal/renderer/opengl/shaders2/DefaultShader.hx" module="openfl._internal.renderer.opengl.shaders2.DefaultShader"><x path="openfl._internal.renderer.opengl.shaders2.Attrib"/></typedef>
	<typedef path="openfl._internal.renderer.opengl.shaders2.DefUniform" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/_internal/renderer/opengl/shaders2/DefaultShader.hx" module="openfl._internal.renderer.opengl.shaders2.DefaultShader"><x path="openfl._internal.renderer.opengl.shaders2.Uniform"/></typedef>
	<typedef path="openfl._internal.renderer.opengl.shaders2.DefVarying" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/_internal/renderer/opengl/shaders2/DefaultShader.hx" module="openfl._internal.renderer.opengl.shaders2.DefaultShader"><x path="openfl._internal.renderer.opengl.shaders2.Varying"/></typedef>
	<class path="openfl._internal.renderer.opengl.shaders2.DrawTrianglesShader" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/_internal/renderer/opengl/shaders2/DrawTrianglesShader.hx">
		<extends path="openfl._internal.renderer.opengl.shaders2.Shader"/>
		<init set="method" line="70" override="1">
			<f a="?force" v="false">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ force : false }</e></m></meta>
		</init>
		<new public="1" set="method" line="10"><f a="gl">
	<c path="lime.graphics.GLRenderContext"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<abstract path="openfl._internal.renderer.opengl.shaders2._DrawTrianglesShader.Attrib" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/_internal/renderer/opengl/shaders2/DrawTrianglesShader.hx" private="1" module="openfl._internal.renderer.opengl.shaders2.DrawTrianglesShader">
		<from><icast><c path="String"/></icast></from>
		<this><c path="String"/></this>
		<to><icast><c path="String"/></icast></to>
		<meta><m n=":enum"/></meta>
		<impl><class path="openfl._internal.renderer.opengl.shaders2._DrawTrianglesShader.Attrib_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/_internal/renderer/opengl/shaders2/DrawTrianglesShader.hx" private="1" module="openfl._internal.renderer.opengl.shaders2.DrawTrianglesShader" extern="1">
	<Position public="1" get="inline" set="null" expr="cast DefAttrib.Position" line="90" static="1">
		<x path="openfl._internal.renderer.opengl.shaders2._DrawTrianglesShader.Attrib"/>
		<meta>
			<m n=":value"><e>cast DefAttrib.Position</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Position>
	<TexCoord public="1" get="inline" set="null" expr="cast DefAttrib.TexCoord" line="91" static="1">
		<x path="openfl._internal.renderer.opengl.shaders2._DrawTrianglesShader.Attrib"/>
		<meta>
			<m n=":value"><e>cast DefAttrib.TexCoord</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</TexCoord>
	<Color public="1" get="inline" set="null" expr="cast DefAttrib.Color" line="92" static="1">
		<x path="openfl._internal.renderer.opengl.shaders2._DrawTrianglesShader.Attrib"/>
		<meta>
			<m n=":value"><e>cast DefAttrib.Color</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Color>
	<meta>
		<m n=":final"/>
		<m n=":enum"/>
	</meta>
</class></impl>
	</abstract>
	<class path="openfl._internal.renderer.opengl.shaders2._DrawTrianglesShader.Attrib_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/_internal/renderer/opengl/shaders2/DrawTrianglesShader.hx" private="1" module="openfl._internal.renderer.opengl.shaders2.DrawTrianglesShader" extern="1">
		<Position public="1" get="inline" set="null" expr="cast DefAttrib.Position" line="90" static="1">
			<x path="openfl._internal.renderer.opengl.shaders2._DrawTrianglesShader.Attrib"/>
			<meta>
				<m n=":value"><e>cast DefAttrib.Position</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Position>
		<TexCoord public="1" get="inline" set="null" expr="cast DefAttrib.TexCoord" line="91" static="1">
			<x path="openfl._internal.renderer.opengl.shaders2._DrawTrianglesShader.Attrib"/>
			<meta>
				<m n=":value"><e>cast DefAttrib.TexCoord</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</TexCoord>
		<Color public="1" get="inline" set="null" expr="cast DefAttrib.Color" line="92" static="1">
			<x path="openfl._internal.renderer.opengl.shaders2._DrawTrianglesShader.Attrib"/>
			<meta>
				<m n=":value"><e>cast DefAttrib.Color</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Color>
		<meta>
			<m n=":final"/>
			<m n=":enum"/>
		</meta>
	</class>
	<abstract path="openfl._internal.renderer.opengl.shaders2._DrawTrianglesShader.Uniform" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/_internal/renderer/opengl/shaders2/DrawTrianglesShader.hx" private="1" module="openfl._internal.renderer.opengl.shaders2.DrawTrianglesShader">
		<from><icast><c path="String"/></icast></from>
		<this><c path="String"/></this>
		<to><icast><c path="String"/></icast></to>
		<meta><m n=":enum"/></meta>
		<impl><class path="openfl._internal.renderer.opengl.shaders2._DrawTrianglesShader.Uniform_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/_internal/renderer/opengl/shaders2/DrawTrianglesShader.hx" private="1" module="openfl._internal.renderer.opengl.shaders2.DrawTrianglesShader" extern="1">
	<UseTexture public="1" get="inline" set="null" expr="cast &quot;openfl_uUseTexture&quot;" line="96" static="1">
		<x path="openfl._internal.renderer.opengl.shaders2._DrawTrianglesShader.Uniform"/>
		<meta>
			<m n=":value"><e>cast "openfl_uUseTexture"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</UseTexture>
	<Sampler public="1" get="inline" set="null" expr="cast DefUniform.Sampler" line="97" static="1">
		<x path="openfl._internal.renderer.opengl.shaders2._DrawTrianglesShader.Uniform"/>
		<meta>
			<m n=":value"><e>cast DefUniform.Sampler</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Sampler>
	<ProjectionMatrix public="1" get="inline" set="null" expr="cast DefUniform.ProjectionMatrix" line="98" static="1">
		<x path="openfl._internal.renderer.opengl.shaders2._DrawTrianglesShader.Uniform"/>
		<meta>
			<m n=":value"><e>cast DefUniform.ProjectionMatrix</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</ProjectionMatrix>
	<Color public="1" get="inline" set="null" expr="cast DefUniform.Color" line="99" static="1">
		<x path="openfl._internal.renderer.opengl.shaders2._DrawTrianglesShader.Uniform"/>
		<meta>
			<m n=":value"><e>cast DefUniform.Color</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Color>
	<Alpha public="1" get="inline" set="null" expr="cast DefUniform.Alpha" line="100" static="1">
		<x path="openfl._internal.renderer.opengl.shaders2._DrawTrianglesShader.Uniform"/>
		<meta>
			<m n=":value"><e>cast DefUniform.Alpha</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Alpha>
	<ColorMultiplier public="1" get="inline" set="null" expr="cast DefUniform.ColorMultiplier" line="101" static="1">
		<x path="openfl._internal.renderer.opengl.shaders2._DrawTrianglesShader.Uniform"/>
		<meta>
			<m n=":value"><e>cast DefUniform.ColorMultiplier</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</ColorMultiplier>
	<ColorOffset public="1" get="inline" set="null" expr="cast DefUniform.ColorOffset" line="102" static="1">
		<x path="openfl._internal.renderer.opengl.shaders2._DrawTrianglesShader.Uniform"/>
		<meta>
			<m n=":value"><e>cast DefUniform.ColorOffset</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</ColorOffset>
	<meta>
		<m n=":final"/>
		<m n=":enum"/>
	</meta>
</class></impl>
	</abstract>
	<class path="openfl._internal.renderer.opengl.shaders2._DrawTrianglesShader.Uniform_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/_internal/renderer/opengl/shaders2/DrawTrianglesShader.hx" private="1" module="openfl._internal.renderer.opengl.shaders2.DrawTrianglesShader" extern="1">
		<UseTexture public="1" get="inline" set="null" expr="cast &quot;openfl_uUseTexture&quot;" line="96" static="1">
			<x path="openfl._internal.renderer.opengl.shaders2._DrawTrianglesShader.Uniform"/>
			<meta>
				<m n=":value"><e>cast "openfl_uUseTexture"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</UseTexture>
		<Sampler public="1" get="inline" set="null" expr="cast DefUniform.Sampler" line="97" static="1">
			<x path="openfl._internal.renderer.opengl.shaders2._DrawTrianglesShader.Uniform"/>
			<meta>
				<m n=":value"><e>cast DefUniform.Sampler</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Sampler>
		<ProjectionMatrix public="1" get="inline" set="null" expr="cast DefUniform.ProjectionMatrix" line="98" static="1">
			<x path="openfl._internal.renderer.opengl.shaders2._DrawTrianglesShader.Uniform"/>
			<meta>
				<m n=":value"><e>cast DefUniform.ProjectionMatrix</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</ProjectionMatrix>
		<Color public="1" get="inline" set="null" expr="cast DefUniform.Color" line="99" static="1">
			<x path="openfl._internal.renderer.opengl.shaders2._DrawTrianglesShader.Uniform"/>
			<meta>
				<m n=":value"><e>cast DefUniform.Color</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Color>
		<Alpha public="1" get="inline" set="null" expr="cast DefUniform.Alpha" line="100" static="1">
			<x path="openfl._internal.renderer.opengl.shaders2._DrawTrianglesShader.Uniform"/>
			<meta>
				<m n=":value"><e>cast DefUniform.Alpha</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Alpha>
		<ColorMultiplier public="1" get="inline" set="null" expr="cast DefUniform.ColorMultiplier" line="101" static="1">
			<x path="openfl._internal.renderer.opengl.shaders2._DrawTrianglesShader.Uniform"/>
			<meta>
				<m n=":value"><e>cast DefUniform.ColorMultiplier</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</ColorMultiplier>
		<ColorOffset public="1" get="inline" set="null" expr="cast DefUniform.ColorOffset" line="102" static="1">
			<x path="openfl._internal.renderer.opengl.shaders2._DrawTrianglesShader.Uniform"/>
			<meta>
				<m n=":value"><e>cast DefUniform.ColorOffset</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</ColorOffset>
		<meta>
			<m n=":final"/>
			<m n=":enum"/>
		</meta>
	</class>
	<typedef path="openfl._internal.renderer.opengl.shaders2.DrawTrianglesAttrib" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/_internal/renderer/opengl/shaders2/DrawTrianglesShader.hx" module="openfl._internal.renderer.opengl.shaders2.DrawTrianglesShader"><x path="openfl._internal.renderer.opengl.shaders2._DrawTrianglesShader.Attrib"/></typedef>
	<typedef path="openfl._internal.renderer.opengl.shaders2.DrawTrianglesUniform" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/_internal/renderer/opengl/shaders2/DrawTrianglesShader.hx" module="openfl._internal.renderer.opengl.shaders2.DrawTrianglesShader"><x path="openfl._internal.renderer.opengl.shaders2._DrawTrianglesShader.Uniform"/></typedef>
	<class path="openfl._internal.renderer.opengl.shaders2.FillShader" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/_internal/renderer/opengl/shaders2/FillShader.hx">
		<extends path="openfl._internal.renderer.opengl.shaders2.Shader"/>
		<init set="method" line="55" override="1">
			<f a="?force" v="false">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ force : false }</e></m></meta>
		</init>
		<new public="1" set="method" line="9"><f a="gl">
	<c path="lime.graphics.GLRenderContext"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<abstract path="openfl._internal.renderer.opengl.shaders2._FillShader.Attrib" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/_internal/renderer/opengl/shaders2/FillShader.hx" private="1" module="openfl._internal.renderer.opengl.shaders2.FillShader">
		<from><icast><c path="String"/></icast></from>
		<this><c path="String"/></this>
		<to><icast><c path="String"/></icast></to>
		<meta><m n=":enum"/></meta>
		<impl><class path="openfl._internal.renderer.opengl.shaders2._FillShader.Attrib_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/_internal/renderer/opengl/shaders2/FillShader.hx" private="1" module="openfl._internal.renderer.opengl.shaders2.FillShader" extern="1">
	<Position public="1" get="inline" set="null" expr="cast DefAttrib.Position" line="69" static="1">
		<x path="openfl._internal.renderer.opengl.shaders2._FillShader.Attrib"/>
		<meta>
			<m n=":value"><e>cast DefAttrib.Position</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Position>
	<meta>
		<m n=":final"/>
		<m n=":enum"/>
	</meta>
</class></impl>
	</abstract>
	<class path="openfl._internal.renderer.opengl.shaders2._FillShader.Attrib_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/_internal/renderer/opengl/shaders2/FillShader.hx" private="1" module="openfl._internal.renderer.opengl.shaders2.FillShader" extern="1">
		<Position public="1" get="inline" set="null" expr="cast DefAttrib.Position" line="69" static="1">
			<x path="openfl._internal.renderer.opengl.shaders2._FillShader.Attrib"/>
			<meta>
				<m n=":value"><e>cast DefAttrib.Position</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Position>
		<meta>
			<m n=":final"/>
			<m n=":enum"/>
		</meta>
	</class>
	<abstract path="openfl._internal.renderer.opengl.shaders2._FillShader.Uniform" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/_internal/renderer/opengl/shaders2/FillShader.hx" private="1" module="openfl._internal.renderer.opengl.shaders2.FillShader">
		<from><icast><c path="String"/></icast></from>
		<this><c path="String"/></this>
		<to><icast><c path="String"/></icast></to>
		<meta><m n=":enum"/></meta>
		<impl><class path="openfl._internal.renderer.opengl.shaders2._FillShader.Uniform_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/_internal/renderer/opengl/shaders2/FillShader.hx" private="1" module="openfl._internal.renderer.opengl.shaders2.FillShader" extern="1">
	<TranslationMatrix public="1" get="inline" set="null" expr="cast &quot;openfl_uTranslationMatrix&quot;" line="73" static="1">
		<x path="openfl._internal.renderer.opengl.shaders2._FillShader.Uniform"/>
		<meta>
			<m n=":value"><e>cast "openfl_uTranslationMatrix"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</TranslationMatrix>
	<ProjectionMatrix public="1" get="inline" set="null" expr="cast DefUniform.ProjectionMatrix" line="74" static="1">
		<x path="openfl._internal.renderer.opengl.shaders2._FillShader.Uniform"/>
		<meta>
			<m n=":value"><e>cast DefUniform.ProjectionMatrix</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</ProjectionMatrix>
	<Color public="1" get="inline" set="null" expr="cast DefUniform.Color" line="75" static="1">
		<x path="openfl._internal.renderer.opengl.shaders2._FillShader.Uniform"/>
		<meta>
			<m n=":value"><e>cast DefUniform.Color</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Color>
	<Alpha public="1" get="inline" set="null" expr="cast DefUniform.Alpha" line="76" static="1">
		<x path="openfl._internal.renderer.opengl.shaders2._FillShader.Uniform"/>
		<meta>
			<m n=":value"><e>cast DefUniform.Alpha</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Alpha>
	<ColorMultiplier public="1" get="inline" set="null" expr="cast DefUniform.ColorMultiplier" line="77" static="1">
		<x path="openfl._internal.renderer.opengl.shaders2._FillShader.Uniform"/>
		<meta>
			<m n=":value"><e>cast DefUniform.ColorMultiplier</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</ColorMultiplier>
	<ColorOffset public="1" get="inline" set="null" expr="cast DefUniform.ColorOffset" line="78" static="1">
		<x path="openfl._internal.renderer.opengl.shaders2._FillShader.Uniform"/>
		<meta>
			<m n=":value"><e>cast DefUniform.ColorOffset</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</ColorOffset>
	<meta>
		<m n=":final"/>
		<m n=":enum"/>
	</meta>
</class></impl>
	</abstract>
	<class path="openfl._internal.renderer.opengl.shaders2._FillShader.Uniform_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/_internal/renderer/opengl/shaders2/FillShader.hx" private="1" module="openfl._internal.renderer.opengl.shaders2.FillShader" extern="1">
		<TranslationMatrix public="1" get="inline" set="null" expr="cast &quot;openfl_uTranslationMatrix&quot;" line="73" static="1">
			<x path="openfl._internal.renderer.opengl.shaders2._FillShader.Uniform"/>
			<meta>
				<m n=":value"><e>cast "openfl_uTranslationMatrix"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</TranslationMatrix>
		<ProjectionMatrix public="1" get="inline" set="null" expr="cast DefUniform.ProjectionMatrix" line="74" static="1">
			<x path="openfl._internal.renderer.opengl.shaders2._FillShader.Uniform"/>
			<meta>
				<m n=":value"><e>cast DefUniform.ProjectionMatrix</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</ProjectionMatrix>
		<Color public="1" get="inline" set="null" expr="cast DefUniform.Color" line="75" static="1">
			<x path="openfl._internal.renderer.opengl.shaders2._FillShader.Uniform"/>
			<meta>
				<m n=":value"><e>cast DefUniform.Color</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Color>
		<Alpha public="1" get="inline" set="null" expr="cast DefUniform.Alpha" line="76" static="1">
			<x path="openfl._internal.renderer.opengl.shaders2._FillShader.Uniform"/>
			<meta>
				<m n=":value"><e>cast DefUniform.Alpha</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Alpha>
		<ColorMultiplier public="1" get="inline" set="null" expr="cast DefUniform.ColorMultiplier" line="77" static="1">
			<x path="openfl._internal.renderer.opengl.shaders2._FillShader.Uniform"/>
			<meta>
				<m n=":value"><e>cast DefUniform.ColorMultiplier</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</ColorMultiplier>
		<ColorOffset public="1" get="inline" set="null" expr="cast DefUniform.ColorOffset" line="78" static="1">
			<x path="openfl._internal.renderer.opengl.shaders2._FillShader.Uniform"/>
			<meta>
				<m n=":value"><e>cast DefUniform.ColorOffset</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</ColorOffset>
		<meta>
			<m n=":final"/>
			<m n=":enum"/>
		</meta>
	</class>
	<typedef path="openfl._internal.renderer.opengl.shaders2.FillAttrib" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/_internal/renderer/opengl/shaders2/FillShader.hx" module="openfl._internal.renderer.opengl.shaders2.FillShader"><x path="openfl._internal.renderer.opengl.shaders2._FillShader.Attrib"/></typedef>
	<typedef path="openfl._internal.renderer.opengl.shaders2.FillUniform" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/_internal/renderer/opengl/shaders2/FillShader.hx" module="openfl._internal.renderer.opengl.shaders2.FillShader"><x path="openfl._internal.renderer.opengl.shaders2._FillShader.Uniform"/></typedef>
	<class path="openfl._internal.renderer.opengl.shaders2.PatternFillShader" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/_internal/renderer/opengl/shaders2/PatternFillShader.hx">
		<extends path="openfl._internal.renderer.opengl.shaders2.Shader"/>
		<init set="method" line="62" override="1">
			<f a="?force" v="false">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ force : false }</e></m></meta>
		</init>
		<new public="1" set="method" line="9"><f a="gl">
	<c path="lime.graphics.GLRenderContext"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<abstract path="openfl._internal.renderer.opengl.shaders2._PatternFillShader.Attrib" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/_internal/renderer/opengl/shaders2/PatternFillShader.hx" private="1" module="openfl._internal.renderer.opengl.shaders2.PatternFillShader">
		<from><icast><c path="String"/></icast></from>
		<this><c path="String"/></this>
		<to><icast><c path="String"/></icast></to>
		<meta><m n=":enum"/></meta>
		<impl><class path="openfl._internal.renderer.opengl.shaders2._PatternFillShader.Attrib_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/_internal/renderer/opengl/shaders2/PatternFillShader.hx" private="1" module="openfl._internal.renderer.opengl.shaders2.PatternFillShader" extern="1">
	<Position public="1" get="inline" set="null" expr="cast DefAttrib.Position" line="81" static="1">
		<x path="openfl._internal.renderer.opengl.shaders2._PatternFillShader.Attrib"/>
		<meta>
			<m n=":value"><e>cast DefAttrib.Position</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Position>
	<meta>
		<m n=":final"/>
		<m n=":enum"/>
	</meta>
</class></impl>
	</abstract>
	<class path="openfl._internal.renderer.opengl.shaders2._PatternFillShader.Attrib_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/_internal/renderer/opengl/shaders2/PatternFillShader.hx" private="1" module="openfl._internal.renderer.opengl.shaders2.PatternFillShader" extern="1">
		<Position public="1" get="inline" set="null" expr="cast DefAttrib.Position" line="81" static="1">
			<x path="openfl._internal.renderer.opengl.shaders2._PatternFillShader.Attrib"/>
			<meta>
				<m n=":value"><e>cast DefAttrib.Position</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Position>
		<meta>
			<m n=":final"/>
			<m n=":enum"/>
		</meta>
	</class>
	<abstract path="openfl._internal.renderer.opengl.shaders2._PatternFillShader.Uniform" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/_internal/renderer/opengl/shaders2/PatternFillShader.hx" private="1" module="openfl._internal.renderer.opengl.shaders2.PatternFillShader">
		<from><icast><c path="String"/></icast></from>
		<this><c path="String"/></this>
		<to><icast><c path="String"/></icast></to>
		<meta><m n=":enum"/></meta>
		<impl><class path="openfl._internal.renderer.opengl.shaders2._PatternFillShader.Uniform_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/_internal/renderer/opengl/shaders2/PatternFillShader.hx" private="1" module="openfl._internal.renderer.opengl.shaders2.PatternFillShader" extern="1">
	<TranslationMatrix public="1" get="inline" set="null" expr="cast &quot;openfl_uTranslationMatrix&quot;" line="85" static="1">
		<x path="openfl._internal.renderer.opengl.shaders2._PatternFillShader.Uniform"/>
		<meta>
			<m n=":value"><e>cast "openfl_uTranslationMatrix"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</TranslationMatrix>
	<PatternMatrix public="1" get="inline" set="null" expr="cast &quot;openfl_uPatternMatrix&quot;" line="86" static="1">
		<x path="openfl._internal.renderer.opengl.shaders2._PatternFillShader.Uniform"/>
		<meta>
			<m n=":value"><e>cast "openfl_uPatternMatrix"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</PatternMatrix>
	<PatternTL public="1" get="inline" set="null" expr="cast &quot;openfl_uPatternTL&quot;" line="87" static="1">
		<x path="openfl._internal.renderer.opengl.shaders2._PatternFillShader.Uniform"/>
		<meta>
			<m n=":value"><e>cast "openfl_uPatternTL"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</PatternTL>
	<PatternBR public="1" get="inline" set="null" expr="cast &quot;openfl_uPatternBR&quot;" line="88" static="1">
		<x path="openfl._internal.renderer.opengl.shaders2._PatternFillShader.Uniform"/>
		<meta>
			<m n=":value"><e>cast "openfl_uPatternBR"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</PatternBR>
	<Sampler public="1" get="inline" set="null" expr="cast DefUniform.Sampler" line="89" static="1">
		<x path="openfl._internal.renderer.opengl.shaders2._PatternFillShader.Uniform"/>
		<meta>
			<m n=":value"><e>cast DefUniform.Sampler</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Sampler>
	<ProjectionMatrix public="1" get="inline" set="null" expr="cast DefUniform.ProjectionMatrix" line="90" static="1">
		<x path="openfl._internal.renderer.opengl.shaders2._PatternFillShader.Uniform"/>
		<meta>
			<m n=":value"><e>cast DefUniform.ProjectionMatrix</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</ProjectionMatrix>
	<Color public="1" get="inline" set="null" expr="cast DefUniform.Color" line="91" static="1">
		<x path="openfl._internal.renderer.opengl.shaders2._PatternFillShader.Uniform"/>
		<meta>
			<m n=":value"><e>cast DefUniform.Color</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Color>
	<Alpha public="1" get="inline" set="null" expr="cast DefUniform.Alpha" line="92" static="1">
		<x path="openfl._internal.renderer.opengl.shaders2._PatternFillShader.Uniform"/>
		<meta>
			<m n=":value"><e>cast DefUniform.Alpha</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Alpha>
	<ColorMultiplier public="1" get="inline" set="null" expr="cast DefUniform.ColorMultiplier" line="93" static="1">
		<x path="openfl._internal.renderer.opengl.shaders2._PatternFillShader.Uniform"/>
		<meta>
			<m n=":value"><e>cast DefUniform.ColorMultiplier</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</ColorMultiplier>
	<ColorOffset public="1" get="inline" set="null" expr="cast DefUniform.ColorOffset" line="94" static="1">
		<x path="openfl._internal.renderer.opengl.shaders2._PatternFillShader.Uniform"/>
		<meta>
			<m n=":value"><e>cast DefUniform.ColorOffset</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</ColorOffset>
	<meta>
		<m n=":final"/>
		<m n=":enum"/>
	</meta>
</class></impl>
	</abstract>
	<class path="openfl._internal.renderer.opengl.shaders2._PatternFillShader.Uniform_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/_internal/renderer/opengl/shaders2/PatternFillShader.hx" private="1" module="openfl._internal.renderer.opengl.shaders2.PatternFillShader" extern="1">
		<TranslationMatrix public="1" get="inline" set="null" expr="cast &quot;openfl_uTranslationMatrix&quot;" line="85" static="1">
			<x path="openfl._internal.renderer.opengl.shaders2._PatternFillShader.Uniform"/>
			<meta>
				<m n=":value"><e>cast "openfl_uTranslationMatrix"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</TranslationMatrix>
		<PatternMatrix public="1" get="inline" set="null" expr="cast &quot;openfl_uPatternMatrix&quot;" line="86" static="1">
			<x path="openfl._internal.renderer.opengl.shaders2._PatternFillShader.Uniform"/>
			<meta>
				<m n=":value"><e>cast "openfl_uPatternMatrix"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</PatternMatrix>
		<PatternTL public="1" get="inline" set="null" expr="cast &quot;openfl_uPatternTL&quot;" line="87" static="1">
			<x path="openfl._internal.renderer.opengl.shaders2._PatternFillShader.Uniform"/>
			<meta>
				<m n=":value"><e>cast "openfl_uPatternTL"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</PatternTL>
		<PatternBR public="1" get="inline" set="null" expr="cast &quot;openfl_uPatternBR&quot;" line="88" static="1">
			<x path="openfl._internal.renderer.opengl.shaders2._PatternFillShader.Uniform"/>
			<meta>
				<m n=":value"><e>cast "openfl_uPatternBR"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</PatternBR>
		<Sampler public="1" get="inline" set="null" expr="cast DefUniform.Sampler" line="89" static="1">
			<x path="openfl._internal.renderer.opengl.shaders2._PatternFillShader.Uniform"/>
			<meta>
				<m n=":value"><e>cast DefUniform.Sampler</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Sampler>
		<ProjectionMatrix public="1" get="inline" set="null" expr="cast DefUniform.ProjectionMatrix" line="90" static="1">
			<x path="openfl._internal.renderer.opengl.shaders2._PatternFillShader.Uniform"/>
			<meta>
				<m n=":value"><e>cast DefUniform.ProjectionMatrix</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</ProjectionMatrix>
		<Color public="1" get="inline" set="null" expr="cast DefUniform.Color" line="91" static="1">
			<x path="openfl._internal.renderer.opengl.shaders2._PatternFillShader.Uniform"/>
			<meta>
				<m n=":value"><e>cast DefUniform.Color</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Color>
		<Alpha public="1" get="inline" set="null" expr="cast DefUniform.Alpha" line="92" static="1">
			<x path="openfl._internal.renderer.opengl.shaders2._PatternFillShader.Uniform"/>
			<meta>
				<m n=":value"><e>cast DefUniform.Alpha</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Alpha>
		<ColorMultiplier public="1" get="inline" set="null" expr="cast DefUniform.ColorMultiplier" line="93" static="1">
			<x path="openfl._internal.renderer.opengl.shaders2._PatternFillShader.Uniform"/>
			<meta>
				<m n=":value"><e>cast DefUniform.ColorMultiplier</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</ColorMultiplier>
		<ColorOffset public="1" get="inline" set="null" expr="cast DefUniform.ColorOffset" line="94" static="1">
			<x path="openfl._internal.renderer.opengl.shaders2._PatternFillShader.Uniform"/>
			<meta>
				<m n=":value"><e>cast DefUniform.ColorOffset</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</ColorOffset>
		<meta>
			<m n=":final"/>
			<m n=":enum"/>
		</meta>
	</class>
	<typedef path="openfl._internal.renderer.opengl.shaders2.PatternFillAttrib" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/_internal/renderer/opengl/shaders2/PatternFillShader.hx" module="openfl._internal.renderer.opengl.shaders2.PatternFillShader"><x path="openfl._internal.renderer.opengl.shaders2._PatternFillShader.Attrib"/></typedef>
	<typedef path="openfl._internal.renderer.opengl.shaders2.PatternFillUniform" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/_internal/renderer/opengl/shaders2/PatternFillShader.hx" module="openfl._internal.renderer.opengl.shaders2.PatternFillShader"><x path="openfl._internal.renderer.opengl.shaders2._PatternFillShader.Uniform"/></typedef>
	<class path="openfl._internal.renderer.opengl.shaders2.PrimitiveShader" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/_internal/renderer/opengl/shaders2/PrimitiveShader.hx">
		<extends path="openfl._internal.renderer.opengl.shaders2.Shader"/>
		<init set="method" line="54" override="1">
			<f a="?force" v="false">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ force : false }</e></m></meta>
		</init>
		<new public="1" set="method" line="9"><f a="gl">
	<c path="lime.graphics.GLRenderContext"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<abstract path="openfl._internal.renderer.opengl.shaders2._PrimitiveShader.Attrib" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/_internal/renderer/opengl/shaders2/PrimitiveShader.hx" private="1" module="openfl._internal.renderer.opengl.shaders2.PrimitiveShader">
		<from><icast><c path="String"/></icast></from>
		<this><c path="String"/></this>
		<to><icast><c path="String"/></icast></to>
		<meta><m n=":enum"/></meta>
		<impl><class path="openfl._internal.renderer.opengl.shaders2._PrimitiveShader.Attrib_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/_internal/renderer/opengl/shaders2/PrimitiveShader.hx" private="1" module="openfl._internal.renderer.opengl.shaders2.PrimitiveShader" extern="1">
	<Position public="1" get="inline" set="null" expr="cast DefAttrib.Position" line="69" static="1">
		<x path="openfl._internal.renderer.opengl.shaders2._PrimitiveShader.Attrib"/>
		<meta>
			<m n=":value"><e>cast DefAttrib.Position</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Position>
	<Color public="1" get="inline" set="null" expr="cast DefAttrib.Color" line="70" static="1">
		<x path="openfl._internal.renderer.opengl.shaders2._PrimitiveShader.Attrib"/>
		<meta>
			<m n=":value"><e>cast DefAttrib.Color</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Color>
	<meta>
		<m n=":final"/>
		<m n=":enum"/>
	</meta>
</class></impl>
	</abstract>
	<class path="openfl._internal.renderer.opengl.shaders2._PrimitiveShader.Attrib_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/_internal/renderer/opengl/shaders2/PrimitiveShader.hx" private="1" module="openfl._internal.renderer.opengl.shaders2.PrimitiveShader" extern="1">
		<Position public="1" get="inline" set="null" expr="cast DefAttrib.Position" line="69" static="1">
			<x path="openfl._internal.renderer.opengl.shaders2._PrimitiveShader.Attrib"/>
			<meta>
				<m n=":value"><e>cast DefAttrib.Position</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Position>
		<Color public="1" get="inline" set="null" expr="cast DefAttrib.Color" line="70" static="1">
			<x path="openfl._internal.renderer.opengl.shaders2._PrimitiveShader.Attrib"/>
			<meta>
				<m n=":value"><e>cast DefAttrib.Color</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Color>
		<meta>
			<m n=":final"/>
			<m n=":enum"/>
		</meta>
	</class>
	<abstract path="openfl._internal.renderer.opengl.shaders2._PrimitiveShader.Uniform" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/_internal/renderer/opengl/shaders2/PrimitiveShader.hx" private="1" module="openfl._internal.renderer.opengl.shaders2.PrimitiveShader">
		<from><icast><c path="String"/></icast></from>
		<this><c path="String"/></this>
		<to><icast><c path="String"/></icast></to>
		<meta><m n=":enum"/></meta>
		<impl><class path="openfl._internal.renderer.opengl.shaders2._PrimitiveShader.Uniform_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/_internal/renderer/opengl/shaders2/PrimitiveShader.hx" private="1" module="openfl._internal.renderer.opengl.shaders2.PrimitiveShader" extern="1">
	<TranslationMatrix public="1" get="inline" set="null" expr="cast &quot;openfl_uTranslationMatrix&quot;" line="74" static="1">
		<x path="openfl._internal.renderer.opengl.shaders2._PrimitiveShader.Uniform"/>
		<meta>
			<m n=":value"><e>cast "openfl_uTranslationMatrix"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</TranslationMatrix>
	<ProjectionMatrix public="1" get="inline" set="null" expr="cast DefUniform.ProjectionMatrix" line="75" static="1">
		<x path="openfl._internal.renderer.opengl.shaders2._PrimitiveShader.Uniform"/>
		<meta>
			<m n=":value"><e>cast DefUniform.ProjectionMatrix</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</ProjectionMatrix>
	<Alpha public="1" get="inline" set="null" expr="cast DefUniform.Alpha" line="76" static="1">
		<x path="openfl._internal.renderer.opengl.shaders2._PrimitiveShader.Uniform"/>
		<meta>
			<m n=":value"><e>cast DefUniform.Alpha</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Alpha>
	<ColorMultiplier public="1" get="inline" set="null" expr="cast DefUniform.ColorMultiplier" line="77" static="1">
		<x path="openfl._internal.renderer.opengl.shaders2._PrimitiveShader.Uniform"/>
		<meta>
			<m n=":value"><e>cast DefUniform.ColorMultiplier</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</ColorMultiplier>
	<ColorOffset public="1" get="inline" set="null" expr="cast DefUniform.ColorOffset" line="78" static="1">
		<x path="openfl._internal.renderer.opengl.shaders2._PrimitiveShader.Uniform"/>
		<meta>
			<m n=":value"><e>cast DefUniform.ColorOffset</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</ColorOffset>
	<meta>
		<m n=":final"/>
		<m n=":enum"/>
	</meta>
</class></impl>
	</abstract>
	<class path="openfl._internal.renderer.opengl.shaders2._PrimitiveShader.Uniform_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/_internal/renderer/opengl/shaders2/PrimitiveShader.hx" private="1" module="openfl._internal.renderer.opengl.shaders2.PrimitiveShader" extern="1">
		<TranslationMatrix public="1" get="inline" set="null" expr="cast &quot;openfl_uTranslationMatrix&quot;" line="74" static="1">
			<x path="openfl._internal.renderer.opengl.shaders2._PrimitiveShader.Uniform"/>
			<meta>
				<m n=":value"><e>cast "openfl_uTranslationMatrix"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</TranslationMatrix>
		<ProjectionMatrix public="1" get="inline" set="null" expr="cast DefUniform.ProjectionMatrix" line="75" static="1">
			<x path="openfl._internal.renderer.opengl.shaders2._PrimitiveShader.Uniform"/>
			<meta>
				<m n=":value"><e>cast DefUniform.ProjectionMatrix</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</ProjectionMatrix>
		<Alpha public="1" get="inline" set="null" expr="cast DefUniform.Alpha" line="76" static="1">
			<x path="openfl._internal.renderer.opengl.shaders2._PrimitiveShader.Uniform"/>
			<meta>
				<m n=":value"><e>cast DefUniform.Alpha</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Alpha>
		<ColorMultiplier public="1" get="inline" set="null" expr="cast DefUniform.ColorMultiplier" line="77" static="1">
			<x path="openfl._internal.renderer.opengl.shaders2._PrimitiveShader.Uniform"/>
			<meta>
				<m n=":value"><e>cast DefUniform.ColorMultiplier</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</ColorMultiplier>
		<ColorOffset public="1" get="inline" set="null" expr="cast DefUniform.ColorOffset" line="78" static="1">
			<x path="openfl._internal.renderer.opengl.shaders2._PrimitiveShader.Uniform"/>
			<meta>
				<m n=":value"><e>cast DefUniform.ColorOffset</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</ColorOffset>
		<meta>
			<m n=":final"/>
			<m n=":enum"/>
		</meta>
	</class>
	<typedef path="openfl._internal.renderer.opengl.shaders2.PrimitiveAttrib" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/_internal/renderer/opengl/shaders2/PrimitiveShader.hx" module="openfl._internal.renderer.opengl.shaders2.PrimitiveShader"><x path="openfl._internal.renderer.opengl.shaders2._PrimitiveShader.Attrib"/></typedef>
	<typedef path="openfl._internal.renderer.opengl.shaders2.PrimitiveUniform" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/_internal/renderer/opengl/shaders2/PrimitiveShader.hx" module="openfl._internal.renderer.opengl.shaders2.PrimitiveShader"><x path="openfl._internal.renderer.opengl.shaders2._PrimitiveShader.Uniform"/></typedef>
	<class path="openfl._internal.renderer.opengl.utils.BlendModeManager" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/_internal/renderer/opengl/utils/BlendModeManager.hx">
		<currentBlendMode public="1"><x path="openfl.display.BlendMode"/></currentBlendMode>
		<gl public="1"><c path="lime.graphics.GLRenderContext"/></gl>
		<destroy public="1" set="method" line="23"><f a=""><x path="Void"/></f></destroy>
		<setBlendMode public="1" set="method" line="30">
			<f a="blendMode:?force" v=":false">
				<x path="openfl.display.BlendMode"/>
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":value"><e>{ force : false }</e></m></meta>
		</setBlendMode>
		<new public="1" set="method" line="15"><f a="gl">
	<c path="lime.graphics.GLRenderContext"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<typedef path="openfl._internal.renderer.opengl.utils.GLBlendMode" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/_internal/renderer/opengl/utils/BlendModeManager.hx" module="openfl._internal.renderer.opengl.utils.BlendModeManager"><a>
	<src><x path="openfl._internal.renderer.opengl.utils.GLBlendFunction"/></src>
	<func><x path="openfl._internal.renderer.opengl.utils.GLBlendEquation"/></func>
	<dest><x path="openfl._internal.renderer.opengl.utils.GLBlendFunction"/></dest>
</a></typedef>
	<abstract path="openfl._internal.renderer.opengl.utils.GLBlendEquation" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/_internal/renderer/opengl/utils/BlendModeManager.hx" module="openfl._internal.renderer.opengl.utils.BlendModeManager">
		<from><icast><x path="Int"/></icast></from>
		<this><x path="Int"/></this>
		<to><icast><x path="Int"/></icast></to>
		<meta><m n=":enum"/></meta>
		<impl><class path="openfl._internal.renderer.opengl.utils._BlendModeManager.GLBlendEquation_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/_internal/renderer/opengl/utils/BlendModeManager.hx" private="1" module="openfl._internal.renderer.opengl.utils.BlendModeManager" extern="1">
	<ADD public="1" get="inline" set="null" expr="cast GL.FUNC_ADD" line="100" static="1">
		<x path="openfl._internal.renderer.opengl.utils.GLBlendEquation"/>
		<meta>
			<m n=":value"><e>cast GL.FUNC_ADD</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</ADD>
	<SUBTRACT public="1" get="inline" set="null" expr="cast GL.FUNC_SUBTRACT" line="101" static="1">
		<x path="openfl._internal.renderer.opengl.utils.GLBlendEquation"/>
		<meta>
			<m n=":value"><e>cast GL.FUNC_SUBTRACT</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</SUBTRACT>
	<REVERSE_SUBTRACT public="1" get="inline" set="null" expr="cast GL.FUNC_REVERSE_SUBTRACT" line="102" static="1">
		<x path="openfl._internal.renderer.opengl.utils.GLBlendEquation"/>
		<meta>
			<m n=":value"><e>cast GL.FUNC_REVERSE_SUBTRACT</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</REVERSE_SUBTRACT>
	<meta>
		<m n=":final"/>
		<m n=":enum"/>
	</meta>
</class></impl>
	</abstract>
	<class path="openfl._internal.renderer.opengl.utils._BlendModeManager.GLBlendEquation_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/_internal/renderer/opengl/utils/BlendModeManager.hx" private="1" module="openfl._internal.renderer.opengl.utils.BlendModeManager" extern="1">
		<ADD public="1" get="inline" set="null" expr="cast GL.FUNC_ADD" line="100" static="1">
			<x path="openfl._internal.renderer.opengl.utils.GLBlendEquation"/>
			<meta>
				<m n=":value"><e>cast GL.FUNC_ADD</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</ADD>
		<SUBTRACT public="1" get="inline" set="null" expr="cast GL.FUNC_SUBTRACT" line="101" static="1">
			<x path="openfl._internal.renderer.opengl.utils.GLBlendEquation"/>
			<meta>
				<m n=":value"><e>cast GL.FUNC_SUBTRACT</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</SUBTRACT>
		<REVERSE_SUBTRACT public="1" get="inline" set="null" expr="cast GL.FUNC_REVERSE_SUBTRACT" line="102" static="1">
			<x path="openfl._internal.renderer.opengl.utils.GLBlendEquation"/>
			<meta>
				<m n=":value"><e>cast GL.FUNC_REVERSE_SUBTRACT</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</REVERSE_SUBTRACT>
		<meta>
			<m n=":final"/>
			<m n=":enum"/>
		</meta>
	</class>
	<abstract path="openfl._internal.renderer.opengl.utils.GLBlendFunction" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/_internal/renderer/opengl/utils/BlendModeManager.hx" module="openfl._internal.renderer.opengl.utils.BlendModeManager">
		<from><icast><x path="Int"/></icast></from>
		<this><x path="Int"/></this>
		<to><icast><x path="Int"/></icast></to>
		<meta><m n=":enum"/></meta>
		<impl><class path="openfl._internal.renderer.opengl.utils._BlendModeManager.GLBlendFunction_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/_internal/renderer/opengl/utils/BlendModeManager.hx" private="1" module="openfl._internal.renderer.opengl.utils.BlendModeManager" extern="1">
	<ZERO public="1" get="inline" set="null" expr="cast GL.ZERO" line="107" static="1">
		<x path="openfl._internal.renderer.opengl.utils.GLBlendFunction"/>
		<meta>
			<m n=":value"><e>cast GL.ZERO</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</ZERO>
	<ONE public="1" get="inline" set="null" expr="cast GL.ONE" line="108" static="1">
		<x path="openfl._internal.renderer.opengl.utils.GLBlendFunction"/>
		<meta>
			<m n=":value"><e>cast GL.ONE</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</ONE>
	<SRC_COLOR public="1" get="inline" set="null" expr="cast GL.SRC_COLOR" line="109" static="1">
		<x path="openfl._internal.renderer.opengl.utils.GLBlendFunction"/>
		<meta>
			<m n=":value"><e>cast GL.SRC_COLOR</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</SRC_COLOR>
	<DST_COLOR public="1" get="inline" set="null" expr="cast GL.DST_COLOR" line="110" static="1">
		<x path="openfl._internal.renderer.opengl.utils.GLBlendFunction"/>
		<meta>
			<m n=":value"><e>cast GL.DST_COLOR</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</DST_COLOR>
	<ONE_MINUS_SRC_COLOR public="1" get="inline" set="null" expr="cast GL.ONE_MINUS_SRC_COLOR" line="111" static="1">
		<x path="openfl._internal.renderer.opengl.utils.GLBlendFunction"/>
		<meta>
			<m n=":value"><e>cast GL.ONE_MINUS_SRC_COLOR</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</ONE_MINUS_SRC_COLOR>
	<ONE_MINUS_DST_COLOR public="1" get="inline" set="null" expr="cast GL.ONE_MINUS_DST_COLOR" line="112" static="1">
		<x path="openfl._internal.renderer.opengl.utils.GLBlendFunction"/>
		<meta>
			<m n=":value"><e>cast GL.ONE_MINUS_DST_COLOR</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</ONE_MINUS_DST_COLOR>
	<CONSTANT_COLOR public="1" get="inline" set="null" expr="cast GL.CONSTANT_COLOR" line="113" static="1">
		<x path="openfl._internal.renderer.opengl.utils.GLBlendFunction"/>
		<meta>
			<m n=":value"><e>cast GL.CONSTANT_COLOR</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</CONSTANT_COLOR>
	<ONE_MINUS_CONSTANT_COLOR public="1" get="inline" set="null" expr="cast GL.ONE_MINUS_CONSTANT_COLOR" line="114" static="1">
		<x path="openfl._internal.renderer.opengl.utils.GLBlendFunction"/>
		<meta>
			<m n=":value"><e>cast GL.ONE_MINUS_CONSTANT_COLOR</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</ONE_MINUS_CONSTANT_COLOR>
	<SRC_ALPHA public="1" get="inline" set="null" expr="cast GL.SRC_ALPHA" line="115" static="1">
		<x path="openfl._internal.renderer.opengl.utils.GLBlendFunction"/>
		<meta>
			<m n=":value"><e>cast GL.SRC_ALPHA</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</SRC_ALPHA>
	<DST_ALPHA public="1" get="inline" set="null" expr="cast GL.DST_ALPHA" line="116" static="1">
		<x path="openfl._internal.renderer.opengl.utils.GLBlendFunction"/>
		<meta>
			<m n=":value"><e>cast GL.DST_ALPHA</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</DST_ALPHA>
	<ONE_MINUS_SRC_ALPHA public="1" get="inline" set="null" expr="cast GL.ONE_MINUS_SRC_ALPHA" line="117" static="1">
		<x path="openfl._internal.renderer.opengl.utils.GLBlendFunction"/>
		<meta>
			<m n=":value"><e>cast GL.ONE_MINUS_SRC_ALPHA</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</ONE_MINUS_SRC_ALPHA>
	<ONE_MINUS_DST_ALPHA public="1" get="inline" set="null" expr="cast GL.ONE_MINUS_DST_ALPHA" line="118" static="1">
		<x path="openfl._internal.renderer.opengl.utils.GLBlendFunction"/>
		<meta>
			<m n=":value"><e>cast GL.ONE_MINUS_DST_ALPHA</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</ONE_MINUS_DST_ALPHA>
	<CONSTANT_ALPHA public="1" get="inline" set="null" expr="cast GL.CONSTANT_ALPHA" line="119" static="1">
		<x path="openfl._internal.renderer.opengl.utils.GLBlendFunction"/>
		<meta>
			<m n=":value"><e>cast GL.CONSTANT_ALPHA</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</CONSTANT_ALPHA>
	<ONE_MINUS_CONSTANT_ALPHA public="1" get="inline" set="null" expr="cast GL.ONE_MINUS_CONSTANT_ALPHA" line="120" static="1">
		<x path="openfl._internal.renderer.opengl.utils.GLBlendFunction"/>
		<meta>
			<m n=":value"><e>cast GL.ONE_MINUS_CONSTANT_ALPHA</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</ONE_MINUS_CONSTANT_ALPHA>
	<SRC_ALPHA_SATURATE public="1" get="inline" set="null" expr="cast GL.SRC_ALPHA_SATURATE" line="121" static="1">
		<x path="openfl._internal.renderer.opengl.utils.GLBlendFunction"/>
		<meta>
			<m n=":value"><e>cast GL.SRC_ALPHA_SATURATE</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</SRC_ALPHA_SATURATE>
	<meta>
		<m n=":final"/>
		<m n=":enum"/>
	</meta>
</class></impl>
	</abstract>
	<class path="openfl._internal.renderer.opengl.utils._BlendModeManager.GLBlendFunction_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/_internal/renderer/opengl/utils/BlendModeManager.hx" private="1" module="openfl._internal.renderer.opengl.utils.BlendModeManager" extern="1">
		<ZERO public="1" get="inline" set="null" expr="cast GL.ZERO" line="107" static="1">
			<x path="openfl._internal.renderer.opengl.utils.GLBlendFunction"/>
			<meta>
				<m n=":value"><e>cast GL.ZERO</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</ZERO>
		<ONE public="1" get="inline" set="null" expr="cast GL.ONE" line="108" static="1">
			<x path="openfl._internal.renderer.opengl.utils.GLBlendFunction"/>
			<meta>
				<m n=":value"><e>cast GL.ONE</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</ONE>
		<SRC_COLOR public="1" get="inline" set="null" expr="cast GL.SRC_COLOR" line="109" static="1">
			<x path="openfl._internal.renderer.opengl.utils.GLBlendFunction"/>
			<meta>
				<m n=":value"><e>cast GL.SRC_COLOR</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</SRC_COLOR>
		<DST_COLOR public="1" get="inline" set="null" expr="cast GL.DST_COLOR" line="110" static="1">
			<x path="openfl._internal.renderer.opengl.utils.GLBlendFunction"/>
			<meta>
				<m n=":value"><e>cast GL.DST_COLOR</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</DST_COLOR>
		<ONE_MINUS_SRC_COLOR public="1" get="inline" set="null" expr="cast GL.ONE_MINUS_SRC_COLOR" line="111" static="1">
			<x path="openfl._internal.renderer.opengl.utils.GLBlendFunction"/>
			<meta>
				<m n=":value"><e>cast GL.ONE_MINUS_SRC_COLOR</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</ONE_MINUS_SRC_COLOR>
		<ONE_MINUS_DST_COLOR public="1" get="inline" set="null" expr="cast GL.ONE_MINUS_DST_COLOR" line="112" static="1">
			<x path="openfl._internal.renderer.opengl.utils.GLBlendFunction"/>
			<meta>
				<m n=":value"><e>cast GL.ONE_MINUS_DST_COLOR</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</ONE_MINUS_DST_COLOR>
		<CONSTANT_COLOR public="1" get="inline" set="null" expr="cast GL.CONSTANT_COLOR" line="113" static="1">
			<x path="openfl._internal.renderer.opengl.utils.GLBlendFunction"/>
			<meta>
				<m n=":value"><e>cast GL.CONSTANT_COLOR</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</CONSTANT_COLOR>
		<ONE_MINUS_CONSTANT_COLOR public="1" get="inline" set="null" expr="cast GL.ONE_MINUS_CONSTANT_COLOR" line="114" static="1">
			<x path="openfl._internal.renderer.opengl.utils.GLBlendFunction"/>
			<meta>
				<m n=":value"><e>cast GL.ONE_MINUS_CONSTANT_COLOR</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</ONE_MINUS_CONSTANT_COLOR>
		<SRC_ALPHA public="1" get="inline" set="null" expr="cast GL.SRC_ALPHA" line="115" static="1">
			<x path="openfl._internal.renderer.opengl.utils.GLBlendFunction"/>
			<meta>
				<m n=":value"><e>cast GL.SRC_ALPHA</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</SRC_ALPHA>
		<DST_ALPHA public="1" get="inline" set="null" expr="cast GL.DST_ALPHA" line="116" static="1">
			<x path="openfl._internal.renderer.opengl.utils.GLBlendFunction"/>
			<meta>
				<m n=":value"><e>cast GL.DST_ALPHA</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</DST_ALPHA>
		<ONE_MINUS_SRC_ALPHA public="1" get="inline" set="null" expr="cast GL.ONE_MINUS_SRC_ALPHA" line="117" static="1">
			<x path="openfl._internal.renderer.opengl.utils.GLBlendFunction"/>
			<meta>
				<m n=":value"><e>cast GL.ONE_MINUS_SRC_ALPHA</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</ONE_MINUS_SRC_ALPHA>
		<ONE_MINUS_DST_ALPHA public="1" get="inline" set="null" expr="cast GL.ONE_MINUS_DST_ALPHA" line="118" static="1">
			<x path="openfl._internal.renderer.opengl.utils.GLBlendFunction"/>
			<meta>
				<m n=":value"><e>cast GL.ONE_MINUS_DST_ALPHA</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</ONE_MINUS_DST_ALPHA>
		<CONSTANT_ALPHA public="1" get="inline" set="null" expr="cast GL.CONSTANT_ALPHA" line="119" static="1">
			<x path="openfl._internal.renderer.opengl.utils.GLBlendFunction"/>
			<meta>
				<m n=":value"><e>cast GL.CONSTANT_ALPHA</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</CONSTANT_ALPHA>
		<ONE_MINUS_CONSTANT_ALPHA public="1" get="inline" set="null" expr="cast GL.ONE_MINUS_CONSTANT_ALPHA" line="120" static="1">
			<x path="openfl._internal.renderer.opengl.utils.GLBlendFunction"/>
			<meta>
				<m n=":value"><e>cast GL.ONE_MINUS_CONSTANT_ALPHA</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</ONE_MINUS_CONSTANT_ALPHA>
		<SRC_ALPHA_SATURATE public="1" get="inline" set="null" expr="cast GL.SRC_ALPHA_SATURATE" line="121" static="1">
			<x path="openfl._internal.renderer.opengl.utils.GLBlendFunction"/>
			<meta>
				<m n=":value"><e>cast GL.SRC_ALPHA_SATURATE</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</SRC_ALPHA_SATURATE>
		<meta>
			<m n=":final"/>
			<m n=":enum"/>
		</meta>
	</class>
	<class path="openfl._internal.renderer.opengl.utils.DrawPath" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/_internal/renderer/opengl/utils/DrawPath.hx">
		<getStack public="1" set="method" line="66" static="1"><f a="graphics:gl">
	<c path="openfl.display.Graphics"/>
	<c path="lime.graphics.GLRenderContext"/>
	<c path="openfl._internal.renderer.opengl.utils.GLStack"/>
</f></getStack>
		<line public="1"><c path="openfl._internal.renderer.opengl.utils.LineStyle"/></line>
		<fill public="1"><e path="openfl._internal.renderer.opengl.utils.FillType"/></fill>
		<fillIndex public="1" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</fillIndex>
		<isRemovable public="1" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</isRemovable>
		<winding public="1" expr="WindingRule.EVEN_ODD">
			<x path="openfl._internal.renderer.opengl.utils.WindingRule"/>
			<meta><m n=":value"><e>WindingRule.EVEN_ODD</e></m></meta>
		</winding>
		<points public="1" expr="null">
			<c path="Array"><x path="Float"/></c>
			<meta><m n=":value"><e>null</e></m></meta>
		</points>
		<type public="1" expr="Polygon">
			<e path="openfl._internal.renderer.opengl.utils.GraphicType"/>
			<meta><m n=":value"><e>Polygon</e></m></meta>
		</type>
		<update public="1" set="method" line="49"><f a="line:fill:fillIndex:winding">
	<c path="openfl._internal.renderer.opengl.utils.LineStyle"/>
	<e path="openfl._internal.renderer.opengl.utils.FillType"/>
	<x path="Int"/>
	<x path="openfl._internal.renderer.opengl.utils.WindingRule"/>
	<x path="Void"/>
</f></update>
		<updateLine public="1" set="method" line="56"><f a="line">
	<c path="openfl._internal.renderer.opengl.utils.LineStyle"/>
	<x path="Void"/>
</f></updateLine>
		<new public="1" set="method" line="40">
			<f a="?makeArray" v="true">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ makeArray : true }</e></m></meta>
		</new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="openfl._internal.renderer.opengl.utils.PathBuiler" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/_internal/renderer/opengl/utils/DrawPath.hx" module="openfl._internal.renderer.opengl.utils.DrawPath">
		<__currentPath static="1"><c path="openfl._internal.renderer.opengl.utils.DrawPath"/></__currentPath>
		<__currentWinding expr="WindingRule.EVEN_ODD" line="77" static="1">
			<x path="openfl._internal.renderer.opengl.utils.WindingRule"/>
			<meta><m n=":value"><e>WindingRule.EVEN_ODD</e></m></meta>
		</__currentWinding>
		<__drawPaths static="1"><c path="Array"><c path="openfl._internal.renderer.opengl.utils.DrawPath"/></c></__drawPaths>
		<__line static="1"><c path="openfl._internal.renderer.opengl.utils.LineStyle"/></__line>
		<__fill static="1"><e path="openfl._internal.renderer.opengl.utils.FillType"/></__fill>
		<__fillIndex expr="0" line="81" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</__fillIndex>
		<closePath set="method" line="83" static="1"><f a=""><x path="Void"/></f></closePath>
		<endFill set="method" line="99" static="1"><f a=""><x path="Void"/></f></endFill>
		<moveTo get="inline" set="null" line="106" static="1"><f a="x:y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></moveTo>
		<lineTo get="inline" set="null" line="119" static="1"><f a="x:y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></lineTo>
		<curveTo get="inline" set="null" line="138" static="1"><f a="cx:cy:x:y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></curveTo>
		<cubicCurveTo get="inline" set="null" line="148" static="1"><f a="cx:cy:cx2:cy2:x:y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></cubicCurveTo>
		<graphicDataPop get="inline" set="null" line="158" static="1"><f a=""><x path="Void"/></f></graphicDataPop>
		<build public="1" set="method" line="168" static="1"><f a="graphics:gl">
	<c path="openfl.display.Graphics"/>
	<c path="lime.graphics.GLRenderContext"/>
	<c path="openfl._internal.renderer.opengl.utils.GLStack"/>
</f></build>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":access"><e>openfl._internal.renderer.opengl.utils.GraphicsRenderer</e></m>
			<m n=":access"><e>openfl.display.Graphics</e></m>
		</meta>
	</class>
	<class path="openfl._internal.renderer.opengl.utils.LineStyle" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/_internal/renderer/opengl/utils/DrawPath.hx" module="openfl._internal.renderer.opengl.utils.DrawPath">
		<width public="1"><x path="Float"/></width>
		<color public="1"><x path="Int"/></color>
		<alpha public="1"><t path="Null"><x path="Float"/></t></alpha>
		<scaleMode public="1"><x path="openfl.display.LineScaleMode"/></scaleMode>
		<caps public="1"><x path="openfl.display.CapsStyle"/></caps>
		<joints public="1"><x path="openfl.display.JointStyle"/></joints>
		<miterLimit public="1"><x path="Float"/></miterLimit>
		<new public="1" set="method" line="515"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<abstract path="openfl._internal.renderer.opengl.utils.WindingRule" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/_internal/renderer/opengl/utils/DrawPath.hx" module="openfl._internal.renderer.opengl.utils.DrawPath">
		<this><x path="Int"/></this>
		<meta><m n=":enum"/></meta>
		<impl><class path="openfl._internal.renderer.opengl.utils._DrawPath.WindingRule_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/_internal/renderer/opengl/utils/DrawPath.hx" private="1" module="openfl._internal.renderer.opengl.utils.DrawPath" extern="1">
	<EVEN_ODD public="1" get="inline" set="null" expr="cast 0" line="528" static="1">
		<x path="openfl._internal.renderer.opengl.utils.WindingRule"/>
		<meta>
			<m n=":value"><e>cast 0</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</EVEN_ODD>
	<NON_ZERO public="1" get="inline" set="null" expr="cast 1" line="529" static="1">
		<x path="openfl._internal.renderer.opengl.utils.WindingRule"/>
		<meta>
			<m n=":value"><e>cast 1</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NON_ZERO>
	<meta>
		<m n=":final"/>
		<m n=":enum"/>
	</meta>
</class></impl>
	</abstract>
	<class path="openfl._internal.renderer.opengl.utils._DrawPath.WindingRule_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/_internal/renderer/opengl/utils/DrawPath.hx" private="1" module="openfl._internal.renderer.opengl.utils.DrawPath" extern="1">
		<EVEN_ODD public="1" get="inline" set="null" expr="cast 0" line="528" static="1">
			<x path="openfl._internal.renderer.opengl.utils.WindingRule"/>
			<meta>
				<m n=":value"><e>cast 0</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</EVEN_ODD>
		<NON_ZERO public="1" get="inline" set="null" expr="cast 1" line="529" static="1">
			<x path="openfl._internal.renderer.opengl.utils.WindingRule"/>
			<meta>
				<m n=":value"><e>cast 1</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NON_ZERO>
		<meta>
			<m n=":final"/>
			<m n=":enum"/>
		</meta>
	</class>
	<enum path="openfl._internal.renderer.opengl.utils.FillType" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/_internal/renderer/opengl/utils/DrawPath.hx" module="openfl._internal.renderer.opengl.utils.DrawPath">
		<None/>
		<Color a="color:alpha">
			<x path="Int"/>
			<x path="Float"/>
		</Color>
		<Texture a="bitmap:matrix:repeat:smooth">
			<c path="openfl.display.BitmapData"/>
			<c path="openfl.geom.Matrix"/>
			<x path="Bool"/>
			<x path="Bool"/>
		</Texture>
		<Gradient/>
		<meta><m n=":directlyUsed"/></meta>
	</enum>
	<class path="openfl._internal.renderer.opengl.utils.FilterManager" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/_internal/renderer/opengl/utils/FilterManager.hx">
		<buffer public="1"><c path="lime.graphics.opengl.GLFramebuffer"/></buffer>
		<colorArray public="1"><x path="lime.utils.Float32Array"/></colorArray>
		<colorBuffer public="1"><c path="lime.graphics.opengl.GLBuffer"/></colorBuffer>
		<defaultShader public="1"><c path="openfl._internal.renderer.opengl.shaders2.DefaultShader"/></defaultShader>
		<filterStack public="1"><c path="Array"><d/></c></filterStack>
		<gl public="1"><c path="lime.graphics.GLRenderContext"/></gl>
		<height public="1"><x path="Int"/></height>
		<indexBuffer public="1"><c path="lime.graphics.opengl.GLBuffer"/></indexBuffer>
		<offsetX public="1"><x path="Float"/></offsetX>
		<offsetY public="1"><x path="Float"/></offsetY>
		<renderSession public="1"><c path="openfl._internal.renderer.RenderSession"/></renderSession>
		<texturePool public="1"><c path="Array"><c path="openfl._internal.renderer.opengl.utils.RenderTexture"/></c></texturePool>
		<transparent public="1"><x path="Bool"/></transparent>
		<uvArray public="1"><x path="lime.utils.Float32Array"/></uvArray>
		<uvBuffer public="1"><c path="lime.graphics.opengl.GLBuffer"/></uvBuffer>
		<vertexArray public="1"><x path="lime.utils.Float32Array"/></vertexArray>
		<vertexBuffer public="1"><c path="lime.graphics.opengl.GLBuffer"/></vertexBuffer>
		<width public="1"><x path="Int"/></width>
		<applyFilterPass public="1" set="method" line="51"><f a="filter:filterArea:width:height">
	<d/>
	<c path="openfl.geom.Rectangle"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></applyFilterPass>
		<begin public="1" set="method" line="102">
			<f a="renderSession:?buffer" v=":null">
				<c path="openfl._internal.renderer.RenderSession"/>
				<c path="lime.graphics.opengl.GLFramebuffer"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ buffer : null }</e></m></meta>
		</begin>
		<destroy public="1" set="method" line="115"><f a=""><x path="Void"/></f></destroy>
		<initShaderBuffers public="1" set="method" line="140"><f a=""><x path="Void"/></f></initShaderBuffers>
		<popFilter public="1" set="method" line="170"><f a=""><x path="Void"/></f></popFilter>
		<pushFilter public="1" set="method" line="329"><f a="filterBlock">
	<d/>
	<x path="Void"/>
</f></pushFilter>
		<setContext public="1" set="method" line="405"><f a="gl">
	<c path="lime.graphics.GLRenderContext"/>
	<x path="Void"/>
</f></setContext>
		<new public="1" set="method" line="37"><f a="gl:transparent">
	<c path="lime.graphics.GLRenderContext"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="openfl._internal.renderer.opengl.utils.GLMaskManager" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/_internal/renderer/opengl/utils/GLMaskManager.hx">
		<extends path="openfl._internal.renderer.AbstractMaskManager"/>
		<gl public="1"><c path="lime.graphics.GLRenderContext"/></gl>
		<clips><c path="Array"><c path="openfl.geom.Rectangle"/></c></clips>
		<currentClip><c path="openfl.geom.Rectangle"/></currentClip>
		<savedClip><c path="openfl.geom.Rectangle"/></savedClip>
		<destroy public="1" set="method" line="33"><f a=""><x path="Void"/></f></destroy>
		<pushRect public="1" set="method" line="40" override="1"><f a="rect:transform">
	<c path="openfl.geom.Rectangle"/>
	<c path="openfl.geom.Matrix"/>
	<x path="Void"/>
</f></pushRect>
		<pushMask public="1" set="method" line="71" override="1"><f a="mask">
	<c path="openfl.display.DisplayObject"/>
	<x path="Void"/>
</f></pushMask>
		<popMask public="1" set="method" line="80" override="1"><f a=""><x path="Void"/></f></popMask>
		<popRect public="1" set="method" line="88" override="1"><f a=""><x path="Void"/></f></popRect>
		<saveState public="1" set="method" line="99" override="1"><f a=""><x path="Void"/></f></saveState>
		<restoreState public="1" set="method" line="106" override="1"><f a=""><x path="Void"/></f></restoreState>
		<setContext public="1" set="method" line="114"><f a="gl">
	<c path="lime.graphics.GLRenderContext"/>
	<x path="Void"/>
</f></setContext>
		<new public="1" set="method" line="22"><f a="renderSession">
	<c path="openfl._internal.renderer.RenderSession"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="openfl._internal.renderer.opengl.utils.VertexAttribute" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/_internal/renderer/opengl/utils/VertexAttribute.hx">
		<components public="1"><x path="Int"/></components>
		<normalized public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</normalized>
		<type public="1"><x path="openfl._internal.renderer.opengl.utils.ElementType"/></type>
		<name public="1"><c path="String"/></name>
		<enabled public="1" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</enabled>
		<elements public="1" get="accessor" set="null"><x path="Int"/></elements>
		<defaultValue public="1"><t path="openfl.utils.Float32Array"/></defaultValue>
		<copy public="1" set="method" line="33"><f a=""><c path="openfl._internal.renderer.opengl.utils.VertexAttribute"/></f></copy>
		<getElementsBytes get="inline" set="null" line="37"><f a=""><x path="Int"/></f></getElementsBytes>
		<get_elements get="inline" set="null" line="45"><f a=""><x path="Int"/></f></get_elements>
		<new public="1" set="method" line="19">
			<f a="components:type:?normalized:name:?defaultValue" v="::false::">
				<x path="Int"/>
				<x path="openfl._internal.renderer.opengl.utils.ElementType"/>
				<x path="Bool"/>
				<c path="String"/>
				<t path="openfl.utils.Float32Array"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ normalized : false }</e></m></meta>
		</new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="openfl._internal.renderer.opengl.utils.GraphicsRenderer" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/_internal/renderer/opengl/utils/GraphicsRenderer.hx">
		<fillVertexAttributes public="1" expr="[new VertexAttribute(2, ElementType.FLOAT, false, FillAttrib.Position)]" line="50" static="1">
			<c path="Array"><c path="openfl._internal.renderer.opengl.utils.VertexAttribute"/></c>
			<meta><m n=":value"><e>[new VertexAttribute(2, ElementType.FLOAT, false, FillAttrib.Position)]</e></m></meta>
		</fillVertexAttributes>
		<drawTrianglesVertexAttributes public="1" expr="[new VertexAttribute(2, ElementType.FLOAT, false, DrawTrianglesAttrib.Position), new VertexAttribute(2, ElementType.FLOAT, false, DrawTrianglesAttrib.TexCoord), new VertexAttribute(4, ElementType.UNSIGNED_BYTE, true, DrawTrianglesAttrib.Color)]" line="53" static="1">
			<c path="Array"><c path="openfl._internal.renderer.opengl.utils.VertexAttribute"/></c>
			<meta><m n=":value"><e>[new VertexAttribute(2, ElementType.FLOAT, false, DrawTrianglesAttrib.Position), new VertexAttribute(2, ElementType.FLOAT, false, DrawTrianglesAttrib.TexCoord), new VertexAttribute(4, ElementType.UNSIGNED_BYTE, true, DrawTrianglesAttrib.Color)]</e></m></meta>
		</drawTrianglesVertexAttributes>
		<primitiveVertexAttributes public="1" expr="[new VertexAttribute(2, ElementType.FLOAT, false, PrimitiveAttrib.Position), new VertexAttribute(4, ElementType.FLOAT, false, PrimitiveAttrib.Color)]" line="58" static="1">
			<c path="Array"><c path="openfl._internal.renderer.opengl.utils.VertexAttribute"/></c>
			<meta><m n=":value"><e>[new VertexAttribute(2, ElementType.FLOAT, false, PrimitiveAttrib.Position), new VertexAttribute(4, ElementType.FLOAT, false, PrimitiveAttrib.Color)]</e></m></meta>
		</primitiveVertexAttributes>
		<graphicsDataPool public="1" expr="[]" line="63" static="1">
			<c path="Array"><c path="openfl._internal.renderer.opengl.utils.GLGraphicsData"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</graphicsDataPool>
		<bucketPool public="1" expr="[]" line="64" static="1">
			<c path="Array"><c path="openfl._internal.renderer.opengl.utils.GLBucket"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</bucketPool>
		<SIN45 expr="0.70710678118654752440084436210485" line="66" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>0.70710678118654752440084436210485</e></m></meta>
		</SIN45>
		<TAN22 expr="0.4142135623730950488016887242097" line="67" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>0.4142135623730950488016887242097</e></m></meta>
		</TAN22>
		<objectPosition expr="new Point()" line="69" static="1">
			<c path="openfl.geom.Point"/>
			<meta><m n=":value"><e>new Point()</e></m></meta>
		</objectPosition>
		<objectBounds expr="new Rectangle()" line="70" static="1">
			<c path="openfl.geom.Rectangle"/>
			<meta><m n=":value"><e>new Rectangle()</e></m></meta>
		</objectBounds>
		<lastVertsBuffer static="1"><c path="lime.graphics.opengl.GLBuffer"/></lastVertsBuffer>
		<lastBucketMode static="1"><e path="openfl._internal.renderer.opengl.utils.BucketMode"/></lastBucketMode>
		<lastTexture static="1"><t path="openfl.gl.GLTexture"/></lastTexture>
		<lastTextureRepeat static="1"><x path="Bool"/></lastTextureRepeat>
		<lastTextureSmooth static="1"><x path="Bool"/></lastTextureSmooth>
		<overrideMatrix static="1"><c path="openfl.geom.Matrix"/></overrideMatrix>
		<buildCircle public="1" set="method" line="79" static="1">
			<f a="path:glStack:?localCoords" v="::false">
				<c path="openfl._internal.renderer.opengl.utils.DrawPath"/>
				<c path="openfl._internal.renderer.opengl.utils.GLStack"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ localCoords : false }</e></m></meta>
		</buildCircle>
		<buildComplexPoly public="1" set="method" line="145" static="1">
			<f a="path:glStack:?localCoords" v="::false">
				<c path="openfl._internal.renderer.opengl.utils.DrawPath"/>
				<c path="openfl._internal.renderer.opengl.utils.GLStack"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ localCoords : false }</e></m></meta>
		</buildComplexPoly>
		<buildLine public="1" set="method" line="184" static="1">
			<f a="path:bucket:?localCoords" v="::false">
				<c path="openfl._internal.renderer.opengl.utils.DrawPath"/>
				<c path="openfl._internal.renderer.opengl.utils.GLBucket"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ localCoords : false }</e></m></meta>
		</buildLine>
		<buildPoly public="1" set="method" line="438" static="1"><f a="path:glStack">
	<c path="openfl._internal.renderer.opengl.utils.DrawPath"/>
	<c path="openfl._internal.renderer.opengl.utils.GLStack"/>
	<x path="Void"/>
</f></buildPoly>
		<buildRectangle public="1" set="method" line="490" static="1">
			<f a="path:glStack:?localCoords" v="::false">
				<c path="openfl._internal.renderer.opengl.utils.DrawPath"/>
				<c path="openfl._internal.renderer.opengl.utils.GLStack"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ localCoords : false }</e></m></meta>
		</buildRectangle>
		<buildRoundedRectangle public="1" set="method" line="539" static="1">
			<f a="path:glStack:?localCoords" v="::false">
				<c path="openfl._internal.renderer.opengl.utils.DrawPath"/>
				<c path="openfl._internal.renderer.opengl.utils.GLStack"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ localCoords : false }</e></m></meta>
		</buildRoundedRectangle>
		<buildDrawTriangles public="1" set="method" line="599" static="1">
			<f a="path:object:glStack:?localCoords" v=":::false">
				<c path="openfl._internal.renderer.opengl.utils.DrawPath"/>
				<c path="openfl.display.DisplayObject"/>
				<c path="openfl._internal.renderer.opengl.utils.GLStack"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ localCoords : false }</e></m></meta>
		</buildDrawTriangles>
		<buildDrawTiles public="1" get="inline" set="null" line="714" static="1"><f a="path:glStack">
	<c path="openfl._internal.renderer.opengl.utils.DrawPath"/>
	<c path="openfl._internal.renderer.opengl.utils.GLStack"/>
	<x path="Void"/>
</f></buildDrawTiles>
		<quadraticBezierCurve set="method" line="719" static="1"><f a="fromX:fromY:cpX:cpY:toX:toY">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<c path="Array"><x path="Float"/></c>
</f></quadraticBezierCurve>
		<render public="1" set="method" line="754" static="1"><f a="object:renderSession">
	<c path="openfl.display.DisplayObject"/>
	<c path="openfl._internal.renderer.RenderSession"/>
	<x path="Void"/>
</f></render>
		<renderGraphics public="1" set="method" line="815" static="1">
			<f a="object:renderSession:?localCoords" v="::false">
				<c path="openfl.display.DisplayObject"/>
				<c path="openfl._internal.renderer.RenderSession"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ localCoords : false }</e></m></meta>
		</renderGraphics>
		<updateGraphics public="1" set="method" line="908" static="1">
			<f a="object:graphics:gl:?localCoords" v=":::false">
				<c path="openfl.display.DisplayObject"/>
				<c path="openfl.display.Graphics"/>
				<c path="lime.graphics.GLRenderContext"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ localCoords : false }</e></m></meta>
		</updateGraphics>
		<prepareBucket set="method" line="981" static="1"><f a="path:glStack">
	<c path="openfl._internal.renderer.opengl.utils.DrawPath"/>
	<c path="openfl._internal.renderer.opengl.utils.GLStack"/>
	<c path="openfl._internal.renderer.opengl.utils.GLBucket"/>
</f></prepareBucket>
		<getBucket set="method" line="1040" static="1"><f a="glStack:mode">
	<c path="openfl._internal.renderer.opengl.utils.GLStack"/>
	<e path="openfl._internal.renderer.opengl.utils.BucketMode"/>
	<c path="openfl._internal.renderer.opengl.utils.GLBucket"/>
</f></getBucket>
		<switchBucket set="method" line="1050" static="1"><f a="fillIndex:glStack:mode">
	<x path="Int"/>
	<c path="openfl._internal.renderer.opengl.utils.GLStack"/>
	<e path="openfl._internal.renderer.opengl.utils.BucketMode"/>
	<c path="openfl._internal.renderer.opengl.utils.GLBucket"/>
</f></switchBucket>
		<prepareShader set="method" line="1071" static="1"><f a="bucket:renderSession:object:translationMatrix">
	<c path="openfl._internal.renderer.opengl.utils.GLBucket"/>
	<c path="openfl._internal.renderer.RenderSession"/>
	<c path="openfl.display.DisplayObject"/>
	<x path="lime.utils.Float32Array"/>
	<c path="openfl._internal.renderer.opengl.shaders2.Shader"/>
</f></prepareShader>
		<renderFill set="method" line="1121" static="1"><f a="bucket:shader:renderSession">
	<c path="openfl._internal.renderer.opengl.utils.GLBucket"/>
	<c path="openfl._internal.renderer.opengl.shaders2.Shader"/>
	<c path="openfl._internal.renderer.RenderSession"/>
	<x path="Void"/>
</f></renderFill>
		<renderDrawTriangles set="method" line="1133" static="1"><f a="bucket:shader:renderSession">
	<c path="openfl._internal.renderer.opengl.utils.GLBucket"/>
	<c path="openfl._internal.renderer.opengl.shaders2.Shader"/>
	<c path="openfl._internal.renderer.RenderSession"/>
	<x path="Void"/>
</f></renderDrawTriangles>
		<bindTexture set="method" line="1147" static="1"><f a="gl:bucket">
	<c path="lime.graphics.GLRenderContext"/>
	<c path="openfl._internal.renderer.opengl.utils.GLBucket"/>
	<x path="Void"/>
</f></bindTexture>
		<isCCW get="inline" set="null" line="1170" static="1"><f a="x1:y1:x2:y2:x3:y3">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Bool"/>
</f></isCCW>
		<hex2rgb public="1" get="inline" set="null" line="1174" static="1"><f a="hex">
	<t path="Null"><x path="Int"/></t>
	<c path="Array"><x path="Float"/></c>
</f></hex2rgb>
		<hex2rgba public="1" get="inline" set="null" line="1178" static="1"><f a="hex">
	<t path="Null"><x path="Int"/></t>
	<c path="Array"><x path="Float"/></c>
</f></hex2rgba>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":access"><e>openfl.display.DisplayObject</e></m>
			<m n=":access"><e>openfl.display.Graphics</e></m>
			<m n=":access"><e>openfl.display.BitmapData</e></m>
			<m n=":access"><e>openfl.geom.Matrix</e></m>
		</meta>
	</class>
	<class path="openfl._internal.renderer.opengl.utils.GLStack" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/_internal/renderer/opengl/utils/GraphicsRenderer.hx" module="openfl._internal.renderer.opengl.utils.GraphicsRenderer">
		<lastIndex public="1" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</lastIndex>
		<buckets public="1"><c path="Array"><c path="openfl._internal.renderer.opengl.utils.GLBucket"/></c></buckets>
		<gl public="1"><c path="lime.graphics.GLRenderContext"/></gl>
		<reset public="1" set="method" line="1196"><f a=""><x path="Void"/></f></reset>
		<upload public="1" set="method" line="1201"><f a=""><x path="Void"/></f></upload>
		<new public="1" set="method" line="1190"><f a="gl">
	<c path="lime.graphics.GLRenderContext"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="openfl._internal.renderer.opengl.utils.GLBucket" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/_internal/renderer/opengl/utils/GraphicsRenderer.hx" module="openfl._internal.renderer.opengl.utils.GraphicsRenderer">
		<gl public="1"><c path="lime.graphics.GLRenderContext"/></gl>
		<color public="1"><c path="Array"><x path="Float"/></c></color>
		<alpha public="1"><x path="Float"/></alpha>
		<dirty public="1"><x path="Bool"/></dirty>
		<graphicType public="1"><e path="openfl._internal.renderer.opengl.utils.GraphicType"/></graphicType>
		<lastIndex public="1"><x path="Int"/></lastIndex>
		<fillIndex public="1" expr="-1">
			<x path="Int"/>
			<meta><m n=":value"><e>-1</e></m></meta>
		</fillIndex>
		<mode public="1"><e path="openfl._internal.renderer.opengl.utils.BucketMode"/></mode>
		<fills public="1" expr="[]">
			<c path="Array"><c path="openfl._internal.renderer.opengl.utils.GLBucketData"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</fills>
		<lines public="1" expr="[]">
			<c path="Array"><c path="openfl._internal.renderer.opengl.utils.GLBucketData"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</lines>
		<bitmap public="1"><c path="openfl.display.BitmapData"/></bitmap>
		<texture public="1"><t path="openfl.gl.GLTexture"/></texture>
		<textureMatrix public="1"><c path="openfl.geom.Matrix"/></textureMatrix>
		<textureRepeat public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</textureRepeat>
		<textureSmooth public="1" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</textureSmooth>
		<textureTL public="1"><c path="openfl.geom.Point"/></textureTL>
		<textureBR public="1"><c path="openfl.geom.Point"/></textureBR>
		<overrideMatrix public="1"><c path="openfl.geom.Matrix"/></overrideMatrix>
		<tileBuffer public="1"><c path="lime.graphics.opengl.GLBuffer"/></tileBuffer>
		<glTile public="1"><t path="openfl.utils.Int16Array"/></glTile>
		<tile public="1"><c path="Array"><x path="Int"/></c></tile>
		<uploadTileBuffer public="1" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</uploadTileBuffer>
		<getData public="1" set="method" line="1261"><f a="type">
	<e path="openfl._internal.renderer.opengl.utils.BucketDataType"/>
	<c path="openfl._internal.renderer.opengl.utils.GLBucketData"/>
</f></getData>
		<optimize public="1" set="method" line="1310"><f a=""><x path="Void"/></f></optimize>
		<reset public="1" set="method" line="1386"><f a=""><x path="Void"/></f></reset>
		<uploadTile public="1" set="method" line="1400"><f a="x:y:w:h">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></uploadTile>
		<upload public="1" set="method" line="1421"><f a=""><x path="Void"/></f></upload>
		<new public="1" set="method" line="1245"><f a="gl">
	<c path="lime.graphics.GLRenderContext"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="openfl._internal.renderer.opengl.utils.GLBucketData" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/_internal/renderer/opengl/utils/GraphicsRenderer.hx" module="openfl._internal.renderer.opengl.utils.GraphicsRenderer">
		<type public="1"><e path="openfl._internal.renderer.opengl.utils.BucketDataType"/></type>
		<gl public="1"><c path="lime.graphics.GLRenderContext"/></gl>
		<drawMode public="1"><x path="Int"/></drawMode>
		<glLength public="1" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</glLength>
		<glStart public="1" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</glStart>
		<vertexArray public="1"><c path="openfl._internal.renderer.opengl.utils.VertexArray"/></vertexArray>
		<glVerts public="1"><x path="lime.utils.Float32Array"/></glVerts>
		<lastVertsSize public="1" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</lastVertsSize>
		<verts public="1"><c path="Array"><x path="Float"/></c></verts>
		<rawVerts public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</rawVerts>
		<stride public="1" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</stride>
		<indexBuffer public="1"><c path="lime.graphics.opengl.GLBuffer"/></indexBuffer>
		<glIndices public="1"><x path="lime.utils.UInt16Array"/></glIndices>
		<indices public="1"><c path="Array"><x path="Int"/></c></indices>
		<rawIndices public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</rawIndices>
		<available public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</available>
		<parent public="1"><c path="openfl._internal.renderer.opengl.utils.GLBucket"/></parent>
		<reset public="1" set="method" line="1474"><f a=""><x path="Void"/></f></reset>
		<upload public="1" set="method" line="1486"><f a=""><x path="Void"/></f></upload>
		<new public="1" set="method" line="1466"><f a="gl">
	<c path="lime.graphics.GLRenderContext"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<enum path="openfl._internal.renderer.opengl.utils.BucketMode" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/_internal/renderer/opengl/utils/GraphicsRenderer.hx" module="openfl._internal.renderer.opengl.utils.GraphicsRenderer">
		<None/>
		<Fill/>
		<PatternFill/>
		<Line/>
		<PatternLine/>
		<DrawTriangles/>
		<DrawTiles/>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<enum path="openfl._internal.renderer.opengl.utils.BucketDataType" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/_internal/renderer/opengl/utils/GraphicsRenderer.hx" module="openfl._internal.renderer.opengl.utils.GraphicsRenderer">
		<Line/>
		<Fill/>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<class path="openfl._internal.renderer.opengl.utils.GLGraphicsData" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/_internal/renderer/opengl/utils/GraphicsRenderer.hx" module="openfl._internal.renderer.opengl.utils.GraphicsRenderer">
		<gl public="1"><c path="lime.graphics.GLRenderContext"/></gl>
		<tint public="1" expr="[1.0, 1.0, 1.0]">
			<c path="Array"><x path="Float"/></c>
			<meta><m n=":value"><e>[1.0, 1.0, 1.0]</e></m></meta>
		</tint>
		<alpha public="1" expr="1.0">
			<x path="Float"/>
			<meta><m n=":value"><e>1.0</e></m></meta>
		</alpha>
		<dirty public="1" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</dirty>
		<mode public="1" expr="RenderMode.DEFAULT">
			<x path="openfl._internal.renderer.opengl.utils.RenderMode"/>
			<meta><m n=":value"><e>RenderMode.DEFAULT</e></m></meta>
		</mode>
		<lastIndex public="1" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</lastIndex>
		<data public="1" expr="[]">
			<c path="Array"><x path="Float"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</data>
		<glData public="1"><x path="lime.utils.Float32Array"/></glData>
		<dataBuffer public="1"><c path="lime.graphics.opengl.GLBuffer"/></dataBuffer>
		<indices public="1" expr="[]">
			<c path="Array"><x path="Int"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</indices>
		<glIndices public="1"><x path="lime.utils.UInt16Array"/></glIndices>
		<indexBuffer public="1"><c path="lime.graphics.opengl.GLBuffer"/></indexBuffer>
		<reset public="1" set="method" line="1569"><f a=""><x path="Void"/></f></reset>
		<upload public="1" set="method" line="1578"><f a=""><x path="Void"/></f></upload>
		<new public="1" set="method" line="1559"><f a="gl">
	<c path="lime.graphics.GLRenderContext"/>
	<x path="Void"/>
</f></new>
	</class>
	<enum path="openfl._internal.renderer.opengl.utils.GraphicType" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/_internal/renderer/opengl/utils/GraphicsRenderer.hx" module="openfl._internal.renderer.opengl.utils.GraphicsRenderer">
		<Polygon/>
		<Rectangle a="rounded"><x path="Bool"/></Rectangle>
		<Circle/>
		<Ellipse/>
		<DrawTriangles a="vertices:indices:uvtData:culling:colors:blendMode">
			<x path="openfl.Vector"><x path="Float"/></x>
			<x path="openfl.Vector"><x path="Int"/></x>
			<x path="openfl.Vector"><x path="Float"/></x>
			<x path="openfl.display.TriangleCulling"/>
			<x path="openfl.Vector"><x path="Int"/></x>
			<x path="Int"/>
		</DrawTriangles>
		<DrawTiles a="sheet:tileData:smooth:flags:shader:count">
			<c path="openfl.display.Tilesheet"/>
			<c path="Array"><x path="Float"/></c>
			<x path="Bool"/>
			<x path="Int"/>
			<t path="openfl.display._Shader.FlashShader"/>
			<x path="Int"/>
		</DrawTiles>
		<OverrideMatrix a="matrix"><c path="openfl.geom.Matrix"/></OverrideMatrix>
		<meta><m n=":directlyUsed"/></meta>
	</enum>
	<abstract path="openfl._internal.renderer.opengl.utils.RenderMode" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/_internal/renderer/opengl/utils/GraphicsRenderer.hx" module="openfl._internal.renderer.opengl.utils.GraphicsRenderer">
		<this><x path="Int"/></this>
		<meta><m n=":enum"/></meta>
		<impl><class path="openfl._internal.renderer.opengl.utils._GraphicsRenderer.RenderMode_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/_internal/renderer/opengl/utils/GraphicsRenderer.hx" private="1" module="openfl._internal.renderer.opengl.utils.GraphicsRenderer" extern="1">
	<DEFAULT public="1" get="inline" set="null" expr="cast 0" line="1610" static="1">
		<x path="openfl._internal.renderer.opengl.utils.RenderMode"/>
		<meta>
			<m n=":value"><e>cast 0</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</DEFAULT>
	<STENCIL public="1" get="inline" set="null" expr="cast 1" line="1611" static="1">
		<x path="openfl._internal.renderer.opengl.utils.RenderMode"/>
		<meta>
			<m n=":value"><e>cast 1</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</STENCIL>
	<meta>
		<m n=":final"/>
		<m n=":enum"/>
	</meta>
</class></impl>
	</abstract>
	<class path="openfl._internal.renderer.opengl.utils._GraphicsRenderer.RenderMode_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/_internal/renderer/opengl/utils/GraphicsRenderer.hx" private="1" module="openfl._internal.renderer.opengl.utils.GraphicsRenderer" extern="1">
		<DEFAULT public="1" get="inline" set="null" expr="cast 0" line="1610" static="1">
			<x path="openfl._internal.renderer.opengl.utils.RenderMode"/>
			<meta>
				<m n=":value"><e>cast 0</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</DEFAULT>
		<STENCIL public="1" get="inline" set="null" expr="cast 1" line="1611" static="1">
			<x path="openfl._internal.renderer.opengl.utils.RenderMode"/>
			<meta>
				<m n=":value"><e>cast 1</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</STENCIL>
		<meta>
			<m n=":final"/>
			<m n=":enum"/>
		</meta>
	</class>
	<class path="openfl._internal.renderer.opengl.utils.PingPongTexture" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/_internal/renderer/opengl/utils/PingPongTexture.hx">
		<gl public="1"><c path="lime.graphics.GLRenderContext"/></gl>
		<renderTexture public="1" get="accessor" set="accessor"><c path="openfl._internal.renderer.opengl.utils.RenderTexture"/></renderTexture>
		<oldRenderTexture public="1" get="accessor" set="accessor"><c path="openfl._internal.renderer.opengl.utils.RenderTexture"/></oldRenderTexture>
		<framebuffer public="1" get="accessor" set="null"><t path="openfl.gl.GLFramebuffer"/></framebuffer>
		<texture public="1" get="accessor" set="null"><t path="openfl.gl.GLTexture"/></texture>
		<width public="1"><x path="Int"/></width>
		<height public="1"><x path="Int"/></height>
		<smoothing public="1"><x path="Bool"/></smoothing>
		<useOldTexture public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</useOldTexture>
		<powerOfTwo public="1" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</powerOfTwo>
		<__swapped expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</__swapped>
		<__texture0><c path="openfl._internal.renderer.opengl.utils.RenderTexture"/></__texture0>
		<__texture1><c path="openfl._internal.renderer.opengl.utils.RenderTexture"/></__texture1>
		<__otherTexture get="accessor" set="null"><c path="openfl._internal.renderer.opengl.utils.RenderTexture"/></__otherTexture>
		<swap public="1" set="method" line="39"><f a=""><x path="Void"/></f></swap>
		<clear public="1" get="inline" set="null" line="46">
			<f a="?r:?g:?b:?a:?mask" v="0:0:0:0:">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ a : 0, b : 0, g : 0, r : 0 }</e></m></meta>
		</clear>
		<resize public="1" set="method" line="52"><f a="width:height">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></resize>
		<destroy public="1" set="method" line="58"><f a=""><x path="Void"/></f></destroy>
		<get_renderTexture get="inline" set="null" line="70"><f a=""><c path="openfl._internal.renderer.opengl.utils.RenderTexture"/></f></get_renderTexture>
		<set_renderTexture get="inline" set="null" line="74"><f a="v">
	<c path="openfl._internal.renderer.opengl.utils.RenderTexture"/>
	<c path="openfl._internal.renderer.opengl.utils.RenderTexture"/>
</f></set_renderTexture>
		<get_oldRenderTexture get="inline" set="null" line="83"><f a=""><c path="openfl._internal.renderer.opengl.utils.RenderTexture"/></f></get_oldRenderTexture>
		<set_oldRenderTexture get="inline" set="null" line="87"><f a="v">
	<c path="openfl._internal.renderer.opengl.utils.RenderTexture"/>
	<c path="openfl._internal.renderer.opengl.utils.RenderTexture"/>
</f></set_oldRenderTexture>
		<get_framebuffer get="inline" set="null" line="96"><f a=""><c path="lime.graphics.opengl.GLFramebuffer"/></f></get_framebuffer>
		<get_texture get="inline" set="null" line="100"><f a=""><c path="lime.graphics.opengl.GLTexture"/></f></get_texture>
		<get___otherTexture get="inline" set="null" line="104"><f a=""><c path="openfl._internal.renderer.opengl.utils.RenderTexture"/></f></get___otherTexture>
		<new public="1" set="method" line="29">
			<f a="gl:width:height:?smoothing:?powerOfTwo" v=":::true:true">
				<c path="lime.graphics.GLRenderContext"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ powerOfTwo : true, smoothing : true }</e></m></meta>
		</new>
		<haxe_doc>* ...
 * @author MrCdK</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="openfl._internal.renderer.opengl.utils.RenderTexture" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/_internal/renderer/opengl/utils/RenderTexture.hx">
		<gl public="1"><c path="lime.graphics.GLRenderContext"/></gl>
		<frameBuffer public="1"><c path="lime.graphics.opengl.GLFramebuffer"/></frameBuffer>
		<renderBuffer public="1"><c path="lime.graphics.opengl.GLRenderbuffer"/></renderBuffer>
		<texture public="1"><c path="lime.graphics.opengl.GLTexture"/></texture>
		<smoothing public="1"><x path="Bool"/></smoothing>
		<width public="1"><x path="Int"/></width>
		<height public="1"><x path="Int"/></height>
		<powerOfTwo public="1" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</powerOfTwo>
		<__width><x path="Int"/></__width>
		<__height><x path="Int"/></__height>
		<__uvData><c path="openfl.display.TextureUvs"/></__uvData>
		<clear public="1" set="method" line="53">
			<f a="?r:?g:?b:?a:?mask" v="0:0:0:0:">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ a : 0, b : 0, g : 0, r : 0 }</e></m></meta>
		</clear>
		<destroy public="1" set="method" line="61"><f a=""><x path="Void"/></f></destroy>
		<resize public="1" set="method" line="72"><f a="width:height">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></resize>
		<createUVs set="method" line="105"><f a=""><x path="Void"/></f></createUVs>
		<powOfTwo get="inline" set="null" line="120"><f a="value">
	<x path="Int"/>
	<x path="Int"/>
</f></powOfTwo>
		<new public="1" set="method" line="27">
			<f a="gl:width:height:?smoothing:?powerOfTwo" v=":::true:true">
				<c path="lime.graphics.GLRenderContext"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ powerOfTwo : true, smoothing : true }</e></m></meta>
		</new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="openfl._internal.renderer.opengl.utils.ShaderManager" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/_internal/renderer/opengl/utils/ShaderManager.hx">
		<compiledShadersCache expr="new Map()" line="10" static="1">
			<x path="Map">
				<c path="String"/>
				<t path="openfl.gl.GLProgram"/>
			</x>
			<meta><m n=":value"><e>new Map()</e></m></meta>
		</compiledShadersCache>
		<gl public="1"><c path="lime.graphics.GLRenderContext"/></gl>
		<currentShader public="1"><c path="openfl._internal.renderer.opengl.shaders2.Shader"/></currentShader>
		<defaultShader public="1"><c path="openfl._internal.renderer.opengl.shaders2.DefaultShader"/></defaultShader>
		<fillShader public="1"><c path="openfl._internal.renderer.opengl.shaders2.FillShader"/></fillShader>
		<patternFillShader public="1"><c path="openfl._internal.renderer.opengl.shaders2.PatternFillShader"/></patternFillShader>
		<drawTrianglesShader public="1"><c path="openfl._internal.renderer.opengl.shaders2.DrawTrianglesShader"/></drawTrianglesShader>
		<primitiveShader public="1"><c path="openfl._internal.renderer.opengl.shaders2.PrimitiveShader"/></primitiveShader>
		<setContext public="1" set="method" line="25"><f a="gl">
	<c path="lime.graphics.GLRenderContext"/>
	<x path="Void"/>
</f></setContext>
		<destroy public="1" set="method" line="38"><f a=""><x path="Void"/></f></destroy>
		<setShader public="1" set="method" line="50">
			<f a="shader:?force" v=":false">
				<c path="openfl._internal.renderer.opengl.shaders2.Shader"/>
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":value"><e>{ force : false }</e></m></meta>
		</setShader>
		<new public="1" set="method" line="21"><f a="gl">
	<c path="lime.graphics.GLRenderContext"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="openfl._internal.renderer.opengl.utils.SpriteBatch" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/_internal/renderer/opengl/utils/SpriteBatch.hx">
		<VERTS_PER_SPRITE get="inline" set="null" expr="4" line="33" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>4</e></m></meta>
		</VERTS_PER_SPRITE>
		<gl public="1"><c path="lime.graphics.GLRenderContext"/></gl>
		<renderSession><c path="openfl._internal.renderer.RenderSession"/></renderSession>
		<states expr="[]">
			<c path="Array"><c path="openfl._internal.renderer.opengl.utils._SpriteBatch.State"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</states>
		<currentState><c path="openfl._internal.renderer.opengl.utils._SpriteBatch.State"/></currentState>
		<vertexArray><c path="openfl._internal.renderer.opengl.utils.VertexArray"/></vertexArray>
		<positions><x path="lime.utils.Float32Array"/></positions>
		<colors><x path="lime.utils.UInt32Array"/></colors>
		<indexBuffer><t path="openfl.gl.GLBuffer"/></indexBuffer>
		<indices><x path="lime.utils.UInt16Array"/></indices>
		<dirty expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</dirty>
		<drawing public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</drawing>
		<clipRect><c path="openfl.geom.Rectangle"/></clipRect>
		<maxSprites><x path="Int"/></maxSprites>
		<batchedSprites><x path="Int"/></batchedSprites>
		<vertexArraySize><x path="Int"/></vertexArraySize>
		<indexArraySize><x path="Int"/></indexArraySize>
		<maxElementsPerVertex><x path="Int"/></maxElementsPerVertex>
		<elementsPerVertex><x path="Int"/></elementsPerVertex>
		<writtenVertexBytes expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</writtenVertexBytes>
		<shader><c path="openfl._internal.renderer.opengl.shaders2.Shader"/></shader>
		<attributes expr="[]">
			<c path="Array"><c path="openfl._internal.renderer.opengl.utils.VertexAttribute"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</attributes>
		<enableColor expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</enableColor>
		<lastEnableColor expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</lastEnableColor>
		<matrix expr="new Matrix()">
			<c path="openfl.geom.Matrix"/>
			<meta><m n=":value"><e>new Matrix()</e></m></meta>
		</matrix>
		<uvs expr="new TextureUvs()">
			<c path="openfl.display.TextureUvs"/>
			<meta><m n=":value"><e>new TextureUvs()</e></m></meta>
		</uvs>
		<colorTransform expr="new ColorTransform()">
			<c path="openfl.geom.ColorTransform"/>
			<meta><m n=":value"><e>new ColorTransform()</e></m></meta>
		</colorTransform>
		<destroy public="1" set="method" line="118"><f a=""><x path="Void"/></f></destroy>
		<begin public="1" set="method" line="135">
			<f a="renderSession:?clipRect" v=":null">
				<c path="openfl._internal.renderer.RenderSession"/>
				<c path="openfl.geom.Rectangle"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ clipRect : null }</e></m></meta>
		</begin>
		<finish public="1" set="method" line="144"><f a=""><x path="Void"/></f></finish>
		<start public="1" set="method" line="150">
			<f a="?clipRect" v="null">
				<c path="openfl.geom.Rectangle"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ clipRect : null }</e></m></meta>
		</start>
		<stop public="1" set="method" line="158"><f a=""><x path="Void"/></f></stop>
		<renderBitmapData public="1" set="method" line="162">
			<f a="bitmapData:smoothing:matrix:ct:?alpha:?blendMode:?flashShader:?pixelSnapping:?bgra" v="::::1::::false">
				<c path="openfl.display.BitmapData"/>
				<x path="Bool"/>
				<c path="openfl.geom.Matrix"/>
				<c path="openfl.geom.ColorTransform"/>
				<x path="Float"/>
				<x path="openfl.display.BlendMode"/>
				<t path="openfl.display._Shader.FlashShader"/>
				<x path="openfl.display.PixelSnapping"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ bgra : false, alpha : 1 }</e></m></meta>
		</renderBitmapData>
		<renderTiles public="1" set="method" line="188">
			<f a="object:sheet:tileData:?smooth:?flags:?flashShader:?count" v=":::false:0::-1">
				<c path="openfl.display.DisplayObject"/>
				<c path="openfl.display.Tilesheet"/>
				<c path="Array"><x path="Float"/></c>
				<x path="Bool"/>
				<x path="Int"/>
				<t path="openfl.display._Shader.FlashShader"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ count : -1, flags : 0, smooth : false }</e></m></meta>
		</renderTiles>
		<fillVertices get="inline" set="null" line="425">
			<f a="index:width:height:matrix:uvs:?color:?pixelSnapping" v=":::::0xFFFFFFFF:">
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
				<c path="openfl.geom.Matrix"/>
				<c path="openfl.display.TextureUvs"/>
				<x path="Int"/>
				<x path="openfl.display.PixelSnapping"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ color : 0xFFFFFFFF }</e></m></meta>
		</fillVertices>
		<enableAttributes get="inline" set="null" line="474">
			<f a="?color" v="0xFFFFFFFF">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ color : 0xFFFFFFFF }</e></m></meta>
		</enableAttributes>
		<flush set="method" line="487"><f a=""><x path="Void"/></f></flush>
		<renderBatch set="method" line="563"><f a="state:size:start">
	<c path="openfl._internal.renderer.opengl.utils._SpriteBatch.State"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></renderBatch>
		<setState get="inline" set="null" line="612">
			<f a="index:texture:?smooth:?blendMode:?colorTransform:?shader:?skipAlpha" v="::false::::false">
				<x path="Int"/>
				<t path="openfl.gl.GLTexture"/>
				<x path="Bool"/>
				<x path="openfl.display.BlendMode"/>
				<c path="openfl.geom.ColorTransform"/>
				<t path="openfl.display._Shader.FlashShader"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ skipAlpha : false, smooth : false }</e></m></meta>
		</setState>
		<setContext public="1" set="method" line="646"><f a="gl">
	<c path="lime.graphics.GLRenderContext"/>
	<x path="Void"/>
</f></setContext>
		<prepareShader get="inline" set="null" line="657"><f a="flashShader:?bd">
	<t path="openfl.display._Shader.FlashShader"/>
	<c path="openfl.display.BitmapData"/>
	<x path="Void"/>
</f></prepareShader>
		<getElementsPerVertex get="inline" set="null" line="686"><f a=""><x path="Int"/></f></getElementsPerVertex>
		<new public="1" set="method" line="73">
			<f a="gl:?maxSprites" v=":2000">
				<c path="lime.graphics.GLRenderContext"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ maxSprites : 2000 }</e></m></meta>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":access"><e>openfl.display.BitmapData</e></m>
			<m n=":access"><e>openfl.display.Graphics</e></m>
			<m n=":access"><e>openfl.display.DisplayObject</e></m>
			<m n=":access"><e>openfl.display.Tilesheet</e></m>
			<m n=":access"><e>openfl.display.Shader</e></m>
			<m n=":access"><e>openfl.geom.Matrix</e></m>
		</meta>
	</class>
	<class path="openfl._internal.renderer.opengl.utils._SpriteBatch.State" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/_internal/renderer/opengl/utils/SpriteBatch.hx" private="1" module="openfl._internal.renderer.opengl.utils.SpriteBatch">
		<texture public="1"><t path="openfl.gl.GLTexture"/></texture>
		<textureSmooth public="1" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</textureSmooth>
		<blendMode public="1"><x path="openfl.display.BlendMode"/></blendMode>
		<colorTransform public="1" expr="new ColorTransform()">
			<c path="openfl.geom.ColorTransform"/>
			<meta><m n=":value"><e>new ColorTransform()</e></m></meta>
		</colorTransform>
		<skipColorTransform public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</skipColorTransform>
		<skipColorTransformAlpha public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</skipColorTransformAlpha>
		<shader public="1"><c path="openfl._internal.renderer.opengl.shaders2.Shader"/></shader>
		<shaderData public="1"><t path="openfl.display.GLShaderData"/></shaderData>
		<equals public="1" get="inline" set="null" line="711"><f a="other">
	<c path="openfl._internal.renderer.opengl.utils._SpriteBatch.State"/>
	<x path="Bool"/>
</f></equals>
		<destroy public="1" set="method" line="724"><f a=""><x path="Void"/></f></destroy>
		<new public="1" set="method" line="709"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":access"><e>openfl.geom.ColorTransform</e></m>
		</meta>
	</class>
	<class path="openfl._internal.renderer.opengl.utils.StencilManager" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/_internal/renderer/opengl/utils/StencilManager.hx">
		<count public="1"><x path="Int"/></count>
		<gl public="1"><c path="lime.graphics.GLRenderContext"/></gl>
		<reverse public="1"><x path="Bool"/></reverse>
		<stencilStack public="1"><c path="Array"><c path="openfl._internal.renderer.opengl.utils.GLGraphicsData"/></c></stencilStack>
		<stencilMask public="1" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</stencilMask>
		<prepareGraphics public="1" get="inline" set="null" line="41"><f a="fill:renderSession:translationMatrix">
	<c path="openfl._internal.renderer.opengl.utils.GLBucketData"/>
	<c path="openfl._internal.renderer.RenderSession"/>
	<x path="lime.utils.Float32Array"/>
	<x path="Void"/>
</f></prepareGraphics>
		<pushBucket public="1" set="method" line="53">
			<f a="bucket:renderSession:translationMatrix:?isMask" v=":::false">
				<c path="openfl._internal.renderer.opengl.utils.GLBucket"/>
				<c path="openfl._internal.renderer.RenderSession"/>
				<x path="lime.utils.Float32Array"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ isMask : false }</e></m></meta>
		</pushBucket>
		<popBucket public="1" set="method" line="81"><f a="object:bucket:renderSession">
	<c path="openfl.display.DisplayObject"/>
	<c path="openfl._internal.renderer.opengl.utils.GLBucket"/>
	<c path="openfl._internal.renderer.RenderSession"/>
	<x path="Void"/>
</f></popBucket>
		<pushMask public="1" set="method" line="85"><f a="object:renderSession">
	<c path="openfl.display.DisplayObject"/>
	<c path="openfl._internal.renderer.RenderSession"/>
	<x path="Void"/>
</f></pushMask>
		<popMask public="1" set="method" line="138"><f a="object:renderSession">
	<c path="openfl.display.DisplayObject"/>
	<c path="openfl._internal.renderer.RenderSession"/>
	<x path="Void"/>
</f></popMask>
		<bindGraphics public="1" set="method" line="153"><f a="object:glData:renderSession">
	<c path="openfl.display.DisplayObject"/>
	<c path="openfl._internal.renderer.opengl.utils.GLGraphicsData"/>
	<c path="openfl._internal.renderer.RenderSession"/>
	<x path="Void"/>
</f></bindGraphics>
		<destroy public="1" set="method" line="209"><f a=""><x path="Void"/></f></destroy>
		<popStencil public="1" set="method" line="217"><f a="object:glData:renderSession">
	<c path="openfl.display.DisplayObject"/>
	<c path="openfl._internal.renderer.opengl.utils.GLGraphicsData"/>
	<c path="openfl._internal.renderer.RenderSession"/>
	<x path="Void"/>
</f></popStencil>
		<pushStencil public="1" set="method" line="303"><f a="object:glData:renderSession">
	<c path="openfl.display.DisplayObject"/>
	<c path="openfl._internal.renderer.opengl.utils.GLGraphicsData"/>
	<c path="openfl._internal.renderer.RenderSession"/>
	<x path="Void"/>
</f></pushStencil>
		<setContext public="1" set="method" line="393"><f a="gl">
	<c path="lime.graphics.GLRenderContext"/>
	<x path="Void"/>
</f></setContext>
		<new public="1" set="method" line="32"><f a="gl">
	<c path="lime.graphics.GLRenderContext"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":access"><e>openfl.display.DisplayObject</e></m>
			<m n=":access"><e>openfl.display.Graphics</e></m>
			<m n=":access"><e>openfl.display.BitmapData</e></m>
			<m n=":access"><e>openfl.geom.Matrix</e></m>
		</meta>
	</class>
	<class path="openfl._internal.renderer.opengl.utils.VertexArray" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/_internal/renderer/opengl/utils/VertexArray.hx">
		<gl public="1"><c path="lime.graphics.GLRenderContext"/></gl>
		<glBuffer public="1"><t path="openfl.gl.GLBuffer"/></glBuffer>
		<attributes public="1" expr="[]">
			<c path="Array"><c path="openfl._internal.renderer.opengl.utils.VertexAttribute"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</attributes>
		<buffer public="1"><t path="openfl.utils.ArrayBuffer"/></buffer>
		<size public="1" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</size>
		<stride public="1" get="accessor" set="null"><x path="Int"/></stride>
		<isStatic public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</isStatic>
		<bind public="1" get="inline" set="null" line="31"><f a=""><x path="Void"/></f></bind>
		<unbind public="1" get="inline" set="null" line="35"><f a=""><x path="Void"/></f></unbind>
		<upload public="1" set="method" line="39"><f a="view">
	<t path="openfl.utils.ArrayBufferView"/>
	<x path="Void"/>
</f></upload>
		<destroy public="1" set="method" line="43"><f a=""><x path="Void"/></f></destroy>
		<setContext public="1" set="method" line="48"><f a="gl:view">
	<c path="lime.graphics.GLRenderContext"/>
	<t path="openfl.utils.ArrayBufferView"/>
	<x path="Void"/>
</f></setContext>
		<get_stride set="method" line="58"><f a=""><x path="Int"/></f></get_stride>
		<new public="1" set="method" line="20">
			<f a="attributes:?size:?isStatic" v=":0:false">
				<c path="Array"><c path="openfl._internal.renderer.opengl.utils.VertexAttribute"/></c>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ isStatic : false, size : 0 }</e></m></meta>
		</new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<abstract path="openfl._internal.renderer.opengl.utils.ElementType" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/_internal/renderer/opengl/utils/VertexAttribute.hx" module="openfl._internal.renderer.opengl.utils.VertexAttribute">
		<from><icast><x path="Int"/></icast></from>
		<this><x path="Int"/></this>
		<to><icast><x path="Int"/></icast></to>
		<meta><m n=":enum"/></meta>
		<impl><class path="openfl._internal.renderer.opengl.utils._VertexAttribute.ElementType_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/_internal/renderer/opengl/utils/VertexAttribute.hx" private="1" module="openfl._internal.renderer.opengl.utils.VertexAttribute" extern="1">
	<BYTE public="1" get="inline" set="null" expr="cast GL.BYTE" line="52" static="1">
		<x path="openfl._internal.renderer.opengl.utils.ElementType"/>
		<meta>
			<m n=":value"><e>cast GL.BYTE</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</BYTE>
	<UNSIGNED_BYTE public="1" get="inline" set="null" expr="cast GL.UNSIGNED_BYTE" line="53" static="1">
		<x path="openfl._internal.renderer.opengl.utils.ElementType"/>
		<meta>
			<m n=":value"><e>cast GL.UNSIGNED_BYTE</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</UNSIGNED_BYTE>
	<SHORT public="1" get="inline" set="null" expr="cast GL.SHORT" line="54" static="1">
		<x path="openfl._internal.renderer.opengl.utils.ElementType"/>
		<meta>
			<m n=":value"><e>cast GL.SHORT</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</SHORT>
	<UNSIGNED_SHORT public="1" get="inline" set="null" expr="cast GL.UNSIGNED_SHORT" line="55" static="1">
		<x path="openfl._internal.renderer.opengl.utils.ElementType"/>
		<meta>
			<m n=":value"><e>cast GL.UNSIGNED_SHORT</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</UNSIGNED_SHORT>
	<FLOAT public="1" get="inline" set="null" expr="cast GL.FLOAT" line="56" static="1">
		<x path="openfl._internal.renderer.opengl.utils.ElementType"/>
		<meta>
			<m n=":value"><e>cast GL.FLOAT</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</FLOAT>
	<meta>
		<m n=":final"/>
		<m n=":enum"/>
	</meta>
</class></impl>
	</abstract>
	<class path="openfl._internal.renderer.opengl.utils._VertexAttribute.ElementType_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/_internal/renderer/opengl/utils/VertexAttribute.hx" private="1" module="openfl._internal.renderer.opengl.utils.VertexAttribute" extern="1">
		<BYTE public="1" get="inline" set="null" expr="cast GL.BYTE" line="52" static="1">
			<x path="openfl._internal.renderer.opengl.utils.ElementType"/>
			<meta>
				<m n=":value"><e>cast GL.BYTE</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</BYTE>
		<UNSIGNED_BYTE public="1" get="inline" set="null" expr="cast GL.UNSIGNED_BYTE" line="53" static="1">
			<x path="openfl._internal.renderer.opengl.utils.ElementType"/>
			<meta>
				<m n=":value"><e>cast GL.UNSIGNED_BYTE</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</UNSIGNED_BYTE>
		<SHORT public="1" get="inline" set="null" expr="cast GL.SHORT" line="54" static="1">
			<x path="openfl._internal.renderer.opengl.utils.ElementType"/>
			<meta>
				<m n=":value"><e>cast GL.SHORT</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</SHORT>
		<UNSIGNED_SHORT public="1" get="inline" set="null" expr="cast GL.UNSIGNED_SHORT" line="55" static="1">
			<x path="openfl._internal.renderer.opengl.utils.ElementType"/>
			<meta>
				<m n=":value"><e>cast GL.UNSIGNED_SHORT</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</UNSIGNED_SHORT>
		<FLOAT public="1" get="inline" set="null" expr="cast GL.FLOAT" line="56" static="1">
			<x path="openfl._internal.renderer.opengl.utils.ElementType"/>
			<meta>
				<m n=":value"><e>cast GL.FLOAT</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</FLOAT>
		<meta>
			<m n=":final"/>
			<m n=":enum"/>
		</meta>
	</class>
	<class path="openfl._internal.text.TextEngine" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/_internal/text/TextEngine.hx">
		<UTF8_TAB get="inline" set="null" expr="9" line="46" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>9</e></m></meta>
		</UTF8_TAB>
		<UTF8_ENDLINE get="inline" set="null" expr="10" line="47" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>10</e></m></meta>
		</UTF8_ENDLINE>
		<UTF8_SPACE get="inline" set="null" expr="32" line="48" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>32</e></m></meta>
		</UTF8_SPACE>
		<UTF8_HYPHEN get="inline" set="null" expr="0x2D" line="49" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x2D</e></m></meta>
		</UTF8_HYPHEN>
		<__defaultFonts expr="new Map&lt;String,Font&gt;()" line="51" static="1">
			<x path="Map">
				<c path="String"/>
				<c path="openfl.text.Font"/>
			</x>
			<meta><m n=":value"><e><![CDATA[new Map<String,Font>()]]></e></m></meta>
		</__defaultFonts>
		<findFont set="method" line="165" static="1"><f a="name">
	<c path="String"/>
	<c path="openfl.text.Font"/>
</f></findFont>
		<getFont public="1" set="method" line="207" static="1"><f a="format">
	<c path="openfl.text.TextFormat"/>
	<c path="String"/>
</f></getFont>
		<getFontInstance public="1" set="method" line="229" static="1"><f a="format">
	<c path="openfl.text.TextFormat"/>
	<c path="openfl.text.Font"/>
</f></getFontInstance>
		<antiAliasType public="1"><x path="openfl.text.AntiAliasType"/></antiAliasType>
		<autoSize public="1"><x path="openfl.text.TextFieldAutoSize"/></autoSize>
		<background public="1"><x path="Bool"/></background>
		<backgroundColor public="1"><x path="Int"/></backgroundColor>
		<border public="1"><x path="Bool"/></border>
		<borderColor public="1"><x path="Int"/></borderColor>
		<bottomScrollV public="1" set="null"><x path="Int"/></bottomScrollV>
		<bounds public="1"><c path="openfl.geom.Rectangle"/></bounds>
		<caretIndex public="1"><x path="Int"/></caretIndex>
		<displayAsPassword public="1"><x path="Bool"/></displayAsPassword>
		<embedFonts public="1"><x path="Bool"/></embedFonts>
		<gridFitType public="1"><x path="openfl.text.GridFitType"/></gridFitType>
		<height public="1"><x path="Float"/></height>
		<layoutGroups public="1"><c path="Array"><c path="openfl._internal.text.TextLayoutGroup"/></c></layoutGroups>
		<lineAscents public="1"><c path="Array"><x path="Float"/></c></lineAscents>
		<lineBreaks public="1"><c path="Array"><x path="Int"/></c></lineBreaks>
		<lineDescents public="1"><c path="Array"><x path="Float"/></c></lineDescents>
		<lineLeadings public="1"><c path="Array"><x path="Float"/></c></lineLeadings>
		<lineHeights public="1"><c path="Array"><x path="Float"/></c></lineHeights>
		<lineWidths public="1"><c path="Array"><x path="Float"/></c></lineWidths>
		<maxChars public="1"><x path="Int"/></maxChars>
		<maxScrollH public="1" set="null"><x path="Int"/></maxScrollH>
		<maxScrollV public="1" set="null"><x path="Int"/></maxScrollV>
		<multiline public="1"><x path="Bool"/></multiline>
		<numLines public="1" set="null"><x path="Int"/></numLines>
		<restrict public="1"><c path="String"/></restrict>
		<scrollH public="1"><x path="Int"/></scrollH>
		<scrollV public="1"><x path="Int"/></scrollV>
		<selectable public="1"><x path="Bool"/></selectable>
		<sharpness public="1"><x path="Float"/></sharpness>
		<text public="1"><c path="String"/></text>
		<textHeight public="1"><x path="Float"/></textHeight>
		<textFormatRanges public="1"><c path="Array"><c path="openfl._internal.text.TextFormatRange"/></c></textFormatRanges>
		<textWidth public="1"><x path="Float"/></textWidth>
		<type public="1"><x path="openfl.text.TextFieldType"/></type>
		<width public="1"><x path="Float"/></width>
		<wordWrap public="1"><x path="Bool"/></wordWrap>
		<textField><c path="openfl.text.TextField"/></textField>
		<__cursorPosition>
			<x path="Int"/>
			<meta><m n=":noCompletion"/></meta>
		</__cursorPosition>
		<__cursorTimer>
			<c path="haxe.Timer"/>
			<meta><m n=":noCompletion"/></meta>
		</__cursorTimer>
		<__hasFocus>
			<x path="Bool"/>
			<meta><m n=":noCompletion"/></meta>
		</__hasFocus>
		<__isKeyDown>
			<x path="Bool"/>
			<meta><m n=":noCompletion"/></meta>
		</__isKeyDown>
		<__measuredHeight>
			<x path="Int"/>
			<meta><m n=":noCompletion"/></meta>
		</__measuredHeight>
		<__measuredWidth>
			<x path="Int"/>
			<meta><m n=":noCompletion"/></meta>
		</__measuredWidth>
		<__selectionStart>
			<x path="Int"/>
			<meta><m n=":noCompletion"/></meta>
		</__selectionStart>
		<__showCursor>
			<x path="Bool"/>
			<meta><m n=":noCompletion"/></meta>
		</__showCursor>
		<__textFormat>
			<c path="openfl.text.TextFormat"/>
			<meta><m n=":noCompletion"/></meta>
		</__textFormat>
		<__textLayout>
			<c path="lime.text.TextLayout"/>
			<meta><m n=":noCompletion"/></meta>
		</__textLayout>
		<__texture>
			<c path="lime.graphics.opengl.GLTexture"/>
			<meta><m n=":noCompletion"/></meta>
		</__texture>
		<__tileData>
			<x path="Map">
				<c path="openfl.display.Tilesheet"/>
				<c path="Array"><x path="Float"/></c>
			</x>
			<meta><m n=":noCompletion"/></meta>
		</__tileData>
		<__tileDataLength>
			<x path="Map">
				<c path="openfl.display.Tilesheet"/>
				<x path="Int"/>
			</x>
			<meta><m n=":noCompletion"/></meta>
		</__tileDataLength>
		<__tilesheets>
			<x path="Map">
				<c path="openfl.display.Tilesheet"/>
				<x path="Bool"/>
			</x>
			<meta><m n=":noCompletion"/></meta>
		</__tilesheets>
		<__cairoFont public="1">
			<x path="lime.graphics.cairo.CairoFontFace"/>
			<meta>
				<m n=":noCompletion"/>
				<m n=":dox"><e>hide</e></m>
			</meta>
		</__cairoFont>
		<__font public="1">
			<c path="openfl.text.Font"/>
			<meta>
				<m n=":noCompletion"/>
				<m n=":dox"><e>hide</e></m>
			</meta>
		</__font>
		<getBounds set="method" line="197"><f a=""><x path="Void"/></f></getBounds>
		<getLine public="1" set="method" line="434"><f a="index">
	<x path="Int"/>
	<c path="String"/>
</f></getLine>
		<getLineMeasurements set="method" line="455"><f a=""><x path="Void"/></f></getLineMeasurements>
		<getLayoutGroups set="method" line="564"><f a=""><x path="Void"/></f></getLayoutGroups>
		<setTextAlignment set="method" line="972"><f a=""><x path="Void"/></f></setTextAlignment>
		<update set="method" line="1073"><f a=""><x path="Void"/></f></update>
		<new public="1" set="method" line="121"><f a="textField">
	<c path="openfl.text.TextField"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":access"><e>openfl.text.Font</e></m>
			<m n=":access"><e>openfl.text.TextField</e></m>
			<m n=":access"><e>openfl.text.TextFormat</e></m>
		</meta>
	</class>
	<class path="openfl._internal.text.TextFormatRange" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/_internal/text/TextFormatRange.hx">
		<end public="1"><x path="Int"/></end>
		<format public="1"><c path="openfl.text.TextFormat"/></format>
		<start public="1"><x path="Int"/></start>
		<new public="1" set="method" line="15"><f a="format:start:end">
	<c path="openfl.text.TextFormat"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="openfl._internal.text.TextLayoutGroup" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/_internal/text/TextLayoutGroup.hx">
		<advances public="1"><c path="Array"><x path="Float"/></c></advances>
		<ascent public="1"><x path="Float"/></ascent>
		<descent public="1"><x path="Float"/></descent>
		<endIndex public="1"><x path="Int"/></endIndex>
		<format public="1"><c path="openfl.text.TextFormat"/></format>
		<height public="1"><x path="Float"/></height>
		<leading public="1"><x path="Int"/></leading>
		<lineIndex public="1"><x path="Int"/></lineIndex>
		<offsetX public="1"><x path="Float"/></offsetX>
		<offsetY public="1"><x path="Float"/></offsetY>
		<startIndex public="1"><x path="Int"/></startIndex>
		<width public="1"><x path="Float"/></width>
		<new public="1" set="method" line="24"><f a="format:startIndex:endIndex">
	<c path="openfl.text.TextFormat"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="openfl.display.Application" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/display/Application.hx">
		<extends path="lime.app.Application"/>
		<create public="1" set="method" line="25" override="1"><f a="config">
	<t path="lime.app.Config"/>
	<x path="Void"/>
</f></create>
		<new public="1" set="method" line="12"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="openfl.display.Bitmap" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/display/Bitmap.hx">
		<extends path="openfl.display.DisplayObject"/>
		<bitmapData public="1"><c path="openfl.display.BitmapData"/></bitmapData>
		<pixelSnapping public="1"><x path="openfl.display.PixelSnapping"/></pixelSnapping>
		<smoothing public="1"><x path="Bool"/></smoothing>
		<__getBounds set="method" line="52" override="1"><f a="rect:matrix">
	<c path="openfl.geom.Rectangle"/>
	<c path="openfl.geom.Matrix"/>
	<x path="Void"/>
</f></__getBounds>
		<__hitTest set="method" line="67" override="1"><f a="x:y:shapeFlag:stack:interactiveOnly:hitObject">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Bool"/>
	<c path="Array"><c path="openfl.display.DisplayObject"/></c>
	<x path="Bool"/>
	<c path="openfl.display.DisplayObject"/>
	<x path="Bool"/>
</f></__hitTest>
		<__hitTestMask set="method" line="94" override="1"><f a="x:y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Bool"/>
</f></__hitTestMask>
		<__renderCairo public="1" set="method" line="114" override="1"><f a="renderSession">
	<c path="openfl._internal.renderer.RenderSession"/>
	<x path="Void"/>
</f></__renderCairo>
		<__renderCairoMask public="1" set="method" line="121" override="1"><f a="renderSession">
	<c path="openfl._internal.renderer.RenderSession"/>
	<x path="Void"/>
</f></__renderCairoMask>
		<__renderCanvas public="1" set="method" line="128" override="1"><f a="renderSession">
	<c path="openfl._internal.renderer.RenderSession"/>
	<x path="Void"/>
</f></__renderCanvas>
		<__renderCanvasMask public="1" set="method" line="135" override="1"><f a="renderSession">
	<c path="openfl._internal.renderer.RenderSession"/>
	<x path="Void"/>
</f></__renderCanvasMask>
		<__renderDOM public="1" set="method" line="142" override="1"><f a="renderSession">
	<c path="openfl._internal.renderer.RenderSession"/>
	<x path="Void"/>
</f></__renderDOM>
		<__renderGL public="1" set="method" line="149" override="1"><f a="renderSession">
	<c path="openfl._internal.renderer.RenderSession"/>
	<x path="Void"/>
</f></__renderGL>
		<__updateMask public="1" set="method" line="162" override="1"><f a="maskGraphics">
	<c path="openfl.display.Graphics"/>
	<x path="Void"/>
</f></__updateMask>
		<get_height set="method" line="193" override="1"><f a=""><x path="Float"/></f></get_height>
		<set_height set="method" line="206" override="1"><f a="value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_height>
		<get_width set="method" line="225" override="1"><f a=""><x path="Float"/></f></get_width>
		<set_width set="method" line="238" override="1"><f a="value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_width>
		<new public="1" set="method" line="35">
			<f a="?bitmapData:?pixelSnapping:?smoothing" v="null:null:false">
				<c path="openfl.display.BitmapData"/>
				<x path="openfl.display.PixelSnapping"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ smoothing : false, pixelSnapping : null, bitmapData : null }</e></m></meta>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":access"><e>openfl.display.BitmapData</e></m>
			<m n=":access"><e>openfl.display.Graphics</e></m>
			<m n=":access"><e>openfl.geom.Rectangle</e></m>
		</meta>
	</class>
	<class path="openfl.display.TextureUvs" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/display/BitmapData.hx" module="openfl.display.BitmapData">
		<x0 public="1" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</x0>
		<x1 public="1" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</x1>
		<x2 public="1" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</x2>
		<x3 public="1" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</x3>
		<y0 public="1" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</y0>
		<y1 public="1" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</y1>
		<y2 public="1" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</y2>
		<y3 public="1" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</y3>
		<reset public="1" get="inline" set="null" line="1436"><f a=""><x path="Void"/></f></reset>
		<new public="1" set="method" line="1440"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<abstract path="openfl.display.BitmapDataChannel" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/display/BitmapDataChannel.hx">
		<from><icast><x path="Int"/></icast></from>
		<this><x path="Int"/></this>
		<to><icast><x path="Int"/></icast></to>
		<meta><m n=":enum"/></meta>
		<impl><class path="openfl.display._BitmapDataChannel.BitmapDataChannel_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/display/BitmapDataChannel.hx" private="1" module="openfl.display.BitmapDataChannel" extern="1">
	<ALPHA public="1" get="inline" set="null" expr="cast 8" line="6" static="1">
		<x path="openfl.display.BitmapDataChannel"/>
		<meta>
			<m n=":value"><e>cast 8</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</ALPHA>
	<BLUE public="1" get="inline" set="null" expr="cast 4" line="7" static="1">
		<x path="openfl.display.BitmapDataChannel"/>
		<meta>
			<m n=":value"><e>cast 4</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</BLUE>
	<GREEN public="1" get="inline" set="null" expr="cast 2" line="8" static="1">
		<x path="openfl.display.BitmapDataChannel"/>
		<meta>
			<m n=":value"><e>cast 2</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</GREEN>
	<RED public="1" get="inline" set="null" expr="cast 1" line="9" static="1">
		<x path="openfl.display.BitmapDataChannel"/>
		<meta>
			<m n=":value"><e>cast 1</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</RED>
	<meta>
		<m n=":final"/>
		<m n=":enum"/>
	</meta>
</class></impl>
	</abstract>
	<class path="openfl.display._BitmapDataChannel.BitmapDataChannel_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/display/BitmapDataChannel.hx" private="1" module="openfl.display.BitmapDataChannel" extern="1">
		<ALPHA public="1" get="inline" set="null" expr="cast 8" line="6" static="1">
			<x path="openfl.display.BitmapDataChannel"/>
			<meta>
				<m n=":value"><e>cast 8</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</ALPHA>
		<BLUE public="1" get="inline" set="null" expr="cast 4" line="7" static="1">
			<x path="openfl.display.BitmapDataChannel"/>
			<meta>
				<m n=":value"><e>cast 4</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</BLUE>
		<GREEN public="1" get="inline" set="null" expr="cast 2" line="8" static="1">
			<x path="openfl.display.BitmapDataChannel"/>
			<meta>
				<m n=":value"><e>cast 2</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</GREEN>
		<RED public="1" get="inline" set="null" expr="cast 1" line="9" static="1">
			<x path="openfl.display.BitmapDataChannel"/>
			<meta>
				<m n=":value"><e>cast 1</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</RED>
		<meta>
			<m n=":final"/>
			<m n=":enum"/>
		</meta>
	</class>
	<abstract path="openfl.display.BlendMode" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/display/BlendMode.hx">
		<from><icast field="fromString"><c path="String"/></icast></from>
		<this><t path="Null"><x path="Int"/></t></this>
		<to><icast field="toString"><c path="String"/></icast></to>
		<meta><m n=":enum"/></meta>
		<impl><class path="openfl.display._BlendMode.BlendMode_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/display/BlendMode.hx" private="1" module="openfl.display.BlendMode">
	<ADD public="1" get="inline" set="null" expr="cast 0" line="6" static="1">
		<x path="openfl.display.BlendMode"/>
		<meta>
			<m n=":value"><e>cast 0</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</ADD>
	<ALPHA public="1" get="inline" set="null" expr="cast 1" line="7" static="1">
		<x path="openfl.display.BlendMode"/>
		<meta>
			<m n=":value"><e>cast 1</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</ALPHA>
	<DARKEN public="1" get="inline" set="null" expr="cast 2" line="8" static="1">
		<x path="openfl.display.BlendMode"/>
		<meta>
			<m n=":value"><e>cast 2</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</DARKEN>
	<DIFFERENCE public="1" get="inline" set="null" expr="cast 3" line="9" static="1">
		<x path="openfl.display.BlendMode"/>
		<meta>
			<m n=":value"><e>cast 3</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</DIFFERENCE>
	<ERASE public="1" get="inline" set="null" expr="cast 4" line="10" static="1">
		<x path="openfl.display.BlendMode"/>
		<meta>
			<m n=":value"><e>cast 4</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</ERASE>
	<HARDLIGHT public="1" get="inline" set="null" expr="cast 5" line="11" static="1">
		<x path="openfl.display.BlendMode"/>
		<meta>
			<m n=":value"><e>cast 5</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</HARDLIGHT>
	<INVERT public="1" get="inline" set="null" expr="cast 6" line="12" static="1">
		<x path="openfl.display.BlendMode"/>
		<meta>
			<m n=":value"><e>cast 6</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</INVERT>
	<LAYER public="1" get="inline" set="null" expr="cast 7" line="13" static="1">
		<x path="openfl.display.BlendMode"/>
		<meta>
			<m n=":value"><e>cast 7</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</LAYER>
	<LIGHTEN public="1" get="inline" set="null" expr="cast 8" line="14" static="1">
		<x path="openfl.display.BlendMode"/>
		<meta>
			<m n=":value"><e>cast 8</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</LIGHTEN>
	<MULTIPLY public="1" get="inline" set="null" expr="cast 9" line="15" static="1">
		<x path="openfl.display.BlendMode"/>
		<meta>
			<m n=":value"><e>cast 9</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</MULTIPLY>
	<NORMAL public="1" get="inline" set="null" expr="cast 10" line="16" static="1">
		<x path="openfl.display.BlendMode"/>
		<meta>
			<m n=":value"><e>cast 10</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NORMAL>
	<OVERLAY public="1" get="inline" set="null" expr="cast 11" line="17" static="1">
		<x path="openfl.display.BlendMode"/>
		<meta>
			<m n=":value"><e>cast 11</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</OVERLAY>
	<SCREEN public="1" get="inline" set="null" expr="cast 12" line="18" static="1">
		<x path="openfl.display.BlendMode"/>
		<meta>
			<m n=":value"><e>cast 12</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</SCREEN>
	<SHADER public="1" get="inline" set="null" expr="cast 13" line="19" static="1">
		<x path="openfl.display.BlendMode"/>
		<meta>
			<m n=":value"><e>cast 13</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</SHADER>
	<SUBTRACT public="1" get="inline" set="null" expr="cast 14" line="20" static="1">
		<x path="openfl.display.BlendMode"/>
		<meta>
			<m n=":value"><e>cast 14</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</SUBTRACT>
	<fromString set="method" line="22" static="1">
		<f a="value">
			<c path="String"/>
			<x path="openfl.display.BlendMode"/>
		</f>
		<meta><m n=":from"/></meta>
	</fromString>
	<toString set="method" line="47" static="1">
		<f a="value">
			<x path="Int"/>
			<c path="String"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":to"/>
		</meta>
	</toString>
	<meta>
		<m n=":final"/>
		<m n=":enum"/>
	</meta>
</class></impl>
	</abstract>
	<class path="openfl.display._BlendMode.BlendMode_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/display/BlendMode.hx" private="1" module="openfl.display.BlendMode">
		<ADD public="1" get="inline" set="null" expr="cast 0" line="6" static="1">
			<x path="openfl.display.BlendMode"/>
			<meta>
				<m n=":value"><e>cast 0</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</ADD>
		<ALPHA public="1" get="inline" set="null" expr="cast 1" line="7" static="1">
			<x path="openfl.display.BlendMode"/>
			<meta>
				<m n=":value"><e>cast 1</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</ALPHA>
		<DARKEN public="1" get="inline" set="null" expr="cast 2" line="8" static="1">
			<x path="openfl.display.BlendMode"/>
			<meta>
				<m n=":value"><e>cast 2</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</DARKEN>
		<DIFFERENCE public="1" get="inline" set="null" expr="cast 3" line="9" static="1">
			<x path="openfl.display.BlendMode"/>
			<meta>
				<m n=":value"><e>cast 3</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</DIFFERENCE>
		<ERASE public="1" get="inline" set="null" expr="cast 4" line="10" static="1">
			<x path="openfl.display.BlendMode"/>
			<meta>
				<m n=":value"><e>cast 4</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</ERASE>
		<HARDLIGHT public="1" get="inline" set="null" expr="cast 5" line="11" static="1">
			<x path="openfl.display.BlendMode"/>
			<meta>
				<m n=":value"><e>cast 5</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</HARDLIGHT>
		<INVERT public="1" get="inline" set="null" expr="cast 6" line="12" static="1">
			<x path="openfl.display.BlendMode"/>
			<meta>
				<m n=":value"><e>cast 6</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</INVERT>
		<LAYER public="1" get="inline" set="null" expr="cast 7" line="13" static="1">
			<x path="openfl.display.BlendMode"/>
			<meta>
				<m n=":value"><e>cast 7</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</LAYER>
		<LIGHTEN public="1" get="inline" set="null" expr="cast 8" line="14" static="1">
			<x path="openfl.display.BlendMode"/>
			<meta>
				<m n=":value"><e>cast 8</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</LIGHTEN>
		<MULTIPLY public="1" get="inline" set="null" expr="cast 9" line="15" static="1">
			<x path="openfl.display.BlendMode"/>
			<meta>
				<m n=":value"><e>cast 9</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</MULTIPLY>
		<NORMAL public="1" get="inline" set="null" expr="cast 10" line="16" static="1">
			<x path="openfl.display.BlendMode"/>
			<meta>
				<m n=":value"><e>cast 10</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NORMAL>
		<OVERLAY public="1" get="inline" set="null" expr="cast 11" line="17" static="1">
			<x path="openfl.display.BlendMode"/>
			<meta>
				<m n=":value"><e>cast 11</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</OVERLAY>
		<SCREEN public="1" get="inline" set="null" expr="cast 12" line="18" static="1">
			<x path="openfl.display.BlendMode"/>
			<meta>
				<m n=":value"><e>cast 12</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</SCREEN>
		<SHADER public="1" get="inline" set="null" expr="cast 13" line="19" static="1">
			<x path="openfl.display.BlendMode"/>
			<meta>
				<m n=":value"><e>cast 13</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</SHADER>
		<SUBTRACT public="1" get="inline" set="null" expr="cast 14" line="20" static="1">
			<x path="openfl.display.BlendMode"/>
			<meta>
				<m n=":value"><e>cast 14</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</SUBTRACT>
		<fromString set="method" line="22" static="1">
			<f a="value">
				<c path="String"/>
				<x path="openfl.display.BlendMode"/>
			</f>
			<meta><m n=":from"/></meta>
		</fromString>
		<toString set="method" line="47" static="1">
			<f a="value">
				<x path="Int"/>
				<c path="String"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":to"/>
			</meta>
		</toString>
		<meta>
			<m n=":final"/>
			<m n=":enum"/>
		</meta>
	</class>
	<abstract path="openfl.display.CapsStyle" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/display/CapsStyle.hx">
		<from><icast field="fromString"><c path="String"/></icast></from>
		<this><t path="Null"><x path="Int"/></t></this>
		<to><icast field="toString"><c path="String"/></icast></to>
		<meta><m n=":enum"/></meta>
		<impl><class path="openfl.display._CapsStyle.CapsStyle_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/display/CapsStyle.hx" private="1" module="openfl.display.CapsStyle">
	<NONE public="1" get="inline" set="null" expr="cast 0" line="6" static="1">
		<x path="openfl.display.CapsStyle"/>
		<meta>
			<m n=":value"><e>cast 0</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NONE>
	<ROUND public="1" get="inline" set="null" expr="cast 1" line="7" static="1">
		<x path="openfl.display.CapsStyle"/>
		<meta>
			<m n=":value"><e>cast 1</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</ROUND>
	<SQUARE public="1" get="inline" set="null" expr="cast 2" line="8" static="1">
		<x path="openfl.display.CapsStyle"/>
		<meta>
			<m n=":value"><e>cast 2</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</SQUARE>
	<fromString set="method" line="10" static="1">
		<f a="value">
			<c path="String"/>
			<x path="openfl.display.CapsStyle"/>
		</f>
		<meta><m n=":from"/></meta>
	</fromString>
	<toString set="method" line="23" static="1">
		<f a="value">
			<x path="Int"/>
			<c path="String"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":to"/>
		</meta>
	</toString>
	<meta>
		<m n=":final"/>
		<m n=":enum"/>
	</meta>
</class></impl>
	</abstract>
	<class path="openfl.display._CapsStyle.CapsStyle_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/display/CapsStyle.hx" private="1" module="openfl.display.CapsStyle">
		<NONE public="1" get="inline" set="null" expr="cast 0" line="6" static="1">
			<x path="openfl.display.CapsStyle"/>
			<meta>
				<m n=":value"><e>cast 0</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NONE>
		<ROUND public="1" get="inline" set="null" expr="cast 1" line="7" static="1">
			<x path="openfl.display.CapsStyle"/>
			<meta>
				<m n=":value"><e>cast 1</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</ROUND>
		<SQUARE public="1" get="inline" set="null" expr="cast 2" line="8" static="1">
			<x path="openfl.display.CapsStyle"/>
			<meta>
				<m n=":value"><e>cast 2</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</SQUARE>
		<fromString set="method" line="10" static="1">
			<f a="value">
				<c path="String"/>
				<x path="openfl.display.CapsStyle"/>
			</f>
			<meta><m n=":from"/></meta>
		</fromString>
		<toString set="method" line="23" static="1">
			<f a="value">
				<x path="Int"/>
				<c path="String"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":to"/>
			</meta>
		</toString>
		<meta>
			<m n=":final"/>
			<m n=":enum"/>
		</meta>
	</class>
	<class path="openfl.display.FrameLabel" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/display/FrameLabel.hx">
		<extends path="openfl.events.EventDispatcher"/>
		<frame public="1" get="accessor" set="null"><x path="Int"/></frame>
		<name public="1" get="accessor" set="null"><c path="String"/></name>
		<__frame><x path="Int"/></__frame>
		<__name><c path="String"/></__name>
		<get_frame set="method" line="34"><f a=""><x path="Int"/></f></get_frame>
		<get_name set="method" line="35"><f a=""><c path="String"/></f></get_name>
		<new public="1" set="method" line="17"><f a="name:frame">
	<c path="String"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":final"/></meta>
	</class>
	<abstract path="openfl.display.GradientType" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/display/GradientType.hx">
		<from><icast field="fromString"><c path="String"/></icast></from>
		<this><t path="Null"><x path="Int"/></t></this>
		<to><icast field="toString"><c path="String"/></icast></to>
		<meta><m n=":enum"/></meta>
		<impl><class path="openfl.display._GradientType.GradientType_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/display/GradientType.hx" private="1" module="openfl.display.GradientType">
	<LINEAR public="1" get="inline" set="null" expr="cast 0" line="6" static="1">
		<x path="openfl.display.GradientType"/>
		<meta>
			<m n=":value"><e>cast 0</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</LINEAR>
	<RADIAL public="1" get="inline" set="null" expr="cast 1" line="7" static="1">
		<x path="openfl.display.GradientType"/>
		<meta>
			<m n=":value"><e>cast 1</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</RADIAL>
	<fromString set="method" line="9" static="1">
		<f a="value">
			<c path="String"/>
			<x path="openfl.display.GradientType"/>
		</f>
		<meta><m n=":from"/></meta>
	</fromString>
	<toString set="method" line="21" static="1">
		<f a="value">
			<x path="Int"/>
			<c path="String"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":to"/>
		</meta>
	</toString>
	<meta>
		<m n=":final"/>
		<m n=":enum"/>
	</meta>
</class></impl>
	</abstract>
	<class path="openfl.display._GradientType.GradientType_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/display/GradientType.hx" private="1" module="openfl.display.GradientType">
		<LINEAR public="1" get="inline" set="null" expr="cast 0" line="6" static="1">
			<x path="openfl.display.GradientType"/>
			<meta>
				<m n=":value"><e>cast 0</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</LINEAR>
		<RADIAL public="1" get="inline" set="null" expr="cast 1" line="7" static="1">
			<x path="openfl.display.GradientType"/>
			<meta>
				<m n=":value"><e>cast 1</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</RADIAL>
		<fromString set="method" line="9" static="1">
			<f a="value">
				<c path="String"/>
				<x path="openfl.display.GradientType"/>
			</f>
			<meta><m n=":from"/></meta>
		</fromString>
		<toString set="method" line="21" static="1">
			<f a="value">
				<x path="Int"/>
				<c path="String"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":to"/>
			</meta>
		</toString>
		<meta>
			<m n=":final"/>
			<m n=":enum"/>
		</meta>
	</class>
	<class path="openfl.display.Graphics" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/display/Graphics.hx">
		<TILE_SCALE public="1" get="inline" set="null" expr="0x0001" line="39" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x0001</e></m></meta>
		</TILE_SCALE>
		<TILE_ROTATION public="1" get="inline" set="null" expr="0x0002" line="40" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x0002</e></m></meta>
		</TILE_ROTATION>
		<TILE_RGB public="1" get="inline" set="null" expr="0x0004" line="41" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x0004</e></m></meta>
		</TILE_RGB>
		<TILE_ALPHA public="1" get="inline" set="null" expr="0x0008" line="42" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x0008</e></m></meta>
		</TILE_ALPHA>
		<TILE_TRANS_2x2 public="1" get="inline" set="null" expr="0x0010" line="43" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x0010</e></m></meta>
		</TILE_TRANS_2x2>
		<TILE_RECT public="1" get="inline" set="null" expr="0x0020" line="44" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x0020</e></m></meta>
		</TILE_RECT>
		<TILE_ORIGIN public="1" get="inline" set="null" expr="0x0040" line="45" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x0040</e></m></meta>
		</TILE_ORIGIN>
		<TILE_BLEND_NORMAL public="1" get="inline" set="null" expr="0x00000000" line="47" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x00000000</e></m></meta>
		</TILE_BLEND_NORMAL>
		<TILE_BLEND_ADD public="1" get="inline" set="null" expr="0x00010000" line="48" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x00010000</e></m></meta>
		</TILE_BLEND_ADD>
		<TILE_BLEND_MULTIPLY public="1" get="inline" set="null" expr="0x00020000" line="49" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x00020000</e></m></meta>
		</TILE_BLEND_MULTIPLY>
		<TILE_BLEND_SCREEN public="1" get="inline" set="null" expr="0x00040000" line="50" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x00040000</e></m></meta>
		</TILE_BLEND_SCREEN>
		<TILE_BLEND_SUBTRACT public="1" get="inline" set="null" expr="0x00080000" line="51" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x00080000</e></m></meta>
		</TILE_BLEND_SUBTRACT>
		<TILE_BLEND_DARKEN public="1" get="inline" set="null" expr="0x00100000" line="52" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x00100000</e></m></meta>
		</TILE_BLEND_DARKEN>
		<TILE_BLEND_LIGHTEN public="1" get="inline" set="null" expr="0x00200000" line="53" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x00200000</e></m></meta>
		</TILE_BLEND_LIGHTEN>
		<TILE_BLEND_OVERLAY public="1" get="inline" set="null" expr="0x00400000" line="54" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x00400000</e></m></meta>
		</TILE_BLEND_OVERLAY>
		<TILE_BLEND_HARDLIGHT public="1" get="inline" set="null" expr="0x00800000" line="55" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x00800000</e></m></meta>
		</TILE_BLEND_HARDLIGHT>
		<TILE_BLEND_DIFFERENCE public="1" get="inline" set="null" expr="0x01000000" line="56" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x01000000</e></m></meta>
		</TILE_BLEND_DIFFERENCE>
		<TILE_BLEND_INVERT public="1" get="inline" set="null" expr="0x02000000" line="57" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x02000000</e></m></meta>
		</TILE_BLEND_INVERT>
		<__hardware public="1"><x path="Bool"/></__hardware>
		<__bounds><c path="openfl.geom.Rectangle"/></__bounds>
		<__commands><c path="openfl._internal.renderer.DrawCommandBuffer"/></__commands>
		<__dirty set="accessor" expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</__dirty>
		<__glStack expr="[]">
			<c path="Array"><c path="openfl._internal.renderer.opengl.utils.GLStack"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</__glStack>
		<__drawPaths><c path="Array"><c path="openfl._internal.renderer.opengl.utils.DrawPath"/></c></__drawPaths>
		<__image><c path="lime.graphics.Image"/></__image>
		<__positionX><x path="Float"/></__positionX>
		<__positionY><x path="Float"/></__positionY>
		<__strokePadding><x path="Float"/></__strokePadding>
		<__transformDirty><x path="Bool"/></__transformDirty>
		<__visible><x path="Bool"/></__visible>
		<__cachedTexture><c path="openfl._internal.renderer.opengl.utils.RenderTexture"/></__cachedTexture>
		<__owner><c path="openfl.display.DisplayObject"/></__owner>
		<__cairo><c path="lime.graphics.cairo.Cairo"/></__cairo>
		<__bitmap><c path="openfl.display.BitmapData"/></__bitmap>
		<beginBitmapFill public="1" set="method" line="100">
			<f a="bitmap:?matrix:?repeat:?smooth" v=":null:true:false">
				<c path="openfl.display.BitmapData"/>
				<c path="openfl.geom.Matrix"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ smooth : false, repeat : true, matrix : null }</e></m></meta>
		</beginBitmapFill>
		<beginFill public="1" set="method" line="109">
			<f a="?color:?alpha" v="0:1">
				<x path="Int"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ alpha : 1, color : 0 }</e></m></meta>
		</beginFill>
		<beginGradientFill public="1" set="method" line="118">
			<f a="type:colors:alphas:ratios:?matrix:?spreadMethod:?interpolationMethod:?focalPointRatio" v="::::null:SpreadMethod.PAD:InterpolationMethod.RGB:0">
				<x path="openfl.display.GradientType"/>
				<c path="Array"><x path="Int"/></c>
				<c path="Array"><x path="Float"/></c>
				<c path="Array"><x path="Int"/></c>
				<c path="openfl.geom.Matrix"/>
				<x path="openfl.display.SpreadMethod"/>
				<x path="openfl.display.InterpolationMethod"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ focalPointRatio : 0, interpolationMethod : InterpolationMethod.RGB, spreadMethod : SpreadMethod.PAD, matrix : null }</e></m></meta>
		</beginGradientFill>
		<clear public="1" set="method" line="137"><f a=""><x path="Void"/></f></clear>
		<copyFrom public="1" set="method" line="160"><f a="sourceGraphics">
	<c path="openfl.display.Graphics"/>
	<x path="Void"/>
</f></copyFrom>
		<cubicCurveTo public="1" set="method" line="174"><f a="controlX1:controlY1:controlX2:controlY2:anchorX:anchorY">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></cubicCurveTo>
		<curveTo public="1" set="method" line="249"><f a="controlX:controlY:anchorX:anchorY">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></curveTo>
		<drawCircle public="1" set="method" line="292"><f a="x:y:radius">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></drawCircle>
		<drawEllipse public="1" set="method" line="307"><f a="x:y:width:height">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></drawEllipse>
		<drawGraphicsData public="1" set="method" line="322"><f a="graphicsData">
	<x path="openfl.Vector"><c path="openfl.display.IGraphicsData"/></x>
	<x path="Void"/>
</f></drawGraphicsData>
		<drawPath public="1" set="method" line="390">
			<f a="commands:data:?winding" v="::GraphicsPathWinding.EVEN_ODD">
				<x path="openfl.Vector"><x path="Int"/></x>
				<x path="openfl.Vector"><x path="Float"/></x>
				<x path="openfl.display.GraphicsPathWinding"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ winding : GraphicsPathWinding.EVEN_ODD }</e></m></meta>
		</drawPath>
		<drawRect public="1" set="method" line="437"><f a="x:y:width:height">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></drawRect>
		<drawRoundRect public="1" set="method" line="451">
			<f a="x:y:width:height:ellipseWidth:?ellipseHeight" v=":::::null">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ ellipseHeight : null }</e></m></meta>
		</drawRoundRect>
		<drawRoundRectComplex public="1" set="method" line="466"><f a="x:y:width:height:topLeftRadius:topRightRadius:bottomLeftRadius:bottomRightRadius">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></drawRoundRectComplex>
		<drawTiles public="1" set="method" line="473">
			<f a="sheet:tileData:?smooth:?flags:?shader:?count" v="::false:0::-1">
				<c path="openfl.display.Tilesheet"/>
				<c path="Array"><x path="Float"/></c>
				<x path="Bool"/>
				<x path="Int"/>
				<c path="openfl.display.Shader"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ count : -1, flags : 0, smooth : false }</e></m></meta>
		</drawTiles>
		<drawTriangles public="1" set="method" line="690">
			<f a="vertices:?indices:?uvtData:?culling" v=":null:null:TriangleCulling.NONE">
				<x path="openfl.Vector"><x path="Float"/></x>
				<x path="openfl.Vector"><x path="Int"/></x>
				<x path="openfl.Vector"><x path="Float"/></x>
				<x path="openfl.display.TriangleCulling"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ culling : TriangleCulling.NONE, uvtData : null, indices : null }</e></m></meta>
		</drawTriangles>
		<endFill public="1" set="method" line="743"><f a=""><x path="Void"/></f></endFill>
		<lineBitmapStyle public="1" set="method" line="750">
			<f a="bitmap:?matrix:?repeat:?smooth" v=":null:true:false">
				<c path="openfl.display.BitmapData"/>
				<c path="openfl.geom.Matrix"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ smooth : false, repeat : true, matrix : null }</e></m></meta>
		</lineBitmapStyle>
		<lineGradientStyle public="1" set="method" line="757">
			<f a="type:colors:alphas:ratios:?matrix:?spreadMethod:?interpolationMethod:?focalPointRatio" v="::::null:SpreadMethod.PAD:InterpolationMethod.RGB:0">
				<x path="openfl.display.GradientType"/>
				<c path="Array"><x path="Int"/></c>
				<c path="Array"><x path="Float"/></c>
				<c path="Array"><x path="Int"/></c>
				<c path="openfl.geom.Matrix"/>
				<x path="openfl.display.SpreadMethod"/>
				<x path="openfl.display.InterpolationMethod"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ focalPointRatio : 0, interpolationMethod : InterpolationMethod.RGB, spreadMethod : SpreadMethod.PAD, matrix : null }</e></m></meta>
		</lineGradientStyle>
		<lineStyle public="1" set="method" line="764">
			<f a="?thickness:?color:?alpha:?pixelHinting:?scaleMode:?caps:?joints:?miterLimit" v="null:0:1:false:LineScaleMode.NORMAL:null:null:3">
				<x path="Float"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Bool"/>
				<x path="openfl.display.LineScaleMode"/>
				<x path="openfl.display.CapsStyle"/>
				<x path="openfl.display.JointStyle"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ miterLimit : 3, joints : null, caps : null, scaleMode : LineScaleMode.NORMAL, pixelHinting : false, alpha : 1, color : 0, thickness : null }</e></m></meta>
		</lineStyle>
		<lineTo public="1" set="method" line="787"><f a="x:y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></lineTo>
		<moveTo public="1" set="method" line="808"><f a="x:y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></moveTo>
		<__calculateBezierCubicPoint set="method" line="818"><f a="t:p1:p2:p3:p4">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></__calculateBezierCubicPoint>
		<__calculateBezierQuadPoint set="method" line="826"><f a="t:p1:p2:p3">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></__calculateBezierQuadPoint>
		<__getBounds set="method" line="834"><f a="rect:matrix">
	<c path="openfl.geom.Rectangle"/>
	<c path="openfl.geom.Matrix"/>
	<x path="Void"/>
</f></__getBounds>
		<__hitTest set="method" line="845"><f a="x:y:shapeFlag:matrix">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Bool"/>
	<c path="openfl.geom.Matrix"/>
	<x path="Bool"/>
</f></__hitTest>
		<__inflateBounds set="method" line="872"><f a="x:y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></__inflateBounds>
		<set___dirty set="method" line="920"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set___dirty>
		<new set="method" line="85"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":access"><e>openfl.geom.Matrix</e></m>
			<m n=":access"><e>openfl.geom.Rectangle</e></m>
			<m n=":final"/>
		</meta>
	</class>
	<class path="openfl.display.IGraphicsFill" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/display/IGraphicsFill.hx" interface="1"><__graphicsFillType public="1" set="null"><e path="openfl.display.GraphicsFillType"/></__graphicsFillType></class>
	<class path="openfl.display.IGraphicsData" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/display/IGraphicsData.hx" interface="1"><__graphicsDataType public="1" set="null"><e path="openfl.display.GraphicsDataType"/></__graphicsDataType></class>
	<class path="openfl.display.GraphicsBitmapFill" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/display/GraphicsBitmapFill.hx">
		<implements path="openfl.display.IGraphicsFill"/>
		<implements path="openfl.display.IGraphicsData"/>
		<bitmapData public="1"><c path="openfl.display.BitmapData"/></bitmapData>
		<matrix public="1"><c path="openfl.geom.Matrix"/></matrix>
		<repeat public="1"><x path="Bool"/></repeat>
		<smooth public="1"><x path="Bool"/></smooth>
		<__graphicsDataType public="1" set="null"><e path="openfl.display.GraphicsDataType"/></__graphicsDataType>
		<__graphicsFillType public="1" set="null"><e path="openfl.display.GraphicsFillType"/></__graphicsFillType>
		<new public="1" set="method" line="22">
			<f a="?bitmapData:?matrix:?repeat:?smooth" v="null:null:true:false">
				<c path="openfl.display.BitmapData"/>
				<c path="openfl.geom.Matrix"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ smooth : false, repeat : true, matrix : null, bitmapData : null }</e></m></meta>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":final"/>
		</meta>
	</class>
	<class path="openfl.display.GraphicsEndFill" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/display/GraphicsEndFill.hx">
		<implements path="openfl.display.IGraphicsFill"/>
		<implements path="openfl.display.IGraphicsData"/>
		<__graphicsDataType public="1" set="null"><e path="openfl.display.GraphicsDataType"/></__graphicsDataType>
		<__graphicsFillType public="1" set="null"><e path="openfl.display.GraphicsFillType"/></__graphicsFillType>
		<new public="1" set="method" line="15"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":final"/>
		</meta>
	</class>
	<class path="openfl.display.GraphicsGradientFill" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/display/GraphicsGradientFill.hx">
		<implements path="openfl.display.IGraphicsFill"/>
		<implements path="openfl.display.IGraphicsData"/>
		<alphas public="1"><c path="Array"><x path="Float"/></c></alphas>
		<colors public="1"><c path="Array"><x path="Int"/></c></colors>
		<focalPointRatio public="1"><x path="Float"/></focalPointRatio>
		<interpolationMethod public="1"><x path="openfl.display.InterpolationMethod"/></interpolationMethod>
		<matrix public="1"><c path="openfl.geom.Matrix"/></matrix>
		<ratios public="1"><c path="Array"><x path="Int"/></c></ratios>
		<spreadMethod public="1"><x path="openfl.display.SpreadMethod"/></spreadMethod>
		<type public="1"><x path="openfl.display.GradientType"/></type>
		<__graphicsDataType public="1" set="null"><e path="openfl.display.GraphicsDataType"/></__graphicsDataType>
		<__graphicsFillType public="1" set="null"><e path="openfl.display.GraphicsFillType"/></__graphicsFillType>
		<new public="1" set="method" line="25">
			<f a="?type:?colors:?alphas:?ratios:?matrix:?spreadMethod:?interpolationMethod:?focalPointRatio" v="null:null:null:null:null:null:null:0">
				<x path="openfl.display.GradientType"/>
				<c path="Array"><x path="Int"/></c>
				<c path="Array"><x path="Float"/></c>
				<c path="Array"><x path="Int"/></c>
				<c path="openfl.geom.Matrix"/>
				<x path="openfl.display.SpreadMethod"/>
				<x path="openfl.display.InterpolationMethod"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ focalPointRatio : 0, interpolationMethod : null, spreadMethod : null, matrix : null, ratios : null, alphas : null, colors : null, type : null }</e></m></meta>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":final"/>
		</meta>
	</class>
	<class path="openfl.display.IGraphicsPath" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/display/IGraphicsPath.hx" interface="1"/>
	<class path="openfl.display.GraphicsPath" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/display/GraphicsPath.hx">
		<implements path="openfl.display.IGraphicsPath"/>
		<implements path="openfl.display.IGraphicsData"/>
		<commands public="1"><x path="openfl.Vector"><x path="Int"/></x></commands>
		<data public="1"><x path="openfl.Vector"><x path="Float"/></x></data>
		<winding public="1"><x path="openfl.display.GraphicsPathWinding"/></winding>
		<__graphicsDataType public="1" set="null"><e path="openfl.display.GraphicsDataType"/></__graphicsDataType>
		<curveTo public="1" set="method" line="34"><f a="controlX:controlY:anchorX:anchorY">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></curveTo>
		<lineTo public="1" set="method" line="49"><f a="x:y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></lineTo>
		<moveTo public="1" set="method" line="62"><f a="x:y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></moveTo>
		<wideLineTo public="1" set="method" line="75"><f a="x:y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></wideLineTo>
		<wideMoveTo public="1" set="method" line="88"><f a="x:y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></wideMoveTo>
		<new public="1" set="method" line="18">
			<f a="?commands:?data:?winding" v="null:null:null">
				<x path="openfl.Vector"><x path="Int"/></x>
				<x path="openfl.Vector"><x path="Float"/></x>
				<x path="openfl.display.GraphicsPathWinding"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ winding : null, data : null, commands : null }</e></m></meta>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":final"/>
		</meta>
	</class>
	<abstract path="openfl.display.GraphicsPathCommand" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/display/GraphicsPathCommand.hx">
		<from><icast><x path="Int"/></icast></from>
		<this><x path="Int"/></this>
		<to><icast><x path="Int"/></icast></to>
		<meta><m n=":enum"/></meta>
		<impl><class path="openfl.display._GraphicsPathCommand.GraphicsPathCommand_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/display/GraphicsPathCommand.hx" private="1" module="openfl.display.GraphicsPathCommand" extern="1">
	<CUBIC_CURVE_TO public="1" get="inline" set="null" expr="cast 6" line="6" static="1">
		<x path="openfl.display.GraphicsPathCommand"/>
		<meta>
			<m n=":value"><e>cast 6</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</CUBIC_CURVE_TO>
	<CURVE_TO public="1" get="inline" set="null" expr="cast 3" line="7" static="1">
		<x path="openfl.display.GraphicsPathCommand"/>
		<meta>
			<m n=":value"><e>cast 3</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</CURVE_TO>
	<LINE_TO public="1" get="inline" set="null" expr="cast 2" line="8" static="1">
		<x path="openfl.display.GraphicsPathCommand"/>
		<meta>
			<m n=":value"><e>cast 2</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</LINE_TO>
	<MOVE_TO public="1" get="inline" set="null" expr="cast 1" line="9" static="1">
		<x path="openfl.display.GraphicsPathCommand"/>
		<meta>
			<m n=":value"><e>cast 1</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</MOVE_TO>
	<NO_OP public="1" get="inline" set="null" expr="cast 0" line="10" static="1">
		<x path="openfl.display.GraphicsPathCommand"/>
		<meta>
			<m n=":value"><e>cast 0</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NO_OP>
	<WIDE_LINE_TO public="1" get="inline" set="null" expr="cast 5" line="11" static="1">
		<x path="openfl.display.GraphicsPathCommand"/>
		<meta>
			<m n=":value"><e>cast 5</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</WIDE_LINE_TO>
	<WIDE_MOVE_TO public="1" get="inline" set="null" expr="cast 4" line="12" static="1">
		<x path="openfl.display.GraphicsPathCommand"/>
		<meta>
			<m n=":value"><e>cast 4</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</WIDE_MOVE_TO>
	<meta>
		<m n=":final"/>
		<m n=":enum"/>
	</meta>
</class></impl>
	</abstract>
	<class path="openfl.display._GraphicsPathCommand.GraphicsPathCommand_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/display/GraphicsPathCommand.hx" private="1" module="openfl.display.GraphicsPathCommand" extern="1">
		<CUBIC_CURVE_TO public="1" get="inline" set="null" expr="cast 6" line="6" static="1">
			<x path="openfl.display.GraphicsPathCommand"/>
			<meta>
				<m n=":value"><e>cast 6</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</CUBIC_CURVE_TO>
		<CURVE_TO public="1" get="inline" set="null" expr="cast 3" line="7" static="1">
			<x path="openfl.display.GraphicsPathCommand"/>
			<meta>
				<m n=":value"><e>cast 3</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</CURVE_TO>
		<LINE_TO public="1" get="inline" set="null" expr="cast 2" line="8" static="1">
			<x path="openfl.display.GraphicsPathCommand"/>
			<meta>
				<m n=":value"><e>cast 2</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</LINE_TO>
		<MOVE_TO public="1" get="inline" set="null" expr="cast 1" line="9" static="1">
			<x path="openfl.display.GraphicsPathCommand"/>
			<meta>
				<m n=":value"><e>cast 1</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</MOVE_TO>
		<NO_OP public="1" get="inline" set="null" expr="cast 0" line="10" static="1">
			<x path="openfl.display.GraphicsPathCommand"/>
			<meta>
				<m n=":value"><e>cast 0</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NO_OP>
		<WIDE_LINE_TO public="1" get="inline" set="null" expr="cast 5" line="11" static="1">
			<x path="openfl.display.GraphicsPathCommand"/>
			<meta>
				<m n=":value"><e>cast 5</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</WIDE_LINE_TO>
		<WIDE_MOVE_TO public="1" get="inline" set="null" expr="cast 4" line="12" static="1">
			<x path="openfl.display.GraphicsPathCommand"/>
			<meta>
				<m n=":value"><e>cast 4</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</WIDE_MOVE_TO>
		<meta>
			<m n=":final"/>
			<m n=":enum"/>
		</meta>
	</class>
	<abstract path="openfl.display.GraphicsPathWinding" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/display/GraphicsPathWinding.hx">
		<from><icast><c path="String"/></icast></from>
		<this><c path="String"/></this>
		<to><icast><c path="String"/></icast></to>
		<meta><m n=":enum"/></meta>
		<impl><class path="openfl.display._GraphicsPathWinding.GraphicsPathWinding_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/display/GraphicsPathWinding.hx" private="1" module="openfl.display.GraphicsPathWinding" extern="1">
	<EVEN_ODD public="1" get="inline" set="null" expr="cast &quot;evenOdd&quot;" line="6" static="1">
		<x path="openfl.display.GraphicsPathWinding"/>
		<meta>
			<m n=":value"><e>cast "evenOdd"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</EVEN_ODD>
	<NON_ZERO public="1" get="inline" set="null" expr="cast &quot;nonZero&quot;" line="7" static="1">
		<x path="openfl.display.GraphicsPathWinding"/>
		<meta>
			<m n=":value"><e>cast "nonZero"</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NON_ZERO>
	<meta>
		<m n=":final"/>
		<m n=":enum"/>
	</meta>
</class></impl>
	</abstract>
	<class path="openfl.display._GraphicsPathWinding.GraphicsPathWinding_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/display/GraphicsPathWinding.hx" private="1" module="openfl.display.GraphicsPathWinding" extern="1">
		<EVEN_ODD public="1" get="inline" set="null" expr="cast &quot;evenOdd&quot;" line="6" static="1">
			<x path="openfl.display.GraphicsPathWinding"/>
			<meta>
				<m n=":value"><e>cast "evenOdd"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</EVEN_ODD>
		<NON_ZERO public="1" get="inline" set="null" expr="cast &quot;nonZero&quot;" line="7" static="1">
			<x path="openfl.display.GraphicsPathWinding"/>
			<meta>
				<m n=":value"><e>cast "nonZero"</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NON_ZERO>
		<meta>
			<m n=":final"/>
			<m n=":enum"/>
		</meta>
	</class>
	<class path="openfl.display.GraphicsSolidFill" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/display/GraphicsSolidFill.hx">
		<implements path="openfl.display.IGraphicsFill"/>
		<implements path="openfl.display.IGraphicsData"/>
		<alpha public="1"><x path="Float"/></alpha>
		<color public="1"><x path="UInt"/></color>
		<__graphicsDataType public="1" set="null"><e path="openfl.display.GraphicsDataType"/></__graphicsDataType>
		<__graphicsFillType public="1" set="null"><e path="openfl.display.GraphicsFillType"/></__graphicsFillType>
		<new public="1" set="method" line="18">
			<f a="?color:?alpha" v="0:1">
				<x path="UInt"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ alpha : 1, color : 0 }</e></m></meta>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":final"/>
		</meta>
	</class>
	<class path="openfl.display.IGraphicsStroke" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/display/IGraphicsStroke.hx" interface="1"/>
	<class path="openfl.display.GraphicsStroke" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/display/GraphicsStroke.hx">
		<implements path="openfl.display.IGraphicsStroke"/>
		<implements path="openfl.display.IGraphicsData"/>
		<caps public="1"><x path="openfl.display.CapsStyle"/></caps>
		<fill public="1"><c path="openfl.display.IGraphicsFill"/></fill>
		<joints public="1"><x path="openfl.display.JointStyle"/></joints>
		<miterLimit public="1"><x path="Float"/></miterLimit>
		<pixelHinting public="1"><x path="Bool"/></pixelHinting>
		<scaleMode public="1"><x path="openfl.display.LineScaleMode"/></scaleMode>
		<thickness public="1"><x path="Float"/></thickness>
		<__graphicsDataType public="1" set="null"><e path="openfl.display.GraphicsDataType"/></__graphicsDataType>
		<new public="1" set="method" line="21">
			<f a="?thickness:?pixelHinting:?scaleMode:?caps:?joints:?miterLimit:?fill" v="0.0:false:null:null:null:3:null">
				<x path="Float"/>
				<x path="Bool"/>
				<x path="openfl.display.LineScaleMode"/>
				<x path="openfl.display.CapsStyle"/>
				<x path="openfl.display.JointStyle"/>
				<x path="Float"/>
				<c path="openfl.display.IGraphicsFill"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ fill : null, miterLimit : 3, joints : null, caps : null, scaleMode : null, pixelHinting : false, thickness : 0.0 }</e></m></meta>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":final"/>
		</meta>
	</class>
	<enum path="openfl.display.GraphicsDataType" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/display/IGraphicsData.hx" module="openfl.display.IGraphicsData">
		<STROKE/>
		<SOLID/>
		<GRADIENT/>
		<PATH/>
		<BITMAP/>
		<END/>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
			<m n=":fakeEnum"><e>Int</e></m>
		</meta>
	</enum>
	<enum path="openfl.display.GraphicsFillType" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/display/IGraphicsFill.hx" module="openfl.display.IGraphicsFill">
		<SOLID_FILL/>
		<GRADIENT_FILL/>
		<BITMAP_FILL/>
		<END_FILL/>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
			<m n=":fakeEnum"><e>Int</e></m>
		</meta>
	</enum>
	<abstract path="openfl.display.InterpolationMethod" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/display/InterpolationMethod.hx">
		<from><icast field="fromString"><c path="String"/></icast></from>
		<this><t path="Null"><x path="Int"/></t></this>
		<to><icast field="toString"><c path="String"/></icast></to>
		<meta><m n=":enum"/></meta>
		<impl><class path="openfl.display._InterpolationMethod.InterpolationMethod_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/display/InterpolationMethod.hx" private="1" module="openfl.display.InterpolationMethod">
	<LINEAR_RGB public="1" get="inline" set="null" expr="cast 0" line="6" static="1">
		<x path="openfl.display.InterpolationMethod"/>
		<meta>
			<m n=":value"><e>cast 0</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</LINEAR_RGB>
	<RGB public="1" get="inline" set="null" expr="cast 1" line="7" static="1">
		<x path="openfl.display.InterpolationMethod"/>
		<meta>
			<m n=":value"><e>cast 1</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</RGB>
	<fromString set="method" line="9" static="1">
		<f a="value">
			<c path="String"/>
			<x path="openfl.display.InterpolationMethod"/>
		</f>
		<meta><m n=":from"/></meta>
	</fromString>
	<toString set="method" line="21" static="1">
		<f a="value">
			<x path="Int"/>
			<c path="String"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":to"/>
		</meta>
	</toString>
	<meta>
		<m n=":final"/>
		<m n=":enum"/>
	</meta>
</class></impl>
	</abstract>
	<class path="openfl.display._InterpolationMethod.InterpolationMethod_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/display/InterpolationMethod.hx" private="1" module="openfl.display.InterpolationMethod">
		<LINEAR_RGB public="1" get="inline" set="null" expr="cast 0" line="6" static="1">
			<x path="openfl.display.InterpolationMethod"/>
			<meta>
				<m n=":value"><e>cast 0</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</LINEAR_RGB>
		<RGB public="1" get="inline" set="null" expr="cast 1" line="7" static="1">
			<x path="openfl.display.InterpolationMethod"/>
			<meta>
				<m n=":value"><e>cast 1</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</RGB>
		<fromString set="method" line="9" static="1">
			<f a="value">
				<c path="String"/>
				<x path="openfl.display.InterpolationMethod"/>
			</f>
			<meta><m n=":from"/></meta>
		</fromString>
		<toString set="method" line="21" static="1">
			<f a="value">
				<x path="Int"/>
				<c path="String"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":to"/>
			</meta>
		</toString>
		<meta>
			<m n=":final"/>
			<m n=":enum"/>
		</meta>
	</class>
	<class path="openfl.display.JPEGEncoderOptions" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/display/JPEGEncoderOptions.hx">
		<quality public="1"><x path="Int"/></quality>
		<new public="1" set="method" line="10">
			<f a="?quality" v="80">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ quality : 80 }</e></m></meta>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":final"/>
		</meta>
	</class>
	<abstract path="openfl.display.JointStyle" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/display/JointStyle.hx">
		<from><icast field="fromString"><c path="String"/></icast></from>
		<this><t path="Null"><x path="Int"/></t></this>
		<to><icast field="toString"><c path="String"/></icast></to>
		<meta><m n=":enum"/></meta>
		<impl><class path="openfl.display._JointStyle.JointStyle_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/display/JointStyle.hx" private="1" module="openfl.display.JointStyle">
	<BEVEL public="1" get="inline" set="null" expr="cast 0" line="6" static="1">
		<x path="openfl.display.JointStyle"/>
		<meta>
			<m n=":value"><e>cast 0</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</BEVEL>
	<MITER public="1" get="inline" set="null" expr="cast 1" line="7" static="1">
		<x path="openfl.display.JointStyle"/>
		<meta>
			<m n=":value"><e>cast 1</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</MITER>
	<ROUND public="1" get="inline" set="null" expr="cast 2" line="8" static="1">
		<x path="openfl.display.JointStyle"/>
		<meta>
			<m n=":value"><e>cast 2</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</ROUND>
	<fromString set="method" line="10" static="1">
		<f a="value">
			<c path="String"/>
			<x path="openfl.display.JointStyle"/>
		</f>
		<meta><m n=":from"/></meta>
	</fromString>
	<toString set="method" line="23" static="1">
		<f a="value">
			<x path="Int"/>
			<c path="String"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":to"/>
		</meta>
	</toString>
	<meta>
		<m n=":final"/>
		<m n=":enum"/>
	</meta>
</class></impl>
	</abstract>
	<class path="openfl.display._JointStyle.JointStyle_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/display/JointStyle.hx" private="1" module="openfl.display.JointStyle">
		<BEVEL public="1" get="inline" set="null" expr="cast 0" line="6" static="1">
			<x path="openfl.display.JointStyle"/>
			<meta>
				<m n=":value"><e>cast 0</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</BEVEL>
		<MITER public="1" get="inline" set="null" expr="cast 1" line="7" static="1">
			<x path="openfl.display.JointStyle"/>
			<meta>
				<m n=":value"><e>cast 1</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</MITER>
		<ROUND public="1" get="inline" set="null" expr="cast 2" line="8" static="1">
			<x path="openfl.display.JointStyle"/>
			<meta>
				<m n=":value"><e>cast 2</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</ROUND>
		<fromString set="method" line="10" static="1">
			<f a="value">
				<c path="String"/>
				<x path="openfl.display.JointStyle"/>
			</f>
			<meta><m n=":from"/></meta>
		</fromString>
		<toString set="method" line="23" static="1">
			<f a="value">
				<x path="Int"/>
				<c path="String"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":to"/>
			</meta>
		</toString>
		<meta>
			<m n=":final"/>
			<m n=":enum"/>
		</meta>
	</class>
	<abstract path="openfl.display.LineScaleMode" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/display/LineScaleMode.hx">
		<from><icast field="fromString"><c path="String"/></icast></from>
		<this><t path="Null"><x path="Int"/></t></this>
		<to><icast field="toString"><c path="String"/></icast></to>
		<meta><m n=":enum"/></meta>
		<impl><class path="openfl.display._LineScaleMode.LineScaleMode_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/display/LineScaleMode.hx" private="1" module="openfl.display.LineScaleMode">
	<HORIZONTAL public="1" get="inline" set="null" expr="cast 0" line="6" static="1">
		<x path="openfl.display.LineScaleMode"/>
		<meta>
			<m n=":value"><e>cast 0</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</HORIZONTAL>
	<NONE public="1" get="inline" set="null" expr="cast 1" line="7" static="1">
		<x path="openfl.display.LineScaleMode"/>
		<meta>
			<m n=":value"><e>cast 1</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NONE>
	<NORMAL public="1" get="inline" set="null" expr="cast 2" line="8" static="1">
		<x path="openfl.display.LineScaleMode"/>
		<meta>
			<m n=":value"><e>cast 2</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NORMAL>
	<VERTICAL public="1" get="inline" set="null" expr="cast 3" line="9" static="1">
		<x path="openfl.display.LineScaleMode"/>
		<meta>
			<m n=":value"><e>cast 3</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</VERTICAL>
	<fromString set="method" line="11" static="1">
		<f a="value">
			<c path="String"/>
			<x path="openfl.display.LineScaleMode"/>
		</f>
		<meta><m n=":from"/></meta>
	</fromString>
	<toString set="method" line="25" static="1">
		<f a="value">
			<x path="Int"/>
			<c path="String"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":to"/>
		</meta>
	</toString>
	<meta>
		<m n=":final"/>
		<m n=":enum"/>
	</meta>
</class></impl>
	</abstract>
	<class path="openfl.display._LineScaleMode.LineScaleMode_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/display/LineScaleMode.hx" private="1" module="openfl.display.LineScaleMode">
		<HORIZONTAL public="1" get="inline" set="null" expr="cast 0" line="6" static="1">
			<x path="openfl.display.LineScaleMode"/>
			<meta>
				<m n=":value"><e>cast 0</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</HORIZONTAL>
		<NONE public="1" get="inline" set="null" expr="cast 1" line="7" static="1">
			<x path="openfl.display.LineScaleMode"/>
			<meta>
				<m n=":value"><e>cast 1</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NONE>
		<NORMAL public="1" get="inline" set="null" expr="cast 2" line="8" static="1">
			<x path="openfl.display.LineScaleMode"/>
			<meta>
				<m n=":value"><e>cast 2</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NORMAL>
		<VERTICAL public="1" get="inline" set="null" expr="cast 3" line="9" static="1">
			<x path="openfl.display.LineScaleMode"/>
			<meta>
				<m n=":value"><e>cast 3</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</VERTICAL>
		<fromString set="method" line="11" static="1">
			<f a="value">
				<c path="String"/>
				<x path="openfl.display.LineScaleMode"/>
			</f>
			<meta><m n=":from"/></meta>
		</fromString>
		<toString set="method" line="25" static="1">
			<f a="value">
				<x path="Int"/>
				<c path="String"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":to"/>
			</meta>
		</toString>
		<meta>
			<m n=":final"/>
			<m n=":enum"/>
		</meta>
	</class>
	<class path="openfl.display.Loader" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/display/Loader.hx">
		<extends path="openfl.display.DisplayObjectContainer"/>
		<content public="1" set="null"><c path="openfl.display.DisplayObject"/></content>
		<contentLoaderInfo public="1" set="null"><c path="openfl.display.LoaderInfo"/></contentLoaderInfo>
		<mImage><c path="openfl.display.BitmapData"/></mImage>
		<mShape><c path="openfl.display.Shape"/></mShape>
		<close public="1" set="method" line="37"><f a=""><x path="Void"/></f></close>
		<load public="1" set="method" line="44">
			<f a="request:?context" v=":null">
				<c path="openfl.net.URLRequest"/>
				<c path="openfl.system.LoaderContext"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ context : null }</e></m></meta>
		</load>
		<loadBytes public="1" set="method" line="134">
			<f a="buffer:?context" v=":null">
				<x path="openfl.utils.ByteArray"/>
				<c path="openfl.system.LoaderContext"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ context : null }</e></m></meta>
		</loadBytes>
		<unload public="1" set="method" line="150"><f a=""><x path="Void"/></f></unload>
		<unloadAndStop public="1" set="method" line="178">
			<f a="?gc" v="true">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ gc : true }</e></m></meta>
		</unloadAndStop>
		<BitmapData_onLoad set="method" line="192"><f a="bitmapData">
	<c path="openfl.display.BitmapData"/>
	<x path="Void"/>
</f></BitmapData_onLoad>
		<BitmapData_onError set="method" line="206"><f a="_">
	<unknown/>
	<x path="Void"/>
</f></BitmapData_onError>
		<new public="1" set="method" line="28"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":access"><e>openfl.display.LoaderInfo</e></m>
			<m n=":access"><e>openfl.events.Event</e></m>
		</meta>
	</class>
	<class path="openfl.display.PNGEncoderOptions" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/display/PNGEncoderOptions.hx">
		<fastCompression public="1"><x path="Bool"/></fastCompression>
		<new public="1" set="method" line="10">
			<f a="?fastCompression" v="false">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ fastCompression : false }</e></m></meta>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":final"/>
		</meta>
	</class>
	<abstract path="openfl.display.PixelSnapping" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/display/PixelSnapping.hx">
		<from><icast field="fromString"><c path="String"/></icast></from>
		<this><t path="Null"><x path="Int"/></t></this>
		<to><icast field="toString"><c path="String"/></icast></to>
		<meta><m n=":enum"/></meta>
		<impl><class path="openfl.display._PixelSnapping.PixelSnapping_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/display/PixelSnapping.hx" private="1" module="openfl.display.PixelSnapping">
	<ALWAYS public="1" get="inline" set="null" expr="cast 0" line="6" static="1">
		<x path="openfl.display.PixelSnapping"/>
		<meta>
			<m n=":value"><e>cast 0</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</ALWAYS>
	<AUTO public="1" get="inline" set="null" expr="cast 1" line="7" static="1">
		<x path="openfl.display.PixelSnapping"/>
		<meta>
			<m n=":value"><e>cast 1</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</AUTO>
	<NEVER public="1" get="inline" set="null" expr="cast 2" line="8" static="1">
		<x path="openfl.display.PixelSnapping"/>
		<meta>
			<m n=":value"><e>cast 2</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NEVER>
	<fromString set="method" line="10" static="1">
		<f a="value">
			<c path="String"/>
			<x path="openfl.display.PixelSnapping"/>
		</f>
		<meta><m n=":from"/></meta>
	</fromString>
	<toString set="method" line="23" static="1">
		<f a="value">
			<x path="Int"/>
			<c path="String"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":to"/>
		</meta>
	</toString>
	<meta>
		<m n=":final"/>
		<m n=":enum"/>
	</meta>
</class></impl>
	</abstract>
	<class path="openfl.display._PixelSnapping.PixelSnapping_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/display/PixelSnapping.hx" private="1" module="openfl.display.PixelSnapping">
		<ALWAYS public="1" get="inline" set="null" expr="cast 0" line="6" static="1">
			<x path="openfl.display.PixelSnapping"/>
			<meta>
				<m n=":value"><e>cast 0</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</ALWAYS>
		<AUTO public="1" get="inline" set="null" expr="cast 1" line="7" static="1">
			<x path="openfl.display.PixelSnapping"/>
			<meta>
				<m n=":value"><e>cast 1</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</AUTO>
		<NEVER public="1" get="inline" set="null" expr="cast 2" line="8" static="1">
			<x path="openfl.display.PixelSnapping"/>
			<meta>
				<m n=":value"><e>cast 2</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NEVER>
		<fromString set="method" line="10" static="1">
			<f a="value">
				<c path="String"/>
				<x path="openfl.display.PixelSnapping"/>
			</f>
			<meta><m n=":from"/></meta>
		</fromString>
		<toString set="method" line="23" static="1">
			<f a="value">
				<x path="Int"/>
				<c path="String"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":to"/>
			</meta>
		</toString>
		<meta>
			<m n=":final"/>
			<m n=":enum"/>
		</meta>
	</class>
	<class path="openfl.display.Shader" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/display/Shader.hx">
		<uniformRegex expr="~/^\s*uniform\s+(sampler(?:2D|Cube)|[bi]?vec[234]|float|int|bool|mat[234])\s+(\w+)\s*(?:\[(\d+)\])?\s*;.*$/" line="14" static="1">
			<c path="EReg"/>
			<meta>
				<m n=":value"><e>~/^\s*uniform\s+(sampler(?:2D|Cube)|[bi]?vec[234]|float|int|bool|mat[234])\s+(\w+)\s*(?:\[(\d+)\])?\s*;.*$/</e></m>
				<m n=":noCompletion"/>
			</meta>
		</uniformRegex>
		<aPosition public="1" expr="DefaultAttrib.Position" line="19" static="1">
			<x path="openfl._internal.renderer.opengl.shaders2.Attrib"/>
			<meta><m n=":value"><e>DefaultAttrib.Position</e></m></meta>
			<haxe_doc>* Attribute (vec2) with the object position.</haxe_doc>
		</aPosition>
		<aTexCoord public="1" expr="DefaultAttrib.TexCoord" line="23" static="1">
			<x path="openfl._internal.renderer.opengl.shaders2.Attrib"/>
			<meta><m n=":value"><e>DefaultAttrib.TexCoord</e></m></meta>
			<haxe_doc>* Attribute (vec2) with the object texture coordinate.</haxe_doc>
		</aTexCoord>
		<aColor public="1" expr="DefaultAttrib.Color" line="27" static="1">
			<x path="openfl._internal.renderer.opengl.shaders2.Attrib"/>
			<meta><m n=":value"><e>DefaultAttrib.Color</e></m></meta>
			<haxe_doc>* Attribute (vec4) with the tint and alpha values of the object.</haxe_doc>
		</aColor>
		<uSampler public="1" expr="DefaultUniform.Sampler" line="32" static="1">
			<x path="openfl._internal.renderer.opengl.shaders2.Uniform"/>
			<meta><m n=":value"><e>DefaultUniform.Sampler</e></m></meta>
			<haxe_doc>* Uniform (sampler2D) holding the object texture.</haxe_doc>
		</uSampler>
		<uProjectionMatrix public="1" expr="DefaultUniform.ProjectionMatrix" line="36" static="1">
			<x path="openfl._internal.renderer.opengl.shaders2.Uniform"/>
			<meta><m n=":value"><e>DefaultUniform.ProjectionMatrix</e></m></meta>
			<haxe_doc>* Uniform (mat4) holding the projection matrix.</haxe_doc>
		</uProjectionMatrix>
		<uColorMultiplier public="1" expr="DefaultUniform.ColorMultiplier" line="40" static="1">
			<x path="openfl._internal.renderer.opengl.shaders2.Uniform"/>
			<meta><m n=":value"><e>DefaultUniform.ColorMultiplier</e></m></meta>
			<haxe_doc>* Uniform (vec4) holding the colorMultiplier values from the transfrom.colorTransform of the object.</haxe_doc>
		</uColorMultiplier>
		<uColorOffset public="1" expr="DefaultUniform.ColorOffset" line="44" static="1">
			<x path="openfl._internal.renderer.opengl.shaders2.Uniform"/>
			<meta><m n=":value"><e>DefaultUniform.ColorOffset</e></m></meta>
			<haxe_doc>* Uniform (vec4) holding the colorOffset values from the transfrom.colorTransform of the object.</haxe_doc>
		</uColorOffset>
		<uObjectSize public="1" expr="&quot;openfl_uObjectSize&quot;" line="49" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"openfl_uObjectSize"</e></m></meta>
			<haxe_doc>* Uniform (vec2) holding the object width and height. If it's used with Tilesheet.drawTiles() the value will be [0, 0]
	 * For example, if the object is 200x200, the value of this uniform will be 200x200.</haxe_doc>
		</uObjectSize>
		<uTextureSize public="1" expr="&quot;openfl_uTextureSize&quot;" line="54" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"openfl_uTextureSize"</e></m></meta>
			<haxe_doc>* Uniform (vec2) holding the object texture real width and height. If it's used with Tilesheet.drawTiles() the value will be [0, 0]
	 * For example, if the object is 200x200, the value of this uniform will be 256x256.</haxe_doc>
		</uTextureSize>
		<vTexCoord public="1" expr="DefaultVarying.TexCoord" line="59" static="1">
			<x path="openfl._internal.renderer.opengl.shaders2.Varying"/>
			<meta><m n=":value"><e>DefaultVarying.TexCoord</e></m></meta>
			<haxe_doc>* Varying (vec2) with the object texture coordinate.</haxe_doc>
		</vTexCoord>
		<vColor public="1" expr="DefaultVarying.Color" line="63" static="1">
			<x path="openfl._internal.renderer.opengl.shaders2.Varying"/>
			<meta><m n=":value"><e>DefaultVarying.Color</e></m></meta>
			<haxe_doc>* Varying (vec4) with the tint and alpha values of the object.</haxe_doc>
		</vColor>
		<vertexHeader expr="[&quot;attribute vec2 ${Shader.aPosition};&quot;, &quot;attribute vec2 ${Shader.aTexCoord};&quot;, &quot;attribute vec4 ${Shader.aColor};&quot;, &quot;uniform mat3 ${Shader.uProjectionMatrix};&quot;, &quot;uniform vec2 ${Shader.uObjectSize};&quot;, &quot;uniform vec2 ${Shader.uTextureSize};&quot;, &quot;varying vec2 ${Shader.vTexCoord};&quot;, &quot;varying vec4 ${Shader.vColor};&quot;]" line="66" static="1">
			<c path="Array"><c path="String"/></c>
			<meta>
				<m n=":value"><e>["attribute vec2 ${Shader.aPosition};", "attribute vec2 ${Shader.aTexCoord};", "attribute vec4 ${Shader.aColor};", "uniform mat3 ${Shader.uProjectionMatrix};", "uniform vec2 ${Shader.uObjectSize};", "uniform vec2 ${Shader.uTextureSize};", "varying vec2 ${Shader.vTexCoord};", "varying vec4 ${Shader.vColor};"]</e></m>
				<m n=":noCompletion"/>
			</meta>
		</vertexHeader>
		<fragmentHeader expr="[&quot;uniform sampler2D ${Shader.uSampler};&quot;, &quot;uniform vec4 ${Shader.uColorMultiplier};&quot;, &quot;uniform vec4 ${Shader.uColorOffset};&quot;, &quot;uniform vec2 ${Shader.uObjectSize};&quot;, &quot;uniform vec2 ${Shader.uTextureSize};&quot;, &quot;varying vec2 ${Shader.vTexCoord};&quot;, &quot;varying vec4 ${Shader.vColor};&quot;, &quot;vec4 colorTransform(const vec4 color, const vec4 tint, const vec4 multiplier, const vec4 offset) {&quot;, &quot;   vec4 unmultiply = vec4(color.rgb / color.a, color.a);&quot;, &quot;   vec4 result = unmultiply * tint * multiplier;&quot;, &quot;   result = result + offset;&quot;, &quot;   result = clamp(result, 0., 1.);&quot;, &quot;   result = vec4(result.rgb * result.a, result.a);&quot;, &quot;   return result;&quot;, &quot;}&quot;]" line="80" static="1">
			<c path="Array"><c path="String"/></c>
			<meta>
				<m n=":value"><e>["uniform sampler2D ${Shader.uSampler};", "uniform vec4 ${Shader.uColorMultiplier};", "uniform vec4 ${Shader.uColorOffset};", "uniform vec2 ${Shader.uObjectSize};", "uniform vec2 ${Shader.uTextureSize};", "varying vec2 ${Shader.vTexCoord};", "varying vec4 ${Shader.vColor};", "vec4 colorTransform(const vec4 color, const vec4 tint, const vec4 multiplier, const vec4 offset) {", "   vec4 unmultiply = vec4(color.rgb / color.a, color.a);", "   vec4 result = unmultiply * tint * multiplier;", "   result = result + offset;", "   result = clamp(result, 0., 1.);", "   result = vec4(result.rgb * result.a, result.a);", "   return result;", "}"]</e></m>
				<m n=":noCompletion"/>
			</meta>
		</fragmentHeader>
		<precision public="1" expr="MEDIUM">
			<x path="openfl.display.GLShaderPrecision"/>
			<meta><m n=":value"><e>MEDIUM</e></m></meta>
			<haxe_doc>* The shader precision. It can be HIGH, MEDIUM or LOW. Defaults to MEDIUM</haxe_doc>
		</precision>
		<data public="1" set="null">
			<t path="openfl.display.GLShaderData"/>
			<haxe_doc><![CDATA[* A Map<String, GLShaderParameter>]]></haxe_doc>
		</data>
		<repeatX public="1" expr="NONE">
			<x path="openfl.display.RepeatMode"/>
			<meta><m n=":value"><e>NONE</e></m></meta>
			<haxe_doc>* Overrides the default repetition applied to the object's bitmap or cached bitmap.
	 * By default: NONE</haxe_doc>
		</repeatX>
		<repeatY public="1" expr="NONE">
			<x path="openfl.display.RepeatMode"/>
			<meta><m n=":value"><e>NONE</e></m></meta>
			<haxe_doc>* Overrides the default repetition applied to the object's bitmap or cached bitmap.
	 * By default: NONE</haxe_doc>
		</repeatY>
		<smooth public="1">
			<t path="Null"><x path="Bool"/></t>
			<haxe_doc>* Overrides the default smooth applied to the object's bitmap or cached bitmap.
	 * By default: Null (not overriden)</haxe_doc>
		</smooth>
		<blendMode public="1">
			<x path="openfl.display.BlendMode"/>
			<haxe_doc>* Overrides the object blendMode property.
	 * By default: Null (not overriden)</haxe_doc>
		</blendMode>
		<__dirty expr="true">
			<x path="Bool"/>
			<meta>
				<m n=":value"><e>true</e></m>
				<m n=":noCompletion"/>
			</meta>
		</__dirty>
		<__fragmentCode>
			<c path="String"/>
			<meta><m n=":noCompletion"/></meta>
		</__fragmentCode>
		<__vertexCode>
			<c path="String"/>
			<meta><m n=":noCompletion"/></meta>
		</__vertexCode>
		<__shader>
			<t path="openfl._internal.renderer.opengl.shaders2._Shader.InternalShader"/>
			<meta><m n=":noCompletion"/></meta>
		</__shader>
		<__init set="method" line="143">
			<f a="gl">
				<c path="lime.graphics.GLRenderContext"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</__init>
		<__buildFragmentCode set="method" line="158">
			<f a="code">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</__buildFragmentCode>
		<__buildVertexCode set="method" line="177">
			<f a="code">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</__buildVertexCode>
		<new public="1" set="method" line="135">
			<f a="?precision" v="MEDIUM">
				<x path="openfl.display.GLShaderPrecision"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ precision : MEDIUM }</e></m></meta>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":autoBuild"><e>openfl._internal.macros.MacroShader.buildUniforms()</e></m>
		</meta>
	</class>
	<class path="openfl.display.GLShaderParameter" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/display/Shader.hx" module="openfl.display.Shader">
		<type public="1" set="null">
			<c path="String"/>
			<haxe_doc>* The raw type as expressed in the glsl code
	 * For example: vec4 will be "vec4"</haxe_doc>
		</type>
		<size public="1" set="null" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* The size of the value.
	 * For example: vec4 will be 4</haxe_doc>
		</size>
		<arraySize public="1" set="null" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* The size of the array.
	 * For example: uniform vec2 uExample[2]; will be 2</haxe_doc>
		</arraySize>
		<value public="1" set="accessor">
			<c path="Array"><x path="Float"/></c>
			<haxe_doc>* The value of the parameter when the type isn't a sampler2D</haxe_doc>
		</value>
		<bitmap public="1" set="accessor">
			<c path="openfl.display.BitmapData"/>
			<haxe_doc>* The BitmapData to be used when the type is a sampler2D</haxe_doc>
		</bitmap>
		<smooth public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
			<haxe_doc>* Enables linear smoothing to the BitmapData</haxe_doc>
		</smooth>
		<repeatX public="1" expr="NONE">
			<x path="openfl.display.RepeatMode"/>
			<meta><m n=":value"><e>NONE</e></m></meta>
			<haxe_doc>* Controls repetition in the x axis for the BitmapData</haxe_doc>
		</repeatX>
		<repeatY public="1" expr="NONE">
			<x path="openfl.display.RepeatMode"/>
			<meta><m n=":value"><e>NONE</e></m></meta>
			<haxe_doc>* Controls repetition in the y axis for the BitmapData</haxe_doc>
		</repeatY>
		<transpose public="1" expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
			<haxe_doc>* Enables matrices to be transposed. Only used in mat* types.</haxe_doc>
		</transpose>
		<internalType expr="NONE">
			<x path="openfl.display._Shader.GLShaderParameterInternal"/>
			<meta><m n=":value"><e>NONE</e></m></meta>
		</internalType>
		<__init set="method" line="246">
			<f a=""><x path="Void"/></f>
			<meta><m n=":noCompletion"/></meta>
		</__init>
		<set_value get="inline" set="null" line="311">
			<f a="v">
				<c path="Array"><x path="Float"/></c>
				<c path="Array"><x path="Float"/></c>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_value>
		<set_bitmap get="inline" set="null" line="315">
			<f a="v">
				<c path="openfl.display.BitmapData"/>
				<c path="openfl.display.BitmapData"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</set_bitmap>
		<new public="1" set="method" line="239"><f a="type:?arraySize">
	<c path="String"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<abstract path="openfl.display.GLShaderPrecision" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/display/Shader.hx" module="openfl.display.Shader">
		<this><x path="Int"/></this>
		<meta><m n=":enum"/></meta>
		<impl><class path="openfl.display._Shader.GLShaderPrecision_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/display/Shader.hx" private="1" module="openfl.display.Shader" extern="1">
	<LOW public="1" get="inline" set="null" expr="cast 0" line="322" static="1">
		<x path="openfl.display.GLShaderPrecision"/>
		<meta>
			<m n=":value"><e>cast 0</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</LOW>
	<MEDIUM public="1" get="inline" set="null" expr="cast 1" line="323" static="1">
		<x path="openfl.display.GLShaderPrecision"/>
		<meta>
			<m n=":value"><e>cast 1</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</MEDIUM>
	<HIGH public="1" get="inline" set="null" expr="cast 2" line="324" static="1">
		<x path="openfl.display.GLShaderPrecision"/>
		<meta>
			<m n=":value"><e>cast 2</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</HIGH>
	<meta>
		<m n=":final"/>
		<m n=":enum"/>
	</meta>
</class></impl>
	</abstract>
	<class path="openfl.display._Shader.GLShaderPrecision_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/display/Shader.hx" private="1" module="openfl.display.Shader" extern="1">
		<LOW public="1" get="inline" set="null" expr="cast 0" line="322" static="1">
			<x path="openfl.display.GLShaderPrecision"/>
			<meta>
				<m n=":value"><e>cast 0</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</LOW>
		<MEDIUM public="1" get="inline" set="null" expr="cast 1" line="323" static="1">
			<x path="openfl.display.GLShaderPrecision"/>
			<meta>
				<m n=":value"><e>cast 1</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</MEDIUM>
		<HIGH public="1" get="inline" set="null" expr="cast 2" line="324" static="1">
			<x path="openfl.display.GLShaderPrecision"/>
			<meta>
				<m n=":value"><e>cast 2</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</HIGH>
		<meta>
			<m n=":final"/>
			<m n=":enum"/>
		</meta>
	</class>
	<abstract path="openfl.display._Shader.GLShaderParameterInternal" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/display/Shader.hx" private="1" module="openfl.display.Shader">
		<this><x path="Int"/></this>
		<meta><m n=":enum"/></meta>
		<impl><class path="openfl.display._Shader.GLShaderParameterInternal_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/display/Shader.hx" private="1" module="openfl.display.Shader" extern="1">
	<NONE public="1" get="inline" set="null" expr="cast 0" line="329" static="1">
		<x path="openfl.display._Shader.GLShaderParameterInternal"/>
		<meta>
			<m n=":value"><e>cast 0</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NONE>
	<INT public="1" get="inline" set="null" expr="cast 1" line="330" static="1">
		<x path="openfl.display._Shader.GLShaderParameterInternal"/>
		<meta>
			<m n=":value"><e>cast 1</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</INT>
	<FLOAT public="1" get="inline" set="null" expr="cast 2" line="331" static="1">
		<x path="openfl.display._Shader.GLShaderParameterInternal"/>
		<meta>
			<m n=":value"><e>cast 2</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</FLOAT>
	<MAT public="1" get="inline" set="null" expr="cast 3" line="332" static="1">
		<x path="openfl.display._Shader.GLShaderParameterInternal"/>
		<meta>
			<m n=":value"><e>cast 3</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</MAT>
	<SAMPLER public="1" get="inline" set="null" expr="cast 4" line="333" static="1">
		<x path="openfl.display._Shader.GLShaderParameterInternal"/>
		<meta>
			<m n=":value"><e>cast 4</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</SAMPLER>
	<meta>
		<m n=":final"/>
		<m n=":enum"/>
	</meta>
</class></impl>
	</abstract>
	<class path="openfl.display._Shader.GLShaderParameterInternal_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/display/Shader.hx" private="1" module="openfl.display.Shader" extern="1">
		<NONE public="1" get="inline" set="null" expr="cast 0" line="329" static="1">
			<x path="openfl.display._Shader.GLShaderParameterInternal"/>
			<meta>
				<m n=":value"><e>cast 0</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NONE>
		<INT public="1" get="inline" set="null" expr="cast 1" line="330" static="1">
			<x path="openfl.display._Shader.GLShaderParameterInternal"/>
			<meta>
				<m n=":value"><e>cast 1</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</INT>
		<FLOAT public="1" get="inline" set="null" expr="cast 2" line="331" static="1">
			<x path="openfl.display._Shader.GLShaderParameterInternal"/>
			<meta>
				<m n=":value"><e>cast 2</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</FLOAT>
		<MAT public="1" get="inline" set="null" expr="cast 3" line="332" static="1">
			<x path="openfl.display._Shader.GLShaderParameterInternal"/>
			<meta>
				<m n=":value"><e>cast 3</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</MAT>
		<SAMPLER public="1" get="inline" set="null" expr="cast 4" line="333" static="1">
			<x path="openfl.display._Shader.GLShaderParameterInternal"/>
			<meta>
				<m n=":value"><e>cast 4</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</SAMPLER>
		<meta>
			<m n=":final"/>
			<m n=":enum"/>
		</meta>
	</class>
	<abstract path="openfl.display.RepeatMode" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/display/Shader.hx" module="openfl.display.Shader">
		<this><x path="Int"/></this>
		<to><icast><x path="Int"/></icast></to>
		<meta><m n=":enum"/></meta>
		<impl><class path="openfl.display._Shader.RepeatMode_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/display/Shader.hx" private="1" module="openfl.display.Shader" extern="1">
	<NONE public="1" get="inline" set="null" expr="cast GL.CLAMP_TO_EDGE" line="337" static="1">
		<x path="openfl.display.RepeatMode"/>
		<meta>
			<m n=":value"><e>cast GL.CLAMP_TO_EDGE</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NONE>
	<REPEAT public="1" get="inline" set="null" expr="cast GL.REPEAT" line="338" static="1">
		<x path="openfl.display.RepeatMode"/>
		<meta>
			<m n=":value"><e>cast GL.REPEAT</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</REPEAT>
	<MIRROR public="1" get="inline" set="null" expr="cast GL.MIRRORED_REPEAT" line="339" static="1">
		<x path="openfl.display.RepeatMode"/>
		<meta>
			<m n=":value"><e>cast GL.MIRRORED_REPEAT</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</MIRROR>
	<meta>
		<m n=":final"/>
		<m n=":enum"/>
	</meta>
</class></impl>
	</abstract>
	<class path="openfl.display._Shader.RepeatMode_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/display/Shader.hx" private="1" module="openfl.display.Shader" extern="1">
		<NONE public="1" get="inline" set="null" expr="cast GL.CLAMP_TO_EDGE" line="337" static="1">
			<x path="openfl.display.RepeatMode"/>
			<meta>
				<m n=":value"><e>cast GL.CLAMP_TO_EDGE</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NONE>
		<REPEAT public="1" get="inline" set="null" expr="cast GL.REPEAT" line="338" static="1">
			<x path="openfl.display.RepeatMode"/>
			<meta>
				<m n=":value"><e>cast GL.REPEAT</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</REPEAT>
		<MIRROR public="1" get="inline" set="null" expr="cast GL.MIRRORED_REPEAT" line="339" static="1">
			<x path="openfl.display.RepeatMode"/>
			<meta>
				<m n=":value"><e>cast GL.MIRRORED_REPEAT</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</MIRROR>
		<meta>
			<m n=":final"/>
			<m n=":enum"/>
		</meta>
	</class>
	<typedef path="openfl.display.GLShaderData" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/display/Shader.hx" module="openfl.display.Shader"><x path="Map">
	<c path="String"/>
	<c path="openfl.display.GLShaderParameter"/>
</x></typedef>
	<typedef path="openfl.display._Shader.DefaultAttrib" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/display/Shader.hx" private="1" module="openfl.display.Shader"><x path="openfl._internal.renderer.opengl.shaders2.Attrib"/></typedef>
	<typedef path="openfl.display._Shader.DefaultUniform" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/display/Shader.hx" private="1" module="openfl.display.Shader"><x path="openfl._internal.renderer.opengl.shaders2.Uniform"/></typedef>
	<typedef path="openfl.display._Shader.DefaultVarying" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/display/Shader.hx" private="1" module="openfl.display.Shader"><x path="openfl._internal.renderer.opengl.shaders2.Varying"/></typedef>
	<class path="openfl.display.Shape" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/display/Shape.hx">
		<extends path="openfl.display.DisplayObject"/>
		<graphics public="1" get="accessor" set="null"><c path="openfl.display.Graphics"/></graphics>
		<get_graphics set="method" line="27"><f a=""><c path="openfl.display.Graphics"/></f></get_graphics>
		<new public="1" set="method" line="13"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":access"><e>openfl.display.Graphics</e></m>
		</meta>
	</class>
	<abstract path="openfl.display.SpreadMethod" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/display/SpreadMethod.hx">
		<from><icast field="fromString"><c path="String"/></icast></from>
		<this><t path="Null"><x path="Int"/></t></this>
		<to><icast field="toString"><c path="String"/></icast></to>
		<meta><m n=":enum"/></meta>
		<impl><class path="openfl.display._SpreadMethod.SpreadMethod_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/display/SpreadMethod.hx" private="1" module="openfl.display.SpreadMethod">
	<PAD public="1" get="inline" set="null" expr="cast 0" line="6" static="1">
		<x path="openfl.display.SpreadMethod"/>
		<meta>
			<m n=":value"><e>cast 0</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</PAD>
	<REFLECT public="1" get="inline" set="null" expr="cast 1" line="7" static="1">
		<x path="openfl.display.SpreadMethod"/>
		<meta>
			<m n=":value"><e>cast 1</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</REFLECT>
	<REPEAT public="1" get="inline" set="null" expr="cast 2" line="8" static="1">
		<x path="openfl.display.SpreadMethod"/>
		<meta>
			<m n=":value"><e>cast 2</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</REPEAT>
	<fromString set="method" line="10" static="1">
		<f a="value">
			<c path="String"/>
			<x path="openfl.display.SpreadMethod"/>
		</f>
		<meta><m n=":from"/></meta>
	</fromString>
	<toString set="method" line="23" static="1">
		<f a="value">
			<x path="Int"/>
			<c path="String"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":to"/>
		</meta>
	</toString>
	<meta>
		<m n=":final"/>
		<m n=":enum"/>
	</meta>
</class></impl>
	</abstract>
	<class path="openfl.display._SpreadMethod.SpreadMethod_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/display/SpreadMethod.hx" private="1" module="openfl.display.SpreadMethod">
		<PAD public="1" get="inline" set="null" expr="cast 0" line="6" static="1">
			<x path="openfl.display.SpreadMethod"/>
			<meta>
				<m n=":value"><e>cast 0</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</PAD>
		<REFLECT public="1" get="inline" set="null" expr="cast 1" line="7" static="1">
			<x path="openfl.display.SpreadMethod"/>
			<meta>
				<m n=":value"><e>cast 1</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</REFLECT>
		<REPEAT public="1" get="inline" set="null" expr="cast 2" line="8" static="1">
			<x path="openfl.display.SpreadMethod"/>
			<meta>
				<m n=":value"><e>cast 2</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</REPEAT>
		<fromString set="method" line="10" static="1">
			<f a="value">
				<c path="String"/>
				<x path="openfl.display.SpreadMethod"/>
			</f>
			<meta><m n=":from"/></meta>
		</fromString>
		<toString set="method" line="23" static="1">
			<f a="value">
				<x path="Int"/>
				<c path="String"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":to"/>
			</meta>
		</toString>
		<meta>
			<m n=":final"/>
			<m n=":enum"/>
		</meta>
	</class>
	<class path="openfl.display.Stage" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/display/Stage.hx">
		<extends path="openfl.display.DisplayObjectContainer"/>
		<implements path="lime.app.IModule"/>
		<align public="1"><x path="openfl.display.StageAlign"/></align>
		<allowsFullScreen public="1" set="null"><x path="Bool"/></allowsFullScreen>
		<allowsFullScreenInteractive public="1" set="null"><x path="Bool"/></allowsFullScreenInteractive>
		<application public="1" set="null"><c path="lime.app.Application"/></application>
		<color public="1" get="accessor" set="accessor"><x path="Int"/></color>
		<displayState public="1" get="accessor" set="accessor"><x path="openfl.display.StageDisplayState"/></displayState>
		<focus public="1" get="accessor" set="accessor"><c path="openfl.display.InteractiveObject"/></focus>
		<frameRate public="1" get="accessor" set="accessor"><x path="Float"/></frameRate>
		<quality public="1"><x path="openfl.display.StageQuality"/></quality>
		<scaleMode public="1"><x path="openfl.display.StageScaleMode"/></scaleMode>
		<stage3Ds public="1" set="null"><x path="openfl.Vector"><c path="openfl.display.Stage3D"/></x></stage3Ds>
		<stageFocusRect public="1"><x path="Bool"/></stageFocusRect>
		<stageHeight public="1" set="null"><x path="Int"/></stageHeight>
		<stageWidth public="1" set="null"><x path="Int"/></stageWidth>
		<window public="1" set="null"><c path="lime.ui.Window"/></window>
		<__clearBeforeRender><x path="Bool"/></__clearBeforeRender>
		<__color><x path="Int"/></__color>
		<__colorSplit><c path="Array"><x path="Float"/></c></__colorSplit>
		<__colorString><c path="String"/></__colorString>
		<__deltaTime><x path="Int"/></__deltaTime>
		<__dirty><x path="Bool"/></__dirty>
		<__displayState><x path="openfl.display.StageDisplayState"/></__displayState>
		<__dragBounds><c path="openfl.geom.Rectangle"/></__dragBounds>
		<__dragObject><c path="openfl.display.Sprite"/></__dragObject>
		<__dragOffsetX><x path="Float"/></__dragOffsetX>
		<__dragOffsetY><x path="Float"/></__dragOffsetY>
		<__focus><c path="openfl.display.InteractiveObject"/></__focus>
		<__fullscreen><x path="Bool"/></__fullscreen>
		<__invalidated><x path="Bool"/></__invalidated>
		<__lastClickTime><x path="Int"/></__lastClickTime>
		<__macKeyboard><x path="Bool"/></__macKeyboard>
		<__mouseDownLeft><c path="openfl.display.InteractiveObject"/></__mouseDownLeft>
		<__mouseDownMiddle><c path="openfl.display.InteractiveObject"/></__mouseDownMiddle>
		<__mouseDownRight><c path="openfl.display.InteractiveObject"/></__mouseDownRight>
		<__mouseOutStack><c path="Array"><c path="openfl.display.DisplayObject"/></c></__mouseOutStack>
		<__mouseX><x path="Float"/></__mouseX>
		<__mouseY><x path="Float"/></__mouseY>
		<__originalWidth><x path="Int"/></__originalWidth>
		<__originalHeight><x path="Int"/></__originalHeight>
		<__renderer><c path="openfl._internal.renderer.AbstractRenderer"/></__renderer>
		<__rendering><x path="Bool"/></__rendering>
		<__stack><c path="Array"><c path="openfl.display.DisplayObject"/></c></__stack>
		<__transparent><x path="Bool"/></__transparent>
		<__wasDirty><x path="Bool"/></__wasDirty>
		<globalToLocal public="1" set="method" line="197" override="1"><f a="pos">
	<c path="openfl.geom.Point"/>
	<c path="openfl.geom.Point"/>
</f></globalToLocal>
		<invalidate public="1" set="method" line="204"><f a=""><x path="Void"/></f></invalidate>
		<localToGlobal public="1" set="method" line="211" override="1"><f a="pos">
	<c path="openfl.geom.Point"/>
	<c path="openfl.geom.Point"/>
</f></localToGlobal>
		<onGamepadAxisMove public="1" set="method" line="218"><f a="gamepad:axis:value">
	<c path="lime.ui.Gamepad"/>
	<x path="lime.ui.GamepadAxis"/>
	<x path="Float"/>
	<x path="Void"/>
</f></onGamepadAxisMove>
		<onGamepadButtonDown public="1" set="method" line="225"><f a="gamepad:button">
	<c path="lime.ui.Gamepad"/>
	<x path="lime.ui.GamepadButton"/>
	<x path="Void"/>
</f></onGamepadButtonDown>
		<onGamepadButtonUp public="1" set="method" line="232"><f a="gamepad:button">
	<c path="lime.ui.Gamepad"/>
	<x path="lime.ui.GamepadButton"/>
	<x path="Void"/>
</f></onGamepadButtonUp>
		<onGamepadConnect public="1" set="method" line="239"><f a="gamepad">
	<c path="lime.ui.Gamepad"/>
	<x path="Void"/>
</f></onGamepadConnect>
		<onGamepadDisconnect public="1" set="method" line="246"><f a="gamepad">
	<c path="lime.ui.Gamepad"/>
	<x path="Void"/>
</f></onGamepadDisconnect>
		<onJoystickAxisMove public="1" set="method" line="253"><f a="joystick:axis:value">
	<c path="lime.ui.Joystick"/>
	<x path="Int"/>
	<x path="Float"/>
	<x path="Void"/>
</f></onJoystickAxisMove>
		<onJoystickButtonDown public="1" set="method" line="260"><f a="joystick:button">
	<c path="lime.ui.Joystick"/>
	<x path="Int"/>
	<x path="Void"/>
</f></onJoystickButtonDown>
		<onJoystickButtonUp public="1" set="method" line="267"><f a="joystick:button">
	<c path="lime.ui.Joystick"/>
	<x path="Int"/>
	<x path="Void"/>
</f></onJoystickButtonUp>
		<onJoystickConnect public="1" set="method" line="274"><f a="joystick">
	<c path="lime.ui.Joystick"/>
	<x path="Void"/>
</f></onJoystickConnect>
		<onJoystickDisconnect public="1" set="method" line="281"><f a="joystick">
	<c path="lime.ui.Joystick"/>
	<x path="Void"/>
</f></onJoystickDisconnect>
		<onJoystickHatMove public="1" set="method" line="288"><f a="joystick:hat:position">
	<c path="lime.ui.Joystick"/>
	<x path="Int"/>
	<x path="lime.ui.JoystickHatPosition"/>
	<x path="Void"/>
</f></onJoystickHatMove>
		<onJoystickTrackballMove public="1" set="method" line="295"><f a="joystick:trackball:value">
	<c path="lime.ui.Joystick"/>
	<x path="Int"/>
	<x path="Float"/>
	<x path="Void"/>
</f></onJoystickTrackballMove>
		<onKeyDown public="1" set="method" line="302"><f a="window:keyCode:modifier">
	<c path="lime.ui.Window"/>
	<x path="lime.ui.KeyCode"/>
	<x path="lime.ui.KeyModifier"/>
	<x path="Void"/>
</f></onKeyDown>
		<onKeyUp public="1" set="method" line="311"><f a="window:keyCode:modifier">
	<c path="lime.ui.Window"/>
	<x path="lime.ui.KeyCode"/>
	<x path="lime.ui.KeyModifier"/>
	<x path="Void"/>
</f></onKeyUp>
		<onModuleExit public="1" set="method" line="320"><f a="code">
	<x path="Int"/>
	<x path="Void"/>
</f></onModuleExit>
		<onMouseDown public="1" set="method" line="332"><f a="window:x:y:button">
	<c path="lime.ui.Window"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Int"/>
	<x path="Void"/>
</f></onMouseDown>
		<onMouseMove public="1" set="method" line="349"><f a="window:x:y">
	<c path="lime.ui.Window"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></onMouseMove>
		<onMouseMoveRelative public="1" set="method" line="358"><f a="window:x:y">
	<c path="lime.ui.Window"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></onMouseMoveRelative>
		<onMouseUp public="1" set="method" line="365"><f a="window:x:y:button">
	<c path="lime.ui.Window"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Int"/>
	<x path="Void"/>
</f></onMouseUp>
		<onMouseWheel public="1" set="method" line="382"><f a="window:deltaX:deltaY">
	<c path="lime.ui.Window"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></onMouseWheel>
		<onPreloadComplete public="1" set="method" line="391"><f a=""><x path="Void"/></f></onPreloadComplete>
		<onPreloadProgress public="1" set="method" line="398"><f a="loaded:total">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></onPreloadProgress>
		<onRenderContextLost public="1" set="method" line="405"><f a="renderer">
	<c path="lime.graphics.Renderer"/>
	<x path="Void"/>
</f></onRenderContextLost>
		<onRenderContextRestored public="1" set="method" line="412"><f a="renderer:context">
	<c path="lime.graphics.Renderer"/>
	<e path="lime.graphics.RenderContext"/>
	<x path="Void"/>
</f></onRenderContextRestored>
		<onTextEdit public="1" set="method" line="419"><f a="window:text:start:length">
	<c path="lime.ui.Window"/>
	<c path="String"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></onTextEdit>
		<onTextInput public="1" set="method" line="426"><f a="window:text">
	<c path="lime.ui.Window"/>
	<c path="String"/>
	<x path="Void"/>
</f></onTextInput>
		<onTouchMove public="1" set="method" line="458"><f a="touch">
	<c path="lime.ui.Touch"/>
	<x path="Void"/>
</f></onTouchMove>
		<onTouchEnd public="1" set="method" line="465"><f a="touch">
	<c path="lime.ui.Touch"/>
	<x path="Void"/>
</f></onTouchEnd>
		<onTouchStart public="1" set="method" line="472"><f a="touch">
	<c path="lime.ui.Touch"/>
	<x path="Void"/>
</f></onTouchStart>
		<onWindowActivate public="1" set="method" line="479"><f a="window">
	<c path="lime.ui.Window"/>
	<x path="Void"/>
</f></onWindowActivate>
		<onWindowClose public="1" set="method" line="489"><f a="window">
	<c path="lime.ui.Window"/>
	<x path="Void"/>
</f></onWindowClose>
		<onWindowCreate public="1" set="method" line="500"><f a="window">
	<c path="lime.ui.Window"/>
	<x path="Void"/>
</f></onWindowCreate>
		<onWindowDeactivate public="1" set="method" line="545"><f a="window">
	<c path="lime.ui.Window"/>
	<x path="Void"/>
</f></onWindowDeactivate>
		<onWindowDropFile public="1" set="method" line="555"><f a="window:file">
	<c path="lime.ui.Window"/>
	<c path="String"/>
	<x path="Void"/>
</f></onWindowDropFile>
		<onWindowEnter public="1" set="method" line="562"><f a="window">
	<c path="lime.ui.Window"/>
	<x path="Void"/>
</f></onWindowEnter>
		<onWindowFocusIn public="1" set="method" line="569"><f a="window">
	<c path="lime.ui.Window"/>
	<x path="Void"/>
</f></onWindowFocusIn>
		<onWindowFocusOut public="1" set="method" line="579"><f a="window">
	<c path="lime.ui.Window"/>
	<x path="Void"/>
</f></onWindowFocusOut>
		<onWindowFullscreen public="1" set="method" line="589"><f a="window">
	<c path="lime.ui.Window"/>
	<x path="Void"/>
</f></onWindowFullscreen>
		<onWindowLeave public="1" set="method" line="602"><f a="window">
	<c path="lime.ui.Window"/>
	<x path="Void"/>
</f></onWindowLeave>
		<onWindowMinimize public="1" set="method" line="611"><f a="window">
	<c path="lime.ui.Window"/>
	<x path="Void"/>
</f></onWindowMinimize>
		<onWindowMove public="1" set="method" line="618"><f a="window:x:y">
	<c path="lime.ui.Window"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></onWindowMove>
		<onWindowResize public="1" set="method" line="625"><f a="window:width:height">
	<c path="lime.ui.Window"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></onWindowResize>
		<onWindowRestore public="1" set="method" line="650"><f a="window">
	<c path="lime.ui.Window"/>
	<x path="Void"/>
</f></onWindowRestore>
		<render public="1" set="method" line="657"><f a="renderer">
	<c path="lime.graphics.Renderer"/>
	<x path="Void"/>
</f></render>
		<update public="1" set="method" line="724"><f a="deltaTime">
	<x path="Int"/>
	<x path="Void"/>
</f></update>
		<__drag set="method" line="731"><f a="mouse">
	<c path="openfl.geom.Point"/>
	<x path="Void"/>
</f></__drag>
		<__fireEvent set="method" line="773"><f a="event:stack">
	<c path="openfl.events.Event"/>
	<c path="Array"><c path="openfl.display.DisplayObject"/></c>
	<x path="Void"/>
</f></__fireEvent>
		<__getInteractive set="method" line="834" override="1"><f a="stack">
	<c path="Array"><c path="openfl.display.DisplayObject"/></c>
	<x path="Bool"/>
</f></__getInteractive>
		<__onKey set="method" line="847"><f a="type:keyCode:modifier">
	<c path="String"/>
	<x path="lime.ui.KeyCode"/>
	<x path="lime.ui.KeyModifier"/>
	<x path="Void"/>
</f></__onKey>
		<__onMouse set="method" line="896"><f a="type:x:y:button">
	<c path="String"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Int"/>
	<x path="Void"/>
</f></__onMouse>
		<__onMouseWheel set="method" line="1077"><f a="deltaX:deltaY">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></__onMouseWheel>
		<__onTouch set="method" line="1099"><f a="type:touch">
	<c path="String"/>
	<c path="lime.ui.Touch"/>
	<x path="Void"/>
</f></__onTouch>
		<__resize set="method" line="1135"><f a=""><x path="Void"/></f></__resize>
		<__startDrag set="method" line="1196"><f a="sprite:lockCenter:bounds">
	<c path="openfl.display.Sprite"/>
	<x path="Bool"/>
	<c path="openfl.geom.Rectangle"/>
	<x path="Void"/>
</f></__startDrag>
		<__stopDrag set="method" line="1229"><f a="sprite">
	<c path="openfl.display.Sprite"/>
	<x path="Void"/>
</f></__stopDrag>
		<__update public="1" set="method" line="1237" override="1">
			<f a="transformOnly:updateChildren:?maskGrahpics" v="::null">
				<x path="Bool"/>
				<x path="Bool"/>
				<c path="openfl.display.Graphics"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ maskGrahpics : null }</e></m></meta>
		</__update>
		<get_mouseX set="method" line="1299" override="1"><f a=""><x path="Float"/></f></get_mouseX>
		<get_mouseY set="method" line="1306" override="1"><f a=""><x path="Float"/></f></get_mouseY>
		<get_color set="method" line="1343"><f a=""><x path="Int"/></f></get_color>
		<set_color set="method" line="1350"><f a="value">
	<x path="Int"/>
	<x path="Int"/>
</f></set_color>
		<get_displayState set="method" line="1364"><f a=""><x path="openfl.display.StageDisplayState"/></f></get_displayState>
		<set_displayState set="method" line="1371"><f a="value">
	<x path="openfl.display.StageDisplayState"/>
	<x path="openfl.display.StageDisplayState"/>
</f></set_displayState>
		<get_focus set="method" line="1414"><f a=""><c path="openfl.display.InteractiveObject"/></f></get_focus>
		<set_focus set="method" line="1421"><f a="value">
	<c path="openfl.display.InteractiveObject"/>
	<c path="openfl.display.InteractiveObject"/>
</f></set_focus>
		<get_frameRate set="method" line="1455"><f a=""><x path="Float"/></f></get_frameRate>
		<set_frameRate set="method" line="1468"><f a="value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_frameRate>
		<new public="1" set="method" line="128">
			<f a="window:?color" v=":null">
				<c path="lime.ui.Window"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ color : null }</e></m></meta>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":access"><e>openfl.events.Event</e></m>
			<m n=":access"><e>openfl.ui.GameInput</e></m>
			<m n=":access"><e>openfl.ui.Keyboard</e></m>
		</meta>
	</class>
	<class path="openfl.display.Stage3D" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/display/Stage3D.hx">
		<extends path="openfl.events.EventDispatcher"/>
		<context3D public="1"><c path="openfl.display3D.Context3D"/></context3D>
		<visible public="1"><x path="Bool"/></visible>
		<x public="1"><x path="Float"/></x>
		<y public="1"><x path="Float"/></y>
		<requestContext3D public="1" set="method" line="27">
			<f a="?context3DRenderMode" v="&quot;&quot;">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ context3DRenderMode : "" }</e></m></meta>
		</requestContext3D>
		<new public="1" set="method" line="21"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<abstract path="openfl.display.StageAlign" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/display/StageAlign.hx">
		<from><icast field="fromString"><c path="String"/></icast></from>
		<this><t path="Null"><x path="Int"/></t></this>
		<to><icast field="toString"><c path="String"/></icast></to>
		<meta><m n=":enum"/></meta>
		<impl><class path="openfl.display._StageAlign.StageAlign_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/display/StageAlign.hx" private="1" module="openfl.display.StageAlign">
	<BOTTOM public="1" get="inline" set="null" expr="cast 0" line="6" static="1">
		<x path="openfl.display.StageAlign"/>
		<meta>
			<m n=":value"><e>cast 0</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</BOTTOM>
	<BOTTOM_LEFT public="1" get="inline" set="null" expr="cast 1" line="7" static="1">
		<x path="openfl.display.StageAlign"/>
		<meta>
			<m n=":value"><e>cast 1</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</BOTTOM_LEFT>
	<BOTTOM_RIGHT public="1" get="inline" set="null" expr="cast 2" line="8" static="1">
		<x path="openfl.display.StageAlign"/>
		<meta>
			<m n=":value"><e>cast 2</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</BOTTOM_RIGHT>
	<LEFT public="1" get="inline" set="null" expr="cast 3" line="9" static="1">
		<x path="openfl.display.StageAlign"/>
		<meta>
			<m n=":value"><e>cast 3</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</LEFT>
	<RIGHT public="1" get="inline" set="null" expr="cast 4" line="10" static="1">
		<x path="openfl.display.StageAlign"/>
		<meta>
			<m n=":value"><e>cast 4</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</RIGHT>
	<TOP public="1" get="inline" set="null" expr="cast 5" line="11" static="1">
		<x path="openfl.display.StageAlign"/>
		<meta>
			<m n=":value"><e>cast 5</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</TOP>
	<TOP_LEFT public="1" get="inline" set="null" expr="cast 6" line="12" static="1">
		<x path="openfl.display.StageAlign"/>
		<meta>
			<m n=":value"><e>cast 6</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</TOP_LEFT>
	<TOP_RIGHT public="1" get="inline" set="null" expr="cast 7" line="13" static="1">
		<x path="openfl.display.StageAlign"/>
		<meta>
			<m n=":value"><e>cast 7</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</TOP_RIGHT>
	<fromString set="method" line="15" static="1">
		<f a="value">
			<c path="String"/>
			<x path="openfl.display.StageAlign"/>
		</f>
		<meta><m n=":from"/></meta>
	</fromString>
	<toString set="method" line="33" static="1">
		<f a="value">
			<x path="Int"/>
			<c path="String"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":to"/>
		</meta>
	</toString>
	<meta>
		<m n=":final"/>
		<m n=":enum"/>
	</meta>
</class></impl>
	</abstract>
	<class path="openfl.display._StageAlign.StageAlign_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/display/StageAlign.hx" private="1" module="openfl.display.StageAlign">
		<BOTTOM public="1" get="inline" set="null" expr="cast 0" line="6" static="1">
			<x path="openfl.display.StageAlign"/>
			<meta>
				<m n=":value"><e>cast 0</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</BOTTOM>
		<BOTTOM_LEFT public="1" get="inline" set="null" expr="cast 1" line="7" static="1">
			<x path="openfl.display.StageAlign"/>
			<meta>
				<m n=":value"><e>cast 1</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</BOTTOM_LEFT>
		<BOTTOM_RIGHT public="1" get="inline" set="null" expr="cast 2" line="8" static="1">
			<x path="openfl.display.StageAlign"/>
			<meta>
				<m n=":value"><e>cast 2</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</BOTTOM_RIGHT>
		<LEFT public="1" get="inline" set="null" expr="cast 3" line="9" static="1">
			<x path="openfl.display.StageAlign"/>
			<meta>
				<m n=":value"><e>cast 3</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</LEFT>
		<RIGHT public="1" get="inline" set="null" expr="cast 4" line="10" static="1">
			<x path="openfl.display.StageAlign"/>
			<meta>
				<m n=":value"><e>cast 4</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</RIGHT>
		<TOP public="1" get="inline" set="null" expr="cast 5" line="11" static="1">
			<x path="openfl.display.StageAlign"/>
			<meta>
				<m n=":value"><e>cast 5</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</TOP>
		<TOP_LEFT public="1" get="inline" set="null" expr="cast 6" line="12" static="1">
			<x path="openfl.display.StageAlign"/>
			<meta>
				<m n=":value"><e>cast 6</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</TOP_LEFT>
		<TOP_RIGHT public="1" get="inline" set="null" expr="cast 7" line="13" static="1">
			<x path="openfl.display.StageAlign"/>
			<meta>
				<m n=":value"><e>cast 7</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</TOP_RIGHT>
		<fromString set="method" line="15" static="1">
			<f a="value">
				<c path="String"/>
				<x path="openfl.display.StageAlign"/>
			</f>
			<meta><m n=":from"/></meta>
		</fromString>
		<toString set="method" line="33" static="1">
			<f a="value">
				<x path="Int"/>
				<c path="String"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":to"/>
			</meta>
		</toString>
		<meta>
			<m n=":final"/>
			<m n=":enum"/>
		</meta>
	</class>
	<abstract path="openfl.display.StageDisplayState" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/display/StageDisplayState.hx">
		<from><icast field="fromString"><c path="String"/></icast></from>
		<this><t path="Null"><x path="Int"/></t></this>
		<to><icast field="toString"><c path="String"/></icast></to>
		<meta><m n=":enum"/></meta>
		<impl><class path="openfl.display._StageDisplayState.StageDisplayState_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/display/StageDisplayState.hx" private="1" module="openfl.display.StageDisplayState">
	<FULL_SCREEN public="1" get="inline" set="null" expr="cast 0" line="6" static="1">
		<x path="openfl.display.StageDisplayState"/>
		<meta>
			<m n=":value"><e>cast 0</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</FULL_SCREEN>
	<FULL_SCREEN_INTERACTIVE public="1" get="inline" set="null" expr="cast 1" line="7" static="1">
		<x path="openfl.display.StageDisplayState"/>
		<meta>
			<m n=":value"><e>cast 1</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</FULL_SCREEN_INTERACTIVE>
	<NORMAL public="1" get="inline" set="null" expr="cast 2" line="8" static="1">
		<x path="openfl.display.StageDisplayState"/>
		<meta>
			<m n=":value"><e>cast 2</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NORMAL>
	<fromString set="method" line="10" static="1">
		<f a="value">
			<c path="String"/>
			<x path="openfl.display.StageDisplayState"/>
		</f>
		<meta><m n=":from"/></meta>
	</fromString>
	<toString set="method" line="23" static="1">
		<f a="value">
			<x path="Int"/>
			<c path="String"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":to"/>
		</meta>
	</toString>
	<meta>
		<m n=":final"/>
		<m n=":enum"/>
	</meta>
</class></impl>
	</abstract>
	<class path="openfl.display._StageDisplayState.StageDisplayState_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/display/StageDisplayState.hx" private="1" module="openfl.display.StageDisplayState">
		<FULL_SCREEN public="1" get="inline" set="null" expr="cast 0" line="6" static="1">
			<x path="openfl.display.StageDisplayState"/>
			<meta>
				<m n=":value"><e>cast 0</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</FULL_SCREEN>
		<FULL_SCREEN_INTERACTIVE public="1" get="inline" set="null" expr="cast 1" line="7" static="1">
			<x path="openfl.display.StageDisplayState"/>
			<meta>
				<m n=":value"><e>cast 1</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</FULL_SCREEN_INTERACTIVE>
		<NORMAL public="1" get="inline" set="null" expr="cast 2" line="8" static="1">
			<x path="openfl.display.StageDisplayState"/>
			<meta>
				<m n=":value"><e>cast 2</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NORMAL>
		<fromString set="method" line="10" static="1">
			<f a="value">
				<c path="String"/>
				<x path="openfl.display.StageDisplayState"/>
			</f>
			<meta><m n=":from"/></meta>
		</fromString>
		<toString set="method" line="23" static="1">
			<f a="value">
				<x path="Int"/>
				<c path="String"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":to"/>
			</meta>
		</toString>
		<meta>
			<m n=":final"/>
			<m n=":enum"/>
		</meta>
	</class>
	<abstract path="openfl.display.StageQuality" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/display/StageQuality.hx">
		<from><icast field="fromString"><c path="String"/></icast></from>
		<this><t path="Null"><x path="Int"/></t></this>
		<to><icast field="toString"><c path="String"/></icast></to>
		<meta><m n=":enum"/></meta>
		<impl><class path="openfl.display._StageQuality.StageQuality_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/display/StageQuality.hx" private="1" module="openfl.display.StageQuality">
	<BEST public="1" get="inline" set="null" expr="cast 0" line="6" static="1">
		<x path="openfl.display.StageQuality"/>
		<meta>
			<m n=":value"><e>cast 0</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</BEST>
	<HIGH public="1" get="inline" set="null" expr="cast 1" line="7" static="1">
		<x path="openfl.display.StageQuality"/>
		<meta>
			<m n=":value"><e>cast 1</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</HIGH>
	<LOW public="1" get="inline" set="null" expr="cast 2" line="8" static="1">
		<x path="openfl.display.StageQuality"/>
		<meta>
			<m n=":value"><e>cast 2</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</LOW>
	<MEDIUM public="1" get="inline" set="null" expr="cast 3" line="9" static="1">
		<x path="openfl.display.StageQuality"/>
		<meta>
			<m n=":value"><e>cast 3</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</MEDIUM>
	<fromString set="method" line="11" static="1">
		<f a="value">
			<c path="String"/>
			<x path="openfl.display.StageQuality"/>
		</f>
		<meta><m n=":from"/></meta>
	</fromString>
	<toString set="method" line="25" static="1">
		<f a="value">
			<x path="Int"/>
			<c path="String"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":to"/>
		</meta>
	</toString>
	<meta>
		<m n=":final"/>
		<m n=":enum"/>
	</meta>
</class></impl>
	</abstract>
	<class path="openfl.display._StageQuality.StageQuality_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/display/StageQuality.hx" private="1" module="openfl.display.StageQuality">
		<BEST public="1" get="inline" set="null" expr="cast 0" line="6" static="1">
			<x path="openfl.display.StageQuality"/>
			<meta>
				<m n=":value"><e>cast 0</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</BEST>
		<HIGH public="1" get="inline" set="null" expr="cast 1" line="7" static="1">
			<x path="openfl.display.StageQuality"/>
			<meta>
				<m n=":value"><e>cast 1</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</HIGH>
		<LOW public="1" get="inline" set="null" expr="cast 2" line="8" static="1">
			<x path="openfl.display.StageQuality"/>
			<meta>
				<m n=":value"><e>cast 2</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</LOW>
		<MEDIUM public="1" get="inline" set="null" expr="cast 3" line="9" static="1">
			<x path="openfl.display.StageQuality"/>
			<meta>
				<m n=":value"><e>cast 3</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</MEDIUM>
		<fromString set="method" line="11" static="1">
			<f a="value">
				<c path="String"/>
				<x path="openfl.display.StageQuality"/>
			</f>
			<meta><m n=":from"/></meta>
		</fromString>
		<toString set="method" line="25" static="1">
			<f a="value">
				<x path="Int"/>
				<c path="String"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":to"/>
			</meta>
		</toString>
		<meta>
			<m n=":final"/>
			<m n=":enum"/>
		</meta>
	</class>
	<abstract path="openfl.display.StageScaleMode" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/display/StageScaleMode.hx">
		<from><icast field="fromString"><c path="String"/></icast></from>
		<this><t path="Null"><x path="Int"/></t></this>
		<to><icast field="toString"><c path="String"/></icast></to>
		<meta><m n=":enum"/></meta>
		<impl><class path="openfl.display._StageScaleMode.StageScaleMode_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/display/StageScaleMode.hx" private="1" module="openfl.display.StageScaleMode">
	<EXACT_FIT public="1" get="inline" set="null" expr="cast 0" line="6" static="1">
		<x path="openfl.display.StageScaleMode"/>
		<meta>
			<m n=":value"><e>cast 0</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</EXACT_FIT>
	<NO_BORDER public="1" get="inline" set="null" expr="cast 1" line="7" static="1">
		<x path="openfl.display.StageScaleMode"/>
		<meta>
			<m n=":value"><e>cast 1</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NO_BORDER>
	<NO_SCALE public="1" get="inline" set="null" expr="cast 2" line="8" static="1">
		<x path="openfl.display.StageScaleMode"/>
		<meta>
			<m n=":value"><e>cast 2</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NO_SCALE>
	<SHOW_ALL public="1" get="inline" set="null" expr="cast 3" line="9" static="1">
		<x path="openfl.display.StageScaleMode"/>
		<meta>
			<m n=":value"><e>cast 3</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</SHOW_ALL>
	<fromString set="method" line="11" static="1">
		<f a="value">
			<c path="String"/>
			<x path="openfl.display.StageScaleMode"/>
		</f>
		<meta><m n=":from"/></meta>
	</fromString>
	<toString set="method" line="25" static="1">
		<f a="value">
			<x path="Int"/>
			<c path="String"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":to"/>
		</meta>
	</toString>
	<meta>
		<m n=":final"/>
		<m n=":enum"/>
	</meta>
</class></impl>
	</abstract>
	<class path="openfl.display._StageScaleMode.StageScaleMode_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/display/StageScaleMode.hx" private="1" module="openfl.display.StageScaleMode">
		<EXACT_FIT public="1" get="inline" set="null" expr="cast 0" line="6" static="1">
			<x path="openfl.display.StageScaleMode"/>
			<meta>
				<m n=":value"><e>cast 0</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</EXACT_FIT>
		<NO_BORDER public="1" get="inline" set="null" expr="cast 1" line="7" static="1">
			<x path="openfl.display.StageScaleMode"/>
			<meta>
				<m n=":value"><e>cast 1</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NO_BORDER>
		<NO_SCALE public="1" get="inline" set="null" expr="cast 2" line="8" static="1">
			<x path="openfl.display.StageScaleMode"/>
			<meta>
				<m n=":value"><e>cast 2</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NO_SCALE>
		<SHOW_ALL public="1" get="inline" set="null" expr="cast 3" line="9" static="1">
			<x path="openfl.display.StageScaleMode"/>
			<meta>
				<m n=":value"><e>cast 3</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</SHOW_ALL>
		<fromString set="method" line="11" static="1">
			<f a="value">
				<c path="String"/>
				<x path="openfl.display.StageScaleMode"/>
			</f>
			<meta><m n=":from"/></meta>
		</fromString>
		<toString set="method" line="25" static="1">
			<f a="value">
				<x path="Int"/>
				<c path="String"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":to"/>
			</meta>
		</toString>
		<meta>
			<m n=":final"/>
			<m n=":enum"/>
		</meta>
	</class>
	<abstract path="openfl.display.TriangleCulling" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/display/TriangleCulling.hx">
		<from><icast field="fromString"><c path="String"/></icast></from>
		<this><t path="Null"><x path="Int"/></t></this>
		<to><icast field="toString"><c path="String"/></icast></to>
		<meta><m n=":enum"/></meta>
		<impl><class path="openfl.display._TriangleCulling.TriangleCulling_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/display/TriangleCulling.hx" private="1" module="openfl.display.TriangleCulling">
	<NEGATIVE public="1" get="inline" set="null" expr="cast 0" line="6" static="1">
		<x path="openfl.display.TriangleCulling"/>
		<meta>
			<m n=":value"><e>cast 0</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NEGATIVE>
	<NONE public="1" get="inline" set="null" expr="cast 1" line="7" static="1">
		<x path="openfl.display.TriangleCulling"/>
		<meta>
			<m n=":value"><e>cast 1</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NONE>
	<POSITIVE public="1" get="inline" set="null" expr="cast 2" line="8" static="1">
		<x path="openfl.display.TriangleCulling"/>
		<meta>
			<m n=":value"><e>cast 2</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</POSITIVE>
	<fromString set="method" line="10" static="1">
		<f a="value">
			<c path="String"/>
			<x path="openfl.display.TriangleCulling"/>
		</f>
		<meta><m n=":from"/></meta>
	</fromString>
	<toString set="method" line="23" static="1">
		<f a="value">
			<x path="Int"/>
			<c path="String"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":to"/>
		</meta>
	</toString>
	<meta>
		<m n=":final"/>
		<m n=":enum"/>
	</meta>
</class></impl>
	</abstract>
	<class path="openfl.display._TriangleCulling.TriangleCulling_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/display/TriangleCulling.hx" private="1" module="openfl.display.TriangleCulling">
		<NEGATIVE public="1" get="inline" set="null" expr="cast 0" line="6" static="1">
			<x path="openfl.display.TriangleCulling"/>
			<meta>
				<m n=":value"><e>cast 0</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NEGATIVE>
		<NONE public="1" get="inline" set="null" expr="cast 1" line="7" static="1">
			<x path="openfl.display.TriangleCulling"/>
			<meta>
				<m n=":value"><e>cast 1</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NONE>
		<POSITIVE public="1" get="inline" set="null" expr="cast 2" line="8" static="1">
			<x path="openfl.display.TriangleCulling"/>
			<meta>
				<m n=":value"><e>cast 2</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</POSITIVE>
		<fromString set="method" line="10" static="1">
			<f a="value">
				<c path="String"/>
				<x path="openfl.display.TriangleCulling"/>
			</f>
			<meta><m n=":from"/></meta>
		</fromString>
		<toString set="method" line="23" static="1">
			<f a="value">
				<x path="Int"/>
				<c path="String"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":to"/>
			</meta>
		</toString>
		<meta>
			<m n=":final"/>
			<m n=":enum"/>
		</meta>
	</class>
	<class path="openfl.display.Window" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/display/Window.hx">
		<extends path="lime.ui.Window"/>
		<create public="1" set="method" line="22" override="1"><f a="application">
	<c path="lime.app.Application"/>
	<x path="Void"/>
</f></create>
		<new public="1" set="method" line="15">
			<f a="?config" v="null">
				<t path="lime.app.WindowConfig"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ config : null }</e></m></meta>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":access"><e>openfl.display.Stage</e></m>
		</meta>
	</class>
	<class path="openfl.display3D.Context3D" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/display3D/Context3D.hx">
		<TEXTURE_MAX_ANISOTROPY_EXT expr="0x84FE" line="29" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x84FE</e></m></meta>
		</TEXTURE_MAX_ANISOTROPY_EXT>
		<MAX_SAMPLERS expr="8" line="30" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>8</e></m></meta>
		</MAX_SAMPLERS>
		<MAX_TEXTURE_MAX_ANISOTROPY_EXT expr="0x84FF" line="31" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0x84FF</e></m></meta>
		</MAX_TEXTURE_MAX_ANISOTROPY_EXT>
		<anisotropySupportTested expr="false" line="33" static="1">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</anisotropySupportTested>
		<supportsAnisotropy expr="false" line="34" static="1">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</supportsAnisotropy>
		<maxSupportedAnisotropy expr="256" line="35" static="1">
			<x path="UInt"/>
			<meta><m n=":value"><e>256</e></m></meta>
		</maxSupportedAnisotropy>
		<driverInfo public="1" set="null"><c path="String"/></driverInfo>
		<enableErrorChecking public="1"><x path="Bool"/></enableErrorChecking>
		<blendDestinationFactor><x path="Int"/></blendDestinationFactor>
		<blendEnabled><x path="Bool"/></blendEnabled>
		<blendSourceFactor><x path="Int"/></blendSourceFactor>
		<currentProgram><c path="openfl.display3D.Program3D"/></currentProgram>
		<disposed><x path="Bool"/></disposed>
		<drawing><x path="Bool"/></drawing>
		<framebuffer><t path="openfl.gl.GLFramebuffer"/></framebuffer>
		<indexBuffersCreated><c path="Array"><c path="openfl.display3D.IndexBuffer3D"/></c></indexBuffersCreated>
		<ogl><c path="openfl.display.OpenGLView"/></ogl>
		<programsCreated><c path="Array"><c path="openfl.display3D.Program3D"/></c></programsCreated>
		<renderbuffer><t path="openfl.gl.GLRenderbuffer"/></renderbuffer>
		<samplerParameters><c path="Array"><c path="openfl.display3D._Context3D.SamplerState"/></c></samplerParameters>
		<scrollRect><c path="openfl.geom.Rectangle"/></scrollRect>
		<stencilbuffer><t path="openfl.gl.GLRenderbuffer"/></stencilbuffer>
		<stencilCompareMode><x path="openfl.display3D.Context3DCompareMode"/></stencilCompareMode>
		<stencilRef><x path="Int"/></stencilRef>
		<stencilReadMask><x path="Int"/></stencilReadMask>
		<texturesCreated><c path="Array"><c path="openfl.display3D.textures.TextureBase"/></c></texturesCreated>
		<vertexBuffersCreated><c path="Array"><c path="openfl.display3D.VertexBuffer3D"/></c></vertexBuffersCreated>
		<_yFlip><x path="Float"/></_yFlip>
		<backBufferDepthAndStencil><x path="Bool"/></backBufferDepthAndStencil>
		<rttDepthAndStencil><x path="Bool"/></rttDepthAndStencil>
		<scissorRectangle><c path="openfl.geom.Rectangle"/></scissorRectangle>
		<renderToTexture><x path="Bool"/></renderToTexture>
		<rttWidth><x path="Int"/></rttWidth>
		<rttHeight><x path="Int"/></rttHeight>
		<clear public="1" set="method" line="109">
			<f a="?red:?green:?blue:?alpha:?depth:?stencil:?mask" v="0:0:0:1:1:0:Context3DClearMask.ALL">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ mask : Context3DClearMask.ALL, stencil : 0, depth : 1, alpha : 1, blue : 0, green : 0, red : 0 }</e></m></meta>
		</clear>
		<configureBackBuffer public="1" set="method" line="136">
			<f a="width:height:antiAlias:?enableDepthAndStencil" v=":::true">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ enableDepthAndStencil : true }</e></m></meta>
		</configureBackBuffer>
		<setBackBufferViewPort set="method" line="147"><f a="?x:?y:?width:?height">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></setBackBufferViewPort>
		<updateBackBufferViewPort set="method" line="165"><f a=""><x path="Void"/></f></updateBackBufferViewPort>
		<updateDepthAndStencilState set="method" line="175"><f a=""><x path="Void"/></f></updateDepthAndStencilState>
		<createCubeTexture public="1" set="method" line="201">
			<f a="size:format:optimizeForRenderToTexture:?streamingLevels" v=":::0">
				<x path="Int"/>
				<e path="openfl.display3D.Context3DTextureFormat"/>
				<x path="Bool"/>
				<x path="Int"/>
				<c path="openfl.display3D.textures.CubeTexture"/>
			</f>
			<meta><m n=":value"><e>{ streamingLevels : 0 }</e></m></meta>
		</createCubeTexture>
		<createIndexBuffer public="1" set="method" line="210">
			<f a="numIndices:?bufferUsage" v=":null">
				<x path="Int"/>
				<e path="openfl.display3D.Context3DBufferUsage"/>
				<c path="openfl.display3D.IndexBuffer3D"/>
			</f>
			<meta><m n=":value"><e>{ bufferUsage : null }</e></m></meta>
		</createIndexBuffer>
		<createProgram public="1" set="method" line="220"><f a=""><c path="openfl.display3D.Program3D"/></f></createProgram>
		<createRectangleTexture public="1" set="method" line="229"><f a="width:height:format:optimizeForRenderToTexture">
	<x path="Int"/>
	<x path="Int"/>
	<e path="openfl.display3D.Context3DTextureFormat"/>
	<x path="Bool"/>
	<c path="openfl.display3D.textures.RectangleTexture"/>
</f></createRectangleTexture>
		<createTexture public="1" set="method" line="238">
			<f a="width:height:format:optimizeForRenderToTexture:?streamingLevels" v="::::0">
				<x path="Int"/>
				<x path="Int"/>
				<e path="openfl.display3D.Context3DTextureFormat"/>
				<x path="Bool"/>
				<x path="Int"/>
				<c path="openfl.display3D.textures.Texture"/>
			</f>
			<meta><m n=":value"><e>{ streamingLevels : 0 }</e></m></meta>
		</createTexture>
		<createVertexBuffer public="1" set="method" line="247">
			<f a="numVertices:data32PerVertex:?bufferUsage" v="::null">
				<x path="Int"/>
				<x path="Int"/>
				<e path="openfl.display3D.Context3DBufferUsage"/>
				<c path="openfl.display3D.VertexBuffer3D"/>
			</f>
			<meta><m n=":value"><e>{ bufferUsage : null }</e></m></meta>
		</createVertexBuffer>
		<__deleteTexture public="1" set="method" line="257"><f a="texture">
	<c path="openfl.display3D.textures.TextureBase"/>
	<x path="Void"/>
</f></__deleteTexture>
		<__deleteVertexBuffer public="1" set="method" line="268"><f a="buffer">
	<c path="openfl.display3D.VertexBuffer3D"/>
	<x path="Void"/>
</f></__deleteVertexBuffer>
		<__deleteIndexBuffer public="1" set="method" line="279"><f a="buffer">
	<c path="openfl.display3D.IndexBuffer3D"/>
	<x path="Void"/>
</f></__deleteIndexBuffer>
		<__deleteProgram public="1" set="method" line="290"><f a="program">
	<c path="openfl.display3D.Program3D"/>
	<x path="Void"/>
</f></__deleteProgram>
		<dispose public="1" set="method" line="301"><f a=""><x path="Void"/></f></dispose>
		<drawToBitmapData public="1" set="method" line="359"><f a="destination">
	<c path="openfl.display.BitmapData"/>
	<x path="Void"/>
</f></drawToBitmapData>
		<drawTriangles public="1" set="method" line="366">
			<f a="indexBuffer:?firstIndex:?numTriangles" v=":0:-1">
				<c path="openfl.display3D.IndexBuffer3D"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ numTriangles : -1, firstIndex : 0 }</e></m></meta>
		</drawTriangles>
		<present public="1" set="method" line="397"><f a=""><x path="Void"/></f></present>
		<removeRenderMethod public="1" set="method" line="420"><f a="func">
	<f a="">
		<c path="openfl.events.Event"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></removeRenderMethod>
		<setBlendFactors public="1" set="method" line="427"><f a="sourceFactor:destinationFactor">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></setBlendFactors>
		<setColorMask public="1" set="method" line="440"><f a="red:green:blue:alpha">
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></setColorMask>
		<setCulling public="1" set="method" line="448"><f a="triangleFaceToCull">
	<x path="Int"/>
	<x path="Void"/>
</f></setCulling>
		<setDepthTest public="1" set="method" line="497"><f a="depthMask:passCompareMode">
	<x path="Bool"/>
	<x path="Int"/>
	<x path="Void"/>
</f></setDepthTest>
		<setGLSLProgramConstantsFromByteArray public="1" set="method" line="507">
			<f a="locationName:data:?byteArrayOffset" v="::0">
				<c path="String"/>
				<x path="openfl.utils.ByteArray"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ byteArrayOffset : 0 }</e></m></meta>
		</setGLSLProgramConstantsFromByteArray>
		<setGLSLProgramConstantsFromMatrix public="1" set="method" line="516">
			<f a="locationName:matrix:?transposedMatrix" v="::false">
				<c path="String"/>
				<c path="openfl.geom.Matrix3D"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ transposedMatrix : false }</e></m></meta>
		</setGLSLProgramConstantsFromMatrix>
		<setGLSLProgramConstantsFromVector4 public="1" set="method" line="524">
			<f a="locationName:data:?startIndex" v="::0">
				<c path="String"/>
				<c path="Array"><x path="Float"/></c>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ startIndex : 0 }</e></m></meta>
		</setGLSLProgramConstantsFromVector4>
		<setGLSLTextureAt public="1" set="method" line="532"><f a="locationName:texture:textureIndex">
	<c path="String"/>
	<c path="openfl.display3D.textures.TextureBase"/>
	<x path="Int"/>
	<x path="Void"/>
</f></setGLSLTextureAt>
		<setGLSLVertexBufferAt public="1" set="method" line="595">
			<f a="locationName:buffer:?bufferOffset:?format" v="::0:">
				<c path="String"/>
				<c path="openfl.display3D.VertexBuffer3D"/>
				<x path="Int"/>
				<e path="openfl.display3D.Context3DVertexBufferFormat"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ bufferOffset : 0 }</e></m></meta>
		</setGLSLVertexBufferAt>
		<setProgram public="1" set="method" line="664"><f a="program3D">
	<c path="openfl.display3D.Program3D"/>
	<x path="Void"/>
</f></setProgram>
		<setProgramConstantsFromByteArray public="1" set="method" line="682"><f a="programType:firstRegister:numRegisters:data:byteArrayOffset">
	<e path="openfl.display3D.Context3DProgramType"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="openfl.utils.ByteArray"/>
	<x path="Int"/>
	<x path="Void"/>
</f></setProgramConstantsFromByteArray>
		<setProgramConstantsFromMatrix public="1" set="method" line="696">
			<f a="programType:firstRegister:matrix:?transposedMatrix" v=":::false">
				<e path="openfl.display3D.Context3DProgramType"/>
				<x path="Int"/>
				<c path="openfl.geom.Matrix3D"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ transposedMatrix : false }</e></m></meta>
		</setProgramConstantsFromMatrix>
		<setProgramConstantsFromVector public="1" set="method" line="717">
			<f a="programType:firstRegister:data:?numRegisters" v=":::1">
				<e path="openfl.display3D.Context3DProgramType"/>
				<x path="Int"/>
				<c path="Array"><x path="Float"/></c>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ numRegisters : 1 }</e></m></meta>
		</setProgramConstantsFromVector>
		<setRenderMethod public="1" set="method" line="730"><f a="func">
	<f a="">
		<c path="openfl.events.Event"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></setRenderMethod>
		<setRenderToBackBuffer public="1" set="method" line="739"><f a=""><x path="Void"/></f></setRenderToBackBuffer>
		<setRenderToTexture public="1" set="method" line="765">
			<f a="texture:?enableDepthAndStencil:?antiAlias:?surfaceSelector" v=":false:0:0">
				<c path="openfl.display3D.textures.TextureBase"/>
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ surfaceSelector : 0, antiAlias : 0, enableDepthAndStencil : false }</e></m></meta>
		</setRenderToTexture>
		<setSamplerStateAt public="1" set="method" line="818"><f a="sampler:wrap:filter:mipfilter">
	<x path="Int"/>
	<e path="openfl.display3D.Context3DWrapMode"/>
	<e path="openfl.display3D.Context3DTextureFilter"/>
	<e path="openfl.display3D.Context3DMipFilter"/>
	<x path="Void"/>
</f></setSamplerStateAt>
		<setScissorRectangle public="1" set="method" line="837"><f a="rectangle">
	<c path="openfl.geom.Rectangle"/>
	<x path="Void"/>
</f></setScissorRectangle>
		<updateScissorRectangle set="method" line="854"><f a=""><x path="Void"/></f></updateScissorRectangle>
		<setStencilActions public="1" set="method" line="870"><f a="?triangleFace:?compareMode:?actionOnBothPass:?actionOnDepthFail:?actionOnDepthPassStencilFail">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></setStencilActions>
		<setStencilReferenceValue public="1" set="method" line="879">
			<f a="referenceValue:?readMask:?writeMask" v=":0xFF:0xFF">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ writeMask : 0xFF, readMask : 0xFF }</e></m></meta>
		</setStencilReferenceValue>
		<setTextureAt public="1" set="method" line="890"><f a="sampler:texture">
	<x path="Int"/>
	<c path="openfl.display3D.textures.TextureBase"/>
	<x path="Void"/>
</f></setTextureAt>
		<setTextureParameters set="method" line="898"><f a="texture:wrap:filter:mipfilter">
	<c path="openfl.display3D.textures.TextureBase"/>
	<e path="openfl.display3D.Context3DWrapMode"/>
	<e path="openfl.display3D.Context3DTextureFilter"/>
	<e path="openfl.display3D.Context3DMipFilter"/>
	<x path="Void"/>
</f></setTextureParameters>
		<setVertexBufferAt public="1" set="method" line="1135">
			<f a="index:buffer:?bufferOffset:?format" v="::0:">
				<x path="Int"/>
				<c path="openfl.display3D.VertexBuffer3D"/>
				<x path="Int"/>
				<e path="openfl.display3D.Context3DVertexBufferFormat"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ bufferOffset : 0 }</e></m></meta>
		</setVertexBufferAt>
		<__getUniformLocationNameFromAgalRegisterIndex set="method" line="1143"><f a="programType:firstRegister">
	<e path="openfl.display3D.Context3DProgramType"/>
	<x path="Int"/>
	<c path="String"/>
</f></__getUniformLocationNameFromAgalRegisterIndex>
		<__updateBlendStatus set="method" line="1160"><f a=""><x path="Void"/></f></__updateBlendStatus>
		<new public="1" set="method" line="67"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":final"/>
		</meta>
	</class>
	<class path="openfl.display3D._Context3D.SamplerState" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/display3D/Context3D.hx" private="1" module="openfl.display3D.Context3D">
		<wrap public="1"><e path="openfl.display3D.Context3DWrapMode"/></wrap>
		<filter public="1"><e path="openfl.display3D.Context3DTextureFilter"/></filter>
		<mipfilter public="1"><e path="openfl.display3D.Context3DMipFilter"/></mipfilter>
		<new public="1" set="method" line="1190"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<enum path="openfl.display3D.Context3DBufferUsage" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/display3D/Context3DBufferUsage.hx">
		<STATIC_DRAW/>
		<DYNAMIC_DRAW/>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<class path="openfl.display3D.Context3DClearMask" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/display3D/Context3DClearMask.hx">
		<ALL public="1" get="inline" set="null" expr="COLOR | DEPTH | STENCIL" line="10" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>COLOR | DEPTH | STENCIL</e></m></meta>
		</ALL>
		<COLOR public="1" get="inline" set="null" expr="GL.COLOR_BUFFER_BIT" line="11" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>GL.COLOR_BUFFER_BIT</e></m></meta>
		</COLOR>
		<DEPTH public="1" get="inline" set="null" expr="GL.DEPTH_BUFFER_BIT" line="12" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>GL.DEPTH_BUFFER_BIT</e></m></meta>
		</DEPTH>
		<STENCIL public="1" get="inline" set="null" expr="GL.STENCIL_BUFFER_BIT" line="13" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>GL.STENCIL_BUFFER_BIT</e></m></meta>
		</STENCIL>
	</class>
	<abstract path="openfl.display3D.Context3DCompareMode" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/display3D/Context3DCompareMode.hx">
		<from><icast field="fromInt"><x path="Int"/></icast></from>
		<this><x path="Int"/></this>
		<to><icast field="toInt"><x path="Int"/></icast></to>
		<impl><class path="openfl.display3D._Context3DCompareMode.Context3DCompareMode_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/display3D/Context3DCompareMode.hx" private="1" module="openfl.display3D.Context3DCompareMode">
	<ALWAYS public="1" get="inline" set="null" expr="GL.ALWAYS" line="10" static="1">
		<x path="Int"/>
		<meta><m n=":value"><e>GL.ALWAYS</e></m></meta>
	</ALWAYS>
	<EQUAL public="1" get="inline" set="null" expr="GL.EQUAL" line="11" static="1">
		<x path="Int"/>
		<meta><m n=":value"><e>GL.EQUAL</e></m></meta>
	</EQUAL>
	<GREATER public="1" get="inline" set="null" expr="GL.GREATER" line="12" static="1">
		<x path="Int"/>
		<meta><m n=":value"><e>GL.GREATER</e></m></meta>
	</GREATER>
	<GREATER_EQUAL public="1" get="inline" set="null" expr="GL.GEQUAL" line="13" static="1">
		<x path="Int"/>
		<meta><m n=":value"><e>GL.GEQUAL</e></m></meta>
	</GREATER_EQUAL>
	<LESS public="1" get="inline" set="null" expr="GL.LESS" line="14" static="1">
		<x path="Int"/>
		<meta><m n=":value"><e>GL.LESS</e></m></meta>
	</LESS>
	<LESS_EQUAL public="1" get="inline" set="null" expr="GL.LEQUAL" line="15" static="1">
		<x path="Int"/>
		<meta><m n=":value"><e>GL.LEQUAL</e></m></meta>
	</LESS_EQUAL>
	<NEVER public="1" get="inline" set="null" expr="GL.NEVER" line="16" static="1">
		<x path="Int"/>
		<meta><m n=":value"><e>GL.NEVER</e></m></meta>
	</NEVER>
	<NOT_EQUAL public="1" get="inline" set="null" expr="GL.NOTEQUAL" line="17" static="1">
		<x path="Int"/>
		<meta><m n=":value"><e>GL.NOTEQUAL</e></m></meta>
	</NOT_EQUAL>
	<_new get="inline" set="null" line="20" static="1">
		<f a="a">
			<x path="Int"/>
			<x path="openfl.display3D.Context3DCompareMode"/>
		</f>
		<meta><m n=":impl"/></meta>
	</_new>
	<fromInt public="1" get="inline" set="null" line="27" static="1">
		<f a="s">
			<x path="Int"/>
			<x path="openfl.display3D.Context3DCompareMode"/>
		</f>
		<meta><m n=":from"/></meta>
	</fromInt>
	<toInt public="1" get="inline" set="null" line="34" static="1">
		<f a="this">
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":to"/>
		</meta>
	</toInt>
	<meta><m n=":final"/></meta>
</class></impl>
	</abstract>
	<class path="openfl.display3D._Context3DCompareMode.Context3DCompareMode_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/display3D/Context3DCompareMode.hx" private="1" module="openfl.display3D.Context3DCompareMode">
		<ALWAYS public="1" get="inline" set="null" expr="GL.ALWAYS" line="10" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>GL.ALWAYS</e></m></meta>
		</ALWAYS>
		<EQUAL public="1" get="inline" set="null" expr="GL.EQUAL" line="11" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>GL.EQUAL</e></m></meta>
		</EQUAL>
		<GREATER public="1" get="inline" set="null" expr="GL.GREATER" line="12" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>GL.GREATER</e></m></meta>
		</GREATER>
		<GREATER_EQUAL public="1" get="inline" set="null" expr="GL.GEQUAL" line="13" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>GL.GEQUAL</e></m></meta>
		</GREATER_EQUAL>
		<LESS public="1" get="inline" set="null" expr="GL.LESS" line="14" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>GL.LESS</e></m></meta>
		</LESS>
		<LESS_EQUAL public="1" get="inline" set="null" expr="GL.LEQUAL" line="15" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>GL.LEQUAL</e></m></meta>
		</LESS_EQUAL>
		<NEVER public="1" get="inline" set="null" expr="GL.NEVER" line="16" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>GL.NEVER</e></m></meta>
		</NEVER>
		<NOT_EQUAL public="1" get="inline" set="null" expr="GL.NOTEQUAL" line="17" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>GL.NOTEQUAL</e></m></meta>
		</NOT_EQUAL>
		<_new get="inline" set="null" line="20" static="1">
			<f a="a">
				<x path="Int"/>
				<x path="openfl.display3D.Context3DCompareMode"/>
			</f>
			<meta><m n=":impl"/></meta>
		</_new>
		<fromInt public="1" get="inline" set="null" line="27" static="1">
			<f a="s">
				<x path="Int"/>
				<x path="openfl.display3D.Context3DCompareMode"/>
			</f>
			<meta><m n=":from"/></meta>
		</fromInt>
		<toInt public="1" get="inline" set="null" line="34" static="1">
			<f a="this">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":to"/>
			</meta>
		</toInt>
		<meta><m n=":final"/></meta>
	</class>
	<enum path="openfl.display3D.Context3DMipFilter" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/display3D/Context3DMipFilter.hx">
		<MIPLINEAR/>
		<MIPNEAREST/>
		<MIPNONE/>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<enum path="openfl.display3D.Context3DProgramType" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/display3D/Context3DProgramType.hx">
		<VERTEX/>
		<FRAGMENT/>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<enum path="openfl.display3D.Context3DTextureFilter" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/display3D/Context3DTextureFilter.hx">
		<ANISOTROPIC2X/>
		<ANISOTROPIC4X/>
		<ANISOTROPIC8X/>
		<ANISOTROPIC16X/>
		<LINEAR/>
		<NEAREST/>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<enum path="openfl.display3D.Context3DTextureFormat" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/display3D/Context3DTextureFormat.hx">
		<BGRA/>
		<COMPRESSED/>
		<COMPRESSED_ALPHA/>
		<meta><m n=":flatEnum"/></meta>
	</enum>
	<abstract path="openfl.display3D.Context3DTriangleFace" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/display3D/Context3DTriangleFace.hx">
		<from><icast field="fromInt"><x path="Int"/></icast></from>
		<this><x path="Int"/></this>
		<to><icast field="toInt"><x path="Int"/></icast></to>
		<impl><class path="openfl.display3D._Context3DTriangleFace.Context3DTriangleFace_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/display3D/Context3DTriangleFace.hx" private="1" module="openfl.display3D.Context3DTriangleFace">
	<BACK public="1" get="inline" set="null" expr="GL.FRONT" line="10" static="1">
		<x path="Int"/>
		<meta><m n=":value"><e>GL.FRONT</e></m></meta>
	</BACK>
	<FRONT public="1" get="inline" set="null" expr="GL.BACK" line="11" static="1">
		<x path="Int"/>
		<meta><m n=":value"><e>GL.BACK</e></m></meta>
	</FRONT>
	<FRONT_AND_BACK public="1" get="inline" set="null" expr="GL.FRONT_AND_BACK" line="12" static="1">
		<x path="Int"/>
		<meta><m n=":value"><e>GL.FRONT_AND_BACK</e></m></meta>
	</FRONT_AND_BACK>
	<NONE public="1" get="inline" set="null" expr="0" line="13" static="1">
		<x path="Int"/>
		<meta><m n=":value"><e>0</e></m></meta>
	</NONE>
	<_new get="inline" set="null" line="16" static="1">
		<f a="a">
			<x path="Int"/>
			<x path="openfl.display3D.Context3DTriangleFace"/>
		</f>
		<meta><m n=":impl"/></meta>
	</_new>
	<fromInt public="1" get="inline" set="null" line="23" static="1">
		<f a="s">
			<x path="Int"/>
			<x path="openfl.display3D.Context3DTriangleFace"/>
		</f>
		<meta><m n=":from"/></meta>
	</fromInt>
	<toInt public="1" get="inline" set="null" line="30" static="1">
		<f a="this">
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":to"/>
		</meta>
	</toInt>
	<meta><m n=":final"/></meta>
</class></impl>
	</abstract>
	<class path="openfl.display3D._Context3DTriangleFace.Context3DTriangleFace_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/display3D/Context3DTriangleFace.hx" private="1" module="openfl.display3D.Context3DTriangleFace">
		<BACK public="1" get="inline" set="null" expr="GL.FRONT" line="10" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>GL.FRONT</e></m></meta>
		</BACK>
		<FRONT public="1" get="inline" set="null" expr="GL.BACK" line="11" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>GL.BACK</e></m></meta>
		</FRONT>
		<FRONT_AND_BACK public="1" get="inline" set="null" expr="GL.FRONT_AND_BACK" line="12" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>GL.FRONT_AND_BACK</e></m></meta>
		</FRONT_AND_BACK>
		<NONE public="1" get="inline" set="null" expr="0" line="13" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</NONE>
		<_new get="inline" set="null" line="16" static="1">
			<f a="a">
				<x path="Int"/>
				<x path="openfl.display3D.Context3DTriangleFace"/>
			</f>
			<meta><m n=":impl"/></meta>
		</_new>
		<fromInt public="1" get="inline" set="null" line="23" static="1">
			<f a="s">
				<x path="Int"/>
				<x path="openfl.display3D.Context3DTriangleFace"/>
			</f>
			<meta><m n=":from"/></meta>
		</fromInt>
		<toInt public="1" get="inline" set="null" line="30" static="1">
			<f a="this">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":to"/>
			</meta>
		</toInt>
		<meta><m n=":final"/></meta>
	</class>
	<enum path="openfl.display3D.Context3DVertexBufferFormat" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/display3D/Context3DVertexBufferFormat.hx">
		<BYTES_4/>
		<FLOAT_1/>
		<FLOAT_2/>
		<FLOAT_3/>
		<FLOAT_4/>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<enum path="openfl.display3D.Context3DWrapMode" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/display3D/Context3DWrapMode.hx">
		<CLAMP/>
		<REPEAT/>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<class path="openfl.display3D.IndexBuffer3D" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/display3D/IndexBuffer3D.hx">
		<context public="1"><c path="openfl.display3D.Context3D"/></context>
		<glBuffer public="1"><t path="openfl.gl.GLBuffer"/></glBuffer>
		<numIndices public="1"><x path="Int"/></numIndices>
		<bufferUsage public="1"><x path="Int"/></bufferUsage>
		<dispose public="1" set="method" line="30"><f a=""><x path="Void"/></f></dispose>
		<uploadFromByteArray public="1" set="method" line="37"><f a="byteArray:byteArrayOffset:startOffset:count">
	<x path="openfl.utils.ByteArray"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></uploadFromByteArray>
		<uploadFromVector public="1" set="method" line="67"><f a="data:startOffset:count">
	<x path="openfl.Vector"><x path="UInt"/></x>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></uploadFromVector>
		<uploadFromInt16Array public="1" set="method" line="89"><f a="data">
	<t path="openfl.utils.Int16Array"/>
	<x path="Void"/>
</f></uploadFromInt16Array>
		<new public="1" set="method" line="20"><f a="context:glBuffer:numIndices:bufferUsage">
	<c path="openfl.display3D.Context3D"/>
	<t path="openfl.gl.GLBuffer"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":final"/>
		</meta>
	</class>
	<class path="openfl.display3D.Program3D" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/display3D/Program3D.hx">
		<context public="1"><c path="openfl.display3D.Context3D"/></context>
		<glProgram public="1"><t path="openfl.gl.GLProgram"/></glProgram>
		<dispose public="1" set="method" line="24"><f a=""><x path="Void"/></f></dispose>
		<upload public="1" set="method" line="31"><f a="vertexShader:fragmentShader">
	<t path="openfl.gl.GLShader"/>
	<t path="openfl.gl.GLShader"/>
	<x path="Void"/>
</f></upload>
		<new public="1" set="method" line="16"><f a="context:program">
	<c path="openfl.display3D.Context3D"/>
	<t path="openfl.gl.GLProgram"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":final"/>
		</meta>
	</class>
	<class path="openfl.display3D.VertexBuffer3D" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/display3D/VertexBuffer3D.hx">
		<context public="1"><c path="openfl.display3D.Context3D"/></context>
		<data32PerVertex public="1"><x path="Int"/></data32PerVertex>
		<glBuffer public="1"><t path="openfl.gl.GLBuffer"/></glBuffer>
		<numVertices public="1"><x path="Int"/></numVertices>
		<bufferUsage public="1"><x path="Int"/></bufferUsage>
		<dispose public="1" set="method" line="32"><f a=""><x path="Void"/></f></dispose>
		<uploadFromByteArray public="1" set="method" line="39"><f a="byteArray:byteArrayOffset:startOffset:count">
	<x path="openfl.utils.ByteArray"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></uploadFromByteArray>
		<uploadFromFloat32Array public="1" set="method" line="70"><f a="data">
	<t path="openfl.utils.Float32Array"/>
	<x path="Void"/>
</f></uploadFromFloat32Array>
		<uploadFromVector public="1" set="method" line="78"><f a="data:startVertex:numVertices">
	<x path="openfl.Vector"><x path="Float"/></x>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></uploadFromVector>
		<new public="1" set="method" line="21"><f a="context:glBuffer:numVertices:data32PerVertex:bufferUsage">
	<c path="openfl.display3D.Context3D"/>
	<t path="openfl.gl.GLBuffer"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="openfl.display3D.textures.TextureBase" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/display3D/textures/TextureBase.hx">
		<extends path="openfl.events.EventDispatcher"/>
		<context public="1"><c path="openfl.display3D.Context3D"/></context>
		<height public="1"><x path="Int"/></height>
		<frameBuffer public="1"><t path="openfl.gl.GLFramebuffer"/></frameBuffer>
		<glTexture public="1"><t path="openfl.gl.GLTexture"/></glTexture>
		<width public="1"><x path="Int"/></width>
		<dispose public="1" set="method" line="31"><f a=""><x path="Void"/></f></dispose>
		<new public="1" set="method" line="19">
			<f a="context:glTexture:?width:?height" v="::0:0">
				<c path="openfl.display3D.Context3D"/>
				<t path="openfl.gl.GLTexture"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ height : 0, width : 0 }</e></m></meta>
		</new>
	</class>
	<class path="openfl.display3D.textures.CubeTexture" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/display3D/textures/CubeTexture.hx">
		<extends path="openfl.display3D.textures.TextureBase"/>
		<size public="1"><x path="Int"/></size>
		<_textures public="1"><c path="Array"><t path="openfl.gl.GLTexture"/></c></_textures>
		<mipmapsGenerated public="1"><x path="Bool"/></mipmapsGenerated>
		<glTextureAt public="1" set="method" line="39"><f a="index">
	<x path="Int"/>
	<t path="openfl.gl.GLTexture"/>
</f></glTextureAt>
		<uploadCompressedTextureFromByteArray public="1" set="method" line="46">
			<f a="data:byteArrayOffset:?async" v="::false">
				<x path="openfl.utils.ByteArray"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ async : false }</e></m></meta>
		</uploadCompressedTextureFromByteArray>
		<uploadFromBitmapData public="1" set="method" line="53">
			<f a="bitmapData:side:?miplevel" v="::0">
				<c path="openfl.display.BitmapData"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ miplevel : 0 }</e></m></meta>
		</uploadFromBitmapData>
		<uploadFromByteArray public="1" set="method" line="102">
			<f a="data:byteArrayOffset:side:?miplevel" v=":::0">
				<x path="openfl.utils.ByteArray"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ miplevel : 0 }</e></m></meta>
		</uploadFromByteArray>
		<new public="1" set="method" line="22"><f a="context:glTexture:size">
	<c path="openfl.display3D.Context3D"/>
	<t path="openfl.gl.GLTexture"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":final"/>
		</meta>
	</class>
	<class path="openfl.display3D.textures.RectangleTexture" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/display3D/textures/RectangleTexture.hx">
		<extends path="openfl.display3D.textures.TextureBase"/>
		<optimizeForRenderToTexture public="1"><x path="Bool"/></optimizeForRenderToTexture>
		<uploadFromBitmapData public="1" set="method" line="47">
			<f a="bitmapData:?miplevel" v=":0">
				<c path="openfl.display.BitmapData"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ miplevel : 0 }</e></m></meta>
		</uploadFromBitmapData>
		<uploadFromByteArray public="1" set="method" line="65"><f a="data:byteArrayOffset">
	<x path="openfl.utils.ByteArray"/>
	<x path="Int"/>
	<x path="Void"/>
</f></uploadFromByteArray>
		<new public="1" set="method" line="19"><f a="context:glTexture:optimize:width:height">
	<c path="openfl.display3D.Context3D"/>
	<t path="openfl.gl.GLTexture"/>
	<x path="Bool"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":final"/>
		</meta>
	</class>
	<class path="openfl.display3D.textures.Texture" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/display3D/textures/Texture.hx">
		<extends path="openfl.display3D.textures.TextureBase"/>
		<internalFormat expr="-1" line="18" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>-1</e></m></meta>
		</internalFormat>
		<optimizeForRenderToTexture public="1"><x path="Bool"/></optimizeForRenderToTexture>
		<mipmapsGenerated public="1"><x path="Bool"/></mipmapsGenerated>
		<uploadCompressedTextureFromByteArray public="1" set="method" line="58">
			<f a="data:byteArrayOffset:?async" v="::false">
				<x path="openfl.utils.ByteArray"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ async : false }</e></m></meta>
		</uploadCompressedTextureFromByteArray>
		<uploadFromBitmapData public="1" set="method" line="65">
			<f a="bitmapData:?miplevel" v=":0">
				<c path="openfl.display.BitmapData"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ miplevel : 0 }</e></m></meta>
		</uploadFromBitmapData>
		<uploadFromByteArray public="1" set="method" line="97">
			<f a="data:byteArrayOffset:?miplevel" v="::0">
				<x path="openfl.utils.ByteArray"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ miplevel : 0 }</e></m></meta>
		</uploadFromByteArray>
		<uploadFromUInt8Array public="1" set="method" line="120">
			<f a="data:?miplevel" v=":0">
				<t path="openfl.utils.UInt8Array"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ miplevel : 0 }</e></m></meta>
		</uploadFromUInt8Array>
		<new public="1" set="method" line="24"><f a="context:glTexture:optimize:width:height">
	<c path="openfl.display3D.Context3D"/>
	<t path="openfl.gl.GLTexture"/>
	<x path="Bool"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":final"/>
		</meta>
	</class>
	<class path="openfl.errors.Error" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/errors/Error.hx">
		<DEFAULT_TO_STRING get="inline" set="null" expr="&quot;Error&quot;" line="10" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"Error"</e></m></meta>
		</DEFAULT_TO_STRING>
		<errorID public="1" set="null"><x path="Int"/></errorID>
		<message public="1"><c path="String"/></message>
		<name public="1"><c path="String"/></name>
		<getStackTrace public="1" set="method" line="26"><f a=""><c path="String"/></f></getStackTrace>
		<toString public="1" set="method" line="33"><f a=""><c path="String"/></f></toString>
		<new public="1" set="method" line="17">
			<f a="?message:?id" v="&quot;&quot;:0">
				<c path="String"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ id : 0, message : "" }</e></m></meta>
		</new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="openfl.errors.ArgumentError" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/errors/ArgumentError.hx">
		<extends path="openfl.errors.Error"/>
		<new public="1" set="method" line="7">
			<f a="?message" v="&quot;&quot;">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ message : "" }</e></m></meta>
		</new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="openfl.errors.IOError" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/errors/IOError.hx">
		<extends path="openfl.errors.Error"/>
		<new public="1" set="method" line="7">
			<f a="?message" v="&quot;&quot;">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ message : "" }</e></m></meta>
		</new>
	</class>
	<class path="openfl.errors.EOFError" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/errors/EOFError.hx">
		<extends path="openfl.errors.IOError"/>
		<new public="1" set="method" line="7"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="openfl.errors.RangeError" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/errors/RangeError.hx">
		<extends path="openfl.errors.Error"/>
		<new public="1" set="method" line="7">
			<f a="?message" v="&quot;&quot;">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ message : "" }</e></m></meta>
		</new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="openfl.errors.TypeError" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/errors/TypeError.hx">
		<extends path="openfl.errors.Error"/>
		<new public="1" set="method" line="7">
			<f a="?message" v="&quot;&quot;">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ message : "" }</e></m></meta>
		</new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="openfl.events.Event" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/events/Event.hx">
		<ACTIVATE public="1" get="inline" set="null" expr="&quot;activate&quot;" line="11" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"activate"</e></m></meta>
		</ACTIVATE>
		<ADDED public="1" get="inline" set="null" expr="&quot;added&quot;" line="12" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"added"</e></m></meta>
		</ADDED>
		<ADDED_TO_STAGE public="1" get="inline" set="null" expr="&quot;addedToStage&quot;" line="13" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"addedToStage"</e></m></meta>
		</ADDED_TO_STAGE>
		<CANCEL public="1" get="inline" set="null" expr="&quot;cancel&quot;" line="14" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"cancel"</e></m></meta>
		</CANCEL>
		<CHANGE public="1" get="inline" set="null" expr="&quot;change&quot;" line="15" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"change"</e></m></meta>
		</CHANGE>
		<CLOSE public="1" get="inline" set="null" expr="&quot;close&quot;" line="16" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"close"</e></m></meta>
		</CLOSE>
		<COMPLETE public="1" get="inline" set="null" expr="&quot;complete&quot;" line="17" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"complete"</e></m></meta>
		</COMPLETE>
		<CONNECT public="1" get="inline" set="null" expr="&quot;connect&quot;" line="18" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"connect"</e></m></meta>
		</CONNECT>
		<CONTEXT3D_CREATE public="1" get="inline" set="null" expr="&quot;context3DCreate&quot;" line="19" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"context3DCreate"</e></m></meta>
		</CONTEXT3D_CREATE>
		<DEACTIVATE public="1" get="inline" set="null" expr="&quot;deactivate&quot;" line="20" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"deactivate"</e></m></meta>
		</DEACTIVATE>
		<ENTER_FRAME public="1" get="inline" set="null" expr="&quot;enterFrame&quot;" line="21" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"enterFrame"</e></m></meta>
		</ENTER_FRAME>
		<ID3 public="1" get="inline" set="null" expr="&quot;id3&quot;" line="22" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"id3"</e></m></meta>
		</ID3>
		<INIT public="1" get="inline" set="null" expr="&quot;init&quot;" line="23" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"init"</e></m></meta>
		</INIT>
		<MOUSE_LEAVE public="1" get="inline" set="null" expr="&quot;mouseLeave&quot;" line="24" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"mouseLeave"</e></m></meta>
		</MOUSE_LEAVE>
		<OPEN public="1" get="inline" set="null" expr="&quot;open&quot;" line="25" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"open"</e></m></meta>
		</OPEN>
		<REMOVED public="1" get="inline" set="null" expr="&quot;removed&quot;" line="26" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"removed"</e></m></meta>
		</REMOVED>
		<REMOVED_FROM_STAGE public="1" get="inline" set="null" expr="&quot;removedFromStage&quot;" line="27" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"removedFromStage"</e></m></meta>
		</REMOVED_FROM_STAGE>
		<RENDER public="1" get="inline" set="null" expr="&quot;render&quot;" line="28" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"render"</e></m></meta>
		</RENDER>
		<RESIZE public="1" get="inline" set="null" expr="&quot;resize&quot;" line="29" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"resize"</e></m></meta>
		</RESIZE>
		<SCROLL public="1" get="inline" set="null" expr="&quot;scroll&quot;" line="30" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"scroll"</e></m></meta>
		</SCROLL>
		<SELECT public="1" get="inline" set="null" expr="&quot;select&quot;" line="31" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"select"</e></m></meta>
		</SELECT>
		<SOUND_COMPLETE public="1" get="inline" set="null" expr="&quot;soundComplete&quot;" line="32" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"soundComplete"</e></m></meta>
		</SOUND_COMPLETE>
		<TAB_CHILDREN_CHANGE public="1" get="inline" set="null" expr="&quot;tabChildrenChange&quot;" line="33" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"tabChildrenChange"</e></m></meta>
		</TAB_CHILDREN_CHANGE>
		<TAB_ENABLED_CHANGE public="1" get="inline" set="null" expr="&quot;tabEnabledChange&quot;" line="34" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"tabEnabledChange"</e></m></meta>
		</TAB_ENABLED_CHANGE>
		<TAB_INDEX_CHANGE public="1" get="inline" set="null" expr="&quot;tabIndexChange&quot;" line="35" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"tabIndexChange"</e></m></meta>
		</TAB_INDEX_CHANGE>
		<UNLOAD public="1" get="inline" set="null" expr="&quot;unload&quot;" line="36" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"unload"</e></m></meta>
		</UNLOAD>
		<bubbles public="1" set="null"><x path="Bool"/></bubbles>
		<cancelable public="1" set="null"><x path="Bool"/></cancelable>
		<currentTarget public="1" set="null"><d/></currentTarget>
		<eventPhase public="1" set="null"><x path="openfl.events.EventPhase"/></eventPhase>
		<target public="1" set="null"><d/></target>
		<type public="1" set="null"><c path="String"/></type>
		<__isCanceled><x path="Bool"/></__isCanceled>
		<__isCanceledNow><x path="Bool"/></__isCanceledNow>
		<__preventDefault><x path="Bool"/></__preventDefault>
		<clone public="1" set="method" line="60"><f a=""><c path="openfl.events.Event"/></f></clone>
		<formatToString public="1" set="method" line="71"><f a="className:?p1:?p2:?p3:?p4:?p5">
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
</f></formatToString>
		<isDefaultPrevented public="1" set="method" line="85"><f a=""><x path="Bool"/></f></isDefaultPrevented>
		<preventDefault public="1" set="method" line="92"><f a=""><x path="Void"/></f></preventDefault>
		<stopImmediatePropagation public="1" set="method" line="103"><f a=""><x path="Void"/></f></stopImmediatePropagation>
		<stopPropagation public="1" set="method" line="111"><f a=""><x path="Void"/></f></stopPropagation>
		<toString public="1" set="method" line="118"><f a=""><c path="String"/></f></toString>
		<__formatToString set="method" line="125"><f a="className:parameters">
	<c path="String"/>
	<c path="Array"><c path="String"/></c>
	<c path="String"/>
</f></__formatToString>
		<new public="1" set="method" line="50">
			<f a="type:?bubbles:?cancelable" v=":false:false">
				<c path="String"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ cancelable : false, bubbles : false }</e></m></meta>
		</new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="openfl.events.ActivityEvent" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/events/ActivityEvent.hx">
		<extends path="openfl.events.Event"/>
		<ACTIVITY public="1" get="inline" set="null" expr="&quot;activity&quot;" line="7" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"activity"</e></m></meta>
		</ACTIVITY>
		<activating public="1"><x path="Bool"/></activating>
		<clone public="1" set="method" line="21" override="1"><f a=""><c path="openfl.events.Event"/></f></clone>
		<toString public="1" set="method" line="34" override="1"><f a=""><c path="String"/></f></toString>
		<new public="1" set="method" line="12">
			<f a="type:?bubbles:?cancelable:?activating" v=":false:false:false">
				<c path="String"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ activating : false, cancelable : false, bubbles : false }</e></m></meta>
		</new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="openfl.events.TextEvent" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/events/TextEvent.hx">
		<extends path="openfl.events.Event"/>
		<LINK public="1" get="inline" set="null" expr="&quot;link&quot;" line="7" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"link"</e></m></meta>
		</LINK>
		<TEXT_INPUT public="1" get="inline" set="null" expr="&quot;textInput&quot;" line="8" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"textInput"</e></m></meta>
		</TEXT_INPUT>
		<text public="1"><c path="String"/></text>
		<clone public="1" set="method" line="22" override="1"><f a=""><c path="openfl.events.Event"/></f></clone>
		<toString public="1" set="method" line="35" override="1"><f a=""><c path="String"/></f></toString>
		<new public="1" set="method" line="13">
			<f a="type:?bubbles:?cancelable:?text" v=":false:false:&quot;&quot;">
				<c path="String"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ text : "", cancelable : false, bubbles : false }</e></m></meta>
		</new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="openfl.events.ErrorEvent" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/events/ErrorEvent.hx">
		<extends path="openfl.events.TextEvent"/>
		<ERROR public="1" get="inline" set="null" expr="&quot;error&quot;" line="7" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"error"</e></m></meta>
		</ERROR>
		<errorID public="1" set="null"><x path="Int"/></errorID>
		<clone public="1" set="method" line="20" override="1"><f a=""><c path="openfl.events.Event"/></f></clone>
		<toString public="1" set="method" line="33" override="1"><f a=""><c path="String"/></f></toString>
		<new public="1" set="method" line="12">
			<f a="type:?bubbles:?cancelable:?text:?id" v=":false:false:&quot;&quot;:0">
				<c path="String"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<c path="String"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ id : 0, text : "", cancelable : false, bubbles : false }</e></m></meta>
		</new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="openfl.events._EventDispatcher.Listener" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/events/EventDispatcher.hx" private="1" module="openfl.events.EventDispatcher">
		<callback public="1"><f a="">
	<d/>
	<x path="Void"/>
</f></callback>
		<priority public="1"><x path="Int"/></priority>
		<useCapture public="1"><x path="Bool"/></useCapture>
		<match public="1" set="method" line="316"><f a="callback:useCapture">
	<f a="">
		<d/>
		<x path="Void"/>
	</f>
	<x path="Bool"/>
	<x path="Bool"/>
</f></match>
		<new public="1" set="method" line="307"><f a="callback:useCapture:priority">
	<f a="">
		<d/>
		<x path="Void"/>
	</f>
	<x path="Bool"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<abstract path="openfl.events.EventPhase" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/events/EventPhase.hx">
		<from><icast><x path="Int"/></icast></from>
		<this><x path="Int"/></this>
		<to><icast><x path="Int"/></icast></to>
		<meta><m n=":enum"/></meta>
		<impl><class path="openfl.events._EventPhase.EventPhase_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/events/EventPhase.hx" private="1" module="openfl.events.EventPhase" extern="1">
	<AT_TARGET public="1" get="inline" set="null" expr="cast 2" line="6" static="1">
		<x path="openfl.events.EventPhase"/>
		<meta>
			<m n=":value"><e>cast 2</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</AT_TARGET>
	<BUBBLING_PHASE public="1" get="inline" set="null" expr="cast 3" line="7" static="1">
		<x path="openfl.events.EventPhase"/>
		<meta>
			<m n=":value"><e>cast 3</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</BUBBLING_PHASE>
	<CAPTURING_PHASE public="1" get="inline" set="null" expr="cast 1" line="8" static="1">
		<x path="openfl.events.EventPhase"/>
		<meta>
			<m n=":value"><e>cast 1</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</CAPTURING_PHASE>
	<meta>
		<m n=":final"/>
		<m n=":enum"/>
	</meta>
</class></impl>
	</abstract>
	<class path="openfl.events._EventPhase.EventPhase_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/events/EventPhase.hx" private="1" module="openfl.events.EventPhase" extern="1">
		<AT_TARGET public="1" get="inline" set="null" expr="cast 2" line="6" static="1">
			<x path="openfl.events.EventPhase"/>
			<meta>
				<m n=":value"><e>cast 2</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</AT_TARGET>
		<BUBBLING_PHASE public="1" get="inline" set="null" expr="cast 3" line="7" static="1">
			<x path="openfl.events.EventPhase"/>
			<meta>
				<m n=":value"><e>cast 3</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</BUBBLING_PHASE>
		<CAPTURING_PHASE public="1" get="inline" set="null" expr="cast 1" line="8" static="1">
			<x path="openfl.events.EventPhase"/>
			<meta>
				<m n=":value"><e>cast 1</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</CAPTURING_PHASE>
		<meta>
			<m n=":final"/>
			<m n=":enum"/>
		</meta>
	</class>
	<class path="openfl.events.FocusEvent" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/events/FocusEvent.hx">
		<extends path="openfl.events.Event"/>
		<FOCUS_IN public="1" get="inline" set="null" expr="&quot;focusIn&quot;" line="10" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"focusIn"</e></m></meta>
		</FOCUS_IN>
		<FOCUS_OUT public="1" get="inline" set="null" expr="&quot;focusOut&quot;" line="11" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"focusOut"</e></m></meta>
		</FOCUS_OUT>
		<KEY_FOCUS_CHANGE public="1" get="inline" set="null" expr="&quot;keyFocusChange&quot;" line="12" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"keyFocusChange"</e></m></meta>
		</KEY_FOCUS_CHANGE>
		<MOUSE_FOCUS_CHANGE public="1" get="inline" set="null" expr="&quot;mouseFocusChange&quot;" line="13" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"mouseFocusChange"</e></m></meta>
		</MOUSE_FOCUS_CHANGE>
		<keyCode public="1"><x path="Int"/></keyCode>
		<relatedObject public="1"><c path="openfl.display.InteractiveObject"/></relatedObject>
		<shiftKey public="1"><x path="Bool"/></shiftKey>
		<clone public="1" set="method" line="31" override="1"><f a=""><c path="openfl.events.Event"/></f></clone>
		<toString public="1" set="method" line="44" override="1"><f a=""><c path="String"/></f></toString>
		<new public="1" set="method" line="20">
			<f a="type:?bubbles:?cancelable:?relatedObject:?shiftKey:?keyCode" v=":false:false:null:false:0">
				<c path="String"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<c path="openfl.display.InteractiveObject"/>
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ keyCode : 0, shiftKey : false, relatedObject : null, cancelable : false, bubbles : false }</e></m></meta>
		</new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="openfl.events.FullScreenEvent" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/events/FullScreenEvent.hx">
		<extends path="openfl.events.ActivityEvent"/>
		<FULL_SCREEN public="1" get="inline" set="null" expr="&quot;fullScreen&quot;" line="7" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"fullScreen"</e></m></meta>
		</FULL_SCREEN>
		<FULL_SCREEN_INTERACTIVE_ACCEPTED public="1" get="inline" set="null" expr="&quot;fullScreenInteractiveAccepted&quot;" line="8" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"fullScreenInteractiveAccepted"</e></m></meta>
		</FULL_SCREEN_INTERACTIVE_ACCEPTED>
		<fullScreen public="1"><x path="Bool"/></fullScreen>
		<interactive public="1"><x path="Bool"/></interactive>
		<clone public="1" set="method" line="26" override="1"><f a=""><c path="openfl.events.Event"/></f></clone>
		<toString public="1" set="method" line="39" override="1"><f a=""><c path="String"/></f></toString>
		<new public="1" set="method" line="14">
			<f a="type:?bubbles:?cancelable:?fullScreen:?interactive" v=":false:false:false:false">
				<c path="String"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ interactive : false, fullScreen : false, cancelable : false, bubbles : false }</e></m></meta>
		</new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="openfl.events.GameInputEvent" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/events/GameInputEvent.hx">
		<extends path="openfl.events.Event"/>
		<DEVICE_ADDED public="1" get="inline" set="null" expr="&quot;deviceAdded&quot;" line="10" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"deviceAdded"</e></m></meta>
		</DEVICE_ADDED>
		<DEVICE_REMOVED public="1" get="inline" set="null" expr="&quot;deviceRemoved&quot;" line="11" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"deviceRemoved"</e></m></meta>
		</DEVICE_REMOVED>
		<DEVICE_UNUSABLE public="1" get="inline" set="null" expr="&quot;deviceUnusable&quot;" line="12" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"deviceUnusable"</e></m></meta>
		</DEVICE_UNUSABLE>
		<device public="1" set="null"><c path="openfl.ui.GameInputDevice"/></device>
		<clone public="1" set="method" line="26" override="1"><f a=""><c path="openfl.events.Event"/></f></clone>
		<toString public="1" set="method" line="39" override="1"><f a=""><c path="String"/></f></toString>
		<new public="1" set="method" line="17">
			<f a="type:?bubbles:?cancelable:?device" v=":true:false:null">
				<c path="String"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<c path="openfl.ui.GameInputDevice"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ device : null, cancelable : false, bubbles : true }</e></m></meta>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":final"/>
		</meta>
	</class>
	<class path="openfl.events.HTTPStatusEvent" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/events/HTTPStatusEvent.hx">
		<extends path="openfl.events.Event"/>
		<HTTP_RESPONSE_STATUS public="1" get="inline" set="null" expr="&quot;httpResponseStatus&quot;" line="7" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"httpResponseStatus"</e></m></meta>
		</HTTP_RESPONSE_STATUS>
		<HTTP_STATUS public="1" get="inline" set="null" expr="&quot;httpStatus&quot;" line="8" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"httpStatus"</e></m></meta>
		</HTTP_STATUS>
		<redirected public="1"><x path="Bool"/></redirected>
		<responseHeaders public="1"><c path="Array"><d/></c></responseHeaders>
		<responseURL public="1"><c path="String"/></responseURL>
		<status public="1" set="null"><x path="Int"/></status>
		<clone public="1" set="method" line="26" override="1"><f a=""><c path="openfl.events.Event"/></f></clone>
		<toString public="1" set="method" line="39" override="1"><f a=""><c path="String"/></f></toString>
		<new public="1" set="method" line="16">
			<f a="type:?bubbles:?cancelable:?status:?redirected" v=":false:false:0:false">
				<c path="String"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ redirected : false, status : 0, cancelable : false, bubbles : false }</e></m></meta>
		</new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="openfl.events.IOErrorEvent" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/events/IOErrorEvent.hx">
		<extends path="openfl.events.ErrorEvent"/>
		<IO_ERROR public="1" get="inline" set="null" expr="&quot;ioError&quot;" line="7" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"ioError"</e></m></meta>
		</IO_ERROR>
		<clone public="1" set="method" line="17" override="1"><f a=""><c path="openfl.events.Event"/></f></clone>
		<toString public="1" set="method" line="30" override="1"><f a=""><c path="String"/></f></toString>
		<new public="1" set="method" line="10">
			<f a="type:?bubbles:?cancelable:?text:?id" v=":true:false:&quot;&quot;:0">
				<c path="String"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<c path="String"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ id : 0, text : "", cancelable : false, bubbles : true }</e></m></meta>
		</new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="openfl.events.KeyboardEvent" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/events/KeyboardEvent.hx">
		<extends path="openfl.events.Event"/>
		<KEY_DOWN public="1" get="inline" set="null" expr="&quot;keyDown&quot;" line="10" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"keyDown"</e></m></meta>
		</KEY_DOWN>
		<KEY_UP public="1" get="inline" set="null" expr="&quot;keyUp&quot;" line="11" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"keyUp"</e></m></meta>
		</KEY_UP>
		<altKey public="1"><x path="Bool"/></altKey>
		<charCode public="1"><x path="Int"/></charCode>
		<ctrlKey public="1"><x path="Bool"/></ctrlKey>
		<commandKey public="1"><x path="Bool"/></commandKey>
		<controlKey public="1"><x path="Bool"/></controlKey>
		<keyCode public="1"><x path="Int"/></keyCode>
		<keyLocation public="1"><x path="openfl.ui.KeyLocation"/></keyLocation>
		<shiftKey public="1"><x path="Bool"/></shiftKey>
		<clone public="1" set="method" line="41" override="1"><f a=""><c path="openfl.events.Event"/></f></clone>
		<toString public="1" set="method" line="52" override="1"><f a=""><c path="String"/></f></toString>
		<new public="1" set="method" line="23">
			<f a="type:?bubbles:?cancelable:?charCodeValue:?keyCodeValue:?keyLocationValue:?ctrlKeyValue:?altKeyValue:?shiftKeyValue:?controlKeyValue:?commandKeyValue" v=":false:false:0:0:null:false:false:false:false:false">
				<c path="String"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="openfl.ui.KeyLocation"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ commandKeyValue : false, controlKeyValue : false, shiftKeyValue : false, altKeyValue : false, ctrlKeyValue : false, keyLocationValue : null, keyCodeValue : 0, charCodeValue : 0, cancelable : false, bubbles : false }</e></m></meta>
		</new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="openfl.events.MouseEvent" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/events/MouseEvent.hx">
		<extends path="openfl.events.Event"/>
		<CLICK public="1" get="inline" set="null" expr="&quot;click&quot;" line="11" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"click"</e></m></meta>
		</CLICK>
		<DOUBLE_CLICK public="1" get="inline" set="null" expr="&quot;doubleClick&quot;" line="12" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"doubleClick"</e></m></meta>
		</DOUBLE_CLICK>
		<MIDDLE_CLICK public="1" get="inline" set="null" expr="&quot;middleClick&quot;" line="13" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"middleClick"</e></m></meta>
		</MIDDLE_CLICK>
		<MIDDLE_MOUSE_DOWN public="1" get="inline" set="null" expr="&quot;middleMouseDown&quot;" line="14" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"middleMouseDown"</e></m></meta>
		</MIDDLE_MOUSE_DOWN>
		<MIDDLE_MOUSE_UP public="1" get="inline" set="null" expr="&quot;middleMouseUp&quot;" line="15" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"middleMouseUp"</e></m></meta>
		</MIDDLE_MOUSE_UP>
		<MOUSE_DOWN public="1" get="inline" set="null" expr="&quot;mouseDown&quot;" line="16" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"mouseDown"</e></m></meta>
		</MOUSE_DOWN>
		<MOUSE_MOVE public="1" get="inline" set="null" expr="&quot;mouseMove&quot;" line="17" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"mouseMove"</e></m></meta>
		</MOUSE_MOVE>
		<MOUSE_OUT public="1" get="inline" set="null" expr="&quot;mouseOut&quot;" line="18" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"mouseOut"</e></m></meta>
		</MOUSE_OUT>
		<MOUSE_OVER public="1" get="inline" set="null" expr="&quot;mouseOver&quot;" line="19" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"mouseOver"</e></m></meta>
		</MOUSE_OVER>
		<MOUSE_UP public="1" get="inline" set="null" expr="&quot;mouseUp&quot;" line="20" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"mouseUp"</e></m></meta>
		</MOUSE_UP>
		<MOUSE_WHEEL public="1" get="inline" set="null" expr="&quot;mouseWheel&quot;" line="21" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"mouseWheel"</e></m></meta>
		</MOUSE_WHEEL>
		<RIGHT_CLICK public="1" get="inline" set="null" expr="&quot;rightClick&quot;" line="22" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"rightClick"</e></m></meta>
		</RIGHT_CLICK>
		<RIGHT_MOUSE_DOWN public="1" get="inline" set="null" expr="&quot;rightMouseDown&quot;" line="23" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"rightMouseDown"</e></m></meta>
		</RIGHT_MOUSE_DOWN>
		<RIGHT_MOUSE_UP public="1" get="inline" set="null" expr="&quot;rightMouseUp&quot;" line="24" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"rightMouseUp"</e></m></meta>
		</RIGHT_MOUSE_UP>
		<ROLL_OUT public="1" get="inline" set="null" expr="&quot;rollOut&quot;" line="25" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"rollOut"</e></m></meta>
		</ROLL_OUT>
		<ROLL_OVER public="1" get="inline" set="null" expr="&quot;rollOver&quot;" line="26" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"rollOver"</e></m></meta>
		</ROLL_OVER>
		<__altKey static="1"><x path="Bool"/></__altKey>
		<__buttonDown static="1"><x path="Bool"/></__buttonDown>
		<__commandKey static="1"><x path="Bool"/></__commandKey>
		<__ctrlKey static="1"><x path="Bool"/></__ctrlKey>
		<__shiftKey static="1"><x path="Bool"/></__shiftKey>
		<__create public="1" set="method" line="67" static="1">
			<f a="type:button:stageX:stageY:local:target:?delta" v="::::::0">
				<c path="String"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
				<c path="openfl.geom.Point"/>
				<c path="openfl.display.InteractiveObject"/>
				<x path="Int"/>
				<c path="openfl.events.MouseEvent"/>
			</f>
			<meta><m n=":value"><e>{ delta : 0 }</e></m></meta>
		</__create>
		<altKey public="1"><x path="Bool"/></altKey>
		<buttonDown public="1"><x path="Bool"/></buttonDown>
		<commandKey public="1"><x path="Bool"/></commandKey>
		<clickCount public="1"><x path="Int"/></clickCount>
		<ctrlKey public="1"><x path="Bool"/></ctrlKey>
		<delta public="1"><x path="Int"/></delta>
		<localX public="1"><x path="Float"/></localX>
		<localY public="1"><x path="Float"/></localY>
		<relatedObject public="1"><c path="openfl.display.InteractiveObject"/></relatedObject>
		<shiftKey public="1"><x path="Bool"/></shiftKey>
		<stageX public="1"><x path="Float"/></stageX>
		<stageY public="1"><x path="Float"/></stageY>
		<clone public="1" set="method" line="93" override="1"><f a=""><c path="openfl.events.Event"/></f></clone>
		<toString public="1" set="method" line="104" override="1"><f a=""><c path="String"/></f></toString>
		<updateAfterEvent public="1" set="method" line="111"><f a=""><x path="Void"/></f></updateAfterEvent>
		<new public="1" set="method" line="48">
			<f a="type:?bubbles:?cancelable:?localX:?localY:?relatedObject:?ctrlKey:?altKey:?shiftKey:?buttonDown:?delta:?commandKey:?clickCount" v=":true:false:0:0:null:false:false:false:false:0:false:0">
				<c path="String"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Float"/>
				<x path="Float"/>
				<c path="openfl.display.InteractiveObject"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ clickCount : 0, commandKey : false, delta : 0, buttonDown : false, shiftKey : false, altKey : false, ctrlKey : false, relatedObject : null, localY : 0, localX : 0, cancelable : false, bubbles : true }</e></m></meta>
		</new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="openfl.events.NetStatusEvent" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/events/NetStatusEvent.hx">
		<extends path="openfl.events.Event"/>
		<NET_STATUS public="1" get="inline" set="null" expr="&quot;netStatus&quot;" line="7" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"netStatus"</e></m></meta>
		</NET_STATUS>
		<info public="1"><d/></info>
		<clone public="1" set="method" line="21" override="1"><f a=""><c path="openfl.events.Event"/></f></clone>
		<toString public="1" set="method" line="34" override="1"><f a=""><c path="String"/></f></toString>
		<new public="1" set="method" line="12">
			<f a="type:?bubbles:?cancelable:?info" v=":false:false:null">
				<c path="String"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<d/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ info : null, cancelable : false, bubbles : false }</e></m></meta>
		</new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="openfl.events.ProgressEvent" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/events/ProgressEvent.hx">
		<extends path="openfl.events.Event"/>
		<PROGRESS public="1" get="inline" set="null" expr="&quot;progress&quot;" line="7" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"progress"</e></m></meta>
		</PROGRESS>
		<SOCKET_DATA public="1" get="inline" set="null" expr="&quot;socketData&quot;" line="8" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"socketData"</e></m></meta>
		</SOCKET_DATA>
		<bytesLoaded public="1"><x path="Float"/></bytesLoaded>
		<bytesTotal public="1"><x path="Float"/></bytesTotal>
		<clone public="1" set="method" line="24" override="1"><f a=""><c path="openfl.events.Event"/></f></clone>
		<toString public="1" set="method" line="37" override="1"><f a=""><c path="String"/></f></toString>
		<new public="1" set="method" line="14">
			<f a="type:?bubbles:?cancelable:?bytesLoaded:?bytesTotal" v=":false:false:0:0">
				<c path="String"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ bytesTotal : 0, bytesLoaded : 0, cancelable : false, bubbles : false }</e></m></meta>
		</new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="openfl.events.SecurityErrorEvent" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/events/SecurityErrorEvent.hx">
		<extends path="openfl.events.ErrorEvent"/>
		<SECURITY_ERROR public="1" get="inline" set="null" expr="&quot;securityError&quot;" line="7" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"securityError"</e></m></meta>
		</SECURITY_ERROR>
		<clone public="1" set="method" line="17" override="1"><f a=""><c path="openfl.events.Event"/></f></clone>
		<toString public="1" set="method" line="30" override="1"><f a=""><c path="String"/></f></toString>
		<new public="1" set="method" line="10">
			<f a="type:?bubbles:?cancelable:?text:?id" v=":false:false:&quot;&quot;:0">
				<c path="String"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<c path="String"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ id : 0, text : "", cancelable : false, bubbles : false }</e></m></meta>
		</new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="openfl.events.TouchEvent" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/events/TouchEvent.hx">
		<extends path="openfl.events.Event"/>
		<TOUCH_BEGIN public="1" get="inline" set="null" expr="&quot;touchBegin&quot;" line="12" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"touchBegin"</e></m></meta>
		</TOUCH_BEGIN>
		<TOUCH_END public="1" get="inline" set="null" expr="&quot;touchEnd&quot;" line="13" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"touchEnd"</e></m></meta>
		</TOUCH_END>
		<TOUCH_MOVE public="1" get="inline" set="null" expr="&quot;touchMove&quot;" line="14" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"touchMove"</e></m></meta>
		</TOUCH_MOVE>
		<TOUCH_OUT public="1" get="inline" set="null" expr="&quot;touchOut&quot;" line="15" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"touchOut"</e></m></meta>
		</TOUCH_OUT>
		<TOUCH_OVER public="1" get="inline" set="null" expr="&quot;touchOver&quot;" line="16" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"touchOver"</e></m></meta>
		</TOUCH_OVER>
		<TOUCH_ROLL_OUT public="1" get="inline" set="null" expr="&quot;touchRollOut&quot;" line="17" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"touchRollOut"</e></m></meta>
		</TOUCH_ROLL_OUT>
		<TOUCH_ROLL_OVER public="1" get="inline" set="null" expr="&quot;touchRollOver&quot;" line="18" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"touchRollOver"</e></m></meta>
		</TOUCH_ROLL_OVER>
		<TOUCH_TAP public="1" get="inline" set="null" expr="&quot;touchTap&quot;" line="19" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"touchTap"</e></m></meta>
		</TOUCH_TAP>
		<__create public="1" set="method" line="85" static="1"><f a="type:touch:stageX:stageY:local:target">
	<c path="String"/>
	<d/>
	<x path="Float"/>
	<x path="Float"/>
	<c path="openfl.geom.Point"/>
	<c path="openfl.display.InteractiveObject"/>
	<c path="openfl.events.TouchEvent"/>
</f></__create>
		<altKey public="1"><x path="Bool"/></altKey>
		<commandKey public="1"><x path="Bool"/></commandKey>
		<controlKey public="1"><x path="Bool"/></controlKey>
		<ctrlKey public="1"><x path="Bool"/></ctrlKey>
		<delta public="1"><x path="Int"/></delta>
		<isPrimaryTouchPoint public="1"><x path="Bool"/></isPrimaryTouchPoint>
		<localX public="1"><x path="Float"/></localX>
		<localY public="1"><x path="Float"/></localY>
		<pressure public="1"><x path="Float"/></pressure>
		<relatedObject public="1"><c path="openfl.display.InteractiveObject"/></relatedObject>
		<shiftKey public="1"><x path="Bool"/></shiftKey>
		<sizeX public="1"><x path="Float"/></sizeX>
		<sizeY public="1"><x path="Float"/></sizeY>
		<stageX public="1"><x path="Float"/></stageX>
		<stageY public="1"><x path="Float"/></stageY>
		<touchPointID public="1"><x path="Int"/></touchPointID>
		<clone public="1" set="method" line="60" override="1"><f a=""><c path="openfl.events.Event"/></f></clone>
		<toString public="1" set="method" line="71" override="1"><f a=""><c path="String"/></f></toString>
		<updateAfterEvent public="1" set="method" line="78"><f a=""><x path="Void"/></f></updateAfterEvent>
		<new public="1" set="method" line="39">
			<f a="type:?bubbles:?cancelable:?touchPointID:?isPrimaryTouchPoint:?localX:?localY:?sizeX:?sizeY:?pressure:?relatedObject:?ctrlKey:?altKey:?shiftKey:?commandKey:?controlKey:?timestamp:?touchIntent:?samples:?isTouchPointCanceled" v=":true:false:0:false:0:0:0:0:0:null:false:false:false:false:false:0:null:null:false">
				<c path="String"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<c path="openfl.display.InteractiveObject"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Float"/>
				<c path="String"/>
				<x path="openfl.utils.ByteArray"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ isTouchPointCanceled : false, samples : null, touchIntent : null, timestamp : 0, controlKey : false, commandKey : false, shiftKey : false, altKey : false, ctrlKey : false, relatedObject : null, pressure : 0, sizeY : 0, sizeX : 0, localY : 0, localX : 0, isPrimaryTouchPoint : false, touchPointID : 0, cancelable : false, bubbles : true }</e></m></meta>
		</new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="openfl.filters.BitmapFilter" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/filters/BitmapFilter.hx">
		<__tmpRenderTexture static="1"><c path="openfl._internal.renderer.opengl.utils.RenderTexture"/></__tmpRenderTexture>
		<__applyFilters set="method" line="51" static="1"><f a="filters:renderSession:source:target:sourceRect:destPoint">
	<c path="Array"><c path="openfl.filters.BitmapFilter"/></c>
	<c path="openfl._internal.renderer.RenderSession"/>
	<c path="openfl.display.BitmapData"/>
	<c path="openfl.display.BitmapData"/>
	<c path="openfl.geom.Rectangle"/>
	<c path="openfl.geom.Point"/>
	<x path="Void"/>
</f></__applyFilters>
		<__expandBounds set="method" line="98" static="1"><f a="filters:rect:matrix">
	<c path="Array"><c path="openfl.filters.BitmapFilter"/></c>
	<c path="openfl.geom.Rectangle"/>
	<c path="openfl.geom.Matrix"/>
	<x path="Void"/>
</f></__expandBounds>
		<__dirty expr="true">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</__dirty>
		<__passes expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</__passes>
		<__saveLastFilter expr="false">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</__saveLastFilter>
		<clone public="1" set="method" line="35"><f a=""><c path="openfl.filters.BitmapFilter"/></f></clone>
		<__growBounds set="method" line="115"><f a="rect">
	<c path="openfl.geom.Rectangle"/>
	<x path="Void"/>
</f></__growBounds>
		<__preparePass set="method" line="122"><f a="pass">
	<x path="Int"/>
	<c path="openfl.display.Shader"/>
</f></__preparePass>
		<__useLastFilter set="method" line="129"><f a="pass">
	<x path="Int"/>
	<x path="Bool"/>
</f></__useLastFilter>
		<new public="1" set="method" line="28"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":access"><e>openfl.display.BitmapData</e></m>
			<m n=":access"><e>openfl.geom.Rectangle</e></m>
		</meta>
	</class>
	<class path="openfl.geom.Matrix3D" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/geom/Matrix3D.hx">
		<create2D public="1" set="method" line="324" static="1">
			<f a="x:y:?scale:?rotation" v="::1:0">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<c path="openfl.geom.Matrix3D"/>
			</f>
			<meta><m n=":value"><e>{ rotation : 0, scale : 1 }</e></m></meta>
		</create2D>
		<createABCD public="1" set="method" line="335" static="1"><f a="a:b:c:d:tx:ty">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<c path="openfl.geom.Matrix3D"/>
</f></createABCD>
		<createOrtho public="1" set="method" line="342" static="1"><f a="x0:x1:y0:y1:zNear:zFar">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<c path="openfl.geom.Matrix3D"/>
</f></createOrtho>
		<interpolate public="1" set="method" line="495" static="1"><f a="thisMat:toMat:percent">
	<c path="openfl.geom.Matrix3D"/>
	<c path="openfl.geom.Matrix3D"/>
	<x path="Float"/>
	<c path="openfl.geom.Matrix3D"/>
</f></interpolate>
		<__getAxisRotation set="method" line="851" static="1"><f a="x:y:z:degrees">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<c path="openfl.geom.Matrix3D"/>
</f></__getAxisRotation>
		<determinant public="1" get="accessor" set="null"><x path="Float"/></determinant>
		<position public="1" get="accessor" set="accessor"><c path="openfl.geom.Vector3D"/></position>
		<rawData public="1"><x path="openfl.Vector"><x path="Float"/></x></rawData>
		<append public="1" set="method" line="33"><f a="lhs">
	<c path="openfl.geom.Matrix3D"/>
	<x path="Void"/>
</f></append>
		<appendRotation public="1" set="method" line="67">
			<f a="degrees:axis:?pivotPoint" v="::null">
				<x path="Float"/>
				<c path="openfl.geom.Vector3D"/>
				<c path="openfl.geom.Vector3D"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ pivotPoint : null }</e></m></meta>
		</appendRotation>
		<appendScale public="1" set="method" line="83"><f a="xScale:yScale:zScale">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></appendScale>
		<appendTranslation public="1" set="method" line="90"><f a="x:y:z">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></appendTranslation>
		<clone public="1" set="method" line="99"><f a=""><c path="openfl.geom.Matrix3D"/></f></clone>
		<copyColumnFrom public="1" set="method" line="106"><f a="column:vector3D">
	<x path="Int"/>
	<c path="openfl.geom.Vector3D"/>
	<x path="Void"/>
</f></copyColumnFrom>
		<copyColumnTo public="1" set="method" line="145"><f a="column:vector3D">
	<x path="Int"/>
	<c path="openfl.geom.Vector3D"/>
	<x path="Void"/>
</f></copyColumnTo>
		<copyFrom public="1" set="method" line="184"><f a="other">
	<c path="openfl.geom.Matrix3D"/>
	<x path="Void"/>
</f></copyFrom>
		<copyRawDataFrom public="1" set="method" line="191">
			<f a="vector:?index:?transpose" v=":0:false">
				<x path="openfl.Vector"><x path="Float"/></x>
				<x path="UInt"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ transpose : false, index : 0 }</e></m></meta>
		</copyRawDataFrom>
		<copyRawDataTo public="1" set="method" line="216">
			<f a="vector:?index:?transpose" v=":0:false">
				<x path="openfl.Vector"><x path="Float"/></x>
				<x path="UInt"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ transpose : false, index : 0 }</e></m></meta>
		</copyRawDataTo>
		<copyRowFrom public="1" set="method" line="239"><f a="row:vector3D">
	<x path="UInt"/>
	<c path="openfl.geom.Vector3D"/>
	<x path="Void"/>
</f></copyRowFrom>
		<copyRowTo public="1" set="method" line="278"><f a="row:vector3D">
	<x path="Int"/>
	<c path="openfl.geom.Vector3D"/>
	<x path="Void"/>
</f></copyRowTo>
		<copyToMatrix3D public="1" set="method" line="317"><f a="other">
	<c path="openfl.geom.Matrix3D"/>
	<x path="Void"/>
</f></copyToMatrix3D>
		<decompose public="1" set="method" line="353"><f a="?orientationStyle">
	<x path="openfl.geom.Orientation3D"/>
	<x path="openfl.Vector"><c path="openfl.geom.Vector3D"/></x>
</f></decompose>
		<deltaTransformVector public="1" set="method" line="479"><f a="v">
	<c path="openfl.geom.Vector3D"/>
	<c path="openfl.geom.Vector3D"/>
</f></deltaTransformVector>
		<identity public="1" set="method" line="488"><f a=""><x path="Void"/></f></identity>
		<interpolateTo public="1" set="method" line="510"><f a="toMat:percent">
	<c path="openfl.geom.Matrix3D"/>
	<x path="Float"/>
	<x path="Void"/>
</f></interpolateTo>
		<invert public="1" set="method" line="521"><f a=""><x path="Bool"/></f></invert>
		<pointAt public="1" set="method" line="559">
			<f a="pos:?at:?up" v=":null:null">
				<c path="openfl.geom.Vector3D"/>
				<c path="openfl.geom.Vector3D"/>
				<c path="openfl.geom.Vector3D"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ up : null, at : null }</e></m></meta>
		</pointAt>
		<prepend public="1" set="method" line="626"><f a="rhs">
	<c path="openfl.geom.Matrix3D"/>
	<x path="Void"/>
</f></prepend>
		<prependRotation public="1" set="method" line="660">
			<f a="degrees:axis:?pivotPoint" v="::null">
				<x path="Float"/>
				<c path="openfl.geom.Vector3D"/>
				<c path="openfl.geom.Vector3D"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ pivotPoint : null }</e></m></meta>
		</prependRotation>
		<prependScale public="1" set="method" line="676"><f a="xScale:yScale:zScale">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></prependScale>
		<prependTranslation public="1" set="method" line="683"><f a="x:y:z">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></prependTranslation>
		<recompose public="1" set="method" line="692"><f a="components:?orientationStyle">
	<x path="openfl.Vector"><c path="openfl.geom.Vector3D"/></x>
	<x path="openfl.geom.Orientation3D"/>
	<x path="Bool"/>
</f></recompose>
		<transformVector public="1" set="method" line="799"><f a="v">
	<c path="openfl.geom.Vector3D"/>
	<c path="openfl.geom.Vector3D"/>
</f></transformVector>
		<transformVectors public="1" set="method" line="810"><f a="vin:vout">
	<x path="openfl.Vector"><x path="Float"/></x>
	<x path="openfl.Vector"><x path="Float"/></x>
	<x path="Void"/>
</f></transformVectors>
		<transpose public="1" set="method" line="832"><f a=""><x path="Void"/></f></transpose>
		<get_determinant public="1" set="method" line="890"><f a=""><x path="Float"/></f></get_determinant>
		<get_position public="1" set="method" line="902"><f a=""><c path="openfl.geom.Vector3D"/></f></get_position>
		<set_position public="1" set="method" line="909"><f a="val">
	<c path="openfl.geom.Vector3D"/>
	<c path="openfl.geom.Vector3D"/>
</f></set_position>
		<new public="1" set="method" line="18">
			<f a="?v" v="null">
				<x path="openfl.Vector"><x path="Float"/></x>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ v : null }</e></m></meta>
		</new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<abstract path="openfl.geom.Orientation3D" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/geom/Orientation3D.hx">
		<from><icast field="fromString"><c path="String"/></icast></from>
		<this><t path="Null"><x path="Int"/></t></this>
		<to><icast field="toString"><c path="String"/></icast></to>
		<meta><m n=":enum"/></meta>
		<impl><class path="openfl.geom._Orientation3D.Orientation3D_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/geom/Orientation3D.hx" private="1" module="openfl.geom.Orientation3D">
	<AXIS_ANGLE public="1" get="inline" set="null" expr="cast 0" line="6" static="1">
		<x path="openfl.geom.Orientation3D"/>
		<meta>
			<m n=":value"><e>cast 0</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</AXIS_ANGLE>
	<EULER_ANGLES public="1" get="inline" set="null" expr="cast 1" line="7" static="1">
		<x path="openfl.geom.Orientation3D"/>
		<meta>
			<m n=":value"><e>cast 1</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</EULER_ANGLES>
	<QUATERNION public="1" get="inline" set="null" expr="cast 2" line="8" static="1">
		<x path="openfl.geom.Orientation3D"/>
		<meta>
			<m n=":value"><e>cast 2</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</QUATERNION>
	<fromString set="method" line="10" static="1">
		<f a="value">
			<c path="String"/>
			<x path="openfl.geom.Orientation3D"/>
		</f>
		<meta><m n=":from"/></meta>
	</fromString>
	<toString set="method" line="23" static="1">
		<f a="value">
			<x path="Int"/>
			<c path="String"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":to"/>
		</meta>
	</toString>
	<meta>
		<m n=":final"/>
		<m n=":enum"/>
	</meta>
</class></impl>
	</abstract>
	<class path="openfl.geom._Orientation3D.Orientation3D_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/geom/Orientation3D.hx" private="1" module="openfl.geom.Orientation3D">
		<AXIS_ANGLE public="1" get="inline" set="null" expr="cast 0" line="6" static="1">
			<x path="openfl.geom.Orientation3D"/>
			<meta>
				<m n=":value"><e>cast 0</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</AXIS_ANGLE>
		<EULER_ANGLES public="1" get="inline" set="null" expr="cast 1" line="7" static="1">
			<x path="openfl.geom.Orientation3D"/>
			<meta>
				<m n=":value"><e>cast 1</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</EULER_ANGLES>
		<QUATERNION public="1" get="inline" set="null" expr="cast 2" line="8" static="1">
			<x path="openfl.geom.Orientation3D"/>
			<meta>
				<m n=":value"><e>cast 2</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</QUATERNION>
		<fromString set="method" line="10" static="1">
			<f a="value">
				<c path="String"/>
				<x path="openfl.geom.Orientation3D"/>
			</f>
			<meta><m n=":from"/></meta>
		</fromString>
		<toString set="method" line="23" static="1">
			<f a="value">
				<x path="Int"/>
				<c path="String"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":to"/>
			</meta>
		</toString>
		<meta>
			<m n=":final"/>
			<m n=":enum"/>
		</meta>
	</class>
	<class path="openfl.geom.Transform" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/geom/Transform.hx">
		<colorTransform public="1" get="accessor" set="accessor"><c path="openfl.geom.ColorTransform"/></colorTransform>
		<concatenatedColorTransform public="1" set="null"><c path="openfl.geom.ColorTransform"/></concatenatedColorTransform>
		<concatenatedMatrix public="1" get="accessor" set="null"><c path="openfl.geom.Matrix"/></concatenatedMatrix>
		<matrix public="1" get="accessor" set="accessor"><c path="openfl.geom.Matrix"/></matrix>
		<matrix3D public="1" get="accessor" set="accessor"><c path="openfl.geom.Matrix3D"/></matrix3D>
		<pixelBounds public="1" set="null"><c path="openfl.geom.Rectangle"/></pixelBounds>
		<__colorTransform><c path="openfl.geom.ColorTransform"/></__colorTransform>
		<__displayObject><c path="openfl.display.DisplayObject"/></__displayObject>
		<__hasMatrix><x path="Bool"/></__hasMatrix>
		<__hasMatrix3D><x path="Bool"/></__hasMatrix3D>
		<get_colorTransform set="method" line="45"><f a=""><c path="openfl.geom.ColorTransform"/></f></get_colorTransform>
		<set_colorTransform set="method" line="52"><f a="value">
	<c path="openfl.geom.ColorTransform"/>
	<c path="openfl.geom.ColorTransform"/>
</f></set_colorTransform>
		<get_matrix set="method" line="73"><f a=""><c path="openfl.geom.Matrix"/></f></get_matrix>
		<get_concatenatedMatrix set="method" line="86"><f a=""><c path="openfl.geom.Matrix"/></f></get_concatenatedMatrix>
		<set_matrix set="method" line="99"><f a="value">
	<c path="openfl.geom.Matrix"/>
	<c path="openfl.geom.Matrix"/>
</f></set_matrix>
		<get_matrix3D set="method" line="134"><f a=""><c path="openfl.geom.Matrix3D"/></f></get_matrix3D>
		<set_matrix3D set="method" line="148"><f a="value">
	<c path="openfl.geom.Matrix3D"/>
	<c path="openfl.geom.Matrix3D"/>
</f></set_matrix3D>
		<new public="1" set="method" line="26"><f a="displayObject">
	<c path="openfl.display.DisplayObject"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":access"><e>openfl.display.DisplayObject</e></m>
			<m n=":access"><e>openfl.geom.ColorTransform</e></m>
		</meta>
	</class>
	<class path="openfl.geom.Vector3D" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/geom/Vector3D.hx">
		<X_AXIS public="1" get="accessor" set="null" static="1"><c path="openfl.geom.Vector3D"/></X_AXIS>
		<Y_AXIS public="1" get="accessor" set="null" static="1"><c path="openfl.geom.Vector3D"/></Y_AXIS>
		<Z_AXIS public="1" get="accessor" set="null" static="1"><c path="openfl.geom.Vector3D"/></Z_AXIS>
		<angleBetween public="1" set="method" line="36" static="1"><f a="a:b">
	<c path="openfl.geom.Vector3D"/>
	<c path="openfl.geom.Vector3D"/>
	<x path="Float"/>
</f></angleBetween>
		<distance public="1" set="method" line="91" static="1"><f a="pt1:pt2">
	<c path="openfl.geom.Vector3D"/>
	<c path="openfl.geom.Vector3D"/>
	<x path="Float"/>
</f></distance>
		<get_X_AXIS get="inline" set="null" line="220" static="1"><f a=""><c path="openfl.geom.Vector3D"/></f></get_X_AXIS>
		<get_Y_AXIS get="inline" set="null" line="227" static="1"><f a=""><c path="openfl.geom.Vector3D"/></f></get_Y_AXIS>
		<get_Z_AXIS get="inline" set="null" line="234" static="1"><f a=""><c path="openfl.geom.Vector3D"/></f></get_Z_AXIS>
		<length public="1" get="accessor" set="null"><x path="Float"/></length>
		<lengthSquared public="1" get="accessor" set="null"><x path="Float"/></lengthSquared>
		<w public="1"><x path="Float"/></w>
		<x public="1"><x path="Float"/></x>
		<y public="1"><x path="Float"/></y>
		<z public="1"><x path="Float"/></z>
		<add public="1" set="method" line="29"><f a="a">
	<c path="openfl.geom.Vector3D"/>
	<c path="openfl.geom.Vector3D"/>
</f></add>
		<clone public="1" set="method" line="59"><f a=""><c path="openfl.geom.Vector3D"/></f></clone>
		<copyFrom public="1" set="method" line="66"><f a="sourceVector3D">
	<c path="openfl.geom.Vector3D"/>
	<x path="Void"/>
</f></copyFrom>
		<crossProduct public="1" set="method" line="75"><f a="a">
	<c path="openfl.geom.Vector3D"/>
	<c path="openfl.geom.Vector3D"/>
</f></crossProduct>
		<decrementBy public="1" set="method" line="82"><f a="a">
	<c path="openfl.geom.Vector3D"/>
	<x path="Void"/>
</f></decrementBy>
		<dotProduct public="1" set="method" line="102"><f a="a">
	<c path="openfl.geom.Vector3D"/>
	<x path="Float"/>
</f></dotProduct>
		<equals public="1" set="method" line="109">
			<f a="toCompare:?allFour" v=":false">
				<c path="openfl.geom.Vector3D"/>
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":value"><e>{ allFour : false }</e></m></meta>
		</equals>
		<incrementBy public="1" set="method" line="116"><f a="a">
	<c path="openfl.geom.Vector3D"/>
	<x path="Void"/>
</f></incrementBy>
		<nearEquals public="1" set="method" line="125">
			<f a="toCompare:tolerance:?allFour" v="::false">
				<c path="openfl.geom.Vector3D"/>
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":value"><e>{ allFour : false }</e></m></meta>
		</nearEquals>
		<negate public="1" set="method" line="132"><f a=""><x path="Void"/></f></negate>
		<normalize public="1" set="method" line="141"><f a=""><x path="Float"/></f></normalize>
		<project public="1" set="method" line="158"><f a=""><x path="Void"/></f></project>
		<scaleBy public="1" set="method" line="167"><f a="s">
	<x path="Float"/>
	<x path="Void"/>
</f></scaleBy>
		<setTo public="1" set="method" line="176"><f a="xa:ya:za">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></setTo>
		<subtract public="1" set="method" line="185"><f a="a">
	<c path="openfl.geom.Vector3D"/>
	<c path="openfl.geom.Vector3D"/>
</f></subtract>
		<toString public="1" set="method" line="192"><f a=""><c path="String"/></f></toString>
		<get_length set="method" line="206"><f a=""><x path="Float"/></f></get_length>
		<get_lengthSquared set="method" line="213"><f a=""><x path="Float"/></f></get_lengthSquared>
		<new public="1" set="method" line="19">
			<f a="?x:?y:?z:?w" v="0:0:0:0">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ w : 0, z : 0, y : 0, x : 0 }</e></m></meta>
		</new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<typedef path="openfl.gl.GL" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/gl/GL.hx"><c path="lime.graphics.opengl.GL"/></typedef>
	<typedef path="openfl.gl.GLBuffer" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/gl/GLBuffer.hx"><c path="lime.graphics.opengl.GLBuffer"/></typedef>
	<typedef path="openfl.gl.GLFramebuffer" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/gl/GLFramebuffer.hx"><c path="lime.graphics.opengl.GLFramebuffer"/></typedef>
	<typedef path="openfl.gl.GLProgram" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/gl/GLProgram.hx"><c path="lime.graphics.opengl.GLProgram"/></typedef>
	<typedef path="openfl.gl.GLRenderbuffer" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/gl/GLRenderbuffer.hx"><c path="lime.graphics.opengl.GLRenderbuffer"/></typedef>
	<typedef path="openfl.gl.GLShader" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/gl/GLShader.hx"><c path="lime.graphics.opengl.GLShader"/></typedef>
	<typedef path="openfl.gl.GLTexture" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/gl/GLTexture.hx"><c path="lime.graphics.opengl.GLTexture"/></typedef>
	<typedef path="openfl.gl.GLUniformLocation" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/gl/GLUniformLocation.hx"><t path="lime.graphics.opengl.GLUniformLocation"/></typedef>
	<class path="openfl.media.ID3Info" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/media/ID3Info.hx">
		<album public="1"><c path="String"/></album>
		<artist public="1"><c path="String"/></artist>
		<comment public="1"><c path="String"/></comment>
		<genre public="1"><c path="String"/></genre>
		<songName public="1"><c path="String"/></songName>
		<track public="1"><c path="String"/></track>
		<year public="1"><c path="String"/></year>
		<new public="1" set="method" line="16"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":final"/>
		</meta>
	</class>
	<class path="openfl.media.Sound" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/media/Sound.hx">
		<extends path="openfl.events.EventDispatcher"/>
		<fromAudioBuffer public="1" set="method" line="80" static="1"><f a="buffer">
	<c path="lime.audio.AudioBuffer"/>
	<c path="openfl.media.Sound"/>
</f></fromAudioBuffer>
		<fromFile public="1" set="method" line="89" static="1"><f a="path">
	<c path="String"/>
	<c path="openfl.media.Sound"/>
</f></fromFile>
		<bytesLoaded public="1" set="null"><x path="Int"/></bytesLoaded>
		<bytesTotal public="1" set="null"><x path="Int"/></bytesTotal>
		<id3 public="1" get="accessor" set="null"><c path="openfl.media.ID3Info"/></id3>
		<isBuffering public="1" set="null"><x path="Bool"/></isBuffering>
		<length public="1" get="accessor" set="null"><x path="Float"/></length>
		<url public="1" set="null"><c path="String"/></url>
		<__buffer><c path="lime.audio.AudioBuffer"/></__buffer>
		<close public="1" set="method" line="57"><f a=""><x path="Void"/></f></close>
		<load public="1" set="method" line="96">
			<f a="stream:?context" v=":null">
				<c path="openfl.net.URLRequest"/>
				<c path="openfl.media.SoundLoaderContext"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ context : null }</e></m></meta>
		</load>
		<loadCompressedDataFromByteArray public="1" set="method" line="125">
			<f a="bytes:bytesLength:?forcePlayAsMusic" v="::false">
				<x path="openfl.utils.ByteArray"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ forcePlayAsMusic : false }</e></m></meta>
		</loadCompressedDataFromByteArray>
		<loadPCMFromByteArray public="1" set="method" line="142">
			<f a="bytes:samples:?format:?stereo:?sampleRate" v="::null:true:44100">
				<x path="openfl.utils.ByteArray"/>
				<x path="Int"/>
				<c path="String"/>
				<x path="Bool"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ sampleRate : 44100, stereo : true, format : null }</e></m></meta>
		</loadPCMFromByteArray>
		<play public="1" set="method" line="159">
			<f a="?startTime:?loops:?sndTransform" v="0.0:0:null">
				<x path="Float"/>
				<x path="Int"/>
				<c path="openfl.media.SoundTransform"/>
				<c path="openfl.media.SoundChannel"/>
			</f>
			<meta><m n=":value"><e>{ sndTransform : null, loops : 0, startTime : 0.0 }</e></m></meta>
		</play>
		<get_id3 set="method" line="218"><f a=""><c path="openfl.media.ID3Info"/></f></get_id3>
		<get_length set="method" line="225"><f a=""><x path="Int"/></f></get_length>
		<AudioBuffer_onURLLoad set="method" line="254"><f a="buffer">
	<c path="lime.audio.AudioBuffer"/>
	<x path="Void"/>
</f></AudioBuffer_onURLLoad>
		<new public="1" set="method" line="38">
			<f a="?stream:?context" v="null:null">
				<c path="openfl.net.URLRequest"/>
				<c path="openfl.media.SoundLoaderContext"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ context : null, stream : null }</e></m></meta>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":autoBuild"><e>openfl.Assets.embedSound()</e></m>
		</meta>
	</class>
	<class path="openfl.media.SoundChannel" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/media/SoundChannel.hx">
		<extends path="openfl.events.EventDispatcher"/>
		<leftPeak public="1" set="null"><x path="Float"/></leftPeak>
		<position public="1" get="accessor" set="accessor"><x path="Float"/></position>
		<rightPeak public="1" set="null"><x path="Float"/></rightPeak>
		<soundTransform public="1" get="accessor" set="accessor"><c path="openfl.media.SoundTransform"/></soundTransform>
		<__isValid><x path="Bool"/></__isValid>
		<__source><c path="lime.audio.AudioSource"/></__source>
		<stop public="1" set="method" line="60"><f a=""><x path="Void"/></f></stop>
		<__dispose set="method" line="74"><f a=""><x path="Void"/></f></__dispose>
		<get_position set="method" line="97"><f a=""><x path="Float"/></f></get_position>
		<set_position set="method" line="110"><f a="value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_position>
		<get_soundTransform set="method" line="125"><f a=""><c path="openfl.media.SoundTransform"/></f></get_soundTransform>
		<set_soundTransform set="method" line="140"><f a="value">
	<c path="openfl.media.SoundTransform"/>
	<c path="openfl.media.SoundTransform"/>
</f></set_soundTransform>
		<source_onComplete set="method" line="176"><f a=""><x path="Void"/></f></source_onComplete>
		<new set="method" line="26">
			<f a="?source" v="null">
				<c path="lime.audio.AudioSource"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ source : null }</e></m></meta>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":final"/>
			<m n=":keep"/>
		</meta>
	</class>
	<class path="openfl.media.SoundLoaderContext" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/media/SoundLoaderContext.hx">
		<bufferTime public="1"><x path="Float"/></bufferTime>
		<checkPolicyFile public="1"><x path="Bool"/></checkPolicyFile>
		<new public="1" set="method" line="11">
			<f a="?bufferTime:?checkPolicyFile" v="1000:false">
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ checkPolicyFile : false, bufferTime : 1000 }</e></m></meta>
		</new>
	</class>
	<class path="openfl.media.SoundTransform" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/media/SoundTransform.hx">
		<leftToLeft public="1"><x path="Float"/></leftToLeft>
		<leftToRight public="1"><x path="Float"/></leftToRight>
		<pan public="1"><x path="Float"/></pan>
		<rightToLeft public="1"><x path="Float"/></rightToLeft>
		<rightToRight public="1"><x path="Float"/></rightToRight>
		<volume public="1"><x path="Float"/></volume>
		<clone public="1" set="method" line="27"><f a=""><c path="openfl.media.SoundTransform"/></f></clone>
		<new public="1" set="method" line="15">
			<f a="?vol:?panning" v="1:0">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ panning : 0, vol : 1 }</e></m></meta>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":final"/>
		</meta>
	</class>
	<class path="openfl.net.NetConnection" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/net/NetConnection.hx">
		<extends path="openfl.events.EventDispatcher"/>
		<CONNECT_SUCCESS public="1" get="inline" set="null" expr="&quot;connectSuccess&quot;" line="11" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"connectSuccess"</e></m></meta>
		</CONNECT_SUCCESS>
		<connect public="1" set="method" line="21"><f a="command:?_:?_:?_:?_:?_">
	<c path="String"/>
	<unknown/>
	<unknown/>
	<unknown/>
	<unknown/>
	<unknown/>
	<x path="Void"/>
</f></connect>
		<new public="1" set="method" line="14"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="openfl.net.SharedObject" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/net/SharedObject.hx">
		<extends path="openfl.events.EventDispatcher"/>
		<defaultObjectEncoding public="1" expr="3" line="29" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>3</e></m></meta>
		</defaultObjectEncoding>
		<__sharedObjects static="1"><x path="Map">
	<c path="String"/>
	<c path="openfl.net.SharedObject"/>
</x></__sharedObjects>
		<getLocal public="1" set="method" line="151" static="1">
			<f a="name:?localPath:?secure" v=":null:false">
				<c path="String"/>
				<c path="String"/>
				<x path="Bool"/>
				<c path="openfl.net.SharedObject"/>
			</f>
			<meta><m n=":value"><e>{ secure : false, localPath : null }</e></m></meta>
		</getLocal>
		<getRemote public="1" set="method" line="228" static="1">
			<f a="name:?remotePath:?persistence:?secure" v=":null:false:false">
				<c path="String"/>
				<c path="String"/>
				<d/>
				<x path="Bool"/>
				<c path="openfl.net.SharedObject"/>
			</f>
			<meta><m n=":value"><e>{ secure : false, persistence : false, remotePath : null }</e></m></meta>
		</getRemote>
		<__mkdir set="method" line="262" static="1"><f a="directory">
	<c path="String"/>
	<x path="Void"/>
</f></__mkdir>
		<__resolveClass set="method" line="321" static="1"><f a="name">
	<c path="String"/>
	<x path="Class"><d/></x>
</f></__resolveClass>
		<application_onExit set="method" line="371" static="1"><f a="_">
	<x path="Int"/>
	<x path="Void"/>
</f></application_onExit>
		<client public="1"><d/></client>
		<data public="1" set="null"><d/></data>
		<fps public="1" get="null"><x path="Float"/></fps>
		<objectEncoding public="1"><x path="Int"/></objectEncoding>
		<size public="1" get="accessor" set="null"><x path="Int"/></size>
		<__localPath><c path="String"/></__localPath>
		<__name><c path="String"/></__name>
		<clear public="1" set="method" line="54"><f a=""><x path="Void"/></f></clear>
		<close public="1" set="method" line="87"><f a=""><x path="Void"/></f></close>
		<connect public="1" set="method" line="94">
			<f a="myConnection:?params" v=":null">
				<c path="openfl.net.NetConnection"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ params : null }</e></m></meta>
		</connect>
		<flush public="1" set="method" line="101">
			<f a="?minDiskSpace" v="0">
				<x path="Int"/>
				<x path="openfl.net.SharedObjectFlushStatus"/>
			</f>
			<meta><m n=":value"><e>{ minDiskSpace : 0 }</e></m></meta>
		</flush>
		<send public="1" set="method" line="237"><f a="arguments">
	<c path="Array"><d/></c>
	<x path="Void"/>
</f></send>
		<setDirty public="1" set="method" line="244"><f a="propertyName">
	<c path="String"/>
	<x path="Void"/>
</f></setDirty>
		<setProperty public="1" set="method" line="251">
			<f a="propertyName:?value" v=":null">
				<c path="String"/>
				<x path="openfl.utils.Object"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ value : null }</e></m></meta>
		</setProperty>
		<get_size set="method" line="389"><f a=""><x path="Int"/></f></get_size>
		<new set="method" line="44"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<abstract path="openfl.net.SharedObjectFlushStatus" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/net/SharedObjectFlushStatus.hx">
		<from><icast field="fromString"><c path="String"/></icast></from>
		<this><t path="Null"><x path="Int"/></t></this>
		<to><icast field="toString"><c path="String"/></icast></to>
		<meta><m n=":enum"/></meta>
		<impl><class path="openfl.net._SharedObjectFlushStatus.SharedObjectFlushStatus_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/net/SharedObjectFlushStatus.hx" private="1" module="openfl.net.SharedObjectFlushStatus">
	<FLUSHED public="1" get="inline" set="null" expr="cast 0" line="6" static="1">
		<x path="openfl.net.SharedObjectFlushStatus"/>
		<meta>
			<m n=":value"><e>cast 0</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</FLUSHED>
	<PENDING public="1" get="inline" set="null" expr="cast 1" line="7" static="1">
		<x path="openfl.net.SharedObjectFlushStatus"/>
		<meta>
			<m n=":value"><e>cast 1</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</PENDING>
	<fromString set="method" line="9" static="1">
		<f a="value">
			<c path="String"/>
			<x path="openfl.net.SharedObjectFlushStatus"/>
		</f>
		<meta><m n=":from"/></meta>
	</fromString>
	<toString set="method" line="21" static="1">
		<f a="value">
			<x path="Int"/>
			<c path="String"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":to"/>
		</meta>
	</toString>
	<meta>
		<m n=":final"/>
		<m n=":enum"/>
	</meta>
</class></impl>
	</abstract>
	<class path="openfl.net._SharedObjectFlushStatus.SharedObjectFlushStatus_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/net/SharedObjectFlushStatus.hx" private="1" module="openfl.net.SharedObjectFlushStatus">
		<FLUSHED public="1" get="inline" set="null" expr="cast 0" line="6" static="1">
			<x path="openfl.net.SharedObjectFlushStatus"/>
			<meta>
				<m n=":value"><e>cast 0</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</FLUSHED>
		<PENDING public="1" get="inline" set="null" expr="cast 1" line="7" static="1">
			<x path="openfl.net.SharedObjectFlushStatus"/>
			<meta>
				<m n=":value"><e>cast 1</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</PENDING>
		<fromString set="method" line="9" static="1">
			<f a="value">
				<c path="String"/>
				<x path="openfl.net.SharedObjectFlushStatus"/>
			</f>
			<meta><m n=":from"/></meta>
		</fromString>
		<toString set="method" line="21" static="1">
			<f a="value">
				<x path="Int"/>
				<c path="String"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":to"/>
			</meta>
		</toString>
		<meta>
			<m n=":final"/>
			<m n=":enum"/>
		</meta>
	</class>
	<class path="openfl.net.URLLoader" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/net/URLLoader.hx">
		<extends path="openfl.events.EventDispatcher"/>
		<bytesLoaded public="1"><x path="Int"/></bytesLoaded>
		<bytesTotal public="1"><x path="Int"/></bytesTotal>
		<data public="1"><d/></data>
		<dataFormat public="1" set="accessor"><x path="openfl.net.URLLoaderDataFormat"/></dataFormat>
		<close public="1" set="method" line="73"><f a=""><x path="Void"/></f></close>
		<getData set="dynamic" line="82"><f a=""><d/></f></getData>
		<load public="1" set="method" line="89"><f a="request">
	<c path="openfl.net.URLRequest"/>
	<x path="Void"/>
</f></load>
		<onData set="method" line="526"><f a="_">
	<unknown/>
	<x path="Void"/>
</f></onData>
		<onError set="method" line="546"><f a="msg">
	<c path="String"/>
	<x path="Void"/>
</f></onError>
		<onOpen set="method" line="556"><f a=""><x path="Void"/></f></onOpen>
		<onProgress set="method" line="565"><f a="event">
	<t path="openfl.net.XMLHttpRequestProgressEvent"/>
	<x path="Void"/>
</f></onProgress>
		<onSecurityError set="method" line="576"><f a="msg">
	<c path="String"/>
	<x path="Void"/>
</f></onSecurityError>
		<onStatus set="method" line="586"><f a="status">
	<x path="Int"/>
	<x path="Void"/>
</f></onStatus>
		<set_dataFormat set="method" line="602"><f a="inputVal">
	<x path="openfl.net.URLLoaderDataFormat"/>
	<x path="openfl.net.URLLoaderDataFormat"/>
</f></set_dataFormat>
		<new public="1" set="method" line="51">
			<f a="?request" v="null">
				<c path="openfl.net.URLRequest"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ request : null }</e></m></meta>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":access"><e>openfl.events.Event</e></m>
		</meta>
	</class>
	<typedef path="openfl.net.XMLHttpRequestProgressEvent" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/net/URLLoader.hx" module="openfl.net.URLLoader"><d/></typedef>
	<abstract path="openfl.net.URLLoaderDataFormat" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/net/URLLoaderDataFormat.hx">
		<from><icast field="fromString"><c path="String"/></icast></from>
		<this><t path="Null"><x path="Int"/></t></this>
		<to><icast field="toString"><c path="String"/></icast></to>
		<meta><m n=":enum"/></meta>
		<impl><class path="openfl.net._URLLoaderDataFormat.URLLoaderDataFormat_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/net/URLLoaderDataFormat.hx" private="1" module="openfl.net.URLLoaderDataFormat">
	<BINARY public="1" get="inline" set="null" expr="cast 0" line="6" static="1">
		<x path="openfl.net.URLLoaderDataFormat"/>
		<meta>
			<m n=":value"><e>cast 0</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</BINARY>
	<TEXT public="1" get="inline" set="null" expr="cast 1" line="7" static="1">
		<x path="openfl.net.URLLoaderDataFormat"/>
		<meta>
			<m n=":value"><e>cast 1</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</TEXT>
	<VARIABLES public="1" get="inline" set="null" expr="cast 2" line="8" static="1">
		<x path="openfl.net.URLLoaderDataFormat"/>
		<meta>
			<m n=":value"><e>cast 2</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</VARIABLES>
	<fromString set="method" line="10" static="1">
		<f a="value">
			<c path="String"/>
			<x path="openfl.net.URLLoaderDataFormat"/>
		</f>
		<meta><m n=":from"/></meta>
	</fromString>
	<toString set="method" line="23" static="1">
		<f a="value">
			<x path="Int"/>
			<c path="String"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":to"/>
		</meta>
	</toString>
	<meta>
		<m n=":final"/>
		<m n=":enum"/>
	</meta>
</class></impl>
	</abstract>
	<class path="openfl.net._URLLoaderDataFormat.URLLoaderDataFormat_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/net/URLLoaderDataFormat.hx" private="1" module="openfl.net.URLLoaderDataFormat">
		<BINARY public="1" get="inline" set="null" expr="cast 0" line="6" static="1">
			<x path="openfl.net.URLLoaderDataFormat"/>
			<meta>
				<m n=":value"><e>cast 0</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</BINARY>
		<TEXT public="1" get="inline" set="null" expr="cast 1" line="7" static="1">
			<x path="openfl.net.URLLoaderDataFormat"/>
			<meta>
				<m n=":value"><e>cast 1</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</TEXT>
		<VARIABLES public="1" get="inline" set="null" expr="cast 2" line="8" static="1">
			<x path="openfl.net.URLLoaderDataFormat"/>
			<meta>
				<m n=":value"><e>cast 2</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</VARIABLES>
		<fromString set="method" line="10" static="1">
			<f a="value">
				<c path="String"/>
				<x path="openfl.net.URLLoaderDataFormat"/>
			</f>
			<meta><m n=":from"/></meta>
		</fromString>
		<toString set="method" line="23" static="1">
			<f a="value">
				<x path="Int"/>
				<c path="String"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":to"/>
			</meta>
		</toString>
		<meta>
			<m n=":final"/>
			<m n=":enum"/>
		</meta>
	</class>
	<class path="openfl.net.URLRequest" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/net/URLRequest.hx">
		<contentType public="1"><c path="String"/></contentType>
		<data public="1"><d/></data>
		<method public="1"><c path="String"/></method>
		<requestHeaders public="1"><c path="Array"><c path="openfl.net.URLRequestHeader"/></c></requestHeaders>
		<url public="1"><c path="String"/></url>
		<userAgent public="1"><c path="String"/></userAgent>
		<formatRequestHeaders public="1" set="method" line="33"><f a=""><c path="Array"><c path="openfl.net.URLRequestHeader"/></c></f></formatRequestHeaders>
		<new public="1" set="method" line="18">
			<f a="?inURL" v="null">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ inURL : null }</e></m></meta>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":final"/>
		</meta>
	</class>
	<class path="openfl.net.URLRequestHeader" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/net/URLRequestHeader.hx">
		<name public="1"><c path="String"/></name>
		<value public="1"><c path="String"/></value>
		<new public="1" set="method" line="11">
			<f a="?name:?value" v="&quot;&quot;:&quot;&quot;">
				<c path="String"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ value : "", name : "" }</e></m></meta>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":final"/>
		</meta>
	</class>
	<abstract path="openfl.net.URLRequestMethod" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/net/URLRequestMethod.hx">
		<from><icast field="fromString"><c path="String"/></icast></from>
		<this><t path="Null"><x path="Int"/></t></this>
		<to><icast field="toString"><c path="String"/></icast></to>
		<meta><m n=":enum"/></meta>
		<impl><class path="openfl.net._URLRequestMethod.URLRequestMethod_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/net/URLRequestMethod.hx" private="1" module="openfl.net.URLRequestMethod">
	<DELETE public="1" get="inline" set="null" expr="cast 0" line="6" static="1">
		<x path="openfl.net.URLRequestMethod"/>
		<meta>
			<m n=":value"><e>cast 0</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</DELETE>
	<GET public="1" get="inline" set="null" expr="cast 1" line="7" static="1">
		<x path="openfl.net.URLRequestMethod"/>
		<meta>
			<m n=":value"><e>cast 1</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</GET>
	<HEAD public="1" get="inline" set="null" expr="cast 2" line="8" static="1">
		<x path="openfl.net.URLRequestMethod"/>
		<meta>
			<m n=":value"><e>cast 2</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</HEAD>
	<OPTIONS public="1" get="inline" set="null" expr="cast 3" line="9" static="1">
		<x path="openfl.net.URLRequestMethod"/>
		<meta>
			<m n=":value"><e>cast 3</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</OPTIONS>
	<POST public="1" get="inline" set="null" expr="cast 4" line="10" static="1">
		<x path="openfl.net.URLRequestMethod"/>
		<meta>
			<m n=":value"><e>cast 4</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</POST>
	<PUT public="1" get="inline" set="null" expr="cast 5" line="11" static="1">
		<x path="openfl.net.URLRequestMethod"/>
		<meta>
			<m n=":value"><e>cast 5</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</PUT>
	<fromString set="method" line="13" static="1">
		<f a="value">
			<c path="String"/>
			<x path="openfl.net.URLRequestMethod"/>
		</f>
		<meta><m n=":from"/></meta>
	</fromString>
	<toString set="method" line="29" static="1">
		<f a="value">
			<x path="Int"/>
			<c path="String"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":to"/>
		</meta>
	</toString>
	<meta>
		<m n=":directlyUsed"/>
		<m n=":final"/>
		<m n=":enum"/>
	</meta>
</class></impl>
	</abstract>
	<class path="openfl.net._URLRequestMethod.URLRequestMethod_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/net/URLRequestMethod.hx" private="1" module="openfl.net.URLRequestMethod">
		<DELETE public="1" get="inline" set="null" expr="cast 0" line="6" static="1">
			<x path="openfl.net.URLRequestMethod"/>
			<meta>
				<m n=":value"><e>cast 0</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</DELETE>
		<GET public="1" get="inline" set="null" expr="cast 1" line="7" static="1">
			<x path="openfl.net.URLRequestMethod"/>
			<meta>
				<m n=":value"><e>cast 1</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</GET>
		<HEAD public="1" get="inline" set="null" expr="cast 2" line="8" static="1">
			<x path="openfl.net.URLRequestMethod"/>
			<meta>
				<m n=":value"><e>cast 2</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</HEAD>
		<OPTIONS public="1" get="inline" set="null" expr="cast 3" line="9" static="1">
			<x path="openfl.net.URLRequestMethod"/>
			<meta>
				<m n=":value"><e>cast 3</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</OPTIONS>
		<POST public="1" get="inline" set="null" expr="cast 4" line="10" static="1">
			<x path="openfl.net.URLRequestMethod"/>
			<meta>
				<m n=":value"><e>cast 4</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</POST>
		<PUT public="1" get="inline" set="null" expr="cast 5" line="11" static="1">
			<x path="openfl.net.URLRequestMethod"/>
			<meta>
				<m n=":value"><e>cast 5</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</PUT>
		<fromString set="method" line="13" static="1">
			<f a="value">
				<c path="String"/>
				<x path="openfl.net.URLRequestMethod"/>
			</f>
			<meta><m n=":from"/></meta>
		</fromString>
		<toString set="method" line="29" static="1">
			<f a="value">
				<x path="Int"/>
				<c path="String"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":to"/>
			</meta>
		</toString>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":final"/>
			<m n=":enum"/>
		</meta>
	</class>
	<class path="openfl.system.LoaderContext" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/system/LoaderContext.hx">
		<allowCodeImport public="1"><x path="Bool"/></allowCodeImport>
		<allowLoadBytesCodeExecution public="1"><x path="Bool"/></allowLoadBytesCodeExecution>
		<applicationDomain public="1"><c path="openfl.system.ApplicationDomain"/></applicationDomain>
		<checkPolicyFile public="1"><x path="Bool"/></checkPolicyFile>
		<securityDomain public="1"><c path="openfl.system.SecurityDomain"/></securityDomain>
		<new public="1" set="method" line="14">
			<f a="?checkPolicyFile:?applicationDomain:?securityDomain" v="false:null:null">
				<x path="Bool"/>
				<c path="openfl.system.ApplicationDomain"/>
				<c path="openfl.system.SecurityDomain"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ securityDomain : null, applicationDomain : null, checkPolicyFile : false }</e></m></meta>
		</new>
	</class>
	<class path="openfl.system.SecurityDomain" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/system/SecurityDomain.hx">
		<currentDomain public="1" set="null" expr="new SecurityDomain()" line="7" static="1">
			<c path="openfl.system.SecurityDomain"/>
			<meta><m n=":value"><e>new SecurityDomain()</e></m></meta>
		</currentDomain>
		<new set="method" line="10"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="openfl.system.System" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/system/System.hx">
		<totalMemory public="1" get="accessor" set="null" static="1"><x path="Int"/></totalMemory>
		<useCodePage public="1" expr="false" line="18" static="1">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</useCodePage>
		<vmVersion public="1" get="accessor" set="null" static="1"><c path="String"/></vmVersion>
		<exit public="1" set="method" line="22" static="1"><f a="code">
	<x path="Int"/>
	<x path="Void"/>
</f></exit>
		<gc public="1" set="method" line="29" static="1"><f a=""><x path="Void"/></f></gc>
		<pause public="1" set="method" line="38" static="1"><f a=""><x path="Void"/></f></pause>
		<resume public="1" set="method" line="45" static="1"><f a=""><x path="Void"/></f></resume>
		<setClipboard public="1" set="method" line="52" static="1"><f a="string">
	<c path="String"/>
	<x path="Void"/>
</f></setClipboard>
		<get_totalMemory set="method" line="66" static="1"><f a=""><x path="Int"/></f></get_totalMemory>
		<get_vmVersion set="method" line="79" static="1"><f a=""><c path="String"/></f></get_vmVersion>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":final"/>
		</meta>
	</class>
	<abstract path="openfl.text.AntiAliasType" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/text/AntiAliasType.hx">
		<from><icast field="fromString"><c path="String"/></icast></from>
		<this><t path="Null"><x path="Int"/></t></this>
		<to><icast field="toString"><c path="String"/></icast></to>
		<meta><m n=":enum"/></meta>
		<impl><class path="openfl.text._AntiAliasType.AntiAliasType_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/text/AntiAliasType.hx" private="1" module="openfl.text.AntiAliasType">
	<ADVANCED public="1" get="inline" set="null" expr="cast 0" line="6" static="1">
		<x path="openfl.text.AntiAliasType"/>
		<meta>
			<m n=":value"><e>cast 0</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</ADVANCED>
	<NORMAL public="1" get="inline" set="null" expr="cast 1" line="7" static="1">
		<x path="openfl.text.AntiAliasType"/>
		<meta>
			<m n=":value"><e>cast 1</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NORMAL>
	<fromString set="method" line="9" static="1">
		<f a="value">
			<c path="String"/>
			<x path="openfl.text.AntiAliasType"/>
		</f>
		<meta><m n=":from"/></meta>
	</fromString>
	<toString set="method" line="21" static="1">
		<f a="value">
			<x path="Int"/>
			<c path="String"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":to"/>
		</meta>
	</toString>
	<meta>
		<m n=":final"/>
		<m n=":enum"/>
	</meta>
</class></impl>
	</abstract>
	<class path="openfl.text._AntiAliasType.AntiAliasType_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/text/AntiAliasType.hx" private="1" module="openfl.text.AntiAliasType">
		<ADVANCED public="1" get="inline" set="null" expr="cast 0" line="6" static="1">
			<x path="openfl.text.AntiAliasType"/>
			<meta>
				<m n=":value"><e>cast 0</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</ADVANCED>
		<NORMAL public="1" get="inline" set="null" expr="cast 1" line="7" static="1">
			<x path="openfl.text.AntiAliasType"/>
			<meta>
				<m n=":value"><e>cast 1</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NORMAL>
		<fromString set="method" line="9" static="1">
			<f a="value">
				<c path="String"/>
				<x path="openfl.text.AntiAliasType"/>
			</f>
			<meta><m n=":from"/></meta>
		</fromString>
		<toString set="method" line="21" static="1">
			<f a="value">
				<x path="Int"/>
				<c path="String"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":to"/>
			</meta>
		</toString>
		<meta>
			<m n=":final"/>
			<m n=":enum"/>
		</meta>
	</class>
	<class path="openfl.text.Font" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/text/Font.hx">
		<extends path="lime.text.Font"/>
		<__registeredFonts expr="new Array&lt;Font&gt;()" line="15" static="1">
			<c path="Array"><c path="openfl.text.Font"/></c>
			<meta><m n=":value"><e><![CDATA[new Array<Font>()]]></e></m></meta>
		</__registeredFonts>
		<enumerateFonts public="1" set="method" line="25" static="1">
			<f a="?enumerateDeviceFonts" v="false">
				<x path="Bool"/>
				<c path="Array"><c path="openfl.text.Font"/></c>
			</f>
			<meta><m n=":value"><e>{ enumerateDeviceFonts : false }</e></m></meta>
		</enumerateFonts>
		<fromBytes public="1" set="method" line="32" static="1"><f a="bytes">
	<x path="openfl.utils.ByteArray"/>
	<c path="openfl.text.Font"/>
</f></fromBytes>
		<fromFile public="1" set="method" line="46" static="1"><f a="path">
	<c path="String"/>
	<c path="openfl.text.Font"/>
</f></fromFile>
		<registerFont public="1" set="method" line="60" static="1"><f a="font">
	<x path="Class"><d/></x>
	<x path="Void"/>
</f></registerFont>
		<__fromLimeFont set="method" line="79" static="1"><f a="value">
	<t path="lime.text._Font.LimeFont"/>
	<c path="openfl.text.Font"/>
</f></__fromLimeFont>
		<fontName public="1" get="accessor" set="accessor"><c path="String"/></fontName>
		<fontStyle public="1"><x path="openfl.text.FontStyle"/></fontStyle>
		<fontType public="1"><x path="openfl.text.FontType"/></fontType>
		<get_fontName get="inline" set="null" line="96"><f a=""><c path="String"/></f></get_fontName>
		<set_fontName get="inline" set="null" line="103"><f a="value">
	<c path="String"/>
	<c path="String"/>
</f></set_fontName>
		<new public="1" set="method" line="18">
			<f a="?name" v="null">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ name : null }</e></m></meta>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>lime.Assets.embedFont()</e></m>
			<m n=":autoBuild"><e>lime.Assets.embedFont()</e></m>
		</meta>
	</class>
	<abstract path="openfl.text.FontStyle" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/text/FontStyle.hx">
		<from><icast field="fromString"><c path="String"/></icast></from>
		<this><t path="Null"><x path="Int"/></t></this>
		<to><icast field="toString"><c path="String"/></icast></to>
		<meta><m n=":enum"/></meta>
		<impl><class path="openfl.text._FontStyle.FontStyle_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/text/FontStyle.hx" private="1" module="openfl.text.FontStyle">
	<BOLD public="1" get="inline" set="null" expr="cast 0" line="6" static="1">
		<x path="openfl.text.FontStyle"/>
		<meta>
			<m n=":value"><e>cast 0</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</BOLD>
	<BOLD_ITALIC public="1" get="inline" set="null" expr="cast 1" line="7" static="1">
		<x path="openfl.text.FontStyle"/>
		<meta>
			<m n=":value"><e>cast 1</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</BOLD_ITALIC>
	<ITALIC public="1" get="inline" set="null" expr="cast 2" line="8" static="1">
		<x path="openfl.text.FontStyle"/>
		<meta>
			<m n=":value"><e>cast 2</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</ITALIC>
	<REGULAR public="1" get="inline" set="null" expr="cast 3" line="9" static="1">
		<x path="openfl.text.FontStyle"/>
		<meta>
			<m n=":value"><e>cast 3</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</REGULAR>
	<fromString set="method" line="11" static="1">
		<f a="value">
			<c path="String"/>
			<x path="openfl.text.FontStyle"/>
		</f>
		<meta><m n=":from"/></meta>
	</fromString>
	<toString set="method" line="25" static="1">
		<f a="value">
			<x path="Int"/>
			<c path="String"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":to"/>
		</meta>
	</toString>
	<meta>
		<m n=":final"/>
		<m n=":enum"/>
	</meta>
</class></impl>
	</abstract>
	<class path="openfl.text._FontStyle.FontStyle_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/text/FontStyle.hx" private="1" module="openfl.text.FontStyle">
		<BOLD public="1" get="inline" set="null" expr="cast 0" line="6" static="1">
			<x path="openfl.text.FontStyle"/>
			<meta>
				<m n=":value"><e>cast 0</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</BOLD>
		<BOLD_ITALIC public="1" get="inline" set="null" expr="cast 1" line="7" static="1">
			<x path="openfl.text.FontStyle"/>
			<meta>
				<m n=":value"><e>cast 1</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</BOLD_ITALIC>
		<ITALIC public="1" get="inline" set="null" expr="cast 2" line="8" static="1">
			<x path="openfl.text.FontStyle"/>
			<meta>
				<m n=":value"><e>cast 2</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</ITALIC>
		<REGULAR public="1" get="inline" set="null" expr="cast 3" line="9" static="1">
			<x path="openfl.text.FontStyle"/>
			<meta>
				<m n=":value"><e>cast 3</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</REGULAR>
		<fromString set="method" line="11" static="1">
			<f a="value">
				<c path="String"/>
				<x path="openfl.text.FontStyle"/>
			</f>
			<meta><m n=":from"/></meta>
		</fromString>
		<toString set="method" line="25" static="1">
			<f a="value">
				<x path="Int"/>
				<c path="String"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":to"/>
			</meta>
		</toString>
		<meta>
			<m n=":final"/>
			<m n=":enum"/>
		</meta>
	</class>
	<abstract path="openfl.text.FontType" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/text/FontType.hx">
		<from><icast field="fromString"><c path="String"/></icast></from>
		<this><t path="Null"><x path="Int"/></t></this>
		<to><icast field="toString"><c path="String"/></icast></to>
		<meta><m n=":enum"/></meta>
		<impl><class path="openfl.text._FontType.FontType_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/text/FontType.hx" private="1" module="openfl.text.FontType">
	<DEVICE public="1" get="inline" set="null" expr="cast 0" line="6" static="1">
		<x path="openfl.text.FontType"/>
		<meta>
			<m n=":value"><e>cast 0</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</DEVICE>
	<EMBEDDED public="1" get="inline" set="null" expr="cast 1" line="7" static="1">
		<x path="openfl.text.FontType"/>
		<meta>
			<m n=":value"><e>cast 1</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</EMBEDDED>
	<EMBEDDED_CFF public="1" get="inline" set="null" expr="cast 2" line="8" static="1">
		<x path="openfl.text.FontType"/>
		<meta>
			<m n=":value"><e>cast 2</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</EMBEDDED_CFF>
	<fromString set="method" line="10" static="1">
		<f a="value">
			<c path="String"/>
			<x path="openfl.text.FontType"/>
		</f>
		<meta><m n=":from"/></meta>
	</fromString>
	<toString set="method" line="23" static="1">
		<f a="value">
			<x path="Int"/>
			<c path="String"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":to"/>
		</meta>
	</toString>
	<meta>
		<m n=":final"/>
		<m n=":enum"/>
	</meta>
</class></impl>
	</abstract>
	<class path="openfl.text._FontType.FontType_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/text/FontType.hx" private="1" module="openfl.text.FontType">
		<DEVICE public="1" get="inline" set="null" expr="cast 0" line="6" static="1">
			<x path="openfl.text.FontType"/>
			<meta>
				<m n=":value"><e>cast 0</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</DEVICE>
		<EMBEDDED public="1" get="inline" set="null" expr="cast 1" line="7" static="1">
			<x path="openfl.text.FontType"/>
			<meta>
				<m n=":value"><e>cast 1</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</EMBEDDED>
		<EMBEDDED_CFF public="1" get="inline" set="null" expr="cast 2" line="8" static="1">
			<x path="openfl.text.FontType"/>
			<meta>
				<m n=":value"><e>cast 2</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</EMBEDDED_CFF>
		<fromString set="method" line="10" static="1">
			<f a="value">
				<c path="String"/>
				<x path="openfl.text.FontType"/>
			</f>
			<meta><m n=":from"/></meta>
		</fromString>
		<toString set="method" line="23" static="1">
			<f a="value">
				<x path="Int"/>
				<c path="String"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":to"/>
			</meta>
		</toString>
		<meta>
			<m n=":final"/>
			<m n=":enum"/>
		</meta>
	</class>
	<abstract path="openfl.text.GridFitType" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/text/GridFitType.hx">
		<from><icast field="fromString"><c path="String"/></icast></from>
		<this><t path="Null"><x path="Int"/></t></this>
		<to><icast field="toString"><c path="String"/></icast></to>
		<meta><m n=":enum"/></meta>
		<impl><class path="openfl.text._GridFitType.GridFitType_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/text/GridFitType.hx" private="1" module="openfl.text.GridFitType">
	<NONE public="1" get="inline" set="null" expr="cast 0" line="6" static="1">
		<x path="openfl.text.GridFitType"/>
		<meta>
			<m n=":value"><e>cast 0</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NONE>
	<PIXEL public="1" get="inline" set="null" expr="cast 1" line="7" static="1">
		<x path="openfl.text.GridFitType"/>
		<meta>
			<m n=":value"><e>cast 1</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</PIXEL>
	<SUBPIXEL public="1" get="inline" set="null" expr="cast 2" line="8" static="1">
		<x path="openfl.text.GridFitType"/>
		<meta>
			<m n=":value"><e>cast 2</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</SUBPIXEL>
	<fromString set="method" line="10" static="1">
		<f a="value">
			<c path="String"/>
			<x path="openfl.text.GridFitType"/>
		</f>
		<meta><m n=":from"/></meta>
	</fromString>
	<toString set="method" line="23" static="1">
		<f a="value">
			<x path="Int"/>
			<c path="String"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":to"/>
		</meta>
	</toString>
	<meta>
		<m n=":final"/>
		<m n=":enum"/>
	</meta>
</class></impl>
	</abstract>
	<class path="openfl.text._GridFitType.GridFitType_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/text/GridFitType.hx" private="1" module="openfl.text.GridFitType">
		<NONE public="1" get="inline" set="null" expr="cast 0" line="6" static="1">
			<x path="openfl.text.GridFitType"/>
			<meta>
				<m n=":value"><e>cast 0</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NONE>
		<PIXEL public="1" get="inline" set="null" expr="cast 1" line="7" static="1">
			<x path="openfl.text.GridFitType"/>
			<meta>
				<m n=":value"><e>cast 1</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</PIXEL>
		<SUBPIXEL public="1" get="inline" set="null" expr="cast 2" line="8" static="1">
			<x path="openfl.text.GridFitType"/>
			<meta>
				<m n=":value"><e>cast 2</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</SUBPIXEL>
		<fromString set="method" line="10" static="1">
			<f a="value">
				<c path="String"/>
				<x path="openfl.text.GridFitType"/>
			</f>
			<meta><m n=":from"/></meta>
		</fromString>
		<toString set="method" line="23" static="1">
			<f a="value">
				<x path="Int"/>
				<c path="String"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":to"/>
			</meta>
		</toString>
		<meta>
			<m n=":final"/>
			<m n=":enum"/>
		</meta>
	</class>
	<abstract path="openfl.text.TextFieldAutoSize" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/text/TextFieldAutoSize.hx">
		<from><icast field="fromString"><c path="String"/></icast></from>
		<this><t path="Null"><x path="Int"/></t></this>
		<to><icast field="toString"><c path="String"/></icast></to>
		<meta><m n=":enum"/></meta>
		<impl><class path="openfl.text._TextFieldAutoSize.TextFieldAutoSize_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/text/TextFieldAutoSize.hx" private="1" module="openfl.text.TextFieldAutoSize">
	<CENTER public="1" get="inline" set="null" expr="cast 0" line="6" static="1">
		<x path="openfl.text.TextFieldAutoSize"/>
		<meta>
			<m n=":value"><e>cast 0</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</CENTER>
	<LEFT public="1" get="inline" set="null" expr="cast 1" line="7" static="1">
		<x path="openfl.text.TextFieldAutoSize"/>
		<meta>
			<m n=":value"><e>cast 1</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</LEFT>
	<NONE public="1" get="inline" set="null" expr="cast 2" line="8" static="1">
		<x path="openfl.text.TextFieldAutoSize"/>
		<meta>
			<m n=":value"><e>cast 2</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NONE>
	<RIGHT public="1" get="inline" set="null" expr="cast 3" line="9" static="1">
		<x path="openfl.text.TextFieldAutoSize"/>
		<meta>
			<m n=":value"><e>cast 3</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</RIGHT>
	<fromString set="method" line="11" static="1">
		<f a="value">
			<c path="String"/>
			<x path="openfl.text.TextFieldAutoSize"/>
		</f>
		<meta><m n=":from"/></meta>
	</fromString>
	<toString set="method" line="25" static="1">
		<f a="value">
			<x path="Int"/>
			<c path="String"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":to"/>
		</meta>
	</toString>
	<meta>
		<m n=":final"/>
		<m n=":enum"/>
	</meta>
</class></impl>
	</abstract>
	<class path="openfl.text._TextFieldAutoSize.TextFieldAutoSize_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/text/TextFieldAutoSize.hx" private="1" module="openfl.text.TextFieldAutoSize">
		<CENTER public="1" get="inline" set="null" expr="cast 0" line="6" static="1">
			<x path="openfl.text.TextFieldAutoSize"/>
			<meta>
				<m n=":value"><e>cast 0</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</CENTER>
		<LEFT public="1" get="inline" set="null" expr="cast 1" line="7" static="1">
			<x path="openfl.text.TextFieldAutoSize"/>
			<meta>
				<m n=":value"><e>cast 1</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</LEFT>
		<NONE public="1" get="inline" set="null" expr="cast 2" line="8" static="1">
			<x path="openfl.text.TextFieldAutoSize"/>
			<meta>
				<m n=":value"><e>cast 2</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NONE>
		<RIGHT public="1" get="inline" set="null" expr="cast 3" line="9" static="1">
			<x path="openfl.text.TextFieldAutoSize"/>
			<meta>
				<m n=":value"><e>cast 3</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</RIGHT>
		<fromString set="method" line="11" static="1">
			<f a="value">
				<c path="String"/>
				<x path="openfl.text.TextFieldAutoSize"/>
			</f>
			<meta><m n=":from"/></meta>
		</fromString>
		<toString set="method" line="25" static="1">
			<f a="value">
				<x path="Int"/>
				<c path="String"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":to"/>
			</meta>
		</toString>
		<meta>
			<m n=":final"/>
			<m n=":enum"/>
		</meta>
	</class>
	<abstract path="openfl.text.TextFieldType" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/text/TextFieldType.hx">
		<from><icast field="fromString"><c path="String"/></icast></from>
		<this><t path="Null"><x path="Int"/></t></this>
		<to><icast field="toString"><c path="String"/></icast></to>
		<meta><m n=":enum"/></meta>
		<impl><class path="openfl.text._TextFieldType.TextFieldType_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/text/TextFieldType.hx" private="1" module="openfl.text.TextFieldType">
	<DYNAMIC public="1" get="inline" set="null" expr="cast 0" line="6" static="1">
		<x path="openfl.text.TextFieldType"/>
		<meta>
			<m n=":value"><e>cast 0</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</DYNAMIC>
	<INPUT public="1" get="inline" set="null" expr="cast 1" line="7" static="1">
		<x path="openfl.text.TextFieldType"/>
		<meta>
			<m n=":value"><e>cast 1</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</INPUT>
	<fromString set="method" line="9" static="1">
		<f a="value">
			<c path="String"/>
			<x path="openfl.text.TextFieldType"/>
		</f>
		<meta><m n=":from"/></meta>
	</fromString>
	<toString set="method" line="21" static="1">
		<f a="value">
			<x path="Int"/>
			<c path="String"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":to"/>
		</meta>
	</toString>
	<meta>
		<m n=":final"/>
		<m n=":enum"/>
	</meta>
</class></impl>
	</abstract>
	<class path="openfl.text._TextFieldType.TextFieldType_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/text/TextFieldType.hx" private="1" module="openfl.text.TextFieldType">
		<DYNAMIC public="1" get="inline" set="null" expr="cast 0" line="6" static="1">
			<x path="openfl.text.TextFieldType"/>
			<meta>
				<m n=":value"><e>cast 0</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</DYNAMIC>
		<INPUT public="1" get="inline" set="null" expr="cast 1" line="7" static="1">
			<x path="openfl.text.TextFieldType"/>
			<meta>
				<m n=":value"><e>cast 1</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</INPUT>
		<fromString set="method" line="9" static="1">
			<f a="value">
				<c path="String"/>
				<x path="openfl.text.TextFieldType"/>
			</f>
			<meta><m n=":from"/></meta>
		</fromString>
		<toString set="method" line="21" static="1">
			<f a="value">
				<x path="Int"/>
				<c path="String"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":to"/>
			</meta>
		</toString>
		<meta>
			<m n=":final"/>
			<m n=":enum"/>
		</meta>
	</class>
	<class path="openfl.text.TextFormat" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/text/TextFormat.hx">
		<align public="1"><x path="openfl.text.TextFormatAlign"/></align>
		<blockIndent public="1"><t path="Null"><x path="Int"/></t></blockIndent>
		<bold public="1"><t path="Null"><x path="Bool"/></t></bold>
		<bullet public="1"><t path="Null"><x path="Bool"/></t></bullet>
		<color public="1"><t path="Null"><x path="Int"/></t></color>
		<font public="1"><c path="String"/></font>
		<indent public="1"><t path="Null"><x path="Int"/></t></indent>
		<italic public="1"><t path="Null"><x path="Bool"/></t></italic>
		<kerning public="1"><t path="Null"><x path="Bool"/></t></kerning>
		<leading public="1"><t path="Null"><x path="Int"/></t></leading>
		<leftMargin public="1"><t path="Null"><x path="Int"/></t></leftMargin>
		<letterSpacing public="1"><t path="Null"><x path="Float"/></t></letterSpacing>
		<rightMargin public="1"><t path="Null"><x path="Int"/></t></rightMargin>
		<size public="1"><t path="Null"><x path="Int"/></t></size>
		<tabStops public="1"><c path="Array"><x path="Int"/></c></tabStops>
		<target public="1"><c path="String"/></target>
		<underline public="1"><t path="Null"><x path="Bool"/></t></underline>
		<url public="1"><c path="String"/></url>
		<clone public="1" set="method" line="46"><f a=""><c path="openfl.text.TextFormat"/></f></clone>
		<__merge set="method" line="67"><f a="format">
	<c path="openfl.text.TextFormat"/>
	<x path="Void"/>
</f></__merge>
		<new public="1" set="method" line="27">
			<f a="?font:?size:?color:?bold:?italic:?underline:?url:?target:?align:?leftMargin:?rightMargin:?indent:?leading" v="null:null:null:null:null:null:null:null:null:null:null:null:null">
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<c path="String"/>
				<c path="String"/>
				<x path="openfl.text.TextFormatAlign"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ leading : null, indent : null, rightMargin : null, leftMargin : null, align : null, target : null, url : null, underline : null, italic : null, bold : null, color : null, size : null, font : null }</e></m></meta>
		</new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<abstract path="openfl.text.TextFormatAlign" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/text/TextFormatAlign.hx">
		<from><icast field="fromString"><c path="String"/></icast></from>
		<this><t path="Null"><x path="Int"/></t></this>
		<to><icast field="toString"><c path="String"/></icast></to>
		<meta><m n=":enum"/></meta>
		<impl><class path="openfl.text._TextFormatAlign.TextFormatAlign_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/text/TextFormatAlign.hx" private="1" module="openfl.text.TextFormatAlign">
	<CENTER public="1" get="inline" set="null" expr="cast 0" line="6" static="1">
		<x path="openfl.text.TextFormatAlign"/>
		<meta>
			<m n=":value"><e>cast 0</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</CENTER>
	<END public="1" get="inline" set="null" expr="cast 1" line="7" static="1">
		<x path="openfl.text.TextFormatAlign"/>
		<meta>
			<m n=":value"><e>cast 1</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</END>
	<JUSTIFY public="1" get="inline" set="null" expr="cast 2" line="8" static="1">
		<x path="openfl.text.TextFormatAlign"/>
		<meta>
			<m n=":value"><e>cast 2</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</JUSTIFY>
	<LEFT public="1" get="inline" set="null" expr="cast 3" line="9" static="1">
		<x path="openfl.text.TextFormatAlign"/>
		<meta>
			<m n=":value"><e>cast 3</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</LEFT>
	<RIGHT public="1" get="inline" set="null" expr="cast 4" line="10" static="1">
		<x path="openfl.text.TextFormatAlign"/>
		<meta>
			<m n=":value"><e>cast 4</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</RIGHT>
	<START public="1" get="inline" set="null" expr="cast 5" line="11" static="1">
		<x path="openfl.text.TextFormatAlign"/>
		<meta>
			<m n=":value"><e>cast 5</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</START>
	<fromString set="method" line="13" static="1">
		<f a="value">
			<c path="String"/>
			<x path="openfl.text.TextFormatAlign"/>
		</f>
		<meta><m n=":from"/></meta>
	</fromString>
	<toString set="method" line="29" static="1">
		<f a="value">
			<x path="Int"/>
			<c path="String"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":to"/>
		</meta>
	</toString>
	<meta>
		<m n=":final"/>
		<m n=":enum"/>
	</meta>
</class></impl>
	</abstract>
	<class path="openfl.text._TextFormatAlign.TextFormatAlign_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/text/TextFormatAlign.hx" private="1" module="openfl.text.TextFormatAlign">
		<CENTER public="1" get="inline" set="null" expr="cast 0" line="6" static="1">
			<x path="openfl.text.TextFormatAlign"/>
			<meta>
				<m n=":value"><e>cast 0</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</CENTER>
		<END public="1" get="inline" set="null" expr="cast 1" line="7" static="1">
			<x path="openfl.text.TextFormatAlign"/>
			<meta>
				<m n=":value"><e>cast 1</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</END>
		<JUSTIFY public="1" get="inline" set="null" expr="cast 2" line="8" static="1">
			<x path="openfl.text.TextFormatAlign"/>
			<meta>
				<m n=":value"><e>cast 2</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</JUSTIFY>
		<LEFT public="1" get="inline" set="null" expr="cast 3" line="9" static="1">
			<x path="openfl.text.TextFormatAlign"/>
			<meta>
				<m n=":value"><e>cast 3</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</LEFT>
		<RIGHT public="1" get="inline" set="null" expr="cast 4" line="10" static="1">
			<x path="openfl.text.TextFormatAlign"/>
			<meta>
				<m n=":value"><e>cast 4</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</RIGHT>
		<START public="1" get="inline" set="null" expr="cast 5" line="11" static="1">
			<x path="openfl.text.TextFormatAlign"/>
			<meta>
				<m n=":value"><e>cast 5</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</START>
		<fromString set="method" line="13" static="1">
			<f a="value">
				<c path="String"/>
				<x path="openfl.text.TextFormatAlign"/>
			</f>
			<meta><m n=":from"/></meta>
		</fromString>
		<toString set="method" line="29" static="1">
			<f a="value">
				<x path="Int"/>
				<c path="String"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":to"/>
			</meta>
		</toString>
		<meta>
			<m n=":final"/>
			<m n=":enum"/>
		</meta>
	</class>
	<class path="openfl.text.TextLineMetrics" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/text/TextLineMetrics.hx">
		<ascent public="1"><x path="Float"/></ascent>
		<descent public="1"><x path="Float"/></descent>
		<height public="1"><x path="Float"/></height>
		<leading public="1"><x path="Float"/></leading>
		<width public="1"><x path="Float"/></width>
		<x public="1"><x path="Float"/></x>
		<new public="1" set="method" line="15"><f a="x:width:height:ascent:descent:leading">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="openfl.ui.GameInputControl" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/ui/GameInputControl.hx">
		<extends path="openfl.events.EventDispatcher"/>
		<device public="1" set="null"><c path="openfl.ui.GameInputDevice"/></device>
		<id public="1" set="null"><c path="String"/></id>
		<maxValue public="1" set="null"><x path="Float"/></maxValue>
		<minValue public="1" set="null"><x path="Float"/></minValue>
		<value public="1" set="null"><x path="Float"/></value>
		<new set="method" line="17">
			<f a="device:id:minValue:maxValue:?value" v="::::0">
				<c path="openfl.ui.GameInputDevice"/>
				<c path="String"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ value : 0 }</e></m></meta>
		</new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="openfl.ui.GameInputDevice" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/ui/GameInputDevice.hx">
		<MAX_BUFFER_SIZE public="1" expr="32000" line="13" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>32000</e></m></meta>
		</MAX_BUFFER_SIZE>
		<enabled public="1"><x path="Bool"/></enabled>
		<id public="1" set="null"><c path="String"/></id>
		<name public="1" set="null"><c path="String"/></name>
		<numControls public="1" get="accessor" set="null"><x path="Int"/></numControls>
		<sampleInterval public="1"><x path="Int"/></sampleInterval>
		<__axis expr="new Map&lt;Int,GameInputControl&gt;()">
			<x path="Map">
				<x path="Int"/>
				<c path="openfl.ui.GameInputControl"/>
			</x>
			<meta><m n=":value"><e><![CDATA[new Map<Int,GameInputControl>()]]></e></m></meta>
		</__axis>
		<__button expr="new Map&lt;Int,GameInputControl&gt;()">
			<x path="Map">
				<x path="Int"/>
				<c path="openfl.ui.GameInputControl"/>
			</x>
			<meta><m n=":value"><e><![CDATA[new Map<Int,GameInputControl>()]]></e></m></meta>
		</__button>
		<__controls expr="new Array&lt;GameInputControl&gt;()">
			<c path="Array"><c path="openfl.ui.GameInputControl"/></c>
			<meta><m n=":value"><e><![CDATA[new Array<GameInputControl>()]]></e></m></meta>
		</__controls>
		<__gamepad><c path="lime.ui.Gamepad"/></__gamepad>
		<getCachedSamples public="1" set="method" line="53">
			<f a="data:?append" v=":false">
				<x path="openfl.utils.ByteArray"/>
				<x path="Bool"/>
				<x path="Int"/>
			</f>
			<meta><m n=":value"><e>{ append : false }</e></m></meta>
		</getCachedSamples>
		<getControlAt public="1" set="method" line="60"><f a="i">
	<x path="Int"/>
	<c path="openfl.ui.GameInputControl"/>
</f></getControlAt>
		<startCachingSamples public="1" set="method" line="73"><f a="numSamples:controls">
	<x path="Int"/>
	<x path="openfl.Vector"><c path="String"/></x>
	<x path="Void"/>
</f></startCachingSamples>
		<stopCachingSamples public="1" set="method" line="80"><f a=""><x path="Void"/></f></stopCachingSamples>
		<get_numControls set="method" line="94"><f a=""><x path="Int"/></f></get_numControls>
		<new set="method" line="27"><f a="id:name">
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":access"><e>openfl.ui.GameInputControl</e></m>
			<m n=":final"/>
		</meta>
	</class>
	<abstract path="openfl.ui.KeyLocation" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/ui/KeyLocation.hx">
		<from><icast><x path="Int"/></icast></from>
		<this><x path="Int"/></this>
		<to><icast><x path="Int"/></icast></to>
		<meta><m n=":enum"/></meta>
		<impl><class path="openfl.ui._KeyLocation.KeyLocation_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/ui/KeyLocation.hx" private="1" module="openfl.ui.KeyLocation" extern="1">
	<LEFT public="1" get="inline" set="null" expr="cast 1" line="6" static="1">
		<x path="openfl.ui.KeyLocation"/>
		<meta>
			<m n=":value"><e>cast 1</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</LEFT>
	<NUM_PAD public="1" get="inline" set="null" expr="cast 3" line="7" static="1">
		<x path="openfl.ui.KeyLocation"/>
		<meta>
			<m n=":value"><e>cast 3</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NUM_PAD>
	<RIGHT public="1" get="inline" set="null" expr="cast 2" line="8" static="1">
		<x path="openfl.ui.KeyLocation"/>
		<meta>
			<m n=":value"><e>cast 2</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</RIGHT>
	<STANDARD public="1" get="inline" set="null" expr="cast 0" line="9" static="1">
		<x path="openfl.ui.KeyLocation"/>
		<meta>
			<m n=":value"><e>cast 0</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</STANDARD>
	<meta>
		<m n=":final"/>
		<m n=":enum"/>
	</meta>
</class></impl>
	</abstract>
	<class path="openfl.ui._KeyLocation.KeyLocation_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/ui/KeyLocation.hx" private="1" module="openfl.ui.KeyLocation" extern="1">
		<LEFT public="1" get="inline" set="null" expr="cast 1" line="6" static="1">
			<x path="openfl.ui.KeyLocation"/>
			<meta>
				<m n=":value"><e>cast 1</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</LEFT>
		<NUM_PAD public="1" get="inline" set="null" expr="cast 3" line="7" static="1">
			<x path="openfl.ui.KeyLocation"/>
			<meta>
				<m n=":value"><e>cast 3</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NUM_PAD>
		<RIGHT public="1" get="inline" set="null" expr="cast 2" line="8" static="1">
			<x path="openfl.ui.KeyLocation"/>
			<meta>
				<m n=":value"><e>cast 2</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</RIGHT>
		<STANDARD public="1" get="inline" set="null" expr="cast 0" line="9" static="1">
			<x path="openfl.ui.KeyLocation"/>
			<meta>
				<m n=":value"><e>cast 0</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</STANDARD>
		<meta>
			<m n=":final"/>
			<m n=":enum"/>
		</meta>
	</class>
	<class path="openfl.ui.Keyboard" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/ui/Keyboard.hx">
		<NUMBER_0 public="1" get="inline" set="null" expr="48" line="10" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>48</e></m></meta>
		</NUMBER_0>
		<NUMBER_1 public="1" get="inline" set="null" expr="49" line="11" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>49</e></m></meta>
		</NUMBER_1>
		<NUMBER_2 public="1" get="inline" set="null" expr="50" line="12" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>50</e></m></meta>
		</NUMBER_2>
		<NUMBER_3 public="1" get="inline" set="null" expr="51" line="13" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>51</e></m></meta>
		</NUMBER_3>
		<NUMBER_4 public="1" get="inline" set="null" expr="52" line="14" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>52</e></m></meta>
		</NUMBER_4>
		<NUMBER_5 public="1" get="inline" set="null" expr="53" line="15" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>53</e></m></meta>
		</NUMBER_5>
		<NUMBER_6 public="1" get="inline" set="null" expr="54" line="16" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>54</e></m></meta>
		</NUMBER_6>
		<NUMBER_7 public="1" get="inline" set="null" expr="55" line="17" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>55</e></m></meta>
		</NUMBER_7>
		<NUMBER_8 public="1" get="inline" set="null" expr="56" line="18" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>56</e></m></meta>
		</NUMBER_8>
		<NUMBER_9 public="1" get="inline" set="null" expr="57" line="19" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>57</e></m></meta>
		</NUMBER_9>
		<A public="1" get="inline" set="null" expr="65" line="20" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>65</e></m></meta>
		</A>
		<B public="1" get="inline" set="null" expr="66" line="21" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>66</e></m></meta>
		</B>
		<C public="1" get="inline" set="null" expr="67" line="22" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>67</e></m></meta>
		</C>
		<D public="1" get="inline" set="null" expr="68" line="23" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>68</e></m></meta>
		</D>
		<E public="1" get="inline" set="null" expr="69" line="24" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>69</e></m></meta>
		</E>
		<F public="1" get="inline" set="null" expr="70" line="25" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>70</e></m></meta>
		</F>
		<G public="1" get="inline" set="null" expr="71" line="26" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>71</e></m></meta>
		</G>
		<H public="1" get="inline" set="null" expr="72" line="27" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>72</e></m></meta>
		</H>
		<I public="1" get="inline" set="null" expr="73" line="28" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>73</e></m></meta>
		</I>
		<J public="1" get="inline" set="null" expr="74" line="29" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>74</e></m></meta>
		</J>
		<K public="1" get="inline" set="null" expr="75" line="30" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>75</e></m></meta>
		</K>
		<L public="1" get="inline" set="null" expr="76" line="31" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>76</e></m></meta>
		</L>
		<M public="1" get="inline" set="null" expr="77" line="32" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>77</e></m></meta>
		</M>
		<N public="1" get="inline" set="null" expr="78" line="33" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>78</e></m></meta>
		</N>
		<O public="1" get="inline" set="null" expr="79" line="34" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>79</e></m></meta>
		</O>
		<P public="1" get="inline" set="null" expr="80" line="35" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>80</e></m></meta>
		</P>
		<Q public="1" get="inline" set="null" expr="81" line="36" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>81</e></m></meta>
		</Q>
		<R public="1" get="inline" set="null" expr="82" line="37" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>82</e></m></meta>
		</R>
		<S public="1" get="inline" set="null" expr="83" line="38" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>83</e></m></meta>
		</S>
		<T public="1" get="inline" set="null" expr="84" line="39" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>84</e></m></meta>
		</T>
		<U public="1" get="inline" set="null" expr="85" line="40" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>85</e></m></meta>
		</U>
		<V public="1" get="inline" set="null" expr="86" line="41" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>86</e></m></meta>
		</V>
		<W public="1" get="inline" set="null" expr="87" line="42" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>87</e></m></meta>
		</W>
		<X public="1" get="inline" set="null" expr="88" line="43" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>88</e></m></meta>
		</X>
		<Y public="1" get="inline" set="null" expr="89" line="44" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>89</e></m></meta>
		</Y>
		<Z public="1" get="inline" set="null" expr="90" line="45" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>90</e></m></meta>
		</Z>
		<NUMPAD_0 public="1" get="inline" set="null" expr="96" line="46" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>96</e></m></meta>
		</NUMPAD_0>
		<NUMPAD_1 public="1" get="inline" set="null" expr="97" line="47" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>97</e></m></meta>
		</NUMPAD_1>
		<NUMPAD_2 public="1" get="inline" set="null" expr="98" line="48" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>98</e></m></meta>
		</NUMPAD_2>
		<NUMPAD_3 public="1" get="inline" set="null" expr="99" line="49" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>99</e></m></meta>
		</NUMPAD_3>
		<NUMPAD_4 public="1" get="inline" set="null" expr="100" line="50" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>100</e></m></meta>
		</NUMPAD_4>
		<NUMPAD_5 public="1" get="inline" set="null" expr="101" line="51" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>101</e></m></meta>
		</NUMPAD_5>
		<NUMPAD_6 public="1" get="inline" set="null" expr="102" line="52" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>102</e></m></meta>
		</NUMPAD_6>
		<NUMPAD_7 public="1" get="inline" set="null" expr="103" line="53" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>103</e></m></meta>
		</NUMPAD_7>
		<NUMPAD_8 public="1" get="inline" set="null" expr="104" line="54" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>104</e></m></meta>
		</NUMPAD_8>
		<NUMPAD_9 public="1" get="inline" set="null" expr="105" line="55" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>105</e></m></meta>
		</NUMPAD_9>
		<NUMPAD_MULTIPLY public="1" get="inline" set="null" expr="106" line="56" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>106</e></m></meta>
		</NUMPAD_MULTIPLY>
		<NUMPAD_ADD public="1" get="inline" set="null" expr="107" line="57" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>107</e></m></meta>
		</NUMPAD_ADD>
		<NUMPAD_ENTER public="1" get="inline" set="null" expr="108" line="58" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>108</e></m></meta>
		</NUMPAD_ENTER>
		<NUMPAD_SUBTRACT public="1" get="inline" set="null" expr="109" line="59" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>109</e></m></meta>
		</NUMPAD_SUBTRACT>
		<NUMPAD_DECIMAL public="1" get="inline" set="null" expr="110" line="60" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>110</e></m></meta>
		</NUMPAD_DECIMAL>
		<NUMPAD_DIVIDE public="1" get="inline" set="null" expr="111" line="61" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>111</e></m></meta>
		</NUMPAD_DIVIDE>
		<F1 public="1" get="inline" set="null" expr="112" line="62" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>112</e></m></meta>
		</F1>
		<F2 public="1" get="inline" set="null" expr="113" line="63" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>113</e></m></meta>
		</F2>
		<F3 public="1" get="inline" set="null" expr="114" line="64" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>114</e></m></meta>
		</F3>
		<F4 public="1" get="inline" set="null" expr="115" line="65" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>115</e></m></meta>
		</F4>
		<F5 public="1" get="inline" set="null" expr="116" line="66" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>116</e></m></meta>
		</F5>
		<F6 public="1" get="inline" set="null" expr="117" line="67" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>117</e></m></meta>
		</F6>
		<F7 public="1" get="inline" set="null" expr="118" line="68" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>118</e></m></meta>
		</F7>
		<F8 public="1" get="inline" set="null" expr="119" line="69" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>119</e></m></meta>
		</F8>
		<F9 public="1" get="inline" set="null" expr="120" line="70" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>120</e></m></meta>
		</F9>
		<F10 public="1" get="inline" set="null" expr="121" line="71" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>121</e></m></meta>
		</F10>
		<F11 public="1" get="inline" set="null" expr="122" line="72" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>122</e></m></meta>
		</F11>
		<F12 public="1" get="inline" set="null" expr="123" line="73" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>123</e></m></meta>
		</F12>
		<F13 public="1" get="inline" set="null" expr="124" line="74" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>124</e></m></meta>
		</F13>
		<F14 public="1" get="inline" set="null" expr="125" line="75" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>125</e></m></meta>
		</F14>
		<F15 public="1" get="inline" set="null" expr="126" line="76" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>126</e></m></meta>
		</F15>
		<BACKSPACE public="1" get="inline" set="null" expr="8" line="77" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>8</e></m></meta>
		</BACKSPACE>
		<TAB public="1" get="inline" set="null" expr="9" line="78" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>9</e></m></meta>
		</TAB>
		<ALTERNATE public="1" get="inline" set="null" expr="18" line="79" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>18</e></m></meta>
		</ALTERNATE>
		<ENTER public="1" get="inline" set="null" expr="13" line="80" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>13</e></m></meta>
		</ENTER>
		<COMMAND public="1" get="inline" set="null" expr="15" line="81" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>15</e></m></meta>
		</COMMAND>
		<SHIFT public="1" get="inline" set="null" expr="16" line="82" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>16</e></m></meta>
		</SHIFT>
		<CONTROL public="1" get="inline" set="null" expr="17" line="83" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>17</e></m></meta>
		</CONTROL>
		<BREAK public="1" get="inline" set="null" expr="19" line="84" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>19</e></m></meta>
		</BREAK>
		<CAPS_LOCK public="1" get="inline" set="null" expr="20" line="85" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>20</e></m></meta>
		</CAPS_LOCK>
		<NUMPAD public="1" get="inline" set="null" expr="21" line="86" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>21</e></m></meta>
		</NUMPAD>
		<ESCAPE public="1" get="inline" set="null" expr="27" line="87" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>27</e></m></meta>
		</ESCAPE>
		<SPACE public="1" get="inline" set="null" expr="32" line="88" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>32</e></m></meta>
		</SPACE>
		<PAGE_UP public="1" get="inline" set="null" expr="33" line="89" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>33</e></m></meta>
		</PAGE_UP>
		<PAGE_DOWN public="1" get="inline" set="null" expr="34" line="90" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>34</e></m></meta>
		</PAGE_DOWN>
		<END public="1" get="inline" set="null" expr="35" line="91" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>35</e></m></meta>
		</END>
		<HOME public="1" get="inline" set="null" expr="36" line="92" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>36</e></m></meta>
		</HOME>
		<LEFT public="1" get="inline" set="null" expr="37" line="93" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>37</e></m></meta>
		</LEFT>
		<RIGHT public="1" get="inline" set="null" expr="39" line="94" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>39</e></m></meta>
		</RIGHT>
		<UP public="1" get="inline" set="null" expr="38" line="95" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>38</e></m></meta>
		</UP>
		<DOWN public="1" get="inline" set="null" expr="40" line="96" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>40</e></m></meta>
		</DOWN>
		<INSERT public="1" get="inline" set="null" expr="45" line="97" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>45</e></m></meta>
		</INSERT>
		<DELETE public="1" get="inline" set="null" expr="46" line="98" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>46</e></m></meta>
		</DELETE>
		<NUMLOCK public="1" get="inline" set="null" expr="144" line="99" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>144</e></m></meta>
		</NUMLOCK>
		<SEMICOLON public="1" get="inline" set="null" expr="186" line="100" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>186</e></m></meta>
		</SEMICOLON>
		<EQUAL public="1" get="inline" set="null" expr="187" line="101" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>187</e></m></meta>
		</EQUAL>
		<COMMA public="1" get="inline" set="null" expr="188" line="102" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>188</e></m></meta>
		</COMMA>
		<MINUS public="1" get="inline" set="null" expr="189" line="103" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>189</e></m></meta>
		</MINUS>
		<PERIOD public="1" get="inline" set="null" expr="190" line="104" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>190</e></m></meta>
		</PERIOD>
		<SLASH public="1" get="inline" set="null" expr="191" line="105" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>191</e></m></meta>
		</SLASH>
		<BACKQUOTE public="1" get="inline" set="null" expr="192" line="106" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>192</e></m></meta>
		</BACKQUOTE>
		<LEFTBRACKET public="1" get="inline" set="null" expr="219" line="107" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>219</e></m></meta>
		</LEFTBRACKET>
		<BACKSLASH public="1" get="inline" set="null" expr="220" line="108" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>220</e></m></meta>
		</BACKSLASH>
		<RIGHTBRACKET public="1" get="inline" set="null" expr="221" line="109" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>221</e></m></meta>
		</RIGHTBRACKET>
		<QUOTE public="1" get="inline" set="null" expr="222" line="110" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>222</e></m></meta>
		</QUOTE>
		<capsLock public="1" set="null" static="1"><x path="Bool"/></capsLock>
		<numLock public="1" set="null" static="1"><x path="Bool"/></numLock>
		<isAccessible public="1" set="method" line="116" static="1"><f a=""><x path="Bool"/></f></isAccessible>
		<__convertKeyCode get="inline" set="null" line="124" static="1"><f a="key">
	<x path="lime.ui.KeyCode"/>
	<x path="Int"/>
</f></__convertKeyCode>
		<__getCharCode set="method" line="370" static="1">
			<f a="key:?shift" v=":false">
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Int"/>
			</f>
			<meta><m n=":value"><e>{ shift : false }</e></m></meta>
		</__getCharCode>
		<__getKeyLocation get="inline" set="null" line="467" static="1"><f a="key">
	<x path="lime.ui.KeyCode"/>
	<x path="openfl.ui.KeyLocation"/>
</f></__getKeyLocation>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":final"/>
		</meta>
	</class>
	<class path="openfl.ui.Mouse" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/ui/Mouse.hx">
		<hide public="1" set="method" line="13" static="1"><f a=""><x path="Void"/></f></hide>
		<show public="1" set="method" line="20" static="1"><f a=""><x path="Void"/></f></show>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":access"><e>openfl.display.Stage</e></m>
			<m n=":final"/>
		</meta>
	</class>
	<class path="openfl.ui.Multitouch" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/ui/Multitouch.hx">
		<inputMode public="1" get="accessor" set="accessor" static="1"><x path="openfl.ui.MultitouchInputMode"/></inputMode>
		<maxTouchPoints public="1" set="null" static="1"><x path="Int"/></maxTouchPoints>
		<supportedGestures public="1" set="null" static="1"><x path="openfl.Vector"><c path="String"/></x></supportedGestures>
		<supportsGestureEvents public="1" set="null" static="1"><x path="Bool"/></supportsGestureEvents>
		<supportsTouchEvents public="1" get="accessor" set="null" static="1"><x path="Bool"/></supportsTouchEvents>
		<get_inputMode set="method" line="39" static="1"><f a=""><x path="openfl.ui.MultitouchInputMode"/></f></get_inputMode>
		<set_inputMode set="method" line="46" static="1"><f a="inMode">
	<x path="openfl.ui.MultitouchInputMode"/>
	<x path="openfl.ui.MultitouchInputMode"/>
</f></set_inputMode>
		<get_supportsTouchEvents set="method" line="60" static="1"><f a=""><x path="Bool"/></f></get_supportsTouchEvents>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":final"/>
		</meta>
	</class>
	<abstract path="openfl.ui.MultitouchInputMode" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/ui/MultitouchInputMode.hx">
		<from><icast field="fromString"><c path="String"/></icast></from>
		<this><t path="Null"><x path="Int"/></t></this>
		<to><icast field="toString"><c path="String"/></icast></to>
		<meta><m n=":enum"/></meta>
		<impl><class path="openfl.ui._MultitouchInputMode.MultitouchInputMode_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/ui/MultitouchInputMode.hx" private="1" module="openfl.ui.MultitouchInputMode">
	<GESTURE public="1" get="inline" set="null" expr="cast 0" line="6" static="1">
		<x path="openfl.ui.MultitouchInputMode"/>
		<meta>
			<m n=":value"><e>cast 0</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</GESTURE>
	<NONE public="1" get="inline" set="null" expr="cast 1" line="7" static="1">
		<x path="openfl.ui.MultitouchInputMode"/>
		<meta>
			<m n=":value"><e>cast 1</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</NONE>
	<TOUCH_POINT public="1" get="inline" set="null" expr="cast 2" line="8" static="1">
		<x path="openfl.ui.MultitouchInputMode"/>
		<meta>
			<m n=":value"><e>cast 2</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</TOUCH_POINT>
	<fromString set="method" line="10" static="1">
		<f a="value">
			<c path="String"/>
			<x path="openfl.ui.MultitouchInputMode"/>
		</f>
		<meta><m n=":from"/></meta>
	</fromString>
	<toString set="method" line="23" static="1">
		<f a="value">
			<x path="Int"/>
			<c path="String"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":to"/>
		</meta>
	</toString>
	<meta>
		<m n=":final"/>
		<m n=":enum"/>
	</meta>
</class></impl>
	</abstract>
	<class path="openfl.ui._MultitouchInputMode.MultitouchInputMode_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/ui/MultitouchInputMode.hx" private="1" module="openfl.ui.MultitouchInputMode">
		<GESTURE public="1" get="inline" set="null" expr="cast 0" line="6" static="1">
			<x path="openfl.ui.MultitouchInputMode"/>
			<meta>
				<m n=":value"><e>cast 0</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</GESTURE>
		<NONE public="1" get="inline" set="null" expr="cast 1" line="7" static="1">
			<x path="openfl.ui.MultitouchInputMode"/>
			<meta>
				<m n=":value"><e>cast 1</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</NONE>
		<TOUCH_POINT public="1" get="inline" set="null" expr="cast 2" line="8" static="1">
			<x path="openfl.ui.MultitouchInputMode"/>
			<meta>
				<m n=":value"><e>cast 2</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</TOUCH_POINT>
		<fromString set="method" line="10" static="1">
			<f a="value">
				<c path="String"/>
				<x path="openfl.ui.MultitouchInputMode"/>
			</f>
			<meta><m n=":from"/></meta>
		</fromString>
		<toString set="method" line="23" static="1">
			<f a="value">
				<x path="Int"/>
				<c path="String"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":to"/>
			</meta>
		</toString>
		<meta>
			<m n=":final"/>
			<m n=":enum"/>
		</meta>
	</class>
	<typedef path="openfl.utils.ArrayBuffer" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/utils/ArrayBuffer.hx"><x path="lime.utils.ArrayBuffer"/></typedef>
	<typedef path="openfl.utils.ArrayBufferView" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/utils/ArrayBufferView.hx"><c path="lime.utils.ArrayBufferView"/></typedef>
	<abstract path="openfl.utils.ByteArray" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/utils/ByteArray.hx">
		<from>
			<icast><c path="openfl.utils.ByteArrayData"/></icast>
			<icast field="fromArrayBuffer"><x path="lime.utils.ArrayBuffer"/></icast>
			<icast field="fromBytes"><c path="haxe.io.Bytes"/></icast>
			<icast field="fromBytesData"><t path="haxe.io.BytesData"/></icast>
		</from>
		<this><c path="openfl.utils.ByteArrayData"/></this>
		<to>
			<icast><c path="openfl.utils.ByteArrayData"/></icast>
			<icast field="toArrayBuffer"><x path="lime.utils.ArrayBuffer"/></icast>
			<icast field="toBytes"><c path="haxe.io.Bytes"/></icast>
			<icast field="toBytesData"><c path="neko.NativeString"/></icast>
			<icast field="toLimeBytes"><c path="lime.utils.Bytes"/></icast>
		</to>
		<meta>
			<m n=":access"><e>haxe.io.Bytes</e></m>
			<m n=":access"><e>openfl.utils.ByteArrayData</e></m>
			<m n=":forward">
				<e>bytesAvailable</e>
				<e>endian</e>
				<e>objectEncoding</e>
				<e>position</e>
				<e>clear</e>
				<e>compress</e>
				<e>deflate</e>
				<e>inflate</e>
				<e>readBoolean</e>
				<e>readByte</e>
				<e>readBytes</e>
				<e>readDouble</e>
				<e>readFloat</e>
				<e>readInt</e>
				<e>readMultiByte</e>
				<e>readShort</e>
				<e>readUnsignedByte</e>
				<e>readUnsignedInt</e>
				<e>readUnsignedShort</e>
				<e>readUTF</e>
				<e>readUTFBytes</e>
				<e>toString</e>
				<e>uncompress</e>
				<e>writeBoolean</e>
				<e>writeByte</e>
				<e>writeBytes</e>
				<e>writeDouble</e>
				<e>writeFloat</e>
				<e>writeInt</e>
				<e>writeMultiByte</e>
				<e>writeShort</e>
				<e>writeUnsignedInt</e>
				<e>writeUTF</e>
				<e>writeUTFBytes</e>
			</m>
		</meta>
		<impl><class path="openfl.utils._ByteArray.ByteArray_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/utils/ByteArray.hx" private="1" module="openfl.utils.ByteArray">
	<defaultObjectEncoding public="1" static="1"><x path="UInt"/></defaultObjectEncoding>
	<length public="1" get="accessor" set="accessor" static="1">
		<x path="Int"/>
		<meta><m n=":impl"/></meta>
	</length>
	<_new public="1" get="inline" set="null" line="31" static="1">
		<f a="?length" v="0">
			<x path="Int"/>
			<x path="openfl.utils.ByteArray"/>
		</f>
		<meta>
			<m n=":value"><e>{ length : 0 }</e></m>
			<m n=":impl"/>
		</meta>
	</_new>
	<get get="inline" set="null" line="43" static="1">
		<f a="this:index">
			<c path="openfl.utils.ByteArrayData"/>
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":arrayAccess"/>
			<m n=":noCompletion"/>
		</meta>
	</get>
	<set get="inline" set="null" line="56" static="1">
		<f a="this:index:value">
			<c path="openfl.utils.ByteArrayData"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":arrayAccess"/>
			<m n=":noCompletion"/>
		</meta>
	</set>
	<fromArrayBuffer public="1" set="method" line="69" static="1">
		<f a="buffer">
			<x path="lime.utils.ArrayBuffer"/>
			<x path="openfl.utils.ByteArray"/>
		</f>
		<meta>
			<m n=":from"/>
			<m n=":noCompletion"/>
		</meta>
	</fromArrayBuffer>
	<fromBytes public="1" set="method" line="84" static="1">
		<f a="bytes">
			<c path="haxe.io.Bytes"/>
			<x path="openfl.utils.ByteArray"/>
		</f>
		<meta>
			<m n=":from"/>
			<m n=":noCompletion"/>
		</meta>
	</fromBytes>
	<fromBytesData public="1" set="method" line="111" static="1">
		<f a="bytesData">
			<t path="haxe.io.BytesData"/>
			<x path="openfl.utils.ByteArray"/>
		</f>
		<meta>
			<m n=":from"/>
			<m n=":noCompletion"/>
		</meta>
	</fromBytesData>
	<toArrayBuffer public="1" set="method" line="124" static="1">
		<f a="byteArray">
			<x path="openfl.utils.ByteArray"/>
			<x path="lime.utils.ArrayBuffer"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":to"/>
			<m n=":noCompletion"/>
		</meta>
	</toArrayBuffer>
	<toBytes set="method" line="139" static="1">
		<f a="byteArray">
			<x path="openfl.utils.ByteArray"/>
			<c path="haxe.io.Bytes"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":to"/>
			<m n=":noCompletion"/>
		</meta>
	</toBytes>
	<toBytesData set="method" line="153" static="1">
		<f a="byteArray">
			<x path="openfl.utils.ByteArray"/>
			<t path="haxe.io.BytesData"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":to"/>
			<m n=":noCompletion"/>
		</meta>
	</toBytesData>
	<toLimeBytes set="method" line="167" static="1">
		<f a="byteArray">
			<x path="openfl.utils.ByteArray"/>
			<t path="lime.utils._Bytes.LimeBytes"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":to"/>
			<m n=":noCompletion"/>
		</meta>
	</toLimeBytes>
	<get_length set="method" line="187" static="1">
		<f a="this">
			<c path="openfl.utils.ByteArrayData"/>
			<x path="Int"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
	</get_length>
	<set_length set="method" line="200" static="1">
		<f a="this:value">
			<c path="openfl.utils.ByteArrayData"/>
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
		</meta>
	</set_length>
	<meta>
		<m n=":directlyUsed"/>
		<m n=":final"/>
		<m n=":access"><e>openfl.utils.ByteArrayData</e></m>
		<m n=":access"><e>haxe.io.Bytes</e></m>
	</meta>
</class></impl>
	</abstract>
	<class path="openfl.utils._ByteArray.ByteArray_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/utils/ByteArray.hx" private="1" module="openfl.utils.ByteArray">
		<defaultObjectEncoding public="1" static="1"><x path="UInt"/></defaultObjectEncoding>
		<length public="1" get="accessor" set="accessor" static="1">
			<x path="Int"/>
			<meta><m n=":impl"/></meta>
		</length>
		<_new public="1" get="inline" set="null" line="31" static="1">
			<f a="?length" v="0">
				<x path="Int"/>
				<x path="openfl.utils.ByteArray"/>
			</f>
			<meta>
				<m n=":value"><e>{ length : 0 }</e></m>
				<m n=":impl"/>
			</meta>
		</_new>
		<get get="inline" set="null" line="43" static="1">
			<f a="this:index">
				<c path="openfl.utils.ByteArrayData"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":arrayAccess"/>
				<m n=":noCompletion"/>
			</meta>
		</get>
		<set get="inline" set="null" line="56" static="1">
			<f a="this:index:value">
				<c path="openfl.utils.ByteArrayData"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":arrayAccess"/>
				<m n=":noCompletion"/>
			</meta>
		</set>
		<fromArrayBuffer public="1" set="method" line="69" static="1">
			<f a="buffer">
				<x path="lime.utils.ArrayBuffer"/>
				<x path="openfl.utils.ByteArray"/>
			</f>
			<meta>
				<m n=":from"/>
				<m n=":noCompletion"/>
			</meta>
		</fromArrayBuffer>
		<fromBytes public="1" set="method" line="84" static="1">
			<f a="bytes">
				<c path="haxe.io.Bytes"/>
				<x path="openfl.utils.ByteArray"/>
			</f>
			<meta>
				<m n=":from"/>
				<m n=":noCompletion"/>
			</meta>
		</fromBytes>
		<fromBytesData public="1" set="method" line="111" static="1">
			<f a="bytesData">
				<t path="haxe.io.BytesData"/>
				<x path="openfl.utils.ByteArray"/>
			</f>
			<meta>
				<m n=":from"/>
				<m n=":noCompletion"/>
			</meta>
		</fromBytesData>
		<toArrayBuffer public="1" set="method" line="124" static="1">
			<f a="byteArray">
				<x path="openfl.utils.ByteArray"/>
				<x path="lime.utils.ArrayBuffer"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":to"/>
				<m n=":noCompletion"/>
			</meta>
		</toArrayBuffer>
		<toBytes set="method" line="139" static="1">
			<f a="byteArray">
				<x path="openfl.utils.ByteArray"/>
				<c path="haxe.io.Bytes"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":to"/>
				<m n=":noCompletion"/>
			</meta>
		</toBytes>
		<toBytesData set="method" line="153" static="1">
			<f a="byteArray">
				<x path="openfl.utils.ByteArray"/>
				<t path="haxe.io.BytesData"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":to"/>
				<m n=":noCompletion"/>
			</meta>
		</toBytesData>
		<toLimeBytes set="method" line="167" static="1">
			<f a="byteArray">
				<x path="openfl.utils.ByteArray"/>
				<t path="lime.utils._Bytes.LimeBytes"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":to"/>
				<m n=":noCompletion"/>
			</meta>
		</toLimeBytes>
		<get_length set="method" line="187" static="1">
			<f a="this">
				<c path="openfl.utils.ByteArrayData"/>
				<x path="Int"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
		</get_length>
		<set_length set="method" line="200" static="1">
			<f a="this:value">
				<c path="openfl.utils.ByteArrayData"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
			</meta>
		</set_length>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":final"/>
			<m n=":access"><e>openfl.utils.ByteArrayData</e></m>
			<m n=":access"><e>haxe.io.Bytes</e></m>
		</meta>
	</class>
	<abstract path="openfl.utils.CompressionAlgorithm" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/utils/CompressionAlgorithm.hx">
		<from><icast field="fromString"><c path="String"/></icast></from>
		<this><t path="Null"><x path="Int"/></t></this>
		<to><icast field="toString"><c path="String"/></icast></to>
		<meta><m n=":enum"/></meta>
		<impl><class path="openfl.utils._CompressionAlgorithm.CompressionAlgorithm_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/utils/CompressionAlgorithm.hx" private="1" module="openfl.utils.CompressionAlgorithm">
	<DEFLATE public="1" get="inline" set="null" expr="cast 0" line="6" static="1">
		<x path="openfl.utils.CompressionAlgorithm"/>
		<meta>
			<m n=":value"><e>cast 0</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</DEFLATE>
	<LZMA public="1" get="inline" set="null" expr="cast 1" line="8" static="1">
		<x path="openfl.utils.CompressionAlgorithm"/>
		<meta>
			<m n=":value"><e>cast 1</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</LZMA>
	<ZLIB public="1" get="inline" set="null" expr="cast 2" line="9" static="1">
		<x path="openfl.utils.CompressionAlgorithm"/>
		<meta>
			<m n=":value"><e>cast 2</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</ZLIB>
	<fromString set="method" line="11" static="1">
		<f a="value">
			<c path="String"/>
			<x path="openfl.utils.CompressionAlgorithm"/>
		</f>
		<meta><m n=":from"/></meta>
	</fromString>
	<toString set="method" line="24" static="1">
		<f a="value">
			<x path="Int"/>
			<c path="String"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":to"/>
		</meta>
	</toString>
	<meta>
		<m n=":final"/>
		<m n=":enum"/>
	</meta>
</class></impl>
	</abstract>
	<class path="openfl.utils._CompressionAlgorithm.CompressionAlgorithm_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/utils/CompressionAlgorithm.hx" private="1" module="openfl.utils.CompressionAlgorithm">
		<DEFLATE public="1" get="inline" set="null" expr="cast 0" line="6" static="1">
			<x path="openfl.utils.CompressionAlgorithm"/>
			<meta>
				<m n=":value"><e>cast 0</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</DEFLATE>
		<LZMA public="1" get="inline" set="null" expr="cast 1" line="8" static="1">
			<x path="openfl.utils.CompressionAlgorithm"/>
			<meta>
				<m n=":value"><e>cast 1</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</LZMA>
		<ZLIB public="1" get="inline" set="null" expr="cast 2" line="9" static="1">
			<x path="openfl.utils.CompressionAlgorithm"/>
			<meta>
				<m n=":value"><e>cast 2</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</ZLIB>
		<fromString set="method" line="11" static="1">
			<f a="value">
				<c path="String"/>
				<x path="openfl.utils.CompressionAlgorithm"/>
			</f>
			<meta><m n=":from"/></meta>
		</fromString>
		<toString set="method" line="24" static="1">
			<f a="value">
				<x path="Int"/>
				<c path="String"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":to"/>
			</meta>
		</toString>
		<meta>
			<m n=":final"/>
			<m n=":enum"/>
		</meta>
	</class>
	<abstract path="openfl.utils.Endian" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/utils/Endian.hx">
		<from><icast field="fromString"><c path="String"/></icast></from>
		<this><t path="Null"><x path="Int"/></t></this>
		<to><icast field="toString"><c path="String"/></icast></to>
		<meta><m n=":enum"/></meta>
		<impl><class path="openfl.utils._Endian.Endian_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/utils/Endian.hx" private="1" module="openfl.utils.Endian">
	<BIG_ENDIAN public="1" get="inline" set="null" expr="cast 0" line="6" static="1">
		<x path="openfl.utils.Endian"/>
		<meta>
			<m n=":value"><e>cast 0</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</BIG_ENDIAN>
	<LITTLE_ENDIAN public="1" get="inline" set="null" expr="cast 1" line="7" static="1">
		<x path="openfl.utils.Endian"/>
		<meta>
			<m n=":value"><e>cast 1</e></m>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</LITTLE_ENDIAN>
	<fromString set="method" line="9" static="1">
		<f a="value">
			<c path="String"/>
			<x path="openfl.utils.Endian"/>
		</f>
		<meta><m n=":from"/></meta>
	</fromString>
	<toString set="method" line="21" static="1">
		<f a="value">
			<x path="Int"/>
			<c path="String"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":to"/>
		</meta>
	</toString>
	<meta>
		<m n=":final"/>
		<m n=":enum"/>
	</meta>
</class></impl>
	</abstract>
	<class path="openfl.utils._Endian.Endian_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/utils/Endian.hx" private="1" module="openfl.utils.Endian">
		<BIG_ENDIAN public="1" get="inline" set="null" expr="cast 0" line="6" static="1">
			<x path="openfl.utils.Endian"/>
			<meta>
				<m n=":value"><e>cast 0</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</BIG_ENDIAN>
		<LITTLE_ENDIAN public="1" get="inline" set="null" expr="cast 1" line="7" static="1">
			<x path="openfl.utils.Endian"/>
			<meta>
				<m n=":value"><e>cast 1</e></m>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</LITTLE_ENDIAN>
		<fromString set="method" line="9" static="1">
			<f a="value">
				<c path="String"/>
				<x path="openfl.utils.Endian"/>
			</f>
			<meta><m n=":from"/></meta>
		</fromString>
		<toString set="method" line="21" static="1">
			<f a="value">
				<x path="Int"/>
				<c path="String"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":to"/>
			</meta>
		</toString>
		<meta>
			<m n=":final"/>
			<m n=":enum"/>
		</meta>
	</class>
	<typedef path="openfl.utils.Float32Array" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/utils/Float32Array.hx"><x path="lime.utils.Float32Array"/></typedef>
	<typedef path="openfl.utils.Int16Array" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/utils/Int16Array.hx"><x path="lime.utils.Int16Array"/></typedef>
	<abstract path="openfl.utils.Object" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/utils/Object.hx">
		<from><icast><t path="openfl.utils.ObjectType"/></icast></from>
		<this><t path="openfl.utils.ObjectType"/></this>
		<to><icast field="toString"><c path="String"/></icast></to>
		<meta><m n=":forward"/></meta>
		<impl><class path="openfl.utils._Object.Object_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/utils/Object.hx" private="1" module="openfl.utils.Object">
	<_new public="1" get="inline" set="null" line="7" static="1">
		<f a=""><x path="openfl.utils.Object"/></f>
		<meta><m n=":impl"/></meta>
	</_new>
	<hasOwnProperty public="1" get="inline" set="null" line="14" static="1">
		<f a="this:name">
			<t path="openfl.utils.ObjectType"/>
			<c path="String"/>
			<x path="Bool"/>
		</f>
		<meta><m n=":impl"/></meta>
	</hasOwnProperty>
	<isPrototypeOf public="1" get="inline" set="null" line="21" static="1">
		<f a="this:theClass">
			<t path="openfl.utils.ObjectType"/>
			<x path="Class"><d/></x>
			<x path="Bool"/>
		</f>
		<meta><m n=":impl"/></meta>
	</isPrototypeOf>
	<iterator public="1" set="method" line="37" static="1">
		<f a="this">
			<t path="openfl.utils.ObjectType"/>
			<t path="Iterator"><c path="String"/></t>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":noCompletion"/>
			<m n=":dox"><e>hide</e></m>
		</meta>
	</iterator>
	<propertyIsEnumerable public="1" get="inline" set="null" line="46" static="1">
		<f a="this:name">
			<t path="openfl.utils.ObjectType"/>
			<c path="String"/>
			<x path="Bool"/>
		</f>
		<meta><m n=":impl"/></meta>
	</propertyIsEnumerable>
	<toLocaleString public="1" get="inline" set="null" line="53" static="1">
		<f a="this">
			<t path="openfl.utils.ObjectType"/>
			<c path="String"/>
		</f>
		<meta><m n=":impl"/></meta>
	</toLocaleString>
	<toString public="1" get="inline" set="null" line="60" static="1">
		<f a="this">
			<t path="openfl.utils.ObjectType"/>
			<c path="String"/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":to"/>
		</meta>
	</toString>
	<valueOf public="1" get="inline" set="null" line="67" static="1">
		<f a="this">
			<t path="openfl.utils.ObjectType"/>
			<x path="openfl.utils.Object"/>
		</f>
		<meta><m n=":impl"/></meta>
	</valueOf>
	<__get public="1" get="inline" set="null" line="74" static="1">
		<f a="this:key">
			<t path="openfl.utils.ObjectType"/>
			<c path="String"/>
			<d/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":arrayAccess"/>
			<m n=":noCompletion"/>
			<m n=":dox"><e>hide</e></m>
		</meta>
	</__get>
	<__set public="1" get="inline" set="null" line="81" static="1">
		<f a="this:key:value">
			<t path="openfl.utils.ObjectType"/>
			<c path="String"/>
			<d/>
			<d/>
		</f>
		<meta>
			<m n=":impl"/>
			<m n=":arrayAccess"/>
			<m n=":noCompletion"/>
			<m n=":dox"><e>hide</e></m>
		</meta>
	</__set>
	<meta><m n=":final"/></meta>
</class></impl>
	</abstract>
	<class path="openfl.utils._Object.Object_Impl_" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/utils/Object.hx" private="1" module="openfl.utils.Object">
		<_new public="1" get="inline" set="null" line="7" static="1">
			<f a=""><x path="openfl.utils.Object"/></f>
			<meta><m n=":impl"/></meta>
		</_new>
		<hasOwnProperty public="1" get="inline" set="null" line="14" static="1">
			<f a="this:name">
				<t path="openfl.utils.ObjectType"/>
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":impl"/></meta>
		</hasOwnProperty>
		<isPrototypeOf public="1" get="inline" set="null" line="21" static="1">
			<f a="this:theClass">
				<t path="openfl.utils.ObjectType"/>
				<x path="Class"><d/></x>
				<x path="Bool"/>
			</f>
			<meta><m n=":impl"/></meta>
		</isPrototypeOf>
		<iterator public="1" set="method" line="37" static="1">
			<f a="this">
				<t path="openfl.utils.ObjectType"/>
				<t path="Iterator"><c path="String"/></t>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":noCompletion"/>
				<m n=":dox"><e>hide</e></m>
			</meta>
		</iterator>
		<propertyIsEnumerable public="1" get="inline" set="null" line="46" static="1">
			<f a="this:name">
				<t path="openfl.utils.ObjectType"/>
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":impl"/></meta>
		</propertyIsEnumerable>
		<toLocaleString public="1" get="inline" set="null" line="53" static="1">
			<f a="this">
				<t path="openfl.utils.ObjectType"/>
				<c path="String"/>
			</f>
			<meta><m n=":impl"/></meta>
		</toLocaleString>
		<toString public="1" get="inline" set="null" line="60" static="1">
			<f a="this">
				<t path="openfl.utils.ObjectType"/>
				<c path="String"/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":to"/>
			</meta>
		</toString>
		<valueOf public="1" get="inline" set="null" line="67" static="1">
			<f a="this">
				<t path="openfl.utils.ObjectType"/>
				<x path="openfl.utils.Object"/>
			</f>
			<meta><m n=":impl"/></meta>
		</valueOf>
		<__get public="1" get="inline" set="null" line="74" static="1">
			<f a="this:key">
				<t path="openfl.utils.ObjectType"/>
				<c path="String"/>
				<d/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":arrayAccess"/>
				<m n=":noCompletion"/>
				<m n=":dox"><e>hide</e></m>
			</meta>
		</__get>
		<__set public="1" get="inline" set="null" line="81" static="1">
			<f a="this:key:value">
				<t path="openfl.utils.ObjectType"/>
				<c path="String"/>
				<d/>
				<d/>
			</f>
			<meta>
				<m n=":impl"/>
				<m n=":arrayAccess"/>
				<m n=":noCompletion"/>
				<m n=":dox"><e>hide</e></m>
			</meta>
		</__set>
		<meta><m n=":final"/></meta>
	</class>
	<class path="openfl.utils._Object.Iterator_" params="T" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/utils/Object.hx" private="1" module="openfl.utils.Object" interface="1">
		<hasNext public="1" set="method"><f a=""><x path="Bool"/></f></hasNext>
		<next public="1" set="method"><f a=""><c path="openfl.utils._Object.Iterator_.T"/></f></next>
		<meta>
			<m n=":keep"/>
			<m n=":native"><e>"haxe.lang.Iterator"</e></m>
		</meta>
	</class>
	<class path="openfl.utils._Object.Iterable_" params="T" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/utils/Object.hx" private="1" module="openfl.utils.Object" interface="1">
		<iterator public="1" set="method"><f a=""><c path="openfl.utils._Object.Iterator_"><c path="openfl.utils._Object.Iterable_.T"/></c></f></iterator>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":keep"/>
			<m n=":native"><e>"haxe.lang.Iterable"</e></m>
		</meta>
	</class>
	<typedef path="openfl.utils.ObjectType" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/utils/Object.hx" module="openfl.utils.Object"><d/></typedef>
	<typedef path="openfl.utils.UInt8Array" params="" file="D:\HaxeToolkit\haxe\lib\openfl/3,6,1/openfl/utils/UInt8Array.hx"><x path="lime.utils.UInt8Array"/></typedef>
	<typedef path="sys.FileStat" params="" file="D:\HaxeToolkit\haxe\std/sys/FileStat.hx">
		<a>
			<uid>
				<x path="Int"/>
				<haxe_doc>The user id for the file's owner.</haxe_doc>
			</uid>
			<size>
				<x path="Int"/>
				<haxe_doc>The size of the file, in bytes.</haxe_doc>
			</size>
			<rdev>
				<x path="Int"/>
				<haxe_doc>The device type on which stat resides (special files only).</haxe_doc>
			</rdev>
			<nlink>
				<x path="Int"/>
				<haxe_doc>The number of hard links to stat.</haxe_doc>
			</nlink>
			<mtime>
				<c path="Date"/>
				<haxe_doc>The last modification time for the file.</haxe_doc>
			</mtime>
			<mode>
				<x path="Int"/>
				<haxe_doc>The permission bits of stat. The meaning of the bits is platform dependent.</haxe_doc>
			</mode>
			<ino>
				<x path="Int"/>
				<haxe_doc>The inode number for stat.</haxe_doc>
			</ino>
			<gid>
				<x path="Int"/>
				<haxe_doc>The user group id for the file's owner.</haxe_doc>
			</gid>
			<dev>
				<x path="Int"/>
				<haxe_doc>The device on which stat resides.</haxe_doc>
			</dev>
			<ctime>
				<c path="Date"/>
				<haxe_doc>The creation time for the file (not all filesystems support this).</haxe_doc>
			</ctime>
			<atime>
				<c path="Date"/>
				<haxe_doc>The last access time for the file (when enabled by the file system).</haxe_doc>
			</atime>
		</a>
		<haxe_doc>File informations, as given by `sys.FileSystem.stat`.</haxe_doc>
	</typedef>
	<enum path="sys.io.FileHandle" params="" file="D:\HaxeToolkit\haxe\std/neko/_std/sys/io/File.hx" module="sys.io.File"><meta><m n=":flatEnum"/></meta></enum>
	<class path="sys.io.File" params="" file="D:\HaxeToolkit\haxe\std/neko/_std/sys/io/File.hx">
		<getContent public="1" set="method" line="29" static="1">
			<f a="path">
				<c path="String"/>
				<c path="String"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Retrieves the content of the file specified by `path` as a String.

		If the file does not exist or can not be read, an exception is thrown.

		`sys.FileSystem.exists` can be used to check for existence.

		If `path` is null, the result is unspecified.</haxe_doc>
		</getContent>
		<write public="1" set="method" line="53" static="1">
			<f a="path:?binary" v=":true">
				<c path="String"/>
				<x path="Bool"/>
				<c path="sys.io.FileOutput"/>
			</f>
			<meta>
				<m n=":has_untyped"/>
				<m n=":value"><e>{ binary : true }</e></m>
			</meta>
			<haxe_doc>Returns an `FileOutput` handle to the file specified by `path`.

		If `binary` is true, the file is opened in binary mode. Otherwise it is
		opened in non-binary mode.

		If the file cannot be written to, an exception is thrown.

		Operations on the returned `FileOutput` handle write to the opened file.
		If the file existed, its previous content is overwritten.

		File handles should be closed via `FileOutput.close` once the operation
		is complete.

		If `path` is null, the result is unspecified.</haxe_doc>
		</write>
		<file_contents expr="neko.Lib.load(&quot;std&quot;, &quot;file_contents&quot;, 1)" line="69" static="1">
			<f a="">
				<unknown/>
				<c path="String"/>
			</f>
			<meta><m n=":value"><e>neko.Lib.load("std", "file_contents", 1)</e></m></meta>
		</file_contents>
		<file_open expr="neko.Lib.load(&quot;std&quot;, &quot;file_open&quot;, 2)" line="70" static="1">
			<f a=":">
				<unknown/>
				<unknown/>
				<e path="sys.io.FileHandle"/>
			</f>
			<meta><m n=":value"><e>neko.Lib.load("std", "file_open", 2)</e></m></meta>
		</file_open>
		<haxe_doc>API for reading and writing to files.

	See `sys.FileSystem` for the complementary file system API.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<class path="sys.io.FileInput" params="" file="D:\HaxeToolkit\haxe\std/neko/_std/sys/io/FileInput.hx">
		<extends path="haxe.io.Input"/>
		<file_read_char expr="neko.Lib.load(&quot;std&quot;, &quot;file_read_char&quot;, 1)" line="75" static="1">
			<f a="">
				<e path="sys.io.FileHandle"/>
				<x path="Int"/>
			</f>
			<meta><m n=":value"><e>neko.Lib.load("std", "file_read_char", 1)</e></m></meta>
		</file_read_char>
		<file_close expr="neko.Lib.load(&quot;std&quot;, &quot;file_close&quot;, 1)" line="77" static="1">
			<f a="">
				<e path="sys.io.FileHandle"/>
				<unknown/>
			</f>
			<meta><m n=":value"><e>neko.Lib.load("std", "file_close", 1)</e></m></meta>
		</file_close>
		<__f><e path="sys.io.FileHandle"/></__f>
		<readByte public="1" set="method" line="32" override="1">
			<f a=""><x path="Int"/></f>
			<meta><m n=":has_untyped"/></meta>
		</readByte>
		<close public="1" set="method" line="54" override="1"><f a=""><x path="Void"/></f></close>
		<new set="method" line="28"><f a="f">
	<e path="sys.io.FileHandle"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>Use `sys.io.File.read` to create a `FileInput`.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<class path="sys.io.FileOutput" params="" file="D:\HaxeToolkit\haxe\std/neko/_std/sys/io/FileOutput.hx">
		<extends path="haxe.io.Output"/>
		<file_close expr="neko.Lib.load(&quot;std&quot;, &quot;file_close&quot;, 1)" line="57" static="1">
			<f a="">
				<e path="sys.io.FileHandle"/>
				<unknown/>
			</f>
			<meta><m n=":value"><e>neko.Lib.load("std", "file_close", 1)</e></m></meta>
		</file_close>
		<file_write expr="neko.Lib.load(&quot;std&quot;, &quot;file_write&quot;, 4)" line="62" static="1">
			<f a=":::">
				<e path="sys.io.FileHandle"/>
				<t path="haxe.io.BytesData"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":value"><e>neko.Lib.load("std", "file_write", 4)</e></m></meta>
		</file_write>
		<file_write_char expr="neko.Lib.load(&quot;std&quot;, &quot;file_write_char&quot;, 2)" line="63" static="1">
			<f a=":">
				<e path="sys.io.FileHandle"/>
				<x path="Int"/>
				<unknown/>
			</f>
			<meta><m n=":value"><e>neko.Lib.load("std", "file_write_char", 2)</e></m></meta>
		</file_write_char>
		<__f><e path="sys.io.FileHandle"/></__f>
		<writeByte public="1" set="method" line="32" override="1"><f a="c">
	<x path="Int"/>
	<x path="Void"/>
</f></writeByte>
		<writeBytes public="1" set="method" line="36" override="1"><f a="s:p:l">
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></writeBytes>
		<close public="1" set="method" line="44" override="1"><f a=""><x path="Void"/></f></close>
		<new set="method" line="28"><f a="f">
	<e path="sys.io.FileHandle"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>Use `sys.io.File.write` to create a `FileOutput`.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":coreApi"/>
		</meta>
	</class>
</haxe>